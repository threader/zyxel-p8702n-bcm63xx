/*****************************************************************************
 **
 ** FILENAME:           icf_ssa_util.c
 **
 ** DESCRIPTION:        This file contains utility functions invoked by the SSA
 **
 ** DATE                NAME            REFERENCE               REASON
 ** ----                ----            ---------               ------
 ** 28-Jan-2005     Umang Singh         SSA LLD             INITIAL CREATION
 ** 29-JAN-2005     Aashish Suchdev
 ** 24-May-2005     Umang Singh         SPR 7541
 ** 31-MAY-2005     Jalaj Negi          IMS CLIENT          Added Code for 
 **                                                         IMS CLIENT           
 ** 07-Jun-2005     Umang Singh         SPR 7650
 ** 08-Jun-2005     Pankaj Negi         SPR 7648
 ** 14-Jun-2005     Umang Singh         SPR 7663            Privacy header handling
 ** 24-Jun-2005     Jalaj Negi          IMS CLIENT          Added code for 
 **                                                         bandwidth support
 **                                                         in SDP
 ** 07-JUL-2005     Aashish Suchdev                         TCP checkin            
 ** 12-AUG-2005     Shekhar Thakur      ICF                 ICF additions 
 ** 13-AUG-2005     Ram Narayan         ICF                 Added utility functions
 **                                                         for header/tag/body 
 **                                                         stream list & some new 
 **                                                         headers.
 ** 20-AUG-2005        Jyoti Narula        ICF                    ICR_CRM: Registration
 ** 02-SEP-2005     Jalaj Negi          ICF                 Changed code for 
 **                                                         extracting URI from
 **                                                            addr_spec.
 ** 03-SEP-2005     Jalaj Negi          ICF                 Changed function for
 **                                                            filling stream list 
 **                                                            SDP message.
 ** 05-SEP-2005     Jalaj Negi          ICF                 Modified list 
 **                                                         implementation for
 **                                                         populating application
 **                                                         specific headers.
 ** 10-SEP-2005     Ram Narayan         None                icf_ssa_extract_challenge
 **                                                         core was fixed, No check on 
 **                                                         NULL Challenge value
 **
 ** 06-DEC-2005        Jyoti Narula        ICF 4.0                Changes under ICF_4_CRM_START and END
 **
 ** 09-DEC-2005     Jalaj Negi          ICF_4_0             Added function for 
 **                                                         extracting P-Media-Authorization
 **                                                         header
 **    25-DEC-2005        Rohit Aggarwal                            Fixed SPR 8978
 **
 ** 28-Dec-2005        Jyoti Narula        SPR 9086            In the send_register() SipMsg formation for
 **                                                            Dereg to be made before using SipMsg
 **
 ** 06-Jan-2006        Jyoti Narula        SPR 9043            To make auts param in 
 **                                                            icf_ssa_chk_n_append_auts()
 **
 ** 09-Jan 2006        Jyoti Narula        SPR 8054            In 
 **                                                            icf_ssa_make_
 **                                                            contact_of_app_data()
 **                                                            changes done to 
 **                                                            add expires 
 **                                                            parameter in
 **                                                            contact header
 ** 11-Jan-2005     Aman Arora          IPSEC               added code to support IPSEC 
 **                                                         on UDP and TCP
 ** 16-Jan-2006        Priyanka Dua        MPH                    added "make request digest"
 **                                                            utility for MPH
 **
 ** 18-Jan-2006        Jyoti Narula        SPR 9042            New functions 
 **                                                            for fixing the 
 **                                                            duplicity of 
 **                                                            application 
 **                                                            specfied 
 **                                                            tags in 
 **                                                            From/To header.
 **    18-Jan-2006        Aman Arora            SPR 9591            set the correct SDP
 **                                                            in the otg re-invte
 **                                                            for session refresh
 ** 27-Jan-2005        Aman Arora            SPR 9864
 ** 08-Feb-2006     Amit Sharma                             Network PDU Logging API from ICF
 ** 22-Feb-2005        Amit Sharma                             Added code for auth support
 ** 03-Mar-2006     Amit Sharma                             ICF merging with ICF2.0
 ** 07-Mar-2006        Anuradha Gupta        None                Added new CC reasons for rejection of media change req
 ** 02-Apr-2006        Puneet Sharma    ICF5.0 LLD                changes done in the comments 
 **                                                            Multiple Public Users ICF5.0
 **
 ** 31-Mar-2006    Deepti Goyal        ICF 5.0              Message Body Header
 **                                                         Changes.
 **
 ** 25-Apr-2006     Deepti Goyal       SPR 10907             Set the content-type
 **                                                          as application/sdp.
 **                                    SPR 10934             Handling of multiple
 **                                                          message bodies in notify
 **                                                          for refer.
 **                                    SPR 10936             Handling of multipart/mixed
 **                                                          in internal subscribe.
 **
 ** 29-July-2006    Aman Aggarwal       ICF_6_0              Multiple m-lines changes
 **                 Deepti Goyal 
 ** 22-Jun-2006     Umang Singh         Rel 5.2              TLS and SIPS URI additions
 ** 01-Sep-2006     Amit Sharma         SPR:12688
 **
 ** 4-Sep-2006      Deepti Goyal        SPR 12759            Merged Options timer code.
 ** 6-Sep-2006        Deepti Goyal        SPR 12719             Memory Leaks in 
 **                                                             Profile
 ** 6-Sep-2006      Deepti Goyal        SPR 12699            New Reason code for
 **                                                          remote media not
 **                                                          received.
 ** 06-Sep-2006     Umang Singh         SPR 12855         Parsing of Require hdr for 100rel
 ** 08-Sep-2006     Umang Singh         SPR 12918
 ** 27-Nov-2006     Deepti Goyal        ICF Rel 6.2      NAT Feature Support
 ** 11-Dec-2006        Deepti Goyal        SPR 14029         Handling for rport in response updated.
 ** 
 ** 12-Dec-2006     Deepti Goyal        SPR 14034        Update the if condition
 **                                                      check for the initial
 **                                                      rport handling.
 **
 ** 12-Dec-2006     Deepti Goyal        SPR 14036        Handling of sending the 
 **                                                      rport and received in 
 **                                                      response messages updated.
 ** 13-Dec-2006     Deepti Goyal        SPR 14040        Binding Refresh timer 
 **                                                      expiry handling.
 ** 14-Dec-2006     Deepti Goyal        SPR 14063        The binding refresh timer
 **                                                       block is set to NULL, 
 **                                                       after freeing the memory.
 ** 15-Dec-2006     Deepti Goyal        SPR 14076        Memory Leaks in Via 
 **                                                      Header Fixed.         
 ** 28-Dec-2006     Deepti Goyal        SPR 14173        Start the binding refresh 
 **                                                      timer for the user address
 **                                                      stored in the 
 **                                                      rport_config_data   
 ** 20-Nov-2006     Umang Singh         SPR 13794
 ** 20-Nov-2006     Umang Singh         SPR 13861
 ** 23-Nov-2006     Umang Singh         SPR 13894/CSR-1-4022527
 ** 24-Nov-2006     Umang Singh         SPR 13908/CSR-1-3704087
 ** 19-Dec-2006     Puneet Sharma       SPR 14054 added checks for header-value
 **                                    in default and unknown header
 ** 13-Jan-2007     Umang Singh        SPR 14068 
 ** 18-Jan-2007     Umang Singh        SPR 14130
 ** 15-Jan-2006     Abhishek Dhammawat  ICF 6.3          Per Line Feature - Added
 **                                                      For SIP DSCP parameter
 ** 08-JAN-2007    Mohit Sharma     ICF Rel 6.3     Forking and Multianswer support 
 ** 1-Feb-2007     Mohit Sharma        SPR 14411          Modification in del_all_
 **                                                       other_call_obj
 ** 05-Feb-2007    Umang Singh        SPR 14445
 ** 06-Feb-2007    Umang Singh        SPR 14483
 ** 26-Mar-2007    Rajat Chandna                        Added func. icf_ssa_is_update_present_in_allow_hdr
 **                                                     as a part of Update/reinvite enhancement.
 ** 31-Jul-2007    Amit Mahajan       SPR 15164 
 ** 08-JUN-2007    Alok Tiwari        IPTK              Added utility functions for STAT handling.
 ** 09-JUL-2007    Neha Choraria      ICF Rel 7.0       Changes for Forking &
 **                                                     Multiple Answer
 ** 10-Jul-2007    Abhishek Dhammawat SPR14958          modified icf_ssa_populate_address_from_sip_addr_spec
 **                                                     for escape char handling 
 **                                                     in request URI
 ** 13-JUL-2007    Tarun Gupta       CSR 1-4816236/SPR 15269
 **                                                     Added a utility function:
 **                                                     icf_ssa_delete_param_from_addr_spec 
 **                                                     called from icf_ssa_revert_to_udp
 ** 3-OCT-2007     Abhishek Dhammawat SPR16408          Modified
 **                                                     icf_ssa_AppendMsgBodyListToSipMessage
 ** 10-OCT-2007    Abhishek Dhammawat SPR16926          Modified icf_ssa_send_authorized_req
 **                                                     related CSR1-5228570 
 **
 ** 22-Aug-2007    Deepti Goyal      ICF 6.5            Changes for DNS/TCP.
 **                                                     DNS buffer stores listen
 **                                                     ing IP address of server
 **                                                     instead of ephemeral port.
 ** 19-Nov-2007   Abhishek Dhammawat SPR17542           Modified icf_ssa_util_cmp_tags
 ** 28-Nov-2007   Jagmohan Chauhan   SPR17569           Modified icf_ssa_fill_conn_info_from_Via
 ** 05-Dec-2007   Jagmohan Chauhan   SPR17557           To print correct traces for ICF_TRACE_NOTIFY_FOR_SUBS 
 ** 06-Dec-2007   Jagmohan Chauhan   SPR17648           To print traces for out of dailog 
 **                                                     options received from network  
 ** 06-Dec-2007   Jagmohan Chauhan   SPR17649           To print correct trace
 **                                                     for in dialog options sent on network 
 ** 23-Dec-2007   Abhishek Dhammawat SPR17855           Modified icf_ssa_trace 
 **                                                     icf_ssa_validate_content_disp
 **
 ** 07-Jan-2008   Amit Sikka         SPR 17945          Support for PUBLISH-MESSAGE
 ** 25-Jun-2008   Rajiv Kumar        SPR - 18722        IPTK not compilable with gcc
 ** 21-Aug-2008   Puneet Sharma      CSR 1-6179301
 **                                                     version 4.2.3
 ** 07-Nov-2008   Anurag Khare       SPR 19168          MOdified Function
 **                                                     icf_ssa_update_callobj_for_profile
 ** 15-Dec-2008	Pavneet Bajaj		SPR 19235		Corrected logic to delete 
 **													call objects.
 ** 29-Dec-2008	Pavneet Bajaj		SPR 19246		Check if transport param is
 **													already present in Contact
 **													header before adding new one
 **
 ** 27-Jan-2009	Vinay Jindal		SPR 19279		NAT handling updated
 ** 10-Feb-2009   Rohit Aggarwal  SPR 19316   Changes for INVITE with Replaces
 ** 16-Feb-2009   Rohit Aggarwal  SPR 19316   Free the Referred-By addr spec
 ** 21-May-2009   Anurag Khare    SPR 19698: CSR 1-7224724  Modified function
 **                                                         icf_ssa_validate_content_disp
 ** 29-May-2009   Anurag Khare    SPR 19484: CSR 1-7297673  Modified function
 **                                                         icf_ssa_send_refer_req
 ** 12-Jun-2009	 Aman Aggarwal	SPR 19736			Added function for handling 
 **													challenge response 
 ** 27-Jun-2009  Rajiv Kumar    SPR 19788           Fix for CSR-1-7444867.
 ** 1-July-2009  Anurag Khare   SPR 19797           Fix for CSR 1-7463467 
 ** 3-July-2009  Anurag Khare   SPR 19788           Fix for CSR 1-7444867
 ** 6-July-2009  Anurag Khare   SPR 19823           Fix for CSR 1-7473533
 ** 10-Jul-2009	Aman Aggarwal	SPR 19838			Fix for CSR 1-7497733
 ** 15-July-2009 Anurag Khare   SPR 19857           Fix for CSR 1-7463287
 ** 23-July-2009 Aman Aggarwal	SPR 19881			Fix for CSR 1-7507275
 ** 27-July-2009 Anurag Khare   CSR 1-7576638       Fix for CSR 1-7576638
 ** 26-Aug-2009  Anurag Khare   SPR 19989           Changes done for NOTIFY
 **                                                 challange enhancement
 ** 24-Sep-2009  Anurag Khare   SPR 20071           Fix for CSR 1-7798174
 ** 18-Nov-2009	Pavneet bajaj	SPR 20220			Fix for CSR 7991608.Modified 
 **													function icf_ssa_app_trace()
 ** 19-Dec-2009  Rohit Aggarwal   SPR 20246  Configuration to strip Route header
 ** 25-Jan-2010  Pavneet Bajaj    SPR 20278          Fix for CSR 8196703
 ** 23-Mar-2010  Udit Gattani     SPR 20336     Send expires in Unsubscribe                                                **                                             irrespective of App setting.
 ** 29-Mar-2010  Kamal Ashraf                      CSR_1-8389294(Registaration Enh)
 ** 09-Apr-2010  Alok Tiwari      SPR 20362         Modified Function:
 **                                       icf_ssa_initiate_dispatch_sequence
 **
 *****************************************************************************
 **                 Copyrights 2010, Aricent.
 *****************************************************************************/

/*Message body header changes Start*/
#define SIP_MIME_PARSING
/*Message body header changes Ends*/
#include "icf_feature_flags.h"

#include "stack_headers.h"
#include "uatk_headers.h"

#include "icf_internal_api_id.h"
#include "icf_common_types.h"
#include "icf_common_defs.h"



#include "icf_common_prototypes.h"

#ifdef ICF_DNS_LOOKUP_ENABLED
#include "sdf_lookup.h"
#endif

#include "icf_port_prototypes.h"
#include "icf_macro.h"
#include "icf_ssa_prototypes.h"
#include "icf_ssa_macro.h"
#include "icf_common_prototypes.h"
#include "icf_dbm_prototypes.h"
#include "icf_regm_types.h"
#include "icf_regm_prototypes.h"
#include "icf_dbm_regm_prototypes.h"

#include "basic.h"
#include "icf_ssa_common_types.h"
#include "icf_cfg_defs.h"

#ifdef ICF_IPSEC_ENABLED
#include "icf_port_intf_prototypes.h"
#endif

#include "icf_ecode.h"
#ifdef ICF_PORT_WINDOWS
#pragma warning(disable:4701)
#pragma warning ( disable : 4702 )
#endif


/* Global defintion of persistent global pdb */
extern icf_glb_pdb_st        *p_persistent_glb_pdb;

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_initiate_dispatch_sequence
 * DESCRIPTION:  1.This function is the last stop before invocation of 
* SendCallToPeer API. It expects that p_ssa_pdb contains pointer to 
* glb_pdb, global cfg data and global ssa data
*       The function does following steps:
*       1. sets options field for compaction of msg if required
        2. set the conn FD in all transactions in case of TCP/TLS call
        3. Invokes Send Call To Peer
        4. In case of IPSEC checks if count of number of transctions on the SA
                need to be increased or decreased
 ***************************************************************************/
icf_return_t icf_ssa_initiate_dispatch_sequence(
        icf_ssa_pdb_st          *p_ssa_pdb,
        Sdf_st_callObject               *p_call_obj,
        Sdf_st_transaction              *p_txn,
        Sdf_st_overlapTransInfo         *p_overlap_txn,
    Sdf_st_eventContext         *p_event_context,
        icf_error_t             *p_ecode)
{
        Sdf_st_transportInfo 		*p_dest_Info = Sdf_co_null;
        Sdf_st_transportInfo 		*p_temp_dest_Info = Sdf_co_null;
       icf_return_t    ret_val = ICF_SUCCESS;
        icf_ssa_ctxt_st  *p_ssa_ctxt =
                (icf_ssa_ctxt_st*)(p_call_obj->pAppData->pData);
        Sdf_ty_s8bit        *p_method = Sdf_co_null;

#ifdef ICF_NAT_RPORT_SUPPORT
    icf_rport_config_data_st            *p_rport_config_data = ICF_NULL;
#endif

#ifdef ICF_IPSEC_ENABLED
        icf_config_data_st    *p_cfg_data = p_ssa_pdb->p_glb_cfg_data;
        icf_uint8_t            *pTemp = ICF_NULL;
#endif
        SipOptions      options = {0};
        SipMessage      *p_sip_msg = SIP_NULL;
        en_SipMessageType       dReqRespType;
        SipError        sip_error;
/*UMR Fix*/
        Sdf_st_error    sdf_error = {0,0,0,"\0"};
        icf_line_data_st    *p_line_data = ICF_NULL;
        icf_line_id_t        line_id = ICF_INVALID_LINE_ID;
        icf_config_data_st        *p_config_data = ICF_NULL;

        /*Fix for CSR 1-8223807 : SPR-20362*/
        Sdf_ty_s8bit     *p_remove_hdr_list = ICF_NULL;
        icf_return_t    dummy_ret_val = ICF_SUCCESS;

        ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

        p_ecode = p_ecode;

        options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM|SIP_OPT_RETRANSCALLBACK;

        /* SipMessage retreival starts*/
        if ( Sdf_co_null == p_txn)
        {
                if (ICF_NULL != p_overlap_txn)
                {
                   /*overlap transaction*/
                   p_sip_msg = p_overlap_txn->pSipMsg;
                }
                else
                {
                   return ICF_FAILURE;
                }  
        }
        else/*either a uac or a Uas transaction*/
        {
                p_sip_msg = p_txn->pSipMsg;
        }
        if ( SIP_NULL == p_sip_msg)
        {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in SipMsg retreival from DnsEvtCtxt"));
                ret_val = ICF_FAILURE;
        }
        /* SipMessage retreival end*/

        if ( (ICF_FAILURE != ret_val) &&
                (SipFail != sip_getMessageType(p_sip_msg,
                &dReqRespType, &sip_error)))
        {
            if (SipMessageRequest == dReqRespType)
            {
                p_ssa_pdb->p_conn_table_entry = p_ssa_pdb->p_ssa_ctxt->p_conn_table_req_entry;
            }
            else
            {
                p_ssa_pdb->p_conn_table_entry = p_ssa_pdb->p_ssa_ctxt->p_conn_table_resp_entry;
            }
 
            if (ICF_NULL != p_txn)
            {
                p_temp_dest_Info = p_txn->pDestInfo;
            }
            else
            {
                p_temp_dest_Info = p_overlap_txn->pDestInfo;
            }

            if ((ICF_NULL != p_ssa_pdb->p_conn_table_entry) && ((0 != 
                icf_port_strcmp((icf_uint8_t *)p_temp_dest_Info->pIp, (icf_uint8_t *)p_ssa_pdb->p_conn_table_entry->peer_ip)) || 
                (p_temp_dest_Info->dPort != p_ssa_pdb->p_conn_table_entry->peer_port_num)))
            {
                /*p_txn->dSocket.dSockfd = Sdf_co_InvalidSocketFd;*/
                p_ssa_pdb->p_conn_table_entry = ICF_NULL;
            }

                /* Check the configuration and determine if the headers are 
                   to be sent in full form or short form */
                if(0 != p_ssa_pdb->p_glb_cfg_data->sip_compact_hdrs)
                {
                        /* Compact headers is on, use the compact form */
                        options.dOption &= ~SIP_OPT_FULLFORM; /* Unset fullform bit */
                        options.dOption |= SIP_OPT_SHORTFORM; /* Set Shortform bit */
                }
                /*Set the TCP connection FD in the transaction structures of callObj*/
                if (( ICF_SSA_TCP_TRANSPORT ==
                                        (ICF_SSA_TCP_TRANSPORT & p_ssa_ctxt->bitmask) ||
                                        (ICF_SSA_TLS_TRANSPORT ==
                                         (ICF_SSA_TLS_TRANSPORT & p_ssa_ctxt->bitmask))))
                {
                        /*Here we are populating the current transaction's SockFd
                         * with the one in the ConnDb,  if there is one,if not
                         * we reset it to an invalid value so taht UATK attempts a 
                         * connect by itself*/
                        icf_uint16_t fd;
                        Sdf_st_listIterator dListIterator;
                        if ( ICF_NULL == p_ssa_pdb->p_conn_table_entry)
                        {       
                                fd = Sdf_co_InvalidSocketFd;
                        }
                        else
                        {
                                fd = p_ssa_pdb->p_conn_table_entry->conn_fd;
                        }
                        if ( ICF_NULL != p_call_obj->pUasTransaction)
                        {
                                p_call_obj->pUasTransaction->dSocket.dSockfd = fd;
#ifdef ICF_SECURE_SUPPORT                
                                if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
                                {
                                        p_call_obj->pUasTransaction->dSocket.dProtocol = Sdf_en_protoTls;
                                }
                                else
                                {
#endif                    
                                        p_call_obj->pUasTransaction->dSocket.dProtocol = Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
                                }
#endif                    
                        }
                        if ( ICF_NULL != p_call_obj->pUacTransaction)
                        {
                                p_call_obj->pUacTransaction->dSocket.dSockfd = fd;
#ifdef ICF_SECURE_SUPPORT                
                                if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
                                {
                                        p_call_obj->pUacTransaction->dSocket.dProtocol = Sdf_en_protoTls;
                                }
                                else
                                {
#endif                    
                                        p_call_obj->pUacTransaction->dSocket.dProtocol = Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
                                }
#endif                    
                        }
                        sdf_listInitIterator(&(p_call_obj->slOverlapTransInfo), \
                                        &dListIterator, &sdf_error);

                        while (dListIterator.pCurrentElement != Sdf_co_null)
                        {
                                Sdf_st_overlapTransInfo *pOverlapTransInfo;

                                pOverlapTransInfo = (Sdf_st_overlapTransInfo *) \
                                        (dListIterator.pCurrentElement->pData);
                                if ( Sdf_co_null != pOverlapTransInfo)
                                {
                                        pOverlapTransInfo->dSocket.dSockfd = fd;
#ifdef ICF_SECURE_SUPPORT                
                                        if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
                                        {
                                                pOverlapTransInfo->dSocket.dProtocol = Sdf_en_protoTls;
                                        }
                                        else
                                        {
#endif                    
                                                pOverlapTransInfo->dSocket.dProtocol = Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
                                        }
#endif                    
                                }
                                sdf_listNext(&dListIterator, &sdf_error);
                        }

                }/*end of loop for filling FD in the transaction structures*/
        if ( ICF_NULL != p_ssa_ctxt->p_call_ctxt)
        {
            line_id = p_ssa_ctxt->p_call_ctxt->line_id;
        }
        else if ( ICF_NULL != p_ssa_ctxt->p_sic_ctxt)
        {    
            line_id = p_ssa_ctxt->p_sic_ctxt->line_id;
            /*Fix for CSR 1-8223807 : SPR-20362*/
            if(ICF_NULL != p_ssa_ctxt->p_sic_ctxt->p_remove_hdrs)
            {
              ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                         ICF_MAX_LARGE_STR_LEN,
                         ICF_MEM_COMMON,
                         p_remove_hdr_list,
                         ICF_RET_ON_FAILURE,
                         p_ssa_pdb->p_ecode,
                         ret_val);
              icf_port_strcpy(p_remove_hdr_list,
                           p_ssa_ctxt->p_sic_ctxt->p_remove_hdrs);
            }
        }
        else if(ICF_NULL != p_ssa_ctxt->p_rgm_ctxt)
        {
            line_id = p_ssa_ctxt->p_rgm_ctxt->rgm_list_of_lines[p_ssa_ctxt->p_rgm_ctxt->num_of_lines-1];
        }
		/*Fix for CSR 1-8081459*/
		else if (ICF_INVALID_LINE_ID != p_ssa_ctxt->line_id)
		{
  		    line_id =  p_ssa_ctxt->line_id;
		}	

        if (ICF_SUCCESS ==
           icf_dbm_fetch_line_cntxt_blk(
           p_ssa_pdb->p_glb_pdb, line_id,
           (icf_line_data_st **)(&p_line_data),
           p_ecode))
        {
                        p_event_context->dTimerOption |= SIP_OPT_TIMER_T1;
                        p_event_context->dTimerOption |= SIP_OPT_TIMER_F;
                        p_event_context->dTimerOption |= SIP_OPT_TIMER_B;
                        p_event_context->dTimerOption |= SIP_OPT_TIMER_T2;
                        p_event_context->dTimerOption |= SIP_OPT_TIMER_H;

                        p_event_context-> dTimeoutValues.dT1 =
                  p_line_data->sip_timer_t1;

                        p_event_context-> dTimeoutValues.dT2 =
                  p_line_data->sip_timer_t2;

                        p_event_context-> dTimeoutValues.dTimerB =
                  p_line_data->sip_timer_invite;

                        p_event_context-> dTimeoutValues.dTimerF_T3 =
                  p_line_data->sip_timer_non_invite;

                        p_event_context-> dTimeoutValues.dTimerH =
                  p_line_data->sip_timer_t1 * 64;

				  /* Fix for CSR 1-8047728: SPR 20246 */
				  /* If remove_route_hdr is TRUE, set the option with
                   * SIP_OPT_REMOVEROUTE which will be used by STACK 
                   * in API sdf_ivk_uaSendCallToPeer to strip Route 
                   * header from outgoing requests.   
                   */
                  if (ICF_TRUE == p_line_data->remove_route_hdr)
                  {
                       options.dOption |= SIP_OPT_REMOVEROUTE;    
                  }
        }

#ifdef ICF_DNS_LOOKUP_ENABLED

        /* DNS-Buffer code starts here-- this code is for making the retries
		   configurable iff line data is filled with default values */ 

        if(p_event_context-> dTimeoutValues.dT1 == ICF_CFG_DEF_SIP_TIMER_T1 &&

                p_event_context-> dTimeoutValues.dT2 == ICF_CFG_DEF_SIP_TIMER_T2 &&

                p_event_context->dTimeoutValues.dTimerB == ICF_CFG_DEF_SIP_TIMER_INVITE &&

                p_event_context->dTimeoutValues.dTimerF_T3 == ICF_CFG_DEF_SIP_TIMER_NON_INVITE)

        {



            if(ICF_FAILURE == icf_dbm_get_module_glb_data(

                        p_ssa_pdb->p_glb_pdb,

                        (icf_int_module_id_t)ICF_INT_MODULE_CFG,

                        (icf_void_t *)&p_config_data, p_ecode))

            {

                /* didn't get the config data can't make the retry to be configurable

                   raise the error */

            }

            else if (ICF_NULL != p_config_data )

            {

                p_event_context->dTimerOption |= SIP_OPT_TIMER_T1;

                p_event_context->dTimerOption |= SIP_OPT_TIMER_F;

                p_event_context->dTimerOption |= SIP_OPT_TIMER_B;

                p_event_context->dTimerOption |= SIP_OPT_TIMER_T2;

                p_event_context->dTimeoutValues.dT1= ICF_CFG_DEF_SIP_TIMER_T1; /* default value */

                /* for NON-Invite x-saction */

                p_event_context->dTimeoutValues.dTimerF_T3=  

                    (icf_ssa_dns_2_pow(p_config_data->sip_req_retry)) * p_event_context->dTimeoutValues.dT1; 

                /* for INvite X-saction */

                p_event_context->dTimeoutValues.dTimerB= 

                    (icf_ssa_dns_2_pow(p_config_data->sip_req_retry)) * p_event_context->dTimeoutValues.dT1;

                /* configure the T2 */

                /*if(6==p_config_data->sip_req_retry)

                {

                    p_event_context-> dTimeoutValues.dT2 = 2 * ICF_CFG_DEF_SIP_TIMER_T2;

                }
                
                if(7==p_config_data->sip_req_retry)

                {

                    p_event_context-> dTimeoutValues.dT2 = 4 * ICF_CFG_DEF_SIP_TIMER_T2;

                }

                else*/

                {

                    p_event_context-> dTimeoutValues.dT2 = ICF_CFG_DEF_SIP_TIMER_T2;/* default value */

                }





            }

        }

#endif
        if(ICF_FALSE == p_ssa_pdb->authorised_req && 
		      ICF_NULL != p_ssa_ctxt->p_call_ctxt &&
		      ICF_CALL_AUTHENTICATION_REQ & 
		      p_ssa_ctxt->p_call_ctxt->common_bitmask )
      {
        if(Sdf_co_fail == sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg, 
                                                            &p_method, 
                                                            &sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
        else if((icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"ACK" ) == 0))
        {
           /*
            * We would not be calling sdf_fn_uaUpdateAuthorization API as 
            * ACK would be using the same authentication credential as 
            * INVITE
            */
        }
        else if(Sdf_co_fail == sdf_fn_uaUpdateAuthorization(p_call_obj,
                                                             p_sip_msg,
                                                             p_method,
                                                             &sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
      }
       /*Fix for CSR 1-8223807 : SPR-20362*/ 
        if ((ICF_SUCCESS == ret_val)&&
            ( Sdf_co_fail == sdf_ivk_uaSendCallToPeer(p_call_obj, p_sip_msg,
                                              options, 0, p_event_context,
                                              p_remove_hdr_list, &sdf_error)))
        {
#ifdef ICF_DNS_LOOKUP_ENABLED
            /*As per discussion with Mayank, it has been decided
              that we will not probe the next available IP in case
              TCP send fails. Logic being that we have already 
              confirmed peer by establishing a connection.However if a UATK 
              triggerd Connect fails we will check for next available IP*/
            if (((ICF_TRANSPORT_TYPE_TCP == p_ssa_ctxt->transport) ||
                        (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport) ||
                        (ICF_TRANSPORT_MODE_BOTH == p_ssa_ctxt->transport)) &&
                    (Sdf_en_tcpConnectError != sdf_error.errCode)
               )
            {
                /*connection oriented transport, failure in send call*/
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSendCallToPeer"));
                ret_val = ICF_FAILURE;
            }
            else
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSendCallToPeer,Going for reattempt "));
                if(ICF_SUCCESS == icf_ssa_resend_ongoing_txn(p_call_obj, p_sip_msg, p_overlap_txn,\
                            options))
                {
                    ret_val = ICF_SUCCESS;
                }
                else
                {
#endif
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSendCallToPeer"));
                    ret_val = ICF_FAILURE;
#ifdef ICF_DNS_LOOKUP_ENABLED
                }
            }
#endif
        }

#ifdef ICF_DNS_LOOKUP_ENABLED
       /*This is to save the Ip and the port at which the request is sent,So that when the response comes 
        *from this Ip,Iptk willl buffer it.
        */ 
        else if (sdf_ivk_uaGetDestInfoFromTransaction(p_txn,
              p_overlap_txn,
			  &p_dest_Info, 
              &sdf_error) == Sdf_co_fail)
         {
             ret_val = Sdf_co_fail;
         }
        else
        {

            icf_port_strcpy(p_ssa_ctxt->ip_fr_req, (icf_uint8_t *)p_dest_Info->pIp);
            p_ssa_ctxt->port_fr_req = (icf_uint16_t)p_dest_Info->dPort;

             if(Sdf_co_null != p_txn)
             {
              	(void)sdf_ivk_uaFreeTransportInfo(p_txn->pDestInfo);
             }
             else if(Sdf_co_null != p_overlap_txn)
             {
                (void)sdf_ivk_uaFreeTransportInfo(p_overlap_txn->pDestInfo);
             }
	}
#endif
        }/*End of ICF_FAILURE check*/

        /*Fix for CSR 1-8223807 : SPR-20362*/
        if(ICF_NULL != p_remove_hdr_list)
        {
            ICF_MEMFREE(
                 p_ssa_pdb->p_glb_pdb,
                 p_remove_hdr_list,
                 ICF_MEM_COMMON,
                 p_ssa_pdb->p_ecode,
                 dummy_ret_val);

            p_remove_hdr_list = ICF_NULL;
        }

        if ( ICF_FAILURE != ret_val)
        {
#ifdef ICF_NAT_RPORT_SUPPORT

           if (ICF_CFG_SELF_ADDR_PER_LINE ==
              p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
           {
                if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                    p_ssa_pdb->p_glb_pdb, p_ssa_ctxt->line_id,
                    &p_line_data, p_ssa_pdb->p_ecode))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    p_rport_config_data = p_line_data->p_rport_config_data;
                }
        
           }
           else
           {
                 p_rport_config_data = &(p_ssa_pdb->p_glb_cfg_data->rport_config_data);
           }

           if (ICF_NULL == p_rport_config_data)
           {
              return ICF_FAILURE; 
           }
            /* Restart the binding refresh timer value if rport status is 
             * completed.
             */
            if(ICF_TRUE == p_rport_config_data->is_rport_reqd && \
                    ICF_INITIAL_RPORT_COMPLETED == 
                       p_rport_config_data->is_rport_completed)
            {
                if(ICF_NULL == p_rport_config_data->p_binding_refresh_timer) 
                {
                    /* Start the timer for this binding for the very first time
                     */
                    icf_ssa_start_binding_refresh_timer(p_ssa_pdb);

                }
                else
                {
                    /* Stop the timer and then start again.
                     */
                    ICF_STOP_TIMER(p_ssa_pdb->p_glb_pdb,p_rport_config_data->binding_refresh_timer_id,
                            p_ssa_pdb->p_ecode,ret_val)

                   ICF_PRINT(("[SSA] Timer Id=%d stopped \n",
                                p_rport_config_data->binding_refresh_timer_id));

                   icf_dbm_ret_mem_to_pool(p_ssa_pdb->p_glb_pdb, 
                           ICF_MEM_TIMER,
                           p_rport_config_data->p_binding_refresh_timer,
                           p_ssa_pdb->p_ecode);

                    p_rport_config_data->binding_refresh_timer_id=ICF_NULL;

                    p_rport_config_data->p_binding_refresh_timer= ICF_NULL;

                    if ( ret_val == ICF_FAILURE)
                    {
#ifdef SDF_ERROR
                        sdf_fn_setError(Sdf_en_minorErrors,Sdf_en_systemError,\
                                (Sdf_ty_s8bit *)"sdf_cbk_uaStopTimer(): "
                                "Failed to stop timer",&(sdf_error));
#endif
                        sip_error = Sdf_en_systemError;
                        /*Raise/Set Error here*/
                        ret_val = ICF_FAILURE;
                    }
                    /* Start the timer for this binding again */
                    icf_ssa_start_binding_refresh_timer(p_ssa_pdb);
                }
            }

#endif    
        }/*end of segment for freeing sip msg and slMsgBodyList*/

#ifdef ICF_IPSEC_ENABLED
        if (  ICF_FAILURE != ret_val)
        {
                /* get config data to check if IPsec is enabled */

                /* get config data from DBM */
                if ((dReqRespType == SipMessageRequest) &&
                                (ICF_TRUE == p_cfg_data->ipsec_enabled) &&
                                (ICF_NULL != p_ssa_ctxt->ssa_sa_context.p_sa_context))
                {
                        SipReqLine                *pReqLine = ICF_NULL;
                        /* for an outgoing request, this will be a new 
                        * transaction incase of all 
                         * requests- but for ACK. */
                        if (SipFail ==
                                sip_getReqLineFromSipReqMsg(p_sip_msg,&pReqLine, &sip_error))
                        {
                                ret_val = ICF_FAILURE;
                        }
                        else
                        {
                                /* get method name from the request URI */
                                if (SipFail == sip_getMethodFromReqLine
                                        (pReqLine,((SIP_S8bit **)&pTemp),&sip_error))
                                {
                                        ret_val = ICF_FAILURE;
                                }
                                sip_freeSipReqLine(pReqLine);
                        }
                        if ((ICF_FAILURE != ret_val) && (icf_port_strcmp(pTemp, "ACK")))
                        {
                                /* increment the active transaction count for the SA */
                                /* we will not increase the count for ACK, since it 
                                * has no response and there is no way we can decrement
                                 * the corresponding counter for the ACK transaction 
                                 */
                                p_ssa_pdb->p_sa_context->num_active_trans += 1;
                                ICF_PRINT(("[SSA]: num_active_trans incremented, current value = %d",
                                                        p_ssa_pdb->p_sa_context->num_active_trans));
                        }
                }
                else if ((dReqRespType == SipMessageResponse) &&
                                (ICF_TRUE == p_cfg_data->ipsec_enabled) &&
                                (ICF_NULL != p_ssa_pdb->p_sa_context))
                {
                        /* decrement the active transaction count for the SA */
                        p_ssa_pdb->p_sa_context->num_active_trans -= 1;
                        ICF_PRINT(("[SSA]: num_active_trans decremented, current value = %d",
                                                p_ssa_pdb->p_sa_context->num_active_trans));

                        if (ICF_NULL == p_ssa_pdb->p_sa_context->num_active_trans)
                        {
                                /* this function will send a trigger to REGM if there are no
                                 * pending transactions on the old SA. If the trans count is
                                 * 0 for the new SA, then no trigger will be sent to REGM */
                                ret_val = icf_ssa_rgm_delete_old_sa_ind(p_ssa_pdb);
                        }
                }
        }
#endif
        
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val; 
}

#ifdef ICF_DNS_LOOKUP_ENABLED
icf_return_t    icf_ssa_get_msg_mthd_type_frm_txn(icf_ssa_pdb_st *p_ssa_pdb, 
        Sdf_st_transaction    *p_txn,
        Sdf_st_overlapTransInfo    *p_overlap_txn,
        en_SipMessageType    *p_msg_type,
        Sdf_ty_s8bit        *p_mthd)
{
    icf_return_t    ret_val = ICF_SUCCESS;

    SipError        sip_error;
    SipMessage      *p_sip_msg = ICF_NULL;
    Sdf_st_error    sdf_error;
    Sdf_ty_s8bit    *p_method = Sdf_co_null;

    if(ICF_NULL == p_ssa_pdb)
    {
          return ICF_FAILURE;
    
    }
    
	p_ssa_pdb = p_ssa_pdb;

	if (Sdf_co_null == p_overlap_txn)
	{
		p_sip_msg = p_txn->pSipMsg;
	}
	else
	{
		p_sip_msg = p_overlap_txn->pSipMsg;
	}
	if ( (ICF_NULL == p_sip_msg) ||
			( SipFail == sip_getMessageType(p_sip_msg, p_msg_type,
							&(sip_error))) ||
			(Sdf_co_fail == 
			 sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg, &p_method, &sdf_error))
	   )
	{
		ret_val = ICF_FAILURE;

    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)p_mthd, (icf_uint8_t *)p_method);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)    
    return ret_val;
}

#endif
/************************************************************************
* Static Function Only Used in this File
*************************************************************************/
#ifdef ICF_SIGCOMP_SUPPORT
static icf_return_t
icf_ssa_checkForSigCompParam(
     INOUT     Sdf_st_callObject              *pObject,
     INOUT     SipMessage                     *pMessage, 
     OUT    icf_boolean_t               *p_isSigcompParamPres,
     OUT    icf_error_t   
     *p_ecode);
#endif
/*Message body header changes Start*/
static icf_return_t icf_ssa_SetMsgBodyListInSipMessage
    (Sdf_ty_slist *pMsgBodyList,
    SipMessage    *pMsg,
    Sdf_ty_s8bit  *p_content_type,
    Sdf_st_error  *pError);

static icf_return_t icf_ssa_AppendMsgBodyListToSipMessage
    (Sdf_ty_slist *pMsgBodyList,
    SipMessage    *pMsg,
    Sdf_ty_s8bit  *p_content_type,
    Sdf_st_error  *pError);

/*Fix done for SPR-18722 : CSR-1-6068965*/
static icf_void_t icf_get_content_type_from_msg_body(
        INOUT  icf_ssa_pdb_st  *p_ssa_pdb,
        OUT icf_int8_t     **p_p_content_type);
static icf_return_t icf_ssa_IsSupportedMediaTypeInMsgBody(
        INOUT    en_SipMessageType dReqRespType, 
        INOUT    Sdf_st_initData   *pInitData,
        INOUT    Sdf_ty_s8bit      *pMediaType,
        OUT   Sdf_st_error      *pErr);

static icf_return_t icf_ssa_get_status_frm_notify_from_mime_body(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT      SipMsgBody           *p_sip_msg_body,
        OUT     icf_boolean_t        *p_status);

/*Message body header changes Ends*/
/************************************************************************
* External Function Only Used Only in this File
*************************************************************************/
#ifdef ICF_SIGCOMP_SUPPORT
extern icf_return_t icf_sigsa_get_sigcomp_proxy_addrs_from_ctxt(
        INOUT  icf_void_t                *p_sigsa_ctxt,
        OUT icf_transport_address_st   **p_sigcomp_proxy_addr,
        OUT icf_boolean_t              *p_is_to_add_sigcomp_param_in_route,
        OUT icf_error_t                *p_ecode);


#endif

/************************************************************************
* External Function WHICH ARE DIRECTLY BEING USED FROM UATK
*************************************************************************/

void icf_cmn_ssa_decodeBase64 (icf_int8_t *p_input, icf_int8_t *p_output)
{
    decodeBase64(p_input,p_output);

}

void icf_cmn_ssa_encodeBase64 (icf_int8_t* p_input,icf_int8_t* p_result)
{
    encodeBase64(p_input,p_result);
}




/*******************************************************************************
 * FUNCTION:        icf_ssa_get_and_populate_self_ip
 * DESCRIPTION:     This function calls UATK callbacks, implemented in SSA,
 *                  to get the system host name, then system ip address
 *                  and then sets the resolved ip address in config data
 ******************************************************************************/
icf_return_t icf_ssa_get_and_populate_self_ip(
        INOUT  icf_ssa_pdb_st             *p_ssa_pdb,
        INOUT  icf_transport_address_st *p_self_address,
        INOUT  icf_uint8_t *p_self_ip_str)
{
    icf_return_t     ret_val = ICF_SUCCESS;

    Sdf_ty_s8bit        *p_host_name = Sdf_co_null,
                        *p_host_ip = Sdf_co_null;
    Sdf_st_error        sdf_error;
    (void)p_ssa_pdb;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        
    /* UMR fix */
    icf_port_memset(
        (icf_void_t *)&sdf_error,
        0,
        ICF_PORT_SIZEOF(Sdf_st_error));

    if (Sdf_co_fail == sdf_fn_uaGetHostName(&p_host_name, &sdf_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in GetHostName"));
        ret_val = ICF_FAILURE;
    }
    else if ( Sdf_co_fail == sdf_fn_uaGetHostIp(p_host_name, &p_host_ip,
                &sdf_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in GetHostIp"));
        ret_val = ICF_FAILURE;
    }
    else
    {
        /* The sdf_cbk_uaGetHostIp callback allocates memory for 
         * p_host_ip. Now we will copy the string ip address to
         * p_self_ip_str argument and then release this memory.
         * Then we will proceed to set the 4-Octets in transport 
         * address st argument*/
        icf_port_strcpy(p_self_ip_str, (icf_uint8_t *)p_host_ip);
        sdf_memfree(0, (Sdf_ty_pvoid *)&p_host_ip, &sdf_error);
        sdf_memfree(0, (Sdf_ty_pvoid *)&p_host_name, &sdf_error);


        if (ICF_FAILURE == icf_ssa_convert_to_tran_addr(p_self_ip_str,
                    p_self_address))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in icf_ssa_convert_to_tran_addr"));
            ret_val = ICF_FAILURE;
        }
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_convert_to_tran_addr
 *
 * DESCRIPTION:     This function converts the IP address
 *                  stored in the SDP body of SIP message
 *                  to the transport address understandable by the
 *                  ICF
 *
 ******************************************************************************/
icf_return_t icf_ssa_convert_to_tran_addr(
        INOUT icf_uint8_t *p_remoteIP,
        OUT icf_transport_address_st *p_rtp_address)
{
       icf_port_str_to_trans_addr(p_remoteIP, &(p_rtp_address->addr));
    return ICF_SUCCESS;
}

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_convert_to_IP_addr
 *
 * DESCRIPTION:     This function converts the transport address to a string
 *                  to be  sored in the SDP body of the SIP message     
 *
 ******************************************************************************/
icf_return_t icf_ssa_convert_to_IP_addr(
        INOUT icf_transport_address_st *p_rtp_address,
        OUT icf_uint8_t *p_remoteIP)
{
    if(p_rtp_address->addr.addr_type == ICF_TRANSPORT_ADDRESS_IPV4_ADDR){
        icf_port_sprintf((icf_int8_t *)p_remoteIP,"%d.%d.%d.%d",
            p_rtp_address->addr.addr.ipv4_addr.octet_1,
            p_rtp_address->addr.addr.ipv4_addr.octet_2,
            p_rtp_address->addr.addr.ipv4_addr.octet_3,
            p_rtp_address->addr.addr.ipv4_addr.octet_4);
    }
#ifdef ICF_IPV6_ENABLED
    else if( p_rtp_address->addr.addr_type == ICF_TRANSPORT_ADDRESS_IPV6_ADDR){
        strcpy(p_remoteIP, p_rtp_address->addr.addr.ipv6_addr.str);
    }
#endif
    return ICF_SUCCESS;
}

#ifdef ICF_ERROR_ENABLE
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_error
 *
 * DESCRIPTION:     This function is used by SSA for error handling.
 *
 ******************************************************************************/
icf_void_t icf_ssa_error(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        IN     Sdf_ty_s8bit	  *p_method, 
        INOUT  icf_error_t    ecode)
{
    icf_error_data_st                error_data;
    icf_glb_pdb_st                   *p_glb_pdb = ICF_NULL;
    icf_rgm_context_st               *p_rgm_ctx = ICF_NULL;
    icf_uint8_t                      int_count = ICF_NULL; 
    icf_uint8_t                      str_count = ICF_NULL; 
    icf_uint8_t                      loop_index = ICF_NULL; 
    icf_app_id_t                     app_id = ICF_NULL;
    icf_line_id_t                    line_id = ICF_NULL;
    icf_call_id_t                    call_id = ICF_NULL;
    Sdf_ty_u16bit                    response_code = ICF_NULL;

    p_glb_pdb = p_ssa_pdb->p_glb_pdb;

    icf_port_memset((icf_void_t *)(&error_data),ICF_NULL,
                    (icf_uint32_t)ICF_PORT_SIZEOF(icf_error_data_st));
    error_data.num_of_integer_values = 0;
   
   /* icf_port_memset((void *)&error_data, 0 , sizeof(error_data)); */
   if (ICF_NULL != p_method)
   {
    if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"REGISTER" ) == 0)
    {
        /* Fetch the app id and line id from the rgm context.
         */
        p_rgm_ctx = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt;
        if(ICF_NULL != p_rgm_ctx)
        {
            /* Form the error data structure for registration DNS 
             * Query Failure/TCP connection failure etc.
             */

            for (loop_index = 0; (loop_index < p_ssa_pdb->p_glb_cfg_data->\
                        max_applications); loop_index++)
            {
                if (ICF_FALSE == p_rgm_ctx->p_app_data_list[loop_index].is_valid)
                {
                    continue;
                }

                else
                {

                    app_id = p_rgm_ctx->p_app_data_list[loop_index].app_id;
                    line_id = p_rgm_ctx->p_app_data_list[loop_index].line_id;
                    break;
                }
            }
            if(ICF_ERROR_AUTHENTICATION_FAILURE == ecode)
            {
                response_code = 401;
            }
        }
            call_id = ICF_INVALID_CALL_ID;
            icf_port_strcpy(error_data.string_val[str_count].str, 
                    (icf_uint8_t *)p_method);
            error_data.string_val[str_count].str_len=\
                                                     (icf_uint16_t )icf_port_strlen((icf_uint8_t *)p_method);
            (str_count)++;
    }
    else if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt)
    {
        if(!(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"INVITE" ) == 0))
        {
            /* Method other than Invite Failed. So send p_method and "INVITE" 
             * in the error indication.
             */
            icf_port_strcpy(error_data.string_val[str_count].str, 
            (icf_uint8_t *)p_method);
            error_data.string_val[str_count].str_len=\
                                                    (icf_uint16_t ) icf_port_strlen((icf_uint8_t *)p_method);
            (str_count)++;

            icf_port_strcpy(error_data.string_val[str_count].str, 
                    (icf_uint8_t *)"INVITE");
            error_data.string_val[str_count].str_len=\
                                                     (icf_uint16_t )icf_port_strlen((icf_uint8_t *)"INVITE");
            (str_count)++;
        }
        else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"INVITE" ) == 0)
        {
            icf_port_strcpy(error_data.string_val[str_count].str, 
                    (icf_uint8_t *)p_method);
            error_data.string_val[str_count].str_len=\
                                                     (icf_uint16_t )icf_port_strlen((icf_uint8_t *)p_method);
            (str_count)++;

        }
        /* Fetch the app id and line id from the call context.
         */
        app_id = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->app_id;
        line_id = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->line_id; 
        call_id = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->call_id;
        response_code = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->\
                        inc_response_code;
    }
    else if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt)

    {
        /* Fetch the app id and line id from sic context
        */
        app_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->app_id;
        line_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->line_id;
        call_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->call_id;
        if(ICF_ERROR_AUTHENTICATION_FAILURE == ecode)
        {
            response_code = 401;
        }
        icf_port_strcpy(error_data.string_val[str_count].str, 
                (icf_uint8_t *)p_method);
        error_data.string_val[str_count].str_len=\
                                             (icf_uint16_t )icf_port_strlen((icf_uint8_t *)p_method);
        (str_count)++;
    }
    else
    {
        return;
    }

    if(ICF_NULL != app_id)
    {
        error_data.int_val[ICF_MAX_INT_ERROR_DATA-1]= app_id;
    }
    else
    {
        error_data.int_val[ICF_MAX_INT_ERROR_DATA-1]= ICF_DUMMY_APP_ID;
    }   
    error_data.int_val[int_count]= line_id;
    int_count++;

    error_data.int_val[ICF_MAX_INT_ERROR_DATA - 2] = call_id;

    error_data.num_of_integer_values = int_count;

    error_data.number_of_string_values = str_count;
   }
    switch (ecode)
    {
        case ICF_ERROR_DNS_QUERY_FAILURE:
            icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_DNS_QUERY_FAILURE");
            error_data.err_string.str_len = (icf_uint16_t )icf_port_strlen(error_data.err_string.str);
            break;
        
        case ICF_ERROR_AUTHENTICATION_FAILURE:
            icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_AUTHENTICATION_FAILURE");
            error_data.err_string.str_len = (icf_uint16_t )icf_port_strlen(error_data.err_string.str);

            break;
        
        case ICF_ERROR_RETRANSMISSION_TIMEOUT:
            icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_RETRANSMISSION_TIMEOUT");
            error_data.err_string.str_len = (icf_uint16_t )icf_port_strlen(error_data.err_string.str);
            if(ICF_NULL != response_code)
              {
                error_data.int_val[error_data.num_of_integer_values]= (icf_uint32_t)response_code;
                (error_data.num_of_integer_values) ++;
              }
            break;

        case ICF_ERROR_OPEN_SOCKET:
            icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_OPEN_SOCKET");
            error_data.err_string.str_len = (icf_uint16_t )icf_port_strlen(error_data.err_string.str);
            break;

        case ICF_ERROR_FAILURE_RESPONSE:
            icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_FAILURE_RESPONSE");
            error_data.err_string.str_len =(icf_uint16_t ) icf_port_strlen(error_data.err_string.str);
            error_data.int_val[error_data.num_of_integer_values]= (icf_uint32_t)p_ssa_pdb->resp_code;

            (error_data.num_of_integer_values) ++;

            break;
        case ICF_ERROR_INTERMIDIATE_RETRANSMISSION_TIMEOUT:
             icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_INTERMIDIATE_RETRANSMISSION_TIMEOUT");
             error_data.err_string.str_len = (icf_uint16_t )icf_port_strlen(error_data.err_string.str);
             error_data.int_val[error_data.num_of_integer_values]= (icf_uint32_t)p_ssa_pdb->retrans_count;
             (error_data.num_of_integer_values) ++;
             if(ICF_NULL != response_code)
              {
                error_data.int_val[error_data.num_of_integer_values]= (icf_uint32_t)response_code;
                (error_data.num_of_integer_values) ++;
              }
             break;
  
        default:
            error_data.num_of_integer_values = ICF_NO_INT_PRESENT;
            error_data.number_of_string_values = ICF_NO_STRING_PRESENT;
            break;
    }
    
    ICF_SET_ERROR(p_glb_pdb,&error_data,ecode,&ecode) 
} /* end of icf_ssa_error() */
#endif

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_add_callid_callobj_map
 *
 * DESCRIPTION:     This function is used by SSA for adding SSA ctxt
 * - nw call id mapping to the SSA db.
 *
 ******************************************************************************/
icf_return_t icf_ssa_add_callid_callobj_map(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        OUT   icf_ssa_ctxt_st  *p_ssa_ctxt,
        OUT   icf_error_t    *p_ecode)
{
    /*icf_uint8_t              count = 0;*/
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_list_st          *p_map_ssa_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st          *p_map_temp_ssa_ctxt = ICF_NULL;
#ifndef ICF_LOOPBACK_SUPPORT
    icf_return_t			dummy_ret_val = ICF_SUCCESS;
#else
    icf_uint32_t            key_length = 0;
#endif
    /* icf_ssa_glb_data_st      *p_ssa_glb_data = (icf_ssa_glb_data_st*)
       (p_ssa_pdb->p_ssa_glb_data);*/

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    

 if(ICF_NULL == p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid)
    {
        return  ICF_FAILURE;
    }
        (void)p_ecode;

#ifdef ICF_LOAD_DEBUG
    printf("\nSSA CTXT Allocated: %x %s\n", p_ssa_ctxt, 
           p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid);
#endif
#ifndef ICF_LOOPBACK_SUPPORT 
    ret_val = icf_dbm_hash_add_ssa_ctxt(p_ssa_pdb->p_glb_pdb,
            p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid,
            p_ssa_ctxt,p_ecode);
    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            (icf_port_strlen(p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid) + 1),
            ICF_MEM_COMMON,
            p_ssa_ctxt->p_hash_key,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            dummy_ret_val)
        icf_port_strcpy(p_ssa_ctxt->p_hash_key,p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid);

#else
    key_length = icf_port_strlen((icf_uint8_t *)p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid) ; 
    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            key_length+ 1,
            ICF_MEM_COMMON,
            p_ssa_ctxt->p_hash_key,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val);
    icf_port_strcpy(p_ssa_ctxt->p_hash_key,(icf_uint8_t *)p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid);
#if 0  
    HASH_ENH 
        icf_port_strcat(p_ssa_ctxt->p_hash_key,local_addr_str.addr_val.str);
    icf_port_strcat(p_ssa_ctxt->p_hash_key,remote_addr_str.addr_val.str);
    if ( 0 != p_ssa_pdb->hash_index)
    {
        icf_port_strcat(p_ssa_ctxt->p_hash_key,hash_index_str);
    }
#endif
    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            sizeof(icf_ssa_ctxt_list_st),
            ICF_MEM_COMMON,
            p_map_ssa_ctxt,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val);
    p_map_ssa_ctxt->p_ssa_ctxt = p_ssa_ctxt;
    p_map_ssa_ctxt->p_next = ICF_NULL;
    ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(p_ssa_pdb->p_glb_pdb,
            p_ssa_ctxt->p_hash_key,
            (icf_void_t **)&p_map_temp_ssa_ctxt,p_ecode);
    if ( ICF_SUCCESS == ret_val)
    {
        /*  append it to linkek list */
        icf_ssa_append_to_ssa_ctxt_list(p_map_temp_ssa_ctxt, p_map_ssa_ctxt);
    }
    else
    {

        ret_val = icf_dbm_hash_add_ssa_ctxt(p_ssa_pdb->p_glb_pdb,
                p_ssa_ctxt->p_hash_key,
                p_map_ssa_ctxt,p_ecode);
    }


#endif	

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}
    

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_map_nw_callid
 *
 * DESCRIPTION:     This function is used by SSA for trace handling.
 *
 ******************************************************************************/
icf_return_t icf_ssa_map_nw_callid(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
#ifdef ICF_LOOPBACK_SUPPORT
        INOUT  Sdf_st_callObject       *p_call_obj,
#endif
        INOUT  icf_uint8_t    *p_nw_call_id,
        OUT   icf_ssa_ctxt_st    **p_p_mapped_ssa_ctxt,
#ifdef ICF_LOOPBACK_SUPPORT
        OUT   Sdf_st_error            *p_sdf_error,
#endif
        OUT   icf_error_t    *p_ecode)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_list_st  *p_ssa_list = ICF_NULL;
    icf_ssa_ctxt_list_st  *p_ssa_temp = ICF_NULL;
    /*
       icf_ssa_glb_data_st      *p_ssa_glb_data = (icf_ssa_glb_data_st*)
       p_ssa_pdb->p_ssa_glb_data;
     */

#ifdef ICF_LOOPBACK_SUPPORT
    SipMessage              *p_temp_msg = Sdf_co_null;
    en_SipMessageType		dMsgType;
    icf_return_t			dummy_ret_val = ICF_SUCCESS;
#endif	
    icf_uint8_t				*p_hash_key = ICF_NULL;
    icf_uint32_t			key_length = 0;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

        (void)p_ecode;

    key_length = icf_port_strlen(p_nw_call_id) + 1;

    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            key_length,
            ICF_MEM_COMMON,
            p_hash_key,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val);

    icf_port_strcpy(p_hash_key,p_nw_call_id);

    ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(
            p_ssa_pdb->p_glb_pdb,p_hash_key,
            (icf_void_t **)&p_ssa_list,p_ecode);
    if ((ret_val == ICF_SUCCESS) &&
            (ICF_NULL != p_ssa_list))
    {
        *p_p_mapped_ssa_ctxt = p_ssa_list->p_ssa_ctxt ;
#ifdef ICF_LOOPBACK_SUPPORT
        if (p_call_obj->pUacTransaction->pSipMsg != Sdf_co_null)
            p_temp_msg = p_call_obj->pUacTransaction->pSipMsg;
        else
            p_temp_msg = p_call_obj->pUasTransaction->pSipMsg;

        sip_getMessageType(p_temp_msg, &dMsgType, \
                (SipError*)    &(p_sdf_error->stkErrCode)) ;
        /* Call dialog is matched as follows:
         * If it is request, then
         *   Call id, From, To should map with call id, To and From.
         *   Note that the order of From and To are changed as requests 
         *   have the To and From reversed. 
         * If the message is a response, then
         *    Call id, From and To should map with the call id, From
         *    and To of the original call object.
         */

        if (ICF_SUCCESS == ret_val)
        {
            for (p_ssa_temp = p_ssa_list;p_ssa_temp != ICF_NULL; p_ssa_temp = p_ssa_temp->p_next)
            {
                p_ssa_pdb->notify_tag_mismatch = ICF_TRUE;
                if(ICF_SUCCESS == icf_ssa_util_cmp_tags(
                            p_ssa_pdb,
                            p_call_obj, 
                            p_ssa_temp->p_ssa_ctxt->p_call_obj,
                            p_sdf_error))
                {
                    *p_p_mapped_ssa_ctxt = p_ssa_temp->p_ssa_ctxt;
                    p_ssa_pdb->notify_tag_mismatch = ICF_FALSE;
                    ret_val =  ICF_SUCCESS;
                    break;
                }
            }
            if (ICF_NULL == p_ssa_temp)
            {

                if ( (SipMessageRequest == dMsgType) && 
                        (ICF_FALSE == p_ssa_pdb->is_otg_msg))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    *p_p_mapped_ssa_ctxt = p_ssa_list->p_ssa_ctxt ;
                    ret_val =  ICF_SUCCESS;
                }
            }
        }


#endif
    }
    else
        *p_p_mapped_ssa_ctxt = ICF_NULL;

    ICF_MEMFREE(
            p_ssa_pdb->p_glb_pdb,
            p_hash_key,
            ICF_MEM_COMMON,
            p_ssa_pdb->p_ecode,
            dummy_ret_val);
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}


#ifdef ICF_TRACE_ENABLE
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_trace
 *
 * DESCRIPTION:     This function is used by SSA for trace handling.
 *
 ******************************************************************************/
icf_void_t icf_ssa_trace(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT icf_trace_id_t trace_id)
{
    icf_trace_data_st                trace_data;

    switch(trace_id)
    {
        default:
            trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;

            trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
            break;

    } /* end of switch-case for trace_id */

    /* Finally, invoke the common macro for trace handling */
    ICF_TRACE(p_ssa_pdb->p_glb_pdb, trace_id, &trace_data)
} /* end of icf_ssa_trace() */




/*******************************************************************************
*
* FUNCTION:        icf_ssa_app_trace
*
* DESCRIPTION:     This function is used by SSA for trace handling.
*
******************************************************************************/
   icf_return_t icf_ssa_app_trace(
          INOUT  icf_ssa_pdb_st *p_ssa_pdb,
          INOUT icf_trace_id_t trace_id)
   {
        icf_trace_data_st               trace_data;
   		icf_trace_criteria_data_st    	*p_criteria_data = ICF_NULL;
	    icf_app_id_t    app_id = ICF_INVALID_APP_ID;
	    icf_call_id_t	call_id = ICF_INVALID_CALL_ID;
	    icf_line_id_t	line_id = ICF_INVALID_LINE_ID;
        icf_line_data_st        *p_line_data = ICF_NULL;
        icf_uint8_t              registrar_addr[100] = {0};
		icf_return_t    ret_val = ICF_SUCCESS;
		icf_uint8_t     p_transp_addr_str[100] = "";

        icf_generic_string_st   *p_msg = ICF_NULL;
        icf_glb_pdb_st        *p_glb_pdb = p_ssa_pdb->p_glb_pdb;
      
        icf_port_memset(&trace_data,0,
                    ICF_PORT_SIZEOF(icf_trace_data_st));
	
	if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt)
	{
	if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt)
	{
	   icf_uint8_t loop_index;

	    for (loop_index = 0; (loop_index < 
		p_ssa_pdb->p_glb_cfg_data->max_applications); loop_index++)
	    {
        	if (ICF_FALSE == p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->
			p_app_data_list[loop_index].is_valid)         
        	{
                continue;
        	}
        	else
        	{
                    app_id = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->
			p_app_data_list[loop_index].app_id;
                    line_id = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->
			p_app_data_list[loop_index].line_id;
		    break;
        	}
	    } 	    
	    call_id = ICF_INVALID_CALL_ID;
	    p_criteria_data = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->
		p_trace_criteria_data;
	}
	else if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt)
	{
	    app_id = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->app_id;
	    call_id = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->call_id;
        if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->
           p_trace_criteria_data)
        {
	         p_criteria_data = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->
                    p_trace_criteria_data;
        }
	}
	else if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt)
	{
	    app_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->app_id;
	    call_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->call_id;
 	     p_criteria_data = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                p_trace_criteria_data;
	}
        else if(ICF_NULL != p_glb_pdb->p_call_ctx)
        {
            app_id = p_glb_pdb->p_call_ctx->app_id;
            call_id = p_glb_pdb->p_call_ctx->call_id;
            p_criteria_data = p_glb_pdb->p_call_ctx->
                p_trace_criteria_data;
        }
        else
	{
	    return ICF_SUCCESS;
	}
	}
	else
	{
            /* Added for the system traces */
         if (ICF_NULL != p_ssa_pdb->p_glb_pdb->p_recv_msg)
         {
          if (0 == p_ssa_pdb->p_glb_pdb->p_recv_msg->hdr.app_id)
          {
              app_id = p_ssa_pdb->p_glb_pdb->p_glb_data->app_trace_info.app_id;
              call_id = p_ssa_pdb->p_glb_pdb->p_glb_data->app_trace_info.call_id;
          }
          else
          {
	      app_id = p_ssa_pdb->p_glb_pdb->p_recv_msg->hdr.app_id;
	      call_id = p_ssa_pdb->p_glb_pdb->p_recv_msg->hdr.call_id;
          }
         }  
	}
    /* For out of dialog options we will the criteria data here */     
    if(((ICF_TRACE_INC_OPTIONS == trace_id) && 
       (0 ==  p_ssa_pdb->dialog_status)) ||((ICF_TRACE_OTG_OPTIONS == trace_id)        
        && (0 ==  p_ssa_pdb->dialog_status)))
    {
        if(ICF_NULL == p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_trace_criteria_data)
        {
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                       ICF_PORT_SIZEOF(icf_trace_criteria_data_st),
                       ICF_MEM_COMMON,
                       p_criteria_data,
                       ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)

             p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_trace_criteria_data = 
                               p_criteria_data;
         }
         /* Added null check for klocworks warning removal*/
         if(ICF_NULL != p_criteria_data)
         {   
            if(ICF_TRACE_INC_OPTIONS == trace_id) /* If incoming options */
            {
                p_criteria_data->line_id =
                    (icf_uint16_t)(p_ssa_pdb->p_ssa_ctxt->line_id);
                p_criteria_data->bitmask |= ICF_TRACE_LINE_ID_PRESENT;
            }
            if(ICF_TRACE_OTG_OPTIONS == trace_id) /* if out of dialog outgoing options */
            {
                p_criteria_data->line_id =
                    (icf_uint16_t)(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->line_id);
                p_criteria_data->bitmask |= ICF_TRACE_LINE_ID_PRESENT;
            }
         }   
    }
       
       ret_val = icf_cmn_check_app_trace(p_ssa_pdb->p_glb_pdb,
                                        trace_id,
					p_criteria_data);
       if( ICF_FAILURE == ret_val)
       {
         return ret_val;
       }
       else
       {

    	p_ssa_pdb->p_glb_pdb->p_glb_data->app_trace_info.app_id =
                app_id;

    	p_ssa_pdb->p_glb_pdb->p_glb_data->app_trace_info.call_id =
                call_id;
 
        switch(trace_id)
        {

            case ICF_TRACE_SIP_PDU:
               
                /* SPR 17555 Fix: Send Call Direction(Incoming/Outgoing) to
                 * application
                 */
                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] = (icf_uint32_t)(p_ssa_pdb->call_direction);
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                	
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                     ICF_PORT_SIZEOF(icf_generic_string_st),
                     ICF_MEM_COMMON,
                     p_msg,
                     ICF_RET_ON_FAILURE,
                     p_ssa_pdb->p_ecode,ret_val)

                p_msg->p_buff = p_ssa_pdb->p_buf;
                p_msg->len = p_ssa_pdb->len;
		        trace_data.p_var_data = (icf_void_t *)p_msg;	
                break;
               
            case ICF_TRACE_INC_INFO:
            case ICF_TRACE_OTG_INFO:

                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] =
                     (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->line_id);

                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;
            
         case ICF_TRACE_INC_INFO_RESP:
         case ICF_TRACE_OTG_INFO_RESP:

                trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
                trace_data.int_val[0] =
                     (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->line_id);
                trace_data.int_val[1] = p_ssa_pdb->resp_code;

                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;

            case ICF_TRACE_INVITE_SENT:
		    {
                if (ICF_NULL != p_criteria_data)
                {
                    icf_transport_addr_st *p_local_addr =
                        &(p_criteria_data->p_local_sip_ip_address->addr);

                    trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                    trace_data.int_val[0] = p_ssa_pdb->p_ssa_ctxt->transport;

                    trace_data.number_of_string_values = ICF_THREE_STRING_PRESENT;

                    icf_port_strcpy(trace_data.string_val[0].str,
                            p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->
                            local_address.addr_val.str);

                    trace_data.string_val[0].str_len =
                        (icf_uint16_t )icf_port_strlen(trace_data.string_val[0].str);

                    icf_port_strcpy(trace_data.string_val[1].str,
                            (icf_uint8_t *)p_ssa_pdb->p_ssa_ctxt->
                            p_call_ctxt->remote_party_addr.addr_val.str);
                    trace_data.string_val[1].str_len =
                        (icf_uint16_t )icf_port_strlen(trace_data.string_val[1].str);
                    if(ICF_NULL !=p_local_addr)
                    {      
                        if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                                p_local_addr->addr_type)
                        {
                            icf_port_strcpy(trace_data.string_val[2].str,
                                    p_local_addr->addr.domain.str);
                        }
                        else if(ICF_TRANSPORT_ADDRESS_IPV4_ADDR == 
                                p_local_addr->addr_type)
                        {
                            icf_port_sprintf((icf_int8_t *)trace_data.string_val[2].str,
                                    "%d.%d.%d.%d",
                                    p_local_addr->addr.ipv4_addr.octet_1,
                                    p_local_addr->addr.ipv4_addr.octet_2,
                                    p_local_addr->addr.ipv4_addr.octet_3,
                                    p_local_addr->addr.ipv4_addr.octet_4);
                        }
                    } 
                    trace_data.string_val[2].str_len =
                        (icf_uint16_t)icf_port_strlen(trace_data.string_val[2].str);
                }
                break;
            }
            

         case ICF_TRACE_INVITE_RECVD:
			{
                if (ICF_NULL != p_criteria_data)
                {

                    icf_transport_addr_st *p_local_addr =
                        &(p_criteria_data->p_local_sip_ip_address->addr);

                    trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
                    trace_data.int_val[0] = p_ssa_pdb->p_ssa_ctxt->transport;
                    trace_data.int_val[2] = p_ssa_pdb->sdp_present;

                    trace_data.number_of_string_values = ICF_THREE_STRING_PRESENT;

                    icf_port_strcpy(trace_data.string_val[0].str,
                            (icf_uint8_t *)p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->
                            remote_party_addr.addr_val.str);

                    trace_data.string_val[0].str_len =
                        (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                    icf_port_strcpy(trace_data.string_val[1].str,
                            (icf_uint8_t *)p_ssa_pdb->p_ssa_ctxt->
                            p_call_ctxt->local_address.addr_val.str);
                    trace_data.string_val[1].str_len =
                       (icf_uint16_t) icf_port_strlen(trace_data.string_val[1].str);

                    if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                            p_local_addr->addr_type)
                    {
                        icf_port_strcpy(trace_data.string_val[2].str,
                                p_local_addr->addr.domain.str);
                    }
                    else if(ICF_TRANSPORT_ADDRESS_IPV4_ADDR == 
                            p_local_addr->addr_type)
                    {
                        icf_port_sprintf((icf_int8_t *)trace_data.string_val[2].str,
                                "%d.%d.%d.%d",
                                p_local_addr->addr.ipv4_addr.octet_1,
                                p_local_addr->addr.ipv4_addr.octet_2,
                                p_local_addr->addr.ipv4_addr.octet_3,
                                p_local_addr->addr.ipv4_addr.octet_4);
                    }

                    trace_data.string_val[2].str_len =
                        (icf_uint16_t)icf_port_strlen(trace_data.string_val[2].str);

                }
                break;
         }
             
         case ICF_TRACE_PRACK_SENT:
         case ICF_TRACE_PRACK_RECVD:
         case ICF_TRACE_UPDATE_SENT:
         case ICF_TRACE_UPDATE_RECVD:
         case ICF_TRACE_REINVITE_RECVD:
         case ICF_TRACE_REINVITE_SENT:

                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] =
                     (icf_uint32_t)p_ssa_pdb->sdp_present;

                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;

	    case ICF_TRACE_PROVISIONAL_RESP_SENT:
      	case ICF_TRACE_PROVISIONAL_RESP_RECVD:

                trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
                trace_data.int_val[0] = p_ssa_pdb->resp_code;
                trace_data.int_val[1] = p_ssa_pdb->sdp_present;

                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                icf_port_strcpy(trace_data.string_val[0].str,
			                 p_ssa_pdb->p_method);
                trace_data.string_val[0].str_len =
                    (icf_uint16_t )icf_port_strlen(trace_data.string_val[0].str);

                break;

     case ICF_TRACE_FAILURE_RESP_SENT:
     case ICF_TRACE_FAILURE_RESP_RECVD:
                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] = p_ssa_pdb->resp_code;

                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                icf_port_strcpy(trace_data.string_val[0].str,
			                 p_ssa_pdb->p_method);
                trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                break;

        case ICF_TRACE_100_SENT:
        case ICF_TRACE_100_RECVD:
        case ICF_TRACE_302_SENT:
        case ICF_TRACE_302_RECVD:
               trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;

                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                icf_port_strcpy(trace_data.string_val[0].str,
                                         p_ssa_pdb->p_method);
                trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                break;               
	
         case ICF_TRACE_183_SENT:
         case ICF_TRACE_180_SENT:
         case ICF_TRACE_183_RECVD:
         case ICF_TRACE_180_RECVD:
        case ICF_TRACE_200_SENT:
        case ICF_TRACE_200_RECVD:
        case ICF_TRACE_202_SENT:
        case ICF_TRACE_202_RECVD:

                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] =
                     (icf_uint32_t)p_ssa_pdb->sdp_present;

                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                icf_port_strcpy(trace_data.string_val[0].str,
			          p_ssa_pdb->p_method);
                trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                break;

     case ICF_TRACE_BYE_SENT:
     case ICF_TRACE_BYE_RECVD:
     case ICF_TRACE_ACK_SENT:
     case ICF_TRACE_ACK_RECVD:
     case ICF_TRACE_CANCEL_SENT:
     case ICF_TRACE_CANCEL_RECVD:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;

     case ICF_TRACE_OUT_OF_DIALOG_MESSAGE_RECVD:
     case ICF_TRACE_OUT_OF_DIALOG_MESSAGE_SENT:

                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;

                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                icf_port_strcpy(trace_data.string_val[0].str,
			         p_ssa_pdb->p_method);
                trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                break;


 	case ICF_TRACE_DNS_QUERY_FAILURE:

           trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;

           trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

            if(ICF_DNS_SRV_QUERY == p_ssa_pdb->dns_query_type)
           {
              icf_port_strcpy(trace_data.string_val[1].str,
                  (icf_uint8_t *)"Srv Query");
           }
           else
            {
           icf_port_strcpy(trace_data.string_val[1].str,
                  (icf_uint8_t *)"AAA Querry");
           }
           trace_data.string_val[1].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[1].str);
            
            
            break;

           case ICF_TRACE_REFER_SENT:
                
                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] = p_ssa_pdb->replace_header_present;

                trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

                icf_port_strcpy(trace_data.string_val[0].str,
                        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_val.str);
                trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                icf_port_strcpy(trace_data.string_val[1].str,
                        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->
                        remote_party_name.str);
            
		trace_data.string_val[1].str_len =
                   (icf_uint16_t) icf_port_strlen(trace_data.string_val[1].str);

                break;  

          case ICF_TRACE_NOTIFY_FOR_REFER_RECVD:

                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] = p_ssa_pdb->resp_code;			
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
 
                
                break;

           case ICF_TRACE_NOTIFY_FOR_REFER_SENT:

                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] = p_ssa_pdb->resp_code;

                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;

                
                break;

           case ICF_TRACE_INC_OPTIONS:

                trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;

	        if(1 == p_ssa_pdb->dialog_status)
	        {
                    trace_data.int_val[0] =
                          (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->line_id);

                }
                if(0 == p_ssa_pdb->dialog_status)
                {
                    trace_data.int_val[0] =
                      (icf_uint32_t)(p_ssa_pdb->line_recvd); /* Assign p_ssa_pdb->line_recvd to line_id  */

                }
                trace_data.int_val[1] =
                       p_ssa_pdb->dialog_status;

	        if(1 == p_ssa_pdb->dialog_status)
	        {
                    trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;
                    icf_port_strcpy(trace_data.string_val[0].str,
                        	 p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_val.str);
                    trace_data.string_val[0].str_len =
                        (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);
	     
                    icf_port_strcpy(trace_data.string_val[1].str,
                             p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_val.str);
                    trace_data.string_val[1].str_len =
                       (icf_uint16_t) icf_port_strlen(trace_data.string_val[1].str);
	        }
                break;

       case ICF_TRACE_INC_OPTIONS_RESP:

             trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
             trace_data.int_val[0] =
                     (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->
                                       p_sic_ctxt->line_id);
             trace_data.int_val[1] =
                     (icf_uint32_t)(p_ssa_pdb->resp_code);
             
             trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

             /*icf_port_strcpy(trace_data.string_val[0].str,
                                  p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_val.str);*/ 
             trace_data.string_val[0].str_len =
                    (icf_uint16_t) icf_port_strlen(trace_data.string_val[0].str);

            /*icf_port_strcpy(trace_data.string_val[1].str,
                                p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_val.str);*/
             trace_data.string_val[1].str_len =
                        (icf_uint16_t)icf_port_strlen(trace_data.string_val[1].str);
             
             break;
    
       case ICF_TRACE_OTG_OPTIONS:

             trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
             trace_data.int_val[0] =
                     (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->
                            p_sic_ctxt->line_id);
             trace_data.int_val[1] = p_ssa_pdb->dialog_status;

             if(1==p_ssa_pdb->dialog_status)
             {

             	trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

             	icf_port_strcpy(trace_data.string_val[0].str,
          	        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_val.str);
             	trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

             	icf_port_strcpy(trace_data.string_val[1].str,
                                        p_ssa_pdb->remote_addr.addr_val.str);
             	trace_data.string_val[1].str_len =
                        (icf_uint16_t) icf_port_strlen(trace_data.string_val[1].str); 
              }
	      else
	      {
	         trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
				icf_port_strcpy(trace_data.string_val[0].str,
                                        p_ssa_pdb->remote_addr.addr_val.str);
            	 trace_data.string_val[0].str_len =
                       (icf_uint16_t) icf_port_strlen(trace_data.string_val[0].str);
	      }

             break;

        case ICF_TRACE_OTG_OPTIONS_RESP:

             trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
             trace_data.int_val[0] =
                     (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->
                              p_sic_ctxt->line_id);
             trace_data.int_val[1] =
                     (icf_uint32_t)(p_ssa_pdb->resp_code);
             
             trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

             /*icf_port_strcpy(trace_data.string_val[0].str,
                             p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_val.str);*/
             trace_data.string_val[0].str_len =
                    (icf_uint16_t) icf_port_strlen(trace_data.string_val[0].str);

             icf_port_strcpy(trace_data.string_val[1].str,
                                        p_ssa_pdb->remote_addr.addr_val.str);
             trace_data.string_val[1].str_len =
                        (icf_uint16_t)icf_port_strlen(trace_data.string_val[1].str);
             
             break;

        case ICF_TRACE_REG_AUTH_401:
        case ICF_TRACE_REG_AUTH_407:

             if (ICF_FAILURE != icf_dbm_fetch_line_cntxt_blk(
                p_ssa_pdb->p_glb_pdb,
                p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->rgm_list_of_lines[0],
                &p_line_data, p_ssa_pdb->p_ecode))
    	     {
         		if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
            			 p_line_data->registrar_addr.addr.addr_type)
         	    { 
            			icf_port_strcpy(
                    			registrar_addr,
                    			p_line_data->registrar_addr.addr.addr.domain.str);
         	     }
                 else if (ICF_TRANSPORT_ADDRESS_IPV4_ADDR ==
                     p_line_data->registrar_addr.addr.addr_type)
                {
            	  icf_port_sprintf((icf_int8_t *)registrar_addr,"%d.%d.%d.%d:%d",
                    p_line_data->registrar_addr.addr.addr.ipv4_addr.octet_1,
                    p_line_data->registrar_addr.addr.addr.ipv4_addr.octet_2,
                    p_line_data->registrar_addr.addr.addr.ipv4_addr.octet_3,
                    p_line_data->registrar_addr.addr.addr.ipv4_addr.octet_4,
                   p_line_data->registrar_addr.port_num);
                }
             }


               trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
               trace_data.int_val[0] = line_id;
             
             trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;
                  icf_port_strcpy(trace_data.string_val[0].str,registrar_addr);
             trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);
             
             icf_port_strcpy(trace_data.string_val[1].str,
                   p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->rgm_user_address.addr_val.str);
             trace_data.string_val[1].str_len =
                        (icf_uint16_t )icf_port_strlen(trace_data.string_val[1].str); 
               
             break;


        case ICF_TRACE_SUBS_AUTH_401:
        case ICF_TRACE_SUBS_AUTH_407:

               trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
               trace_data.int_val[0] =
                     (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->line_id);

                             if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
              {
                 trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

                 icf_port_strcpy(trace_data.string_val[0].str,
                   p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->dest_addr.addr_val.str);
                 trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                 icf_port_strcpy(trace_data.string_val[1].str,
                   p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_val.str);
                 trace_data.string_val[1].str_len =
                        (icf_uint16_t )icf_port_strlen(trace_data.string_val[1].str);
              }
              else
              {
                 trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                 icf_port_strcpy(trace_data.string_val[0].str,
                   p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->dest_addr.addr_val.str);
                 trace_data.string_val[0].str_len =
                   (icf_uint16_t ) icf_port_strlen(trace_data.string_val[0].str);
              }


             break;
   
        case ICF_TRACE_NOTIFY_FOR_SUBS:
             
             /*CSR 1-6179301 In case the subs state is not present no need to 
               send the trace to APP*/

             if(ICF_NULL == p_ssa_pdb->p_subs_state)
             {
                 return ICF_SUCCESS;
             }

             trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;

             trace_data.int_val[0] =
                 (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->line_id);

             trace_data.int_val[1] =
                 (icf_uint32_t)(p_ssa_pdb->notify_duration);

             if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
             {
                 trace_data.number_of_string_values = 
                     ICF_TWO_STRING_PRESENT;

                 icf_port_strcpy(trace_data.string_val[0].str,
                     (icf_uint8_t *)p_ssa_pdb->p_subs_state);

                 trace_data.string_val[0].str_len = (icf_uint16_t )
                    icf_port_strlen(trace_data.string_val[0].str);

                 icf_port_strcpy(trace_data.string_val[1].str,
                     p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                         p_preferred_identity->addr_val.str);

                 trace_data.string_val[1].str_len = (icf_uint16_t)
                     icf_port_strlen(trace_data.string_val[1].str);
             }
             else 
             {
                 trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                 icf_port_strcpy(trace_data.string_val[0].str,
                     (icf_uint8_t *)p_ssa_pdb->p_subs_state);

                 trace_data.string_val[0].str_len = (icf_uint16_t )
                     icf_port_strlen(trace_data.string_val[0].str);
             }

             break;

         case ICF_TRACE_TCP_CONNECTION_OPEN:
         case ICF_TRACE_TLS_CONNECTION_OPEN:
         case ICF_TRACE_UDP_SERVER_OPEN:
         case ICF_TRACE_TCP_SERVER_OPEN:
         case ICF_TRACE_TLS_SERVER_OPEN:
             
              trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;

              trace_data.int_val[0] =
                     (icf_uint32_t)(p_ssa_pdb->result);
			/*Fix for CSR 7991608 SPR 20220*/
			/*Added traces for per line configuration*/
			if (ICF_CFG_SELF_ADDR_PER_LINE ==
                       p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)

            {
			trace_data.int_val[1] = 
                     p_ssa_pdb->p_line_data->self_addr.port_num;
             
              trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
	          if( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME 
			       == p_ssa_pdb->p_line_data->self_addr.addr.addr_type)
	          {
	     	   	  icf_port_strcpy(trace_data.string_val[0].str,
                       p_ssa_pdb->p_line_data->self_addr.addr.addr.domain.str);
	    	  }
	          else if(ICF_TRANSPORT_ADDRESS_IPV4_ADDR
				== p_ssa_pdb->p_line_data->self_addr.addr.addr_type)
	          {
		     	icf_ssa_convert_to_IP_addr(&(p_ssa_pdb->p_line_data->self_addr),
                	            p_transp_addr_str);
	    		icf_port_strcpy(trace_data.string_val[0].str,
                                        p_transp_addr_str);
	    	  }
	    	  else if(ICF_TRANSPORT_ADDRESS_IPV6_ADDR
					== p_ssa_pdb->p_line_data->self_addr.addr.addr_type)
	      	  {
              	icf_port_strcpy(trace_data.string_val[0].str,
                    p_ssa_pdb->p_line_data->self_addr.addr.addr.ipv6_addr.str);
	    	  }

			}
			else
			{

	          trace_data.int_val[1] = 
                     p_ssa_pdb->p_glb_cfg_data->self_ip_address.port_num;
             
              trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
	          if( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME 
			       == p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
	          {
	     	   	  icf_port_strcpy(trace_data.string_val[0].str,
                       p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr.domain.str);
	    	  }
	          else if(ICF_TRANSPORT_ADDRESS_IPV4_ADDR
				== p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
	          {
		     	icf_ssa_convert_to_IP_addr(&(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                	            p_transp_addr_str);
	    		icf_port_strcpy(trace_data.string_val[0].str,
                                        p_transp_addr_str);
	    	  }
	    	  else if(ICF_TRANSPORT_ADDRESS_IPV6_ADDR
					== p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
	      	  {
              	icf_port_strcpy(trace_data.string_val[0].str,
                    p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr.ipv6_addr.str);
	    	  }
			}
              trace_data.string_val[0].str_len =
                    (icf_uint16_t )icf_port_strlen(trace_data.string_val[0].str);
              break;
	 
         case ICF_TRACE_TCP_CONNECTION_CLOSE:
         case ICF_TRACE_TLS_CONNECTION_CLOSE:
         case ICF_TRACE_UDP_SERVER_CLOSE:
         case ICF_TRACE_TCP_SERVER_CLOSE:
         case ICF_TRACE_TLS_SERVER_CLOSE:
            
               
             trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;

               trace_data.int_val[0] =
                     p_ssa_pdb->p_glb_cfg_data->self_ip_address.port_num;
             
            
            trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
            /* To check if self address per line feature is enabled or not*/
            /* If yes then fetch the data for trace from p_line_data */
            if (ICF_CFG_SELF_ADDR_PER_LINE ==
                       p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)

            {
                  trace_data.int_val[0] =
                         p_ssa_pdb->p_line_data->self_addr.port_num;        
                  if( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME
                        == p_ssa_pdb->p_line_data->self_addr.addr.addr_type)
                  { 
                        icf_port_strcpy(trace_data.string_val[0].str,
                             p_ssa_pdb->p_line_data->self_addr.addr.addr.domain.str);
                  } 
                  else if(ICF_TRANSPORT_ADDRESS_IPV4_ADDR
                                == p_ssa_pdb->p_line_data->self_addr.addr.addr_type)
                  { 
                        icf_ssa_convert_to_IP_addr(&(p_ssa_pdb->p_line_data->self_addr),
                                    p_transp_addr_str);
                        icf_port_strcpy(trace_data.string_val[0].str,
                                        p_transp_addr_str);
                  } 
                  else if(ICF_TRANSPORT_ADDRESS_IPV6_ADDR
                           == p_ssa_pdb->p_line_data->self_addr.addr.addr_type)
                  {
                        icf_port_strcpy(trace_data.string_val[0].str,
                             p_ssa_pdb->p_line_data->self_addr.addr.addr.ipv6_addr.str);
                  }

            }
            /* Else fetch the trace data from cfg data */   
            else
            {
                  trace_data.int_val[0] =
                     p_ssa_pdb->p_glb_cfg_data->self_ip_address.port_num;

                  if( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME
                        == p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
                  {
                        icf_port_strcpy(trace_data.string_val[0].str,
                             p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr.domain.str);
                  }
                  else if(ICF_TRANSPORT_ADDRESS_IPV4_ADDR
                                == p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
                  {
                        icf_ssa_convert_to_IP_addr(&(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                                    p_transp_addr_str);
                        icf_port_strcpy(trace_data.string_val[0].str,
                                        p_transp_addr_str);
                  }
                  else if(ICF_TRANSPORT_ADDRESS_IPV6_ADDR
                           == p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
                  {
                        icf_port_strcpy(trace_data.string_val[0].str,
                        p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr.ipv6_addr.str);
                  }
            }
            trace_data.string_val[0].str_len =
                    (icf_uint16_t )icf_port_strlen(trace_data.string_val[0].str);
             break;

        case ICF_TRACE_UDP_SEND_ERROR:
        case ICF_TRACE_TCP_SEND_ERROR:
        case ICF_TRACE_TLS_SEND_ERROR:

              trace_data.num_of_integer_values = ICF_NO_INT_PRESENT; 
              /*
              trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;

               trace_data.int_val[0] =
                     (icf_uint32_t)(p_ssa_pdb->local_port_num);

                trace_data.int_val[1] =
                     (icf_uint32_t)(p_ssa_pdb->remote_port_num); */
   
              trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
            /*
             trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

                  icf_port_strcpy(trace_data.string_val[0].str,
                                        p_ssa_pdb->p_ssa_ctxt->local_transport_addr.str);
             trace_data.string_val[0].str_len =
                    icf_port_strlen(trace_data.string_val[0].str);

               icf_port_strcpy(trace_data.string_val[1].str,
                                        p_ssa_pdb->p_ssa_ctxt->remote_transport_addr.str);
             trace_data.string_val[1].str_len =
                    icf_port_strlen(trace_data.string_val[1].str);
               */
               break;

         case ICF_TRACE_SIP_MSG_RETRANSMISSION_TIMEOUT:

               trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;

                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                /*
                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                  icf_port_strcpy(trace_data.string_val[0].str,
                                        p_ssa_pdb->p_sip_msg);
               trace_data.string_val[0].str_len =
                    icf_port_strlen(trace_data.string_val[0].str);
                                                                   */
             break;

	    default:
               trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
    
               trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
             
               
               return ICF_SUCCESS;
     
        } /* end of switch-case for trace_id */
        if((p_ssa_pdb->common_bitmask & ICF_SSA_MSG_TRACE_ALREADY_SENT))
        {
        }
        else
        {
            /* Finally, invoke the common macro for trace handling */
            ICF_APP_TRACE(p_ssa_pdb->p_glb_pdb, trace_id, &trace_data,
                    p_criteria_data)
        }

     if(ICF_NULL != p_msg)
        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_msg,ICF_MEM_COMMON, 
             p_ssa_pdb->p_ecode,ret_val)

     return ret_val;
   }
} /* end of icf_ssa_app_trace() */

/*****************************************************************************
 * FUNCTION:           icf_ssa_port_stack_trace
 *
 * DESCRIPTION:        This function is used to print stack traces
 *
 *****************************************************************************/
icf_return_t icf_ssa_port_stack_trace(
              Sdf_ty_uaTraceLevel dLevel,
              Sdf_ty_traceType dType,
              const Sdf_ty_s8bit *pStr,
              Sdf_ty_u32bit dLen,
              Sdf_st_error *pErr)
{
    icf_trace_data_st                trace_data;

    if(ICF_NULL == p_persistent_glb_pdb)
        return ICF_SUCCESS;

    if (ICF_NULL != pStr)
        icf_port_strcpy(trace_data.string_val[0].str, 
                (icf_uint8_t *)pStr);
   
    trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
    trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

    if(dLevel || Sdf_en_briefTraces)
    {
/*        ICF_TRACE(p_persistent_glb_pdb, ICF_SIP_STACK_BRIEF_TRACE,*/
/*                &trace_data)*/
    }
    else 
    {
/*        ICF_TRACE(p_persistent_glb_pdb, ICF_SIP_STACK_DETAILED_TRACE,*/
/*                &trace_data)*/
    }

    dLevel= dLevel;
    dType= dType;
    dLen = dLen;
    pErr=pErr;
    return ICF_NULL;
}
#endif /* end of #ifdef ICF_TRACE_ENABLE */

#ifdef ICF_DEBUG_TRACE_ENABLE
/****************************************************************************
 * FUNCTION:           icf_ssa_port_stack_debug
 *
 * DESCRIPTION:        This function is used to print stack debug traces
 *
 *****************************************************************************/
icf_void_t icf_ssa_port_stack_debug(
              const Sdf_ty_s8bit *pStr)
{
    icf_sm_glb_data_st               *p_sm_data =  ICF_NULL;
    icf_trace_type_t glb_trace_type =  ICF_NULL;

    if(ICF_NULL == p_persistent_glb_pdb)
        return;

    p_sm_data = 
     p_persistent_glb_pdb->p_glb_data->p_module_data[ICF_INT_MODULE_SM];

     glb_trace_type = p_sm_data->trace_type;

    if (ICF_TRACE_TYPE_SIP_STACK_DEBUG & glb_trace_type)
    {
        if (ICF_NULL != pStr)
        {
            printf("\n[SDF]: %s\n", pStr);
        }
    }
}
#endif /* end of #ifdef ICF_DEBUG_TRACE_ENABLE */

/*****************************************************************************
 ** FUNCTION:           icf_ssa_isHeaderPresent
 **
 ** DESCRIPTION:        This function checks for the presence of given header
 **                                     inside a SipMessage structure.
 **
 *****************************************************************************/
icf_return_t icf_ssa_isHeaderPresent
        (SipMessage             *p_sipMsg,
         en_HeaderType          dHeader,
         Sdf_st_error           *p_err)
{
        SipHeader dSipHdr;

        if (SipFail == sip_getHeader(
                    p_sipMsg,dHeader,&dSipHdr,
                    (SipError*)&p_err->stkErrCode))
        {
                return ICF_FAILURE;
        }
        sip_freeSipHeader(&dSipHdr);

        return ICF_SUCCESS;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_get_new_call_obj
 **
 ** DESCRIPTION:        This function checks if a new call obj can be allocated
 **                     by checking against the ssa ctxt - nw call id map.
 **                     This routine first iterates through the map array
 **                     to see if an entry can be added.  This is essentially
 **                     the same traversal we do in adding the actual map
 **                     Can be avoided for better performance
 **                     This routine also updates the PDB with the call obj
 **                     pointer.
 *****************************************************************************/
icf_return_t icf_ssa_get_new_call_obj
        (INOUT   icf_ssa_pdb_st      *p_ssa_pdb,
         INOUT   Sdf_st_callObject      **p_p_call_obj)
{ 
    icf_return_t         ret_val = ICF_SUCCESS;
    icf_glb_pdb_st       *p_glb_pdb = 
        p_ssa_pdb->p_glb_pdb;

    /*
    icf_ssa_glb_data_st  *p_ssa_glb_data = 
        p_ssa_pdb->p_ssa_glb_data;
    icf_uint16_t         count = 0;
    */
    Sdf_st_error sdf_error;

    ICF_FUNCTION_ENTER(p_glb_pdb)
    p_glb_pdb = p_glb_pdb;
           /* UMR fix */
           icf_port_memset(
               (icf_void_t *)&sdf_error,
               0,
               ICF_PORT_SIZEOF(Sdf_st_error));
           if(p_ssa_pdb->p_glb_pdb->no_of_call_obj == ICF_SSA_MAX_CALL_OBJ)
           {
               ret_val = ICF_FAILURE;
           }
           else
           {

           if (Sdf_co_fail == 
                   sdf_ivk_uaInitCall(p_p_call_obj, &sdf_error))
           {
               /*
                * This means a memory allocation failed in SDF, 
                * so  it must have been taken care of there only
                * so we will attempt a MINOR error here
                */
               ret_val = ICF_FAILURE;
           }
           else
           {
                   /*Fix for CSR 1-7407479*/
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj = *p_p_call_obj;
                   p_ssa_pdb->p_glb_pdb->no_of_call_obj++;
               }
               }
   ICF_FUNCTION_EXIT(p_glb_pdb)
   return ret_val;
}



/*****************************************************************************
 ** FUNCTION:           icf_ssa_update_callobj_for_profile
 **
 ** DESCRIPTION:        This  routine:
 **                     1. Forms strings for From and Contact headers
 **                     2. Clones the global profile
 **                     3. Sets default From and Contact in the cloned profile
 **                     using the API received from CC.
 **                     5. Sets the profile in the callobject
 *****************************************************************************/
icf_return_t icf_ssa_update_callobj_for_profile(
        INOUT   icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_glb_pdb_st                   *p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    icf_error_t                      *p_ecode = p_ssa_pdb->p_ecode;
    icf_config_data_st               *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    icf_address_st                   *p_user_address = ICF_NULL;
    Sdf_st_initData                  *p_callobj_spec_profile = Sdf_co_null;
    Sdf_st_error                     sdf_error; 
    Sdf_ty_s8bit                     tpt_scheme[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                     from_user_addr[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                     display_name[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                     contact_addr[ICF_MAX_STR_LEN] = "\0";
    icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;
    icf_uint8_t                      *p_temp = ICF_NULL;
    icf_uint16_t                     port_us = ICF_NULL,default_port = ICF_NULL,final_from_port = ICF_NULL;
    icf_app_id_t                     app_id = ICF_APP_ID_INVALID;
#ifdef ICF_IPSEC_ENABLED
    icf_transport_address_st         *p_transport_address = ICF_NULL;
    icf_uint8_t                      p_transp_addr_str[20] = "";
#endif
    Sdf_ty_s8bit                    self_ip[ICF_MAX_STR_LEN] = "\0";
    icf_boolean_t                req_from_reg = ICF_FALSE;
    icf_boolean_t                int_subscribe_req = ICF_FALSE;
    icf_boolean_t                use_app_add_profile = ICF_FALSE;
#ifdef ICF_QOS_SUPPORT
    Sdf_st_error                  *p_sdf_error = &sdf_error;
    SipError                      sip_err, *p_sip_error = &sip_err;
    Sdf_st_configExtraHeaders     *p_required = ICF_NULL;
#endif
    icf_transport_address_st      *p_contact_address = ICF_NULL;
    icf_transport_address_st     self_addr ;
    icf_uint8_t                  *p_contact_str = ICF_NULL;
   Sdf_ty_s8bit                     contact_user_id[ICF_MAX_STR_LEN] = "\0";   
    Sdf_ty_s8bit                     contact_scheme[ICF_MAX_STR_LEN] = "sip"; 

#ifdef ICF_NAT_RPORT_SUPPORT
    icf_rport_config_data_st            *p_rport_config_data = ICF_NULL;
#endif
 
    ICF_FUNCTION_ENTER(p_glb_pdb)

    p_ecode = p_ecode;

    /* UMR fix */
    icf_port_memset(
        (icf_void_t *)&sdf_error,
        0,
        ICF_PORT_SIZEOF(Sdf_st_error));
    ICF_SSA_INIT_TRANS_ADDR(&self_addr)

    /*
     * If call object's initdata is not null, this function need not do 
     * anything since the From and Contact will alraedy be set
     */
    if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData)
    {
        ICF_FUNCTION_EXIT(p_glb_pdb)
        return ret_val;
    }
    /*
     * If the bit ICF_SSA_USER_ADDR_FRM_CC is set in the SSA
     * PDB,it indicates that the address to be used for
     * the population of the From and Contact header is the local
     * address of the call contetx,else pick the user address stored 
     * in the RGM context.
     */

    if (ICF_SSA_USER_ADDR_FRM_CC & p_ssa_pdb->common_bitmask)
    {
        p_user_address = &(p_glb_pdb->p_call_ctx->local_address);

        if ( ICF_LOCAL_NAME_PRESENT &
                p_glb_pdb->p_call_ctx->common_bitmask)
        {
            icf_port_strcpy((icf_uint8_t *)display_name, 
                    (icf_uint8_t *)p_glb_pdb->p_call_ctx->local_name.str);
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)display_name,(icf_uint8_t *) "");
        }
        app_id = p_glb_pdb->p_call_ctx->app_id;
    }
    else if (ICF_SSA_USER_ADDR_FRM_SIC & p_ssa_pdb->common_bitmask)
    {
        p_user_address = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_user_address;
        app_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->app_id;
        if(ICF_DUMMY_APP_ID == app_id)
        {
            /* This is the case for SUBSCRIBE initiated by ICF */
            int_subscribe_req = ICF_TRUE;
        }
        /* Code for display name to be added */
        icf_port_strcpy((icf_uint8_t *)display_name, (icf_uint8_t *)"");
    }
    else
    {
        p_ssa_ctxt = 
            (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
        ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))
        /* SPR 9849 Fix start */
        /*following is valid for IMS/Non-IMS*/
        p_user_address = &(p_ssa_ctxt->p_rgm_ctxt->rgm_user_address);
#if 0

ICF_CRM_START
        p_user_address = p_ssa_ctxt->p_rgm_ctxt->p_rgm_uris;
ICF_CRM_END
#endif
        /* SPR 9849 Fix end  */
        if ( ICF_NULL != p_ssa_pdb->p_line_data->user_name.str_len)
        {
            icf_port_strcpy((icf_uint8_t *)display_name, 
                    (icf_uint8_t *)p_ssa_pdb->p_line_data->user_name.str);
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)display_name, (icf_uint8_t *)"");
        }
        req_from_reg = ICF_TRUE;
    }

    
    /*
     * We are not checking whether there is atleast one user address
     * configured on this line. Assumed it has already been done
     * by some upstream module
     */

    /*Assumption: Address type validation must have 
     * been done in CFG*/
    if ( (ICF_ADDRESS_PLAN_SIP_URI == 
                p_user_address->addr_type) ||
            (ICF_ADDRESS_PLAN_E164 ==
             p_user_address->addr_type))
    {
        icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"sip");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    else if (ICF_ADDRESS_PLAN_SIPS_URI == 
            p_user_address->addr_type)
    {
        icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"sips");
        icf_port_strcpy((icf_uint8_t *)contact_scheme, (icf_uint8_t *)"sips"); /* By default it should be sips */
        default_port = ICF_DEFAULT_SIPS_SERVER_PORT;
    }
    else if (ICF_ADDRESS_PLAN_TEL_URI == 
            p_user_address->addr_type)
    {
        icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"tel");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    /*
     * We copy the complete user address string from the local
     * address and then check if it is a E164, if it is then 
     * we append the self user address from global config data
     * to the string to get complete userid@hostname string
     */
    icf_port_strcpy((icf_uint8_t *)from_user_addr,
            (icf_uint8_t *)p_user_address->addr_val.str);
    
    /*If per line self transport then copy address from line_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
    {
        icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                        sizeof(icf_transport_address_st));
#ifdef ICF_NAT_RPORT_SUPPORT
        p_rport_config_data = p_ssa_pdb->p_line_data->p_rport_config_data;
#endif
    }
    else
    {
        icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                        sizeof(icf_transport_address_st));
#ifdef ICF_NAT_RPORT_SUPPORT
        p_rport_config_data = &(p_glb_cfg_data->rport_config_data);
#endif
    }
    
#ifdef ICF_NAT_RPORT_SUPPORT

    if(ICF_TRUE == p_rport_config_data->is_rport_reqd)
    {
        p_contact_address = &(p_rport_config_data->contact_ip_addr);
    }
    else
    {
        p_contact_address = &(self_addr); 
    }
#else
    p_contact_address = &(self_addr);
#endif

    /* ------------------------------------------------- */
    /* The userId in Contact header should be the userid configured through 
     * set_line_params api. If this is not configured, then the userid part
     * of From header should be used.
     */
    if (ICF_NULL != p_ssa_pdb->p_line_data->contact_user_info.str_len)
    {
        icf_port_strcpy((icf_uint8_t *)contact_user_id, 
            (icf_uint8_t *)p_ssa_pdb->p_line_data->contact_user_info.str);
    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)contact_user_id, (icf_uint8_t *)from_user_addr);
        p_temp = icf_port_strchr((icf_uint8_t *)contact_user_id,(icf_uint8_t)'@');
        if (p_temp)
        {
            *p_temp = '\0';
        }        
    }
    icf_port_strcat((icf_uint8_t *)contact_user_id,(icf_uint8_t *)"@");
    icf_port_strcpy((icf_uint8_t *)contact_addr, (icf_uint8_t *)contact_user_id);
    /* ------------------------------------------------- */

    if ( ICF_ADDRESS_PLAN_E164 ==
            p_user_address->addr_type)
    {
	icf_transport_address_st       *p_from_address = ICF_NULL;

        icf_port_strcat((icf_uint8_t *)from_user_addr,(icf_uint8_t *)"@");

	 /* ----------- Form the From address ------------------ */
         /* In case of REGISTER message, if the configured user is E.164,
          * the From and To header should carry Registrar domain/IP and not
          * self address
          */
         if (ICF_SSA_USER_ADDR_FRM_RGM & p_ssa_pdb->common_bitmask)
         {
             p_from_address = &(p_ssa_pdb->p_line_data->registrar_addr);
         }
         else
         {
             p_from_address = &self_addr;
         }

if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
               p_from_address->addr.addr_type) 
        {
            icf_port_strcat(
				(icf_uint8_t *)from_user_addr,
                (icf_uint8_t *)p_from_address->addr.addr.domain.str);

        }
        else/*Assumption that it will be IPV4*/
        {
           /* icf_uint8_t remote_ip[16];
            icf_uint8_t contact_ip[16];
            if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                        &(self_addr), remote_ip))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                icf_port_strcat(from_user_addr, remote_ip);
                if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                            p_contact_address, contact_ip))
                {
                    ret_val = ICF_FAILURE;
                }   
                else
                {
                    icf_port_strcat(contact_addr, contact_ip);
                }
            }
	    */
	    icf_uint8_t from_ip[16] = "\0";
            if (ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                                                p_from_address, from_ip))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                icf_port_strcat((icf_uint8_t *)from_user_addr, (icf_uint8_t *)from_ip);
            }
        }

	/* ----------- Form the Contact address ------------------ */
        if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
               p_contact_address->addr.addr_type)
        {
            icf_port_strcat(
                   (icf_uint8_t *)contact_addr,
                   (icf_uint8_t *)p_contact_address->addr.addr.domain.str);
        }
        else/*Assumption that it will be IPV4*/
        {
            icf_uint8_t contact_ip[16] = "\0";
            if (ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                         p_contact_address, contact_ip))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                icf_port_strcat((icf_uint8_t *)contact_addr, (icf_uint8_t *)contact_ip);
            }
        }
    }

    /*
     * If the address type is SIP URI ,then we will
     * extract the userid from the SIP URI and then 
     * append the self IP address and port in order
     * to form the contact header
     */

     if (( ICF_ADDRESS_PLAN_SIP_URI ==
            p_user_address->addr_type) ||
            (ICF_ADDRESS_PLAN_SIPS_URI ==
            p_user_address->addr_type))
    {
        if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
               p_contact_address->addr.addr_type)
        {
            icf_port_strcat((icf_uint8_t *)contact_addr,
                    (icf_uint8_t *)p_contact_address->addr.addr.domain.str);
        }
        else/*Assumption that it will be IPV4*/
        {
            icf_uint8_t remote_ip[16];

            if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                        p_contact_address, remote_ip))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                icf_port_strcat((icf_uint8_t *)contact_addr, (icf_uint8_t *)remote_ip);
            }
        }
    }
    else if ( ICF_ADDRESS_PLAN_TEL_URI ==
            p_user_address->addr_type)
    {
        if(ICF_FAILURE ==
                icf_ssa_get_hostname_str_frm_trans_addr(
                    p_ssa_pdb,p_contact_address,(icf_uint8_t *)self_ip))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)contact_addr,(icf_uint8_t *)self_ip);
        }
    }
    if ( ICF_SUCCESS == ret_val)
    {
#ifdef ICF_QOS_SUPPORT
        if(ICF_NULL != p_glb_pdb->p_call_ctx)
        {
ICF_CHECK_QOS_SUPPORT_START(p_glb_pdb,ICF_TRUE)

            Sdf_ty_s8bit        Tmp1[ICF_MAX_STR_LEN];
            Sdf_ty_s8bit        Tmp2[ICF_MAX_STR_LEN];

                        icf_port_strcpy((icf_uint8_t *)Tmp1,(icf_uint8_t *)"REQUIRE");
            icf_port_strcpy((icf_uint8_t *)Tmp2, (icf_uint8_t *)"precondition");

            /* Add Require header to the user profile */
            if (Sdf_co_fail == sdf_ivk_uaInitConfigExtraHeaders(
                        &p_required, p_sdf_error))
            {
                ret_val = ICF_FAILURE;
            }
            else if (SipFail == sip_setNameInSipParam(p_required->pParam, 
                                                Sdf_mc_strdupCT(Tmp1), p_sip_error))
            {
                ret_val = ICF_FAILURE;
            }
            else if (SipFail == sip_insertValueAtIndexInSipParam(
                                p_required->pParam,
                                Sdf_mc_strdupCT(Tmp2),
                                0, p_sip_error))
                                         
            {
                 ret_val = ICF_FAILURE;
            }
            /*Checking whether It is for call (INVITE) or Register*/
            else if (ICF_SSA_USER_ADDR_FRM_CC & p_ssa_pdb->common_bitmask)
                    p_required->pData = Sdf_mc_strdupSdp("yes");
            else
                p_required->pData = Sdf_mc_strdupSdp("no");

            sdf_ivk_uaFreeConfigExtraHeaders(p_required);

ICF_CHECK_QOS_SUPPORT_END
        }
#endif
    /* Init the Initdata */
        if( Sdf_co_fail == sdf_ivk_uaInitInitData(&p_callobj_spec_profile, &sdf_error))
        {
        /* Return from here, in all other failure legs we free the Initdata
            before returning */
            return ICF_FAILURE;
        }
        else if(ICF_TRUE == req_from_reg)
        {
            /* We will not do anything for registration */
          /* Make a profile by cloning the default profile and 
            adding the extra headers given in app_profile */
        }

        else if(ICF_TRUE == int_subscribe_req)
        {
            ret_val = icf_ssa_make_profile_for_internal_subscribe(
                p_callobj_spec_profile,p_ssa_pdb);

        }
        else if(ICF_FAILURE == icf_cfg_fetch_app_conf(p_ssa_pdb->p_glb_pdb,app_id,&(p_ssa_pdb->p_app_conf),p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
        /* Make the application profile */
        /* For INVITE/SUBSCRIBE/MESSAGE/PUBLISH/out-of-dialog-REFER, Supported 
         * and Accept headers will be populated from the request header list and
         * not from the app profile */
        if (
            (ICF_NW_OTG_CALL_SETUP == 
                p_ssa_pdb->p_internal_msg->msg_hdr.msg_id) ||
            (ICF_NW_OTG_SUBSCRIBE_REQ == 
                p_ssa_pdb->p_internal_msg->msg_hdr.msg_id) ||
            (ICF_NW_OTG_MESSAGE_REQ == 
                p_ssa_pdb->p_internal_msg->msg_hdr.msg_id) ||
            (ICF_NW_OTG_PUBLISH_REQ == 
                p_ssa_pdb->p_internal_msg->msg_hdr.msg_id) ||
            (ICF_NW_OTG_OPTIONS_REQ ==
                p_ssa_pdb->p_internal_msg->msg_hdr.msg_id))
        {
            use_app_add_profile = ICF_FALSE;
        }
        else
        {
            use_app_add_profile = ICF_TRUE;
        }
        /* check for out-of-call REFER request */
        if ((ICF_NW_OTG_REFER == 
                p_ssa_pdb->p_internal_msg->msg_hdr.msg_id) &&
            (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt))
        {
            if (!(ICF_SIC_REQUEST_WITHIN_DIALOG & 
                 p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->bitmask))
            {
                use_app_add_profile = ICF_FALSE;
            }
        }

        if ((ICF_SUCCESS == ret_val) && 
            (ICF_FALSE == req_from_reg) && 
            (ICF_FALSE == int_subscribe_req))
        {
            if (ICF_FALSE == use_app_add_profile)
            {
                ret_val = icf_ssa_make_otg_app_profile(
                            p_callobj_spec_profile,p_ssa_pdb);
            }
            else
            {
                ret_val = icf_ssa_make_app_profile(
                            p_callobj_spec_profile,p_ssa_pdb);
            }
        }

        /* I observed a case where ret_val was equal to value 92, hence this */
        if (ICF_FAILURE != ret_val)
        {
#ifdef ICF_IPSEC_ENABLED
            
            /* If IPSec is enabled, set the port in Via and Contact headers to 
             * be the UE protected server port, for subsequent protected 
             * messages */

            if ((ICF_TRUE == p_glb_cfg_data->ipsec_enabled) &&
                (ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context))
            {
                /* For Registration message, rgm ctxt would have been already 
                 * copied in ssa pdb from ssa ctxt. For non-reg message, rgm ctx
                 * would have been fetched from uri and placed in ssa pdb */
                if (ICF_NULL != 
                        ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
                            p_ue_security_params)
                {
                    /* this means an SA exists */
                    port_us = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
                                p_ue_security_params->port_s;
                    
                    /* this code for getting p_transp_addr_str has been copied 
                     * from the function icf_ssa_process_open_nw_servers()
                     */

                    p_transport_address = &(self_addr);
                    if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                            p_transport_address->addr.addr_type)
                    {
                        icf_port_strcpy(p_transp_addr_str, 
                            p_transport_address->addr.addr.domain.str);
                    }
                    else if (ICF_TRANSPORT_ADDRESS_IPV4_ADDR == 
                                p_transport_address->addr.addr_type)
                    {
                        icf_ssa_convert_to_IP_addr(p_transport_address,
                            p_transp_addr_str);

                        if (0 == icf_port_strcmp(
                                    "0.0.0.0", 
                                    p_transp_addr_str))
                        {
                            ret_val = icf_ssa_get_and_populate_self_ip(
                                        p_ssa_pdb,
                                        p_transport_address,
                                        p_transp_addr_str);
                        }
                    }
#ifdef ICF_IPV6_ENABLED
                    else if(ICF_TRANSPORT_ADDRESS_IPV6_ADDR == 
                            p_transport_address->addr.addr_type)
                    {
                        icf_ssa_convert_to_IP_addr(p_transport_address,
                            p_transp_addr_str);
                        if( (0 == icf_port_strcmp("",p_transp_addr_str)) 
                                    || ( 0 == icf_port_strcmp("::",p_transp_addr_str))){
                            ret_val = icf_ssa_get_and_populate_self_ip(
                                        p_ssa_pdb,
                                        p_transport_address,
                                        p_transp_addr_str);
                        }
                    }
#endif
                    else
                    {
                        /* Raise a Major Category Error from here */
                        ret_val = ICF_FAILURE;
                    }

                    if (ICF_FAILURE != ret_val)
                    {
                        /* change the Via header in the default profile */
                        if (Sdf_co_fail == sdf_ivk_uaSetDefaultTransport(
                                            p_callobj_spec_profile,     
                                            (Sdf_ty_s8bit *)p_transp_addr_str,
                                            port_us,
                                            &sdf_error))
                        {
                            /*Raise A Major Error here-SDF PROCESSING FAILURE*/
                            ret_val = ICF_FAILURE;
                        }
                    }
                }
            } /* End if(ipsec_enabled) */
            else
            {
#endif
                  if (ICF_ADDRESS_PLAN_SIPS_URI ==
                        p_user_address->addr_type)         
                {
                    port_us = p_glb_cfg_data->p_tls_init_data->tls_sip_serv_port_num;
            /* Update the Via header stored in the profile with the TLS server port number */
            p_callobj_spec_profile->pTransport->dPort = port_us;
            icf_port_strcpy((icf_uint8_t *)contact_scheme, (icf_uint8_t *)"sips");            
                }
                else
                {
                    port_us = p_contact_address->port_num;
                }
#ifdef ICF_IPSEC_ENABLED
            }
#endif
        }

        if (ICF_SUCCESS == ret_val)
    {
        if(ICF_TRUE == req_from_reg)
        {

            if(Sdf_co_fail == sdf_ivk_uaSetDefaultFrom(
                        p_callobj_spec_profile,
                        display_name,
                        from_user_addr,
                        ICF_NULL,
                        (Sdf_ty_s8bit*)(&tpt_scheme),
                        &sdf_error))
            {
                /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                 * major ERROR*/
                /* sdf_ivk_uaFreeInitData(p_callobj_spec_profile); */
                ret_val = ICF_FAILURE;
            }
        }
        else
        {
           /*   Fix for SPR 19168 */
           /*  SCENARIO :
               iF APPLICATION explicitly asked for not sending port 
               then do not send otherwise send port in from header */
               
            final_from_port = (port_us == default_port)?ICF_NULL:port_us;
            if (final_from_port != ICF_NULL)
            {
                if (ICF_FALSE == p_glb_cfg_data->port_to_be_sent_in_from_header)
                {
                    final_from_port = ICF_NULL;
                }
            }
            if(Sdf_co_fail == sdf_ivk_uaSetDefaultFrom(
                        p_callobj_spec_profile,
                        display_name,
                        from_user_addr,
                        /* fix - default port should not go in header */
                        (Sdf_ty_u16bit)(final_from_port),
                        (Sdf_ty_s8bit*)(&tpt_scheme),
                        &sdf_error))
            {
                /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                 * major ERROR*/
                /*sdf_ivk_uaFreeInitData(p_callobj_spec_profile); */
                ret_val = ICF_FAILURE;
            }
        }
    }/*end of ICF_SUCCESS check*/
        /*If Contact header is present in header_list then Add default Contact
         *from call context header list*/
        if (ICF_FAILURE == ret_val)
        {}
        else if (ICF_TRUE == icf_ssa_is_contact_present_in_hdr_list(p_ssa_pdb, &p_contact_str, (icf_uint8_t *)display_name,
                                                             (icf_uint8_t *)contact_scheme))

        {
             if (Sdf_co_fail == sdf_ivk_uaAddDefaultContact(
                    p_callobj_spec_profile,
                    display_name,
                    (icf_int8_t *)p_contact_str,
                    ICF_NULL,
                    contact_scheme,
                    &sdf_error))
         {
             /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
              * major ERROR*/
             sdf_ivk_uaFreeInitData(p_callobj_spec_profile);
             ret_val = ICF_FAILURE;
         }
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_contact_str,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
    }
        else
        {
            if (Sdf_co_fail == sdf_ivk_uaAddDefaultContact(
                p_callobj_spec_profile, display_name, contact_addr,
                /* fix - default port should not go in header */
                (Sdf_ty_u16bit)((port_us == default_port)?ICF_NULL:port_us),
                /* incase of IPSEC this will be the protected 
                 * server port in the protected  message 
                 */
                (Sdf_ty_s8bit*)(&contact_scheme), &sdf_error))

            {
                /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                 * major ERROR*/
                sdf_ivk_uaFreeInitData(p_callobj_spec_profile);
                ret_val = ICF_FAILURE;
            }
        }
        if ( ICF_FAILURE == ret_val)
        {
             /*do nothing*/
        }
        else
        {
#ifdef ICF_SIGCOMP_SUPPORT
            /* Check The Config data whether we are supporting 
             * sigcomp or not,If Yes then add comp=sigcomp param
             * in the contact header
             */
            if(ICF_TRUE == 
                p_glb_cfg_data->sigcomp_required)
            {
                /* ABOVE CHECK COMMENTED AS CFG CODING IS NOT DONE */
                if(ICF_FAILURE == 
                    icf_ssa_AddParamToContactHdrList
                                   (&(p_callobj_spec_profile->slContact),
                                   "comp=sigcomp",
                                   &sdf_error))
                {
                    /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                    * major ERROR*/
                    /*sdf_ivk_uaFreeInitData(p_callobj_spec_profile);*/
                    ret_val = ICF_FAILURE;
                }

            }
#else
            ret_val = ICF_SUCCESS;
#endif
        }
         
        if ((ICF_FAILURE != ret_val)
                && (ICF_TRUE == p_ssa_pdb->send_trans_param)
                && (ICF_TRANSPORT_MODE_BOTH != 
                    p_ssa_pdb->p_ssa_ctxt->transport))
        {
            /*Add transport paramater in Contact header if TCP/UDP*/
            ret_val = icf_ssa_add_transport_param_in_contact_hdr(
                    p_ssa_pdb,
                    p_callobj_spec_profile,
                    &sdf_error);
            /* Sone servers like Cisco, Nortel CS1K do not insert the 
             * ';transport=udp' in To URI, due to which strict URI comparison
             * in UATK fails and message is rejected. To Ensure interop for now,
             * IPTK will not send transport URI param when the value is UDP.
             */
            /* As per RFC 3261 Table 1, transport-param should not be 
             * sent in From and To headers. so once the param is inserted
             * in Contact Header, reset the flag so that it is not inserted 
             * later in To header
             */
            p_ssa_pdb->send_trans_param = ICF_FALSE;
        }

        if(ret_val == ICF_FAILURE)
        {
           /* Free the Init Data for all failure cases */
            sdf_ivk_uaFreeInitData(p_callobj_spec_profile);
        }
        /*Set the Init Data*/
        else if ( Sdf_co_fail == sdf_ivk_uaSetInitDataInCallObject(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_callobj_spec_profile,
                    &sdf_error))
        {
            /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
             * major ERROR*/
            sdf_ivk_uaFreeInitData (p_callobj_spec_profile);
            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_ivk_uaFreeInitData (p_callobj_spec_profile))
        {
               /*Raise a Major error*/
               ret_val = ICF_FAILURE;
        }
        /*This FreeInitData will be called irrespective of the return 
         * value from the call to SetInitDataInCallObject.
         * In case of success, the ref count of profile has been incr-
         * -mented and we need to decrease it to allow a future Free-
         * -InitData release the memory.
         * In case of failure, we need to free the profile right here.*/
        /*sdf_ivk_uaFreeInitData(pInitData);*/
    }
    /*
    else
    {
        sdf_ivk_uaFreeInitData(p_callobj_spec_profile);
    }
    */
    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * 
 * FUNCTION:           icf_ssa_set_to_in_reg_callobj
 * 
 * DESCRIPTION:        This routine sets the To header for REGISTER request.
 *                  1.The To header is populated on the basis of the user 
 *                  addr stored in the RGM context.
 *                  2.If the user address is E164,then self address
 *                  (IP/domain name) is appended.
 *                  3.Invoke the sdf_ivk_uaSetTo API which sets the To header
 *                  4. Check if taranport mode in reg_addr and in line_data
 *                  is different then return failure else if transport is 
 *                  TCP/UDP and transport is preset in user_addr then create 
 *                  transport=tcp/udp parameter and insert in TO header
 *
 ******************************************************************************/
icf_return_t icf_ssa_set_to_in_reg_callobj(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
#ifdef IMS_CLIENT
    icf_uint8_t                      proxy_address[ICF_MAX_STR_LEN];
#endif

    icf_address_st                   *p_user_address = ICF_NULL;
    icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;
    icf_uint16_t                     dest_port_num = ICF_NULL;
    Sdf_st_error                     sdf_error;
    /* CAUTION: if we modify the size of char array
     * in icf_string_st, we should do the same 
     * here in this local variable*/
    icf_uint8_t                      dest_request_uri[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t                      display_name[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t                      proto[ICF_MAX_SIZE_INT_USAGE_STR] = "\0";
    icf_uint8_t                      scheme[ICF_MAX_SIZE_INT_USAGE_STR] = "\0";
    icf_uint8_t                      reg_route_addr[ICF_MAX_STR_LEN] = "\0";
    icf_transport_address_st         self_addr ;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    ICF_SSA_INIT_TRANS_ADDR(&self_addr)

    /* UMR fix */
    icf_port_memset(
        (icf_void_t *)&sdf_error,
        0,
        ICF_PORT_SIZEOF(Sdf_st_error));

    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))

    /*If per line self transport then copy address from line_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE == 
        p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                        sizeof(icf_transport_address_st));
    }
    else
    {
        icf_port_memcpy(&self_addr, 
                        &(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                        sizeof(icf_transport_address_st));
    }
 
    /*Merge decision: assumed that this function will be called for setting
     * the To header for outgoing SUBSCRIBE requests also*/
    if (ICF_SSA_USER_ADDR_FRM_SIC & p_ssa_pdb->common_bitmask)
    {
        p_user_address = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_user_address;
        icf_port_strcpy(display_name,(icf_uint8_t *) "");    
    }
    else
    {/*if not from SIC, then must be from REG module*/
        /* SPR 9849 Fix start */
        p_user_address = &(p_ssa_ctxt->p_rgm_ctxt->rgm_user_address);        
                
#if 0
        /* Picking the URI from the rgm_uri list */
        p_user_address = p_ssa_ctxt->p_rgm_ctxt->p_rgm_uris;
#endif
        /* SPR 9849 Fix end  */
    }

    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_user_address))
    
    if (( ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type) &&
            (ICF_TRANSPORT_TYPE_TLS != p_ssa_pdb->p_glb_cfg_data->self_mode))
    {
        ret_val = ICF_FAILURE;
        return ret_val;
    }

    /* Get the scheme type sip/tel) */
    if ( ICF_ADDRESS_PLAN_TEL_URI == p_user_address->addr_type)
    {
        icf_port_strcpy(scheme, (icf_uint8_t *)"tel");
    }
    else if ( ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type)
    {
        icf_port_strcpy(scheme, (icf_uint8_t *)"sips");
    }
    else
    {
        icf_port_strcpy(scheme, (icf_uint8_t *)"sip");
    }

    if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_line_data->reg_mode) ||
        (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_line_data->reg_mode))
    {
        icf_port_strcpy(proto, (icf_uint8_t *)"TCP");
    }
    else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_line_data->reg_mode)
    {
        icf_port_strcpy(proto, (icf_uint8_t *)"TLS");
    }
    else
    {
        icf_port_strcpy(proto, (icf_uint8_t *)"UDP");
    }

#ifdef NON_IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_FALSE)

    /* In case the application wants to send the Register request via NAT or 
     * proxy then add the Route header specifying the configured next hop */
    if ((ICF_SUCCESS == ret_val) && 
        (ICF_CFG_LINE_DATA_REG_ROUTE_ADDR_RECD & 
        p_ssa_pdb->p_line_data->line_data_received))
    {
        dest_port_num = p_ssa_pdb->p_line_data->reg_route_addr.port_num;

        if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
            p_ssa_pdb->p_line_data->reg_route_addr.addr.addr_type)
        {
            icf_port_strcpy(reg_route_addr,
                p_ssa_pdb->p_line_data->reg_route_addr.addr.addr.domain.str);
        }
        else
        {
            icf_ssa_convert_to_IP_addr(
                &(p_ssa_pdb->p_line_data->reg_route_addr),
                reg_route_addr);
        }
        if (Sdf_co_fail == sdf_ivk_uaAddDefaultPreLoadedRoute(
                              p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                              Sdf_co_null,
                              (icf_int8_t *)reg_route_addr,
                              dest_port_num,
                              "lr",/*pParam*/
                              ((ICF_TRANSPORT_TYPE_TLS == 
                              p_ssa_pdb->p_line_data->reg_mode)?"sips":"sip"),
                              &sdf_error))
        {

            ret_val = ICF_FAILURE;
        }
    } /* send Route header in REGISTER */

ICF_CHECK_IMS_END
#endif

#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
    dest_port_num = p_ssa_pdb->p_line_data->proxy_addr.port_num;

    if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
            p_ssa_pdb->p_line_data->proxy_addr.addr.addr_type)
    {
        icf_port_strcpy(proxy_address,
            p_ssa_pdb->p_line_data->proxy_addr.addr.addr.domain.str);
    }
    else
    {
        icf_ssa_convert_to_IP_addr(
              &(p_ssa_pdb->p_line_data->proxy_addr),
              proxy_address);
    }

#ifdef ICF_SIGCOMP_SUPPORT
    if(ICF_PEER_SUPPORTS_SIGCOMP == 
        p_ssa_pdb->p_line_data->sigcomp_support_by_proxy)
    {
        if ( Sdf_co_fail == 
            sdf_ivk_uaAddDefaultPreLoadedRoute(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
            Sdf_co_null,
            proxy_address,
            dest_port_num,
            "lr;comp=sigcomp",/*pParam*/
            ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_line_data->reg_mode)?"sips":"sip"),
            &sdf_error))
        {
            /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
        
    }
    else
    {
        if ( Sdf_co_fail == 
            sdf_ivk_uaAddDefaultPreLoadedRoute(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
            Sdf_co_null,
            proxy_address,
            dest_port_num,
            "lr",/*pParam*/
            ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_line_data->reg_mode) ? "sips":"sip"),
            &sdf_error))
        {
            /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
        
    }
#else
    if(ICF_FAILURE == ret_val)
    {
        /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
        
    }
    else if ( Sdf_co_fail == 
        sdf_ivk_uaAddDefaultPreLoadedRoute(
        p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
        Sdf_co_null,
        proxy_address,
        dest_port_num,
        "lr",/*pParam*/
        ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_line_data->reg_mode)?"sips":"sip"),
        &sdf_error))
    {
        /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
#endif
    if(ICF_FAILURE == ret_val)
    {
        /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
        
    }
ICF_CHECK_IMS_END    
#endif
    if(ICF_SUCCESS == ret_val)
    {
        dest_port_num = self_addr.port_num;

        /*Form the Request URI String*/
        icf_port_strcpy(
                dest_request_uri,
                p_user_address->addr_val.str);

        if ( (ICF_ADDRESS_PLAN_E164  == 
                    p_user_address->addr_type ))
        {
            icf_port_strcat(dest_request_uri,(icf_uint8_t *)"@");

            /* In case of REGISTER message, if the configured user is E.164, 
	     * the From and To header should carry Registrar domain/IP and not 
	     * self address
	     */
            if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
					p_ssa_pdb->p_line_data->registrar_addr.addr.addr_type)
            {
                icf_port_strcat(
				  dest_request_uri,
				  p_ssa_pdb->p_line_data->registrar_addr.addr.addr.domain.str);
            }
            else/*Assumption that it will be IPV4*/
            {
                icf_uint8_t remote_ip[16] = "\0";

                if (ICF_FAILURE == icf_ssa_convert_to_IP_addr(
									&(p_ssa_pdb->p_line_data->registrar_addr),
									remote_ip))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    icf_port_strcat(dest_request_uri, remote_ip);
                }
            }
        }
    }

    if(ICF_SUCCESS == ret_val)
    {
        if ( ICF_NULL != 
                p_ssa_pdb->p_line_data->user_name.str_len)
        {
            icf_port_strcpy(display_name, 
                    p_ssa_pdb->p_line_data->user_name.str);
        }
        else
        {
            icf_port_strcpy(display_name, (icf_uint8_t *)"");
        }

        if(Sdf_co_fail == sdf_ivk_uaSetTo(p_ssa_pdb->p_ssa_ctxt->p_call_obj, 
                    (icf_int8_t *)display_name,
                    (icf_int8_t *)dest_request_uri, 
        /* Merged from 4.3, this port shud be 0 always */
            ICF_NULL,
                    (icf_int8_t *)scheme,
                    &sdf_error))
        {
            /*Raise/Set Major Error here:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_set_to_in_callobj
 **
 * DESCRIPTION:     This  routine's purpose is to set the TO header
 *                  for outgoing calls.
 *                  1.For that, we need to get the 
 *                  remote party uri, scheme-sip/tel, remote's port
 *                  number, remote party display name.
 *                  2.Sets the proxy, if it is to be used, in the PreLoaded
 *                  Route set of the profile
 *                  3. Check if Transport is TCP/UDP and transport is preset 
 *                  in user_addr then create transport=tcp/udp parameter
 *                  and insert in TO header
*****************************************************************************/
icf_return_t icf_ssa_set_to_in_callobj(
        INOUT   icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_return_t                 ret_val = ICF_SUCCESS;
    icf_glb_pdb_st               *p_glb_pdb = 
        p_ssa_pdb->p_glb_pdb;

    icf_call_ctx_st              *p_call_ctxt =
        p_glb_pdb->p_call_ctx;

    icf_line_data_st             *p_line_data =
        p_ssa_pdb->p_line_data;

    icf_config_data_st           *p_glb_cfg_data =
        p_ssa_pdb->p_glb_cfg_data;

    icf_address_st               *p_rem_addr = 
        &(p_call_ctxt->remote_party_addr);
    icf_transport_address_st     *p_proxy_addr = 
                                       &(p_line_data->proxy_addr);

    icf_boolean_t                is_proxy_cfg = ICF_FALSE, 
                                    is_preloaded_req = ICF_FALSE;

    icf_uint8_t  proxy_address[ICF_MAX_STR_LEN],
                 str_count = 0;
#ifdef ICF_SIGCOMP_SUPPORT
    icf_void_t            *p_sigsa_ctxt = ICF_NULL;
#endif

    /*
     * CAUTION: if we modify the size of char array
     * in icf_string_st, we should do the same 
     * here in this local variable
     */

    icf_uint8_t       dest_request_uri[ICF_MAX_STR_LEN] = "\0",
                         dest_request_ip[ICF_MAX_STR_LEN] = "\0",
                         display_name[ICF_MAX_STR_LEN] = "\0",
                         tpt_scheme[ICF_MAX_SIZE_INT_USAGE_STR] = "\0",
                         proxy_addr_str[ICF_MAX_STR_LEN] = "\0";

    icf_uint8_t       *p_temp = ICF_NULL,*p_temp_1 = ICF_NULL;
    icf_uint16_t      dest_port_num = 0,default_port =ICF_NULL;
    Sdf_st_error         sdf_error;
    icf_string_st     param_val;

#ifdef ICF_SIGCOMP_SUPPORT
    icf_transport_address_st     *p_sigcomp_proxy_addr = ICF_NULL;
    icf_error_t      ecode;
    icf_boolean_t    is_to_add_sigcomp_param_in_route = ICF_FALSE;
#endif

    ICF_FUNCTION_ENTER(p_glb_pdb)
        
    ICF_ASSERT(p_glb_pdb, p_line_data)

#ifdef ICF_SIGCOMP_SUPPORT
#ifdef ICF_IPSEC_ENABLED
    if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
    {
        icf_rgm_glb_data_st         *p_rgm_glb_data  = ICF_NULL;

        if (ICF_FAILURE == \
                icf_dbm_get_module_glb_data(p_ssa_pdb->p_glb_pdb,\
                ICF_INT_MODULE_REGM, 
                (icf_void_t **)(p_rgm_glb_data),
                p_ssa_pdb->p_ecode))
        {
            /*ICF_SIGSA_TRACE(("\nFailure while getting RGM Global Data in SIGSA\n"));*/
            return ICF_FAILURE;
        }
        p_sigsa_ctxt = p_rgm_glb_data->p_sigsa_ctxt;
    }
    else
    {
        p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
    }
#else
    p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
#endif
#endif

    /* UMR fix */
    icf_port_memset(
        (icf_void_t *)&sdf_error,
        0,
        ICF_PORT_SIZEOF(Sdf_st_error));

    is_proxy_cfg = (ICF_CFG_LINE_DATA_PROXY_RECD &
            p_line_data->line_data_received)?
    ICF_TRUE:ICF_FALSE; 

#ifdef ICF_SIGCOMP_SUPPORT
    if((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) &&
       (ICF_NULL != p_sigsa_ctxt) &&
       (ICF_SUCCESS == icf_sigsa_get_sigcomp_proxy_addrs_from_ctxt
                        (p_sigsa_ctxt,
                        &p_sigcomp_proxy_addr,
                        &is_to_add_sigcomp_param_in_route,&ecode)))
    {
        if(ICF_NULL != p_sigcomp_proxy_addr)
        {
            p_proxy_addr = p_sigcomp_proxy_addr;
        }
    }
#endif

    if (ICF_TRUE == is_proxy_cfg)
    {
        if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_proxy_addr->addr.addr_type)
        {
            icf_port_strcpy(proxy_addr_str,
                    p_proxy_addr->addr.addr.domain.str);
        } /* p_proxy_addr->addr.a... */
        else
        {
            icf_ssa_convert_to_IP_addr(p_proxy_addr,
                    proxy_addr_str);
        }
    }

    /*Get the scheme type sip/tel)*/
    if ( ICF_ADDRESS_PLAN_TEL_URI ==
            p_rem_addr->addr_type)
    {
        icf_port_strcpy(tpt_scheme, (icf_uint8_t *)"tel");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    else if ( ICF_ADDRESS_PLAN_SIPS_URI ==
            p_rem_addr->addr_type)
    {
        icf_port_strcpy(tpt_scheme, (icf_uint8_t *)"sips");
        default_port = ICF_DEFAULT_SIPS_SERVER_PORT;
    }
    else
    {   
        icf_port_strcpy(tpt_scheme, (icf_uint8_t *)"sip");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    
    /*
     * Copy the received address string in dest request uri
     * Whatever type it is, it will be the first part of dest req uri
     */

    icf_port_strcpy(
            dest_request_uri,
            p_rem_addr->addr_val.str);
    /* Removing any params from address. These will be
       inserted once to is formed earlier we were doing
       this only for TEL uri*/

    str_count=0;

    while('\0' != dest_request_uri[str_count])
    {
        if(';' == dest_request_uri[str_count])
            break;
        str_count++;
    }

    dest_request_uri[str_count] = '\0';


    if ( (ICF_ADDRESS_PLAN_E164  == p_rem_addr->addr_type ) ||
            (ICF_ADDRESS_PLAN_TEL_URI == p_rem_addr->addr_type ))
    {
        if ( ICF_TRUE == is_proxy_cfg )
        {
            dest_port_num = p_proxy_addr->port_num;
            is_preloaded_req = ICF_TRUE;
            
           if ( ICF_ADDRESS_PLAN_E164  == p_rem_addr->addr_type )
            {
                /*Form the request URI*/
                icf_port_strcat(
                        dest_request_uri,(icf_uint8_t *)"@");
                icf_port_strcat(
                        dest_request_uri,
                        proxy_addr_str);
            }
        }
        else
        {
            /* Set the call clear reson */
            p_call_ctxt->release_cause = 
                ICF_CALL_CLEAR_REASON_PROXY_ADDRESS_NOT_CONFIGURED;
            ret_val = ICF_FAILURE;
        }
    }
    else if ((ICF_ADDRESS_PLAN_SIP_URI == p_rem_addr->addr_type ) ||
                (ICF_ADDRESS_PLAN_SIPS_URI == p_rem_addr->addr_type))
    {
        icf_uint8_t       str[ICF_MAX_STR_LEN];
        /* Now we will attempt to get the port number*/
#ifdef ICF_IPV6_ENABLED
        p_temp = icf_port_strchr(dest_request_uri,']');
    /*if p_temp is Null then dest_request_uri is IPv4 format*/
    if(ICF_NULL == p_temp)
    {
#endif 
            p_temp = dest_request_uri;
#ifdef ICF_IPV6_ENABLED
    }
#endif
        p_temp_1 = icf_port_strchr(p_temp,':');

        if ( ICF_NULL == p_temp_1 )
        {
            if (ICF_ADDRESS_PLAN_SIPS_URI == p_rem_addr->addr_type )
            {
                dest_port_num = ICF_DEFAULT_SIPS_SERVER_PORT;
            }
            else
            {
                dest_port_num = ICF_DEFAULT_SIP_SERVER_PORT;
            }
        }
        else
        {
            dest_port_num = (icf_uint16_t)icf_port_atoi((const icf_int8_t *)(p_temp_1+1));
        }
        icf_port_strcpy(str, dest_request_uri);
#ifdef ICF_IPV6_ENABLED
            p_temp = icf_port_strchr(dest_request_uri,']');
            if(ICF_NULL == p_temp)
#endif        
            {
                p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)str,":");
                if(ICF_NULL != p_temp)
                {
                    icf_port_strcpy(dest_request_uri,p_temp);
                }
            }
#ifdef ICF_IPV6_ENABLED
            
            else{
                p_temp = icf_port_strtok(str,"]");
                if(ICF_NULL != temp)
                {
                    icf_port_strcpy(dest_request_uri,p_temp);
                    icf_port_strcat(dest_request_uri,"]");
                }
            }
#endif

        /*
         * Here onwards, we are sure that dest_request_uri does
         * not has :portnum
         */

        if ( ICF_NULL != (ICF_CFG_CC_CALL_THRU_SIP_PROXY & 
                    p_glb_cfg_data->default_settings))
        {
            /*Not a Direct Call, proxy routed one*/
            if (ICF_NULL == is_proxy_cfg)
            {
                /* Set the call clear reson */
                p_call_ctxt->release_cause = 
                    ICF_CALL_CLEAR_REASON_PROXY_ADDRESS_NOT_CONFIGURED;
                ret_val = ICF_FAILURE;
            }
            else
            {
                /*The sip request URI has been already copied
                 * into the dest_req_uri at the start of the routine
                 * Implicitly ensured that is_preloaded_req is set
                 * only if is_proxy_cfg is set
                 */
                is_preloaded_req = ICF_TRUE;
            }
        }
        else
        {
            /*Direct Call*/
            icf_uint8_t      *p_temp = ICF_NULL, 
            userid[ICF_MAX_SIZE_INT_USAGE_STR];

            icf_port_strcpy(userid, (icf_uint8_t *)"");
            p_temp = icf_port_strchr(dest_request_uri,'@');

            if ( ICF_NULL == p_temp)
            {
                ret_val = ICF_FAILURE;
            }
#ifndef ICF_DNS_LOOKUP_ENABLED            
            else if (! icf_ssa_check_if_ip(p_temp + 1))
            {
                /*Hostname is not IP*/
                /* In case of a direct-routed call, the called party address 
                 * should not be replaced by the proxy address. Why was the 
                 * below written code added ?? This might be required if DNS 
                 * is not enabled, but when DNS is supported we can definitely 
                 * attempt DNS query to the called party address in direct call.
				 *
                 */
                if ( ICF_TRUE == is_proxy_cfg)
                {
                    icf_port_strcpy(str, dest_request_uri);
                    p_temp = icf_port_strtok(str,"@");
                    if(ICF_NULL == p_temp)
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else
                    {
                    icf_port_strcpy(userid, p_temp);
                    /*Here we overwrite the dest_request_uri
                     * which was initially set to the remote add
                     * string and then append it with proxy address*/
                    icf_port_strcpy(dest_request_uri, userid);
                    icf_port_strcat(dest_request_uri,"@");
                    icf_port_strcat(
                            dest_request_uri,
                            proxy_addr_str);
                    dest_port_num = p_proxy_addr->port_num;
                    is_preloaded_req = ICF_TRUE;
                    }
                }
                else
                {
                    /*Since the hostname was not an IP address, and the
                     * proxy is also not configured, we do not know
                     * where to send the call and hence we fail it*/
                    /* Set the call clear reson */
                    p_call_ctxt->release_cause = 
                        ICF_CALL_CLEAR_REASON_PROXY_ADDRESS_NOT_CONFIGURED;
                    ret_val = ICF_FAILURE;
                }
            }
#endif /* NOT(ICF_DNS_LOOKUP_ENABLED) */
            /*This is needed for TCP calls*/
            else
            {
                icf_port_strcpy(dest_request_ip, (p_temp + 1));
            }
            /*Hostname is not an IP, so we will use the complete URI as
             * the dest_req_uri while setting the TO header, no pre-loaded
             * route will be set and the message will be sent by UATK
             * to the peer directly*/
        }
    }

    if ( ICF_TRUE == is_preloaded_req)
    {
        if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_proxy_addr->addr.addr_type)
        {
            icf_port_strcpy(proxy_address,
                p_proxy_addr->addr.addr.domain.str);
        }
        else
        {
            icf_ssa_convert_to_IP_addr(
               p_proxy_addr,
               proxy_address);

        }
    }
    if ( ICF_SUCCESS == ret_val)
    {
         /* 
         * The proxy port should not be appended in case 
         * the called party is an E164 number and
         * phone-context field is present
         */
        icf_uint16_t      port_num = 0;
        if ((ICF_ADDRESS_PLAN_E164  == p_rem_addr->addr_type) &&
               (ICF_FALSE == icf_cmn_check_if_param_present(
                &(p_rem_addr->addr_val), (icf_uint8_t *)"phone-context", param_val.str,
                (icf_uint8_t *)"To", &(p_call_ctxt->tag_list))))
        {
            port_num = 0;
        }
        else
        {
            port_num = dest_port_num;
        }
        
        if ( ICF_REMOTE_NAME_PRESENT & 
                p_call_ctxt->common_bitmask)
        {
            icf_port_strcpy(display_name,
                    p_call_ctxt->remote_party_name.str);
        }
        else
        {
            icf_port_strcpy(display_name,(icf_uint8_t *)"");
        }

       if(Sdf_co_fail == sdf_ivk_uaSetTo(p_ssa_pdb->p_ssa_ctxt->p_call_obj, 
                    (icf_int8_t *)display_name,
                    (icf_int8_t *)dest_request_uri, 
                    /* fix - default port should not go in header */
                    ((dest_port_num == default_port)?ICF_NULL:dest_port_num), 
                    (icf_int8_t *)tpt_scheme,
                    &sdf_error))
        {
            /*Raise/Set Major Error here:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
/*#if 0*/
    /* 
         * After creating TO header check if transport mode is TCP/UDP not both
         * then create transport parameter and insert it in TO header
         */
        else
        {
            icf_uint8_t    param_val[4]; 
            SipHeader         *p_to = 
                p_ssa_pdb->p_ssa_ctxt->p_call_obj->pCommonInfo->pTo;
            
            if (ICF_TRUE == p_ssa_pdb->send_trans_param)
            {
                
                if (ICF_TRANSPORT_TYPE_UDP == 
                    p_ssa_pdb->p_ssa_ctxt->transport)
                {
                    icf_port_strcpy(param_val, (icf_uint8_t *)"udp");
                }
                else if (ICF_TRANSPORT_TYPE_TCP == 
                    p_ssa_pdb->p_ssa_ctxt->transport)
                {
                    icf_port_strcpy(param_val, (icf_uint8_t *)"tcp");
                }
                else if (ICF_TRANSPORT_TYPE_TLS == 
                    p_ssa_pdb->p_ssa_ctxt->transport)
                {
                    icf_port_strcpy(param_val, (icf_uint8_t *)"tls");
                }
                
                /* 
                * Create and insert transport parameter only if 
                * transport mode is TCP or UDP
                */
                if ((ICF_TRANSPORT_TYPE_UDP == 
                    p_ssa_pdb->p_ssa_ctxt->transport)
                    ||(ICF_TRANSPORT_TYPE_TCP ==
                    p_ssa_pdb->p_ssa_ctxt->transport)
                    ||(ICF_TRANSPORT_TYPE_TLS ==
                    p_ssa_pdb->p_ssa_ctxt->transport))
                {
                    if (ICF_FAILURE == 
                        icf_ssa_insert_param_in_addr_spec(
                        p_ssa_pdb,
                        ((SipToHeader*)p_to->pHeader)->pAddrSpec,
                        (icf_uint8_t *)"transport",param_val,&sdf_error))
                    {
                        ret_val = ICF_FAILURE;
                    }
                }
            }
        /*
         * Insert params (like phone-context and user
         * into the addr spec of the To header
         */
            if (ICF_FAILURE != ret_val)
            {
                if (ICF_FAILURE ==
                    icf_ssa_insert_params_frm_address_st(
                    p_ssa_pdb,
                    ((SipToHeader*)p_to->pHeader)->pAddrSpec,
                    p_rem_addr))
                {
                    ret_val = ICF_FAILURE;
                }
            }
        }/*END OF CODE LEG USED FOR INSERTING TRANSPORT PARAM INOUT to HEADER*/
/*#endif*/
    }
    if ((ICF_FAILURE != ret_val) && ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_ssa_ctxt->transport) || 
            (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)))
    {
            if ( ICF_TRUE == is_preloaded_req)
            {
                icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->dest_ip, (icf_uint8_t *)proxy_address);
                p_ssa_pdb->dest_port = p_proxy_addr->port_num;
            }
            else
            {
                icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->dest_ip, (icf_uint8_t *)dest_request_ip);
                p_ssa_pdb->dest_port = dest_port_num;
            }  
#if 0
        }
#endif
    }

    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_set_to_in_sic_callobj
 **
 ** DESCRIPTION:        This  routine's purpose is to set the TO header
 **                     for outgoing call.For that, we need to get the 
 **                     remote party uri, scheme-sip/tel, remote's port
 **                     number, remote party display name.
 **                     Sets the proxy, if it is to be used, in the PreLoaded
 **                         Route set of the profile
*****************************************************************************/
icf_return_t icf_ssa_set_to_in_sic_callobj(
      
        INOUT   icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT        icf_uint8_t           *p_proto)
{
    icf_return_t                 ret_val = ICF_SUCCESS;
    icf_glb_pdb_st               *p_glb_pdb = 
        p_ssa_pdb->p_glb_pdb;

    icf_sic_ctx_st              *p_sic_ctx = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt;

    icf_line_data_st             *p_line_data =
        p_ssa_pdb->p_line_data;

    icf_config_data_st           *p_glb_cfg_data =
        p_ssa_pdb->p_glb_cfg_data;

    icf_address_st               *p_rem_addr = 
        &(p_sic_ctx->dest_addr);
    icf_transport_address_st     *p_proxy_addr = 
                                       &(p_line_data->proxy_addr);

    icf_boolean_t                is_proxy_cfg = ICF_FALSE, 
                                    is_preloaded_req = ICF_FALSE;

    icf_uint8_t  proxy_address[ICF_MAX_STR_LEN];

    /*
     * CAUTION: if we modify the size of char array
     * in icf_string_st, we should do the same 
     * here in this local variable
     */

    icf_uint8_t       dest_request_uri[ICF_MAX_STR_LEN] = "\0",
                         dest_request_ip[ICF_MAX_STR_LEN] = "\0",
                         display_name[ICF_MAX_STR_LEN] = "\0",
                         tpt_scheme[ICF_MAX_SIZE_INT_USAGE_STR] = "\0",
                         proxy_addr_str[ICF_MAX_STR_LEN] = "\0";

    icf_uint8_t       *p_temp = ICF_NULL;
    icf_uint16_t      dest_port_num = 0,default_port = ICF_NULL;
    Sdf_st_error         sdf_error;
#ifdef ICF_SIGCOMP_SUPPORT
    icf_transport_address_st     *p_sigcomp_proxy_addr = ICF_NULL;
    icf_error_t      ecode;
    icf_boolean_t    is_to_add_sigcomp_param_in_route = ICF_FALSE;
#endif

    
    if(ICF_NULL == p_glb_pdb)
    {
       return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_glb_pdb)
        
    ICF_ASSERT(p_glb_pdb, p_line_data)

#ifdef ICF_SIGCOMP_SUPPORT
#ifdef ICF_IPSEC_ENABLED
    if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
    {
        icf_rgm_glb_data_st         *p_rgm_glb_data  = ICF_NULL;

        if (ICF_FAILURE == \
                icf_dbm_get_module_glb_data(p_ssa_pdb->p_glb_pdb,\
                ICF_INT_MODULE_REGM, 
                (icf_void_t **)(&p_rgm_glb_data),
                p_ssa_pdb->p_ecode))
        {
            /*ICF_SIGSA_TRACE(("\nFailure while getting RGM Global Data in SIGSA\n"));*/
            return ICF_FAILURE;
        }
        p_sigsa_ctxt = p_rgm_glb_data->p_sigsa_ctxt;
    }
    else
    {
        p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
    }
#else
    p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
#endif
#endif


    /* UMR fix */
    icf_port_memset(
        (icf_void_t *)&sdf_error,
        0,
        ICF_PORT_SIZEOF(Sdf_st_error));

    is_proxy_cfg = (ICF_CFG_LINE_DATA_PROXY_RECD &
            p_line_data->line_data_received)?
    ICF_TRUE:ICF_FALSE; 
#ifdef ICF_SIGCOMP_SUPPORT
    if((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) &&
       (ICF_NULL != p_sigsa_ctxt) &&
       (ICF_SUCCESS == icf_sigsa_get_sigcomp_proxy_addrs_from_ctxt
                        (p_sigsa_ctxt,
                        &p_sigcomp_proxy_addr,
                        &is_to_add_sigcomp_param_in_route,&ecode)))
    {
        if(ICF_NULL != p_sigcomp_proxy_addr)
        {
            p_proxy_addr = p_sigcomp_proxy_addr;
        }
    }

#endif
    if (ICF_TRUE == is_proxy_cfg)
    {
        if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_proxy_addr->addr.addr_type)
        {
            icf_port_strcpy(proxy_addr_str,
                    p_proxy_addr->addr.addr.domain.str);
        } /* p_proxy_addr->addr.a... */
        else
        {
            icf_ssa_convert_to_IP_addr(p_proxy_addr,
                    proxy_addr_str);
        }
    }

    /*Get the scheme type sip/tel)*/
    if ( ICF_ADDRESS_PLAN_TEL_URI ==
               p_rem_addr->addr_type)
    {
        icf_port_strcpy(tpt_scheme, (icf_uint8_t *)"tel");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    else if ( ICF_ADDRESS_PLAN_SIPS_URI ==
               p_rem_addr->addr_type)
    {
        icf_port_strcpy(tpt_scheme, (icf_uint8_t *)"sips");
        default_port = ICF_DEFAULT_SIPS_SERVER_PORT;
    }
    else
    {
        icf_port_strcpy(tpt_scheme, (icf_uint8_t *)"sip");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    
    /*
     * Copy the received address string in dest request uri
     * Whatever type it is, it will be the first part of dest req uri
     */
    icf_port_strcpy(
            dest_request_uri,
            p_rem_addr->addr_val.str);

    if ( (ICF_ADDRESS_PLAN_E164  == p_rem_addr->addr_type ) ||
            (ICF_ADDRESS_PLAN_TEL_URI == p_rem_addr->addr_type ))
    {
        if ( ICF_TRUE == is_proxy_cfg )
        {
            dest_port_num = p_proxy_addr->port_num;
            is_preloaded_req = ICF_TRUE;
            if ( ICF_ADDRESS_PLAN_E164  == p_rem_addr->addr_type )
            {
                /*Form the request URI*/
                icf_port_strcat(
                        dest_request_uri,(icf_uint8_t *)"@");
                icf_port_strcat(
                        dest_request_uri,
                        proxy_addr_str);
            }
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
    }
    else if ((ICF_ADDRESS_PLAN_SIP_URI == p_rem_addr->addr_type ) ||
                (ICF_ADDRESS_PLAN_SIPS_URI == p_rem_addr->addr_type ))
    {
        icf_uint8_t       str[ICF_MAX_STR_LEN];

        /* Now we will attempt to get the port number*/
        p_temp = icf_port_strchr(dest_request_uri,':');
        if ( ICF_NULL == p_temp )
        {
            if (ICF_ADDRESS_PLAN_SIPS_URI == p_rem_addr->addr_type )
            {
                dest_port_num = ICF_DEFAULT_SIPS_SERVER_PORT;
            }
            else
            {
                dest_port_num = ICF_DEFAULT_SIP_SERVER_PORT;
            }
        }
        else
        {
            dest_port_num = (icf_uint16_t )icf_port_atoi((const icf_int8_t *)p_temp+1);

            icf_port_strcpy(str, dest_request_uri);
            p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)str,":");
            if(ICF_NULL != p_temp)
                icf_port_strcpy(dest_request_uri,p_temp);
        }
        /*
         * Here onwards, we are sure that dest_request_uri does
         * not has :portnum
         */

        if ( ICF_NULL != (ICF_CFG_CC_CALL_THRU_SIP_PROXY & 
                    p_glb_cfg_data->default_settings))
        {
            /*Not a Direct Call, proxy routed one*/
            if (ICF_NULL == is_proxy_cfg)
            {
                /* Set the call clear reson */
            /*    p_call_ctxt->release_cause = */
            /*        ICF_CALL_CLEAR_REASON_PROXY_ADDRESS_NOT_CONFIGURED;*/
                ret_val = ICF_FAILURE;
            }
            else
            {
                /*The sip request URI has been already copied
                 * into the dest_req_uri at the start of the routine
                 * Implicitly ensured that is_preloaded_req is set
                 * only if is_proxy_cfg is set
                 */
                is_preloaded_req = ICF_TRUE;
            }
        }
        /* This might be required if DNS is not enabled, but when DNS is 
         * supported we can definitely attempt DNS query to the remote addr 
         */
#ifndef ICF_DNS_LOOKUP_ENABLED
        else
        {
            /*Direct Call*/
            icf_uint8_t      *p_temp = ICF_NULL, 
            userid[ICF_MAX_SIZE_INT_USAGE_STR];

            icf_port_strcpy(userid, "");
            p_temp = icf_port_strchr(dest_request_uri,'@');

            if ( ICF_NULL == p_temp)
            {
                ret_val = ICF_FAILURE;
            }
            else if (! icf_ssa_check_if_ip(p_temp + 1))
            {
                /*Hostname is not IP*/
                if ( ICF_TRUE == is_proxy_cfg)
                {
                    icf_port_strcpy(str, dest_request_uri);
                    p_temp = icf_port_strtok(str,"@");
                    if(ICF_NULL != p_temp)
                    {
                    icf_port_strcpy(userid, p_temp);
                    /*Here we overwrite the dest_request_uri
                     * which was initially set to the remote add
                     * string and then append it with proxy address*/
                    icf_port_strcpy(dest_request_uri, userid);
                    icf_port_strcat(dest_request_uri,"@");
                    icf_port_strcat(
                            dest_request_uri,
                            proxy_addr_str);
                    dest_port_num = p_proxy_addr->port_num;
                    is_preloaded_req = ICF_TRUE;
                    }
                    else
                    {
                        ret_val = ICF_FAILURE;
                    }
                }
                else
                {
                    /*Since the hostname was not an IP address, and the
                     * proxy is also not configured, we do not know
                     * where to send the call and hence we fail it*/
                    /* Set the call clear reson */
        /*            p_call_ctxt->release_cause = */
          /*              ICF_CALL_CLEAR_REASON_PROXY_ADDRESS_NOT_CONFIGURED;*/
                    ret_val = ICF_FAILURE;
                }
            }
            /*Hostname is not an IP, so we will use the complete URI as
             * the dest_req_uri while setting the TO header, no pre-loaded
             * route will be set and the message will be sent by UATK
             * to the peer directly*/
        }
#endif
    }

    if ( ICF_TRUE == is_preloaded_req)
    {
        if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_proxy_addr->addr.addr_type)
        {
            icf_port_strcpy(proxy_address,
                p_proxy_addr->addr.addr.domain.str);
        }
        else
        {
            icf_ssa_convert_to_IP_addr(
               p_proxy_addr,
               proxy_address);

        }
    }
    if ( ICF_SUCCESS == ret_val)
    {
        icf_port_strcpy(display_name,(icf_uint8_t *)"");
        

        if(Sdf_co_fail == sdf_ivk_uaSetTo(p_ssa_pdb->p_ssa_ctxt->p_call_obj, 
                    (icf_int8_t *)display_name,
                    (icf_int8_t *)dest_request_uri, 
                    /* fix - default port should not go in header */
                    ((dest_port_num == default_port)?ICF_NULL:dest_port_num), 
                    (icf_int8_t *)tpt_scheme,
                    &sdf_error))
        {
            /*Raise/Set Major Error here:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
    else
    {
        icf_uint8_t    param_val[4]; 
        SipHeader         *p_to = 
            p_ssa_pdb->p_ssa_ctxt->p_call_obj->pCommonInfo->pTo;

        if (ICF_TRANSPORT_TYPE_UDP == 
                p_ssa_pdb->p_ssa_ctxt->transport)
        {
            icf_port_strcpy(param_val, (icf_uint8_t *)"udp");
        }
        else if (ICF_TRANSPORT_TYPE_TCP == 
                p_ssa_pdb->p_ssa_ctxt->transport)
        {
            icf_port_strcpy(param_val, (icf_uint8_t *)"tcp");
        }
        else if (ICF_TRANSPORT_TYPE_TLS == 
                p_ssa_pdb->p_ssa_ctxt->transport)
        {
            icf_port_strcpy(param_val,(icf_uint8_t *) "tls");
        }

        /* 
         * Create and insert transport parameter only if 
         * transport mode is TCP or UDP
         */
        if ((ICF_TRANSPORT_TYPE_UDP == 
                    p_ssa_pdb->p_ssa_ctxt->transport)
                ||(ICF_TRANSPORT_TYPE_TCP ==
                    p_ssa_pdb->p_ssa_ctxt->transport)
                ||(ICF_TRANSPORT_TYPE_TLS ==
                    p_ssa_pdb->p_ssa_ctxt->transport))
        {
            if (ICF_FAILURE == 
                    icf_ssa_insert_param_in_addr_spec(
                        p_ssa_pdb,
                        ((SipToHeader*)p_to->pHeader)->pAddrSpec,
                        (icf_uint8_t *)"transport",param_val,&sdf_error))
            {
                ret_val = ICF_FAILURE;
            }
                        /* Insert the transport parameter into the Conatct header also */
            else 
                        {
                icf_uint8_t    transport_param[15]="\0";
                icf_port_strcpy(transport_param,(icf_uint8_t *)"transport=");
                icf_port_strcat(transport_param,param_val);

                if(ICF_FAILURE ==
                        icf_ssa_AddParamToContactHdrList
                        (&(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData->slContact),
                         transport_param,
                         &sdf_error))
                {
                    /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                     * major ERROR*/
                    ret_val = ICF_FAILURE;
                }
            }
        }
    }/*END OF CODE LEG USED FOR INSERTING TRANSPORT PARAM INOUT to HEADER*/
    }
    if ((ICF_FAILURE != ret_val) &&
            ((0 == icf_port_strcmp(p_proto,(icf_uint8_t *)"TCP"))
             || (0 == icf_port_strcmp(p_proto,(icf_uint8_t *)"TLS"))))
    {
        /* the con db node will be allocated from inside the ssa_send_to_peer function when 
           icf_ssa_attempt_out_of_uatk_connect is invoked*/
        if ( ICF_TRUE == is_preloaded_req)
        {
            icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->dest_ip,(icf_uint8_t *)proxy_address);
            p_ssa_pdb->dest_port = p_proxy_addr->port_num;
        }
        else
        {
            /*get the destination IP address and port from
             * destination address*/
            icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->dest_ip, (icf_uint8_t *)dest_request_ip);
        p_ssa_pdb->dest_port = dest_port_num;
    }

    if (0 == icf_port_strcmp(p_proto,(icf_uint8_t *)"TLS"))
    {
        p_ssa_pdb->p_ssa_ctxt->bitmask |= ICF_SSA_TLS_TRANSPORT;
    }
    else
    {
            p_ssa_pdb->p_ssa_ctxt->bitmask |= ICF_SSA_TCP_TRANSPORT;
        }
    }
    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}


/*****************************************************************************
 ** FUNCTION:           icf_ssa_map_sip_resp_code
 **
 ** DESCRIPTION:        This function maps the SIP response codes to
 **                     CC specific reason codes
 **
 *****************************************************************************/
icf_return_t icf_ssa_map_sip_resp_code(
        Sdf_ty_u16bit dRespCode,
        icf_ssa_reason_t *p_reason_code)
{
    icf_return_t             ret_val = ICF_SUCCESS;

    switch(dRespCode)
    {
        case 300 :
        case 301 :
        case 410 :
        case 480 :
        case 485 :
        case 604 :
        case 404 :        
            *p_reason_code = ICF_CALL_CLEAR_REASON_USER_NOT_FOUND;
            break;

        case 305 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_CORRECT_PROXY_REQD;
            break;

        case 380 :
        case 400 :
        case 413 :
        case 414 :
        case 416 :
        case 481 :
        case 482 :
        case 483 :
        case 484 :
        case 493 :
        case 500 :
        case 501 :
        case 502 :
        case 503 :
        case 504 :
        case 505 :
        case 513 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_NW_ERROR;
            break;

        case 401 :
        case 407 :
          *p_reason_code = ICF_CALL_CLEAR_REASON_PROXY_AUTH_FAILURE;
            break;
        case 403 :
        case 420 :
        case 421 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_NW_REJECTED;
            break;

        case 402 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_PAYMENT_REQD;
            break;

        case 405 :
        case 415 :
        case 406 :
        case 603 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_REMOTE_REJECTED;
            break;

        case 408 :
            *p_reason_code = ICF_CALL_CLEAR_REMOTE_UNREACHABLE;
            break;

        case 423 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_UNDEFINED;
            break;

        case 486 :
        case 600 :
            *p_reason_code = ICF_CALL_CLEAR_REMOTE_BUSY;
            break;

        case 488 :
        /* SPR 17399 : response code 606 is Not Acceptable Here and is send for
         * media mismatch.
         */
        case 606 :
            *p_reason_code = ICF_CALL_CLEAR_MEDIA_MISMATCH;
            break;

            /*Filling it here since in case of 487 we are not
             * indicating an error as it will come for a CANCELLED
             * txn, if not then we need to have some valid value here
             */
        case 487 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_INVALID;
            break;

        case 491 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_REQUEST_PENDING;
            break;

#ifdef ICF_QOS_SUPPORT
        case 580 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_PRECONDITIONS_FAILURE;
            break;
#endif

        case 508 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_REMOTE_MEDIA_NOT_RECEIVED ;
            break;

        default :
	    if((400 < dRespCode) && (600 > dRespCode))
	    {
		*p_reason_code = ICF_CALL_CLEAR_REASON_NW_ERROR;
  	    }
	    else if((601 < dRespCode) && (700 > dRespCode))
	    {
		*p_reason_code = ICF_CALL_CLEAR_REMOTE_BUSY;
  	    }
	    else
	    {
                *p_reason_code = ICF_CALL_CLEAR_REASON_UNDEFINED;
	    }
            break;
    }
    return ret_val;
}
/*****************************************************************************
 ** FUNCTION:           icf_ssa_map_cc_reason_code
 **
 ** DESCRIPTION:        This function maps the CC reason codes to
 **                     SIP response codes
 **
 *****************************************************************************/
icf_return_t icf_ssa_map_cc_reason_code(
        icf_ssa_reason_t reason_code,
        Sdf_ty_u16bit *p_respcode)
{
    icf_return_t             ret_val = ICF_SUCCESS;

    switch(reason_code)
    {
        case ICF_CALL_CLEAR_REASON_CALL_ABANDONED :
        case ICF_CALL_CLEAR_REASON_USER_BUSY :
        case ICF_CALL_CLEAR_REASON_ATTEMPT_ON_ALTERNATE_LINE :
        case ICF_CALL_CLEAR_REASON_LINE_BUSY :
            *p_respcode = 486;
            break;
ICF_HANDLE_REINVITE_START
        case ICF_CALL_MODIFY_REASON_USER_BUSY:
ICF_HANDLE_REINVITE_END
            *p_respcode = 504;
            break;

        case ICF_CALL_CLEAR_REASON_SYSTEM_ERROR :
        case ICF_CALL_CLEAR_REASON_SERVICE_FAILURE :
        case ICF_CALL_CLEAR_REASON_MAX_AUDIO_CALLS_EXCEEDED :
        case ICF_CALL_CLEAR_REASON_RESOURCES_NOT_AVAILABLE :
        case ICF_CALL_CLEAR_REASON_UNDEFINED :
        case ICF_SA_SERVER_INTERNAL_ERROR :
        case ICF_CALL_CLEAR_REASON_LINE_NOT_CONFIGURED:
            *p_respcode = 500;
            break;

        case ICF_FAX_ERR_CALL_NOT_ALLOWED:
        case ICF_FAX_ERR_INVALID_REQUEST:
        case ICF_CAUSE_FAX_PROFILE_NOT_CONFIGURED:
ICF_HANDLE_REINVITE_START
        case ICF_CALL_MODIFY_REASON_REJECT_MEDIA_CHANGE:
ICF_HANDLE_REINVITE_END
    /* Fix for CSR 1-7798174 : SPR 20071 */
    /* Changes done for to send 488 when GCL response received 
     * with error cause ICF_CAUSE_AUDIO_CODEC_NOT_AVAILABLE
     * or ICF_CAUSE_VIDEO_CODEC_NOT_AVAILABLE*/
        case ICF_CALL_CLEAR_REASON_CODEC_NOT_AVAILABLE:
            *p_respcode = 488;
            break;

        case ICF_CALL_CLEAR_REASON_USER_NOT_FOUND :
            *p_respcode = 404;
            break;

        case ICF_CALL_CLEAR_REASON_NOANSWER :
        case ICF_CALL_CLEAR_APP_REJECT:
            *p_respcode = 480;
            break;

        case ICF_CALL_CLEAR_REASON_REQUEST_PENDING :
        case ICF_REQUEST_PENDING :
            *p_respcode = 491;
            break;

#ifdef ICF_QOS_SUPPORT
        case ICF_CALL_CLEAR_REASON_PRECONDITIONS_FAILURE:
            *p_respcode = 580;
            break;
#endif


ICF_HANDLE_REINVITE_START
        case ICF_CALL_MODIFY_REASON_REQUEST_TERMINATED:
        case ICF_CALL_CLEAR_REASON_REQUEST_TERMINATED:
            *p_respcode = 487;
            break;
ICF_HANDLE_REINVITE_END
        case ICF_CALL_CLEAR_REASON_REMOTE_MEDIA_NOT_RECEIVED:
            *p_respcode = 508;
            break;
        case ICF_CALL_CLEAR_REASON_NW_ERROR:
            *p_respcode = 400;
            break;

    case ICF_CALL_CLEAR_MEDIA_MISMATCH :
        *p_respcode = 415;
        break;

        case ICF_CALL_CLEAR_REASON_MEDIA_TRANSPORT_FAILURE :
        case ICF_CALL_CLEAR_REASON_UNABLE_TO_CREATE_MEDIA :
             *p_respcode = 503;
             break;


        default :
            *p_respcode = 500;
            break;
    }
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_map_interface_reason_code
 **
 ** DESCRIPTION:        This function maps the reason codes of interface messages 
 **                     to SIP response codes
 **
 *****************************************************************************/
icf_return_t icf_ssa_map_interface_reason_code(
        icf_ssa_reason_t reason_code,
        Sdf_ty_u16bit *p_respcode)
{
    icf_return_t             ret_val = ICF_SUCCESS;

    switch(reason_code)
    {
        case ICF_SA_REJECT:
            *p_respcode = 488;
            break;

        case ICF_SA_SERVER_INTERNAL_ERROR:
            *p_respcode = 500;
            break;

        case ICF_REQUEST_PENDING:
            *p_respcode = 491;
            break;

        case ICF_SA_PRECONDITION_FAILURE:
            *p_respcode = 580;
            break;

        case ICF_SA_NETWORK_ERROR:
            *p_respcode = 415;
            break;
    
    default:
        *p_respcode = 500;
    break;
    }

    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:        icf_ssa_form_sip_uri_frm_e164
 ** 
 ** DESCRIPTION:    This function takes a string (E164 user ID), an instance
 **                 of icf_transport_address_st ( proxy address, self address)
 **                 address of a variable to return port number if any.
 **                 Based on the type of address in the instance of
 **                 icf_transport_address_st, it appends appropriate string
 **                 to the received user ID to return the comeplte SIP uri
 *****************************************************************************/
icf_return_t icf_ssa_form_sip_uri_frm_e164(
        icf_ssa_pdb_st               *p_ssa_pdb,
        icf_uint8_t                  *p_address_str,
        icf_transport_address_st     *p_transport_addr,
        icf_uint16_t                 *p_port_num)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    icf_glb_pdb_st       *p_glb_pdb = 
        p_ssa_pdb->p_glb_pdb;

    ICF_FUNCTION_ENTER(p_glb_pdb)
    p_glb_pdb = p_glb_pdb;

    icf_port_strcat(p_address_str,(icf_uint8_t *)"@");   

    if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
            p_transport_addr->addr.addr_type)
    {
        icf_port_strcat(p_address_str,
                p_transport_addr->
                addr.addr.domain.str);
        *p_port_num = p_transport_addr->port_num;
    }
    else/*Assumption that it will be IPV4*/
    {
        icf_uint8_t remote_ip[16];

        if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                    p_transport_addr, remote_ip))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            icf_port_strcat(p_address_str, remote_ip);
        }
        *p_port_num = p_transport_addr->port_num;
    }

    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_clone_profile_data
 ** DESCRIPTION:  This function is a cut down version of the Clone
 *                Init Data API.  It is used to copy selected information
 *                from the global profile to the call object specific profile
 *                Currently we only copy default transport
 ***************************************************************************/
icf_return_t    icf_ssa_clone_profile_data(
        INOUT    icf_glb_pdb_st       *p_glb_pdb,
        INOUT      Sdf_st_initData         *p_dest_profile,
        INOUT      Sdf_st_initData          *p_source_profile,
        OUT     icf_error_t           *p_ecode)
{
    icf_return_t         ret_val = ICF_SUCCESS;

    Sdf_st_error            sdf_error;
    Sdf_st_listIterator     dListIterator;

    p_ecode = p_ecode;
    p_glb_pdb = p_glb_pdb;

    ICF_FUNCTION_ENTER(p_glb_pdb)

    /* UMR fix */
    icf_port_memset(
        (icf_void_t *)&sdf_error,
        0,
        ICF_PORT_SIZEOF(Sdf_st_error));

    if ( Sdf_co_fail == 
            sdf_ivk_uaCloneTransportInfo(p_dest_profile->pTransport,
                p_source_profile->pTransport, &sdf_error))
    {
        /*Raise Alarm/Error-Major UATK PROCESSING FAILURE*/
        /*Raise Trace : Failure in CloneTransportInfo-MINOR*/
        ret_val = ICF_FAILURE;
    }

    else
    {
        /* 
         * Clone list of extra headers
         */
        sdf_listDeleteAll(&(p_dest_profile->slExtraHeadersList), &sdf_error);

        sdf_listInitIterator(&(p_source_profile->slExtraHeadersList), \
                &dListIterator, &sdf_error);

        while (dListIterator.pCurrentElement != Sdf_co_null)
        {
            Sdf_st_configExtraHeaders *p_extra_hdrs = ICF_NULL;
            Sdf_st_configExtraHeaders *p_cloned_extra_hdrs = ICF_NULL;

            p_extra_hdrs =\
            (Sdf_st_configExtraHeaders*)(dListIterator.pCurrentElement->pData);

            if(Sdf_co_fail == 
                    sdf_ivk_uaInitConfigExtraHeaders(&p_cloned_extra_hdrs,\
                        &sdf_error))
            {
                ret_val = ICF_FAILURE;
                break;
            }
            else if(Sdf_co_fail == 
                    sdf_ivk_uaCloneConfigExtraHeaders(p_cloned_extra_hdrs, 
                        p_extra_hdrs, &sdf_error))
            {
                ret_val = ICF_FAILURE;
                break;
            }
            else if(Sdf_co_fail == 
                    sdf_listAppend(&(p_dest_profile->slExtraHeadersList), 
                        (Sdf_ty_pvoid)p_cloned_extra_hdrs, &sdf_error))
            {
                ret_val = ICF_FAILURE;
                break;
            }
            sdf_listNext(&dListIterator, &sdf_error);
        }
    }

    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_send_to_peer
 * DESCRIPTION:  1.This function internally calls sdf_ivk_uaSendCallToPeer
 *               after initialising an Event Context and setting the 
 *               SSA ctxt into it.
 *               2.In the case of TCP as transport,
 *               we are populating the current transactions' SockFd
 *               with the one in the ConnDb,  if there is one,if not
 *               we reset it to an invalid value so that UATK attempts a 
 *               connect by itself
 ***************************************************************************/
icf_return_t icf_ssa_send_to_peer(
        icf_ssa_pdb_st *p_ssa_pdb,
        Sdf_st_callObject *p_call_obj,
        SipMessage *p_sip_msg,
        SipOptions *p_options,
        Sdf_st_error *p_sdf_error)
{
    icf_return_t ret_val = ICF_SUCCESS;
    icf_uint32_t count = 0;
    icf_ssa_ctxt_st  *p_ssa_ctxt =
        (icf_ssa_ctxt_st*)(p_call_obj->pAppData->pData);
    icf_error_t      local_ecode = 0;
#ifdef ICF_SIGCOMP_SUPPORT
    icf_boolean_t    should_msg_compress = ICF_FALSE;
        icf_void_t                      *p_sigsa_ctxt = ICF_NULL;
#endif


    SipError                SipErr;
#if defined(ICF_SECURE_SUPPORT) || defined(ICF_SIGCOMP_SUPPORT) || defined(ICF_NAT_RPORT_SUPPORT)
    en_SipMessageType       dReqRespType;
#endif

#ifdef ICF_SECURE_SUPPORT
    SipParam                *p_alias_param = ICF_NULL, *p_alias_param_1 = ICF_NULL;
#endif
#ifdef ICF_NAT_RPORT_SUPPORT
    icf_line_data_st *p_line_data =  ICF_NULL;
    icf_rport_config_data_st            *p_rport_config_data = ICF_NULL;
    SipParam                *p_param = ICF_NULL,*p_param_1 = ICF_NULL;
#endif

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    p_ssa_ctxt->p_ssa_pdb = (struct icf_ssa_pdb_st*)p_ssa_pdb;
    p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;
    p_options = p_options;

#ifdef ICF_SIGCOMP_SUPPORT
        if (sip_getMessageType(p_sip_msg,
                &dReqRespType, (SipError*)\
                &(SipErr)) ==  SipFail)
        {
                return ICF_FAILURE;
        }

#endif

#ifdef ICF_SIGCOMP_SUPPORT
#ifdef ICF_IPSEC_ENABLED
        if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
        {
                icf_rgm_glb_data_st              *p_rgm_glb_data  = ICF_NULL;

                if (ICF_FAILURE == \
                                icf_dbm_get_module_glb_data(p_ssa_pdb->p_glb_pdb,\
                                ICF_INT_MODULE_REGM,
                                (icf_void_t **)(&p_rgm_glb_data),
                                p_ssa_pdb->p_ecode))
                {
                        /*ICF_SIGSA_TRACE(("\nFailure while getting RGM Global Data in SIGSA\n"));*/
                        return ICF_FAILURE;
                }
                p_sigsa_ctxt = p_rgm_glb_data->p_sigsa_ctxt;
        }
        else
        {
                p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
        }
#else
    p_sigsa_ctxt = p_ssa_ctxt->p_sigsa_ctxt;
#endif
#endif

#ifdef ICF_SIGCOMP_SUPPORT
        /* fix for stray msg crash */
        /* this will only avoid the problem when sigcomp is OFF, but it will still
         * crash when sigcomp is runtime enabled */
        if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->sigcomp_required)
        {
                if(ICF_SSA_SIP_MSG_SHOULD_BE_COMPRESSED !=
                        ICF_SSA_GET_COMMON_BITMASK(p_ssa_ctxt->bitmask,
                        ICF_SSA_SIP_MSG_SHOULD_BE_COMPRESSED))
                {
        /* For Failure Case of the below function we will 
                 * send the Uncompressed Message.So No Check required for the Failure
                 * leg*/

                        if(ICF_SUCCESS == icf_ssa_checkForSigCompParam(
                                p_call_obj,p_sip_msg,&should_msg_compress,
                                &local_ecode))
                        {
                                ICF_SSA_SET_COMMON_BITMASK(p_ssa_ctxt->bitmask,
                                        ICF_SSA_SIP_MSG_SHOULD_BE_COMPRESSED);
                        }
                }

                /* Add Comp=sigcomp param in the via header if it is a request
                * Message only if the sigsa context stored in the ssa context
                * is not null(secure connection is up)
                */

                if(ICF_NULL != p_sigsa_ctxt)
                {
                    if (dReqRespType == SipMessageRequest)
                        {

                                icf_tag_st            sigcomptag;
                                /* Make the local tag for adding comp=sigcomp
                                * parameter in the list 
                                */
                                icf_port_strcpy((icf_uint8_t*)&sigcomptag.hdr_name.str,"Via");
                                sigcomptag.hdr_name.str_len = icf_port_strlen("Via");

                                icf_port_strcpy((icf_uint8_t*)&sigcomptag.tag_value.str,"comp=sigcomp");
                                sigcomptag.tag_value.str_len = icf_port_strlen("comp=sigcomp");
                                sigcomptag.tag_type = ICF_TAG_TYPE_HDR_PARAM;

                                if(ICF_FAILURE ==
                                        icf_append_tag_params_to_hdr(p_ssa_pdb,&sigcomptag,p_sip_msg))
                                {
                                        ret_val = ICF_FAILURE;
                                }
                        }
                }
        }/* end if(sigcomp_required) */
#endif


    if(ICF_FAILURE == ret_val)
    {
    }
    /*  check for presence of allow header and populate it with only the methods
        which the application supports */
    else if (SipFail == sip_getHeaderCount(p_sip_msg, SipHdrTypeAllow, &count, \
        &SipErr) )
    {
        /*ICF_SSA_TRACE(("\nFailed to get Header Count "))*/
        ret_val = ICF_FAILURE;
    }
    /* Allow header present */
    else if(0 < count )
    {
        SipHeader               *p_allow_hdr = ICF_NULL;
        icf_uint8_t *p_method=ICF_NULL;
        icf_uint32_t index;

        if ((ICF_NULL == p_ssa_pdb->p_app_conf) &&
            ((ICF_SSA_USER_ADDR_FRM_SIC & p_ssa_pdb->common_bitmask) ||
             (
              (ICF_NULL != p_ssa_ctxt->p_sic_ctxt) &&
              (ICF_DUMMY_APP_ID == p_ssa_ctxt->p_sic_ctxt->app_id)
             )
            )
           )
        {
            /* Internal Subscribe */
            if(ICF_FAILURE == icf_ssa_make_allow_hdr_for_int_subscribe(p_ssa_pdb,&p_allow_hdr))
            {
                ret_val = ICF_FAILURE;
            }
        }
        else if(ICF_FAILURE == sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg,
                        (Sdf_ty_s8bit**)&p_method,p_sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
        else if((0 == icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER")) &&
                (ICF_NULL != p_ssa_ctxt->p_rgm_ctxt))
        {
            if(ICF_FAILURE == icf_ssa_make_allow_hdr_for_reg(p_ssa_pdb,&p_allow_hdr))
            {
                ret_val = ICF_FAILURE;
            }
        }
        /* Fix for CSR_1-5316323(ETSI conformance case SIP_MG_TE_V_006.
         * The NULL check of p_ssa_pdb->p_app_conf has been removed since
         * the function being called here does the same checking.
         */
        else if(ICF_FAILURE == icf_ssa_make_allow_hdr_from_app_profile(p_ssa_pdb,&p_allow_hdr))
        {
            p_allow_hdr = ICF_NULL;
            ret_val = ICF_FAILURE;
        }
        /*
         * This else block has been removed as per the above mentioned fix.If the above
         * called function returns success,405 sent out will not contain the Allow header 
         * as the following check would make it NULL.Hence it has been commented.
         */

        /*
        else
            p_allow_hdr = ICF_NULL;
        */
            
        /* Set new Allow header */
        if(ICF_FAILURE != ret_val)
        {
            /* Delete all allow headers */
            for(index = 0; index < count; index++)
            {
                if(SipFail == sip_deleteHeaderAtIndex (p_sip_msg,SipHdrTypeAllow, 0, &SipErr))
                {
                    ret_val = ICF_FAILURE;
                    break;
                }
            }
            if(ICF_FAILURE == ret_val)
            {
            }
            else if(ICF_NULL != p_allow_hdr)
            {
                /* Insert header in sip message */
                if(SipFail == sip_insertHeaderAtIndex (p_sip_msg, p_allow_hdr, 0, &SipErr))
                {
                    ret_val = ICF_FAILURE;
                }
            }
        }
        if(ICF_NULL != p_allow_hdr)
        {
            sip_freeSipHeader(p_allow_hdr);
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        }
    }

    if (ICF_SSA_FAILURE_RESP_CODE_488 == (p_ssa_pdb->p_ssa_ctxt->failure_bitmask 
                                          & ICF_SSA_FAILURE_RESP_CODE_488))
    {
       ret_val = icf_ssa_form_and_insert_warning_hdr(p_ssa_pdb,p_sip_msg);    
    }
    
    if ( ICF_FAILURE != ret_val)
    {
        Sdf_st_eventContext *p_event_context = Sdf_co_null;
        if (Sdf_co_fail ==
                sdf_ivk_uaInitEventContext(&p_event_context, p_sdf_error))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInInitEventCtxt in SSASendToPeer"));
            ret_val = ICF_FAILURE;
        }
        else
        {
            Sdf_st_transaction          *p_txn = Sdf_co_null;
            Sdf_st_overlapTransInfo     *p_overlap_txn = Sdf_co_null;

            p_event_context->pData = p_call_obj->pAppData->pData;
           
#ifdef ICF_DNS_LOOKUP_ENABLED
#if 0

            /* DNS-Buffer code starts here-- this code is for making the retries
        configurable */ 
            if(ICF_FAILURE == icf_dbm_get_module_glb_data(
                        p_ssa_pdb->p_glb_pdb,
                        (icf_int_module_id_t)ICF_INT_MODULE_CFG,
                        (icf_void_t *)&p_config_data, p_ssa_pdb->p_ecode))
            {
                /* didn't get the config data can't make the retry to be configurable
                   raise the error */
            }
            else if(ICF_NULL != p_config_data)
            {

                p_event_context->dTimerOption |= SIP_OPT_TIMER_T1;
                p_event_context->dTimerOption |= SIP_OPT_TIMER_F;
                p_event_context->dTimerOption |= SIP_OPT_TIMER_B;
                    p_event_context->dTimeoutValues.dT1= 500; /* default value */
                /* for NON-Invite x-saction */    
                p_event_context->dTimeoutValues.dTimerF_T3=  
                (icf_ssa_dns_2_pow (p_config_data->sip_req_retry)) * p_event_context->dTimeoutValues.dT1; 
                /* for INvite X-saction */
                p_event_context->dTimeoutValues.dTimerB= 
               (icf_ssa_dns_2_pow (p_config_data->sip_req_retry))* p_event_context->dTimeoutValues.dT1;
            } 
            else
            {
                /* configuration data is null raise the error */
               ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_config_data));
            }
        /* end of DNS-buffer code */
#endif
#endif

            if (Sdf_co_fail == sdf_ivk_uaGetTransactionForSipMsg(
                        p_call_obj, p_sip_msg,
                        &p_txn, &p_overlap_txn, p_sdf_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Can'tGetTxnFromMsg!!!"));
                ret_val = ICF_FAILURE;
            }
#ifdef ICF_DNS_LOOKUP_ENABLED
#ifdef ICF_RUNTIME_NAMESERVER_CONFIG
            /* DNS Lookup is not required while sending:
             * - De/REGSITER with credentials on getting challenge from 
             * Registrar
             */
            if(ICF_NULL != 
                    (p_ssa_pdb->common_bitmask & ICF_SSA_NO_NAMESERVER_REFRESH))
            {
			    p_ssa_ctxt->refresh_nameserver = ICF_FALSE;
            }
            else
            {
    			p_ssa_ctxt->refresh_nameserver = ICF_TRUE;
            }
			if (ICF_FAILURE == ret_val)
			{
				ret_val = ICF_FAILURE; /* effective no-op */
			}
#endif
            else if ( Sdf_co_fail == sdf_ivk_uaHandleLookup(p_call_obj,
                        p_overlap_txn, p_sip_msg,
                        p_event_context,p_sdf_error) &&
                    ( Sdf_en_dnsInvState != p_sdf_error->errCode))
            {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureIn HandleLookUp API"));
                    ret_val = ICF_FAILURE;
            }
            else if ((Sdf_co_false == sdf_ivk_uaIsDnsQueryState(p_call_obj,
                        p_overlap_txn, p_sdf_error)) || ICF_NULL == (p_ssa_ctxt->bitmask & 
                                                        ICF_SSA_DNS_FQDN_PRESENT ))
            {
#endif
                if (ICF_FAILURE != ret_val)
                {
                    /*this flag is used to identify whether a connection
                      has been made fully or not. Tjus is it to be used for
                      TCP/TLS cases only*/
                    icf_boolean_t    ready_to_send = ICF_TRUE;
#ifdef ICF_DNS_LOOKUP_ENABLED
                    p_ssa_pdb->p_event_ctxt = p_event_context;
#endif
                    if (ICF_NULL != 
                            (ICF_SSA_EXPLICIT_CONNECT_REQ & p_ssa_ctxt->bitmask))
                    {
                        if (ICF_FAILURE == icf_ssa_attempt_out_of_uatk_connect(
                                    p_ssa_pdb, p_call_obj, p_txn, 
                                    p_overlap_txn, &ready_to_send))
                        {
                            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureFrom AttemptOutOfDlgConnect"));
                            ret_val = ICF_FAILURE;
                        }
                    }/*out of UATK connect*/
#ifdef ICF_SECURE_SUPPORT
                    if(SipFail == sip_getMessageType(p_sip_msg,&dReqRespType,\
                                (SipError*)&(SipErr)))
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else if (SipMessageRequest == dReqRespType)
                    {
                        /*  Fix for CSR 1-7576638 */
                        /*If connection table entry is not NULL and connection type is TLS
                         *and persistent connection is supported and message is request 
                         *then send "alias" in Via header Also check bitmask should not be set
                         *with ICF_ALIAS_HEADER_PRESENT bit, which indicates that alias is already
                         *set*/
                        if ((p_ssa_pdb->p_ssa_ctxt->p_conn_table_req_entry != ICF_NULL) &&
                            (0 != ICF_PURGE_TIMER_DURATION) &&
                                (p_ssa_pdb->p_ssa_ctxt->p_conn_table_req_entry->prot_conn_bitmask &
                                  ICF_TRANSPORT_TLS) &&
                            (ICF_ALIAS_HEADER_PRESENT != 
                            (ICF_ALIAS_HEADER_PRESENT & p_ssa_pdb->p_ssa_ctxt->bitmask_1)))
                        {
                            if(SipFail != sip_initSipParam(&p_alias_param,\
                                        (SipError*)&(SipErr)))
                            {
                                Sdf_mc_strdup(p_alias_param->pName,"alias");

                                if(SipFail == icf_ssa_set_param_in_Via\
                                        (p_sip_msg,p_ssa_pdb,p_alias_param,\
                                         SipErr))
                                {
                                    /* Free any local references and
                                     * return failure.
                                     */
                                    sdf_memfree(Sdf_mc_callHandlerMemId,\
                                            (Sdf_ty_pvoid*)&p_alias_param,\
                                            p_sdf_error);
                                }
                            }
                            sip_freeSipParam(p_alias_param);
                            p_ssa_pdb->p_ssa_ctxt->bitmask_1 |=
                                ICF_ALIAS_HEADER_PRESENT;

                        }
                    }
                    else if (SipMessageResponse == dReqRespType)
                    {
                        if ((p_ssa_pdb->p_ssa_ctxt->p_conn_table_resp_entry != ICF_NULL) &&
                                (p_ssa_pdb->p_ssa_ctxt->p_conn_table_resp_entry->prot_conn_bitmask &
                                 ICF_TRANSPORT_TLS) &&
                                (p_ssa_pdb->p_ssa_ctxt->bitmask_1 &
                                 ICF_ALIAS_HEADER_PRESENT))
                        {
                            if(ICF_FAILURE == icf_ssa_del_params_in_Via(\
                                                    p_sip_msg,p_ssa_pdb,&SipErr))
                            {
                                ICF_PRINT(("\n Unable to delete Params"\
                                            " from Via Header.\n"));
                                ret_val = ICF_FAILURE;

                            }
                            
                            else if(SipFail != sip_initSipParam(&p_alias_param_1,\
                                        (SipError*)&(SipErr)))
                            {
                                if(SipFail != sip_initSipParam(&p_alias_param,\
                                        (SipError*)&(SipErr)))
                                {
                                    Sdf_mc_strdup(p_alias_param->pName,"alias");

                                    if(SipFail == icf_ssa_set_param_in_Via\
                                            (p_sip_msg,p_ssa_pdb,p_alias_param,\
                                             SipErr))
                                    {
                                        /* Free any local references and
                                         * return failure.
                                         */
                                        sdf_memfree(Sdf_mc_callHandlerMemId,\
                                                (Sdf_ty_pvoid*)&p_alias_param,\
                                                p_sdf_error);
                                    }
                                }

                                Sdf_mc_strdup(p_alias_param_1->pName,"received");
                                sip_listInit(&(p_alias_param_1->slValue),\
                                                    __sip_freeSipParam, \
                                                    (SipError*)&(SipErr));
                                            
                                if(SipFail == sip_listInsertAt(\
                                               &(p_alias_param_1->slValue),0,\
                                             (icf_void_t *)(p_ssa_ctxt->p_conn_table_req_entry->\
                                                 peer_ip),&SipErr))
                                {
                                    ret_val = ICF_FAILURE;

                                }

                                else if(SipFail == icf_ssa_set_param_in_Via\
                                        (p_sip_msg,p_ssa_pdb,p_alias_param_1,\
                                         SipErr))
                                {
                                    /* Free any local references and
                                     * return failure.
                                     */
                                    sdf_memfree(Sdf_mc_callHandlerMemId,\
                                            (Sdf_ty_pvoid*)&p_alias_param_1,\
                                            p_sdf_error);
                                }
                            }
                            sip_freeSipParam(p_alias_param_1);
                            sip_freeSipParam(p_alias_param);
                        }
                    }

#endif

                    
#ifdef ICF_NAT_RPORT_SUPPORT
                    if (ICF_CFG_SELF_ADDR_PER_LINE ==
                        p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
                    {
                           if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                            p_ssa_pdb->p_glb_pdb,p_ssa_ctxt->line_id,
                            &p_line_data, p_ssa_pdb->p_ecode))
                           {
                                     ret_val = ICF_FAILURE;
                           }
                           else
                           {
                                p_rport_config_data = p_line_data->p_rport_config_data;
                            }
    
                    }
                    else
                    {
                        p_rport_config_data = &(p_ssa_pdb->p_glb_cfg_data->rport_config_data);
                    }

                    /* Check whether rport needs to be send in the outgoing 
                     * request or not. 
                     */
                    /* Get the message type being send on the network.
                     */
                    if(SipFail == sip_getMessageType(p_sip_msg,&dReqRespType,\
                                (SipError*)&(SipErr)))
                    {
                        ret_val = ICF_FAILURE;
                    }

                    else
                    {
                        if(ICF_SUCCESS == ret_val)
                        {
                            switch(dReqRespType)
                            {
                                case SipMessageRequest:
                                    /* send rport in the Via Header of request
                                     * message
                                    */
                                    if((ICF_TRUE == p_rport_config_data->is_rport_reqd) &&
                                        (ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->\
                                         p_ssa_ctxt->transport))
                                    {

                                       if(SipFail != sip_initSipParam(&p_param,\
                                                  (SipError*)&(SipErr)))
                                        {
                                            Sdf_mc_strdup(p_param->pName,"rport");
                                            
                                            if(SipFail == icf_ssa_set_param_in_Via\
                                                    (p_sip_msg,p_ssa_pdb,p_param,\
                                                    SipErr))
                                            {
                                                /* Free any local references and
                                                 * return failure.
                                                 */
                                                sdf_memfree(Sdf_mc_callHandlerMemId,\
                                                        (Sdf_ty_pvoid*)&p_param,\
                                                        p_sdf_error);
                                            }
                                        }
                                       sip_freeSipParam(p_param);

                                     }
                                    /* Persistent TLS connection */
                                    else
                                     {
                                         p_rport_config_data->is_rport_reqd = ICF_FALSE;
                                     }
                                     break;
                                case SipMessageResponse:
                                    /* Check whether rport was received in the
                                     * request, if yes then send the received
                                     * and rport parameters in the Via Header of 
                                     * the response.
                                     */
                                     
                                    if(ICF_RPORT_RECEIVED & p_ssa_ctxt->\
                                        rport_bitmask)
                                    {
                                        icf_uint8_t     temp_rport[10];

                                        /* Delete the "rport" and "received" 
                                         * parameters from the Via Header if 
                                         * already present.
                                         */
                                        if(ICF_FAILURE == icf_ssa_del_params_in_Via(\
                                                    p_sip_msg,p_ssa_pdb,&SipErr))
                                        {
                                            ICF_PRINT(("\n Unable to delete Params"\
                                                        " from Via Header.\n"));
                                            ret_val = ICF_FAILURE;

                                        }
                                        else if(SipFail != sip_initSipParam(&p_param,\
                                                    (SipError*)&(SipErr)))

                                        {
                                            Sdf_mc_strdup(p_param->pName,"received");
                                            sip_listInit(&(p_param->slValue),\
                                                    __sip_freeSipParam, \
                                                    (SipError*)&(SipErr));
                                            
                                            if(SipFail == sip_listInsertAt(\
                                               &(p_param->slValue),0,\
                                             (icf_void_t *)(p_ssa_ctxt->\
                                                 destination_ip),&SipErr))
                                            {
                                                ret_val = ICF_FAILURE;

                                            }
                                            
                                            else if(SipFail == icf_ssa_set_param_in_Via(\
                                                        p_sip_msg,p_ssa_pdb,p_param,\
                                                      SipErr))
                                            {
                                                /* Free any local references and
                                                 * return failure.
                                                 */

                                                sdf_memfree(Sdf_mc_callHandlerMemId,\
                                                    (Sdf_ty_pvoid*)&p_param,p_sdf_error);
                                                ret_val = ICF_FAILURE;
                                            }
                                        
                                            /* Set the rport parameter in the Via Header
                                             */
                                            else if(SipFail != sip_initSipParam(&p_param_1,(SipError*)&(SipErr)))
                                            {
                                                Sdf_mc_strdup(p_param_1->pName,"rport");

                                                icf_port_sprintf(temp_rport,"%d",\
                                                        p_ssa_ctxt->destination_port);
                                                sip_listInit(&(p_param_1->slValue),\
                                                        __sip_freeSipParam, \
                                                        (SipError*)&(SipErr));

                                                if(SipFail == sip_listInsertAt(\
                                                            &(p_param_1->slValue),0,\
                                                            (icf_void_t *)(temp_rport),&SipErr))
                                                {
                                                    ret_val = ICF_FAILURE;

                                                }

                                                else if(SipFail == icf_ssa_set_param_in_Via(\
                                                            p_sip_msg, p_ssa_pdb,p_param_1,\
                                                            SipErr))
                                                {
                                                    /* Free any local references and 
                                                     * return failure.
                                                     */
                                                    sdf_memfree(Sdf_mc_callHandlerMemId,\
                                                            (Sdf_ty_pvoid*)&p_param,p_sdf_error);
                                                    sdf_memfree(Sdf_mc_callHandlerMemId,\
                                                            (Sdf_ty_pvoid*)&p_param_1,p_sdf_error);
                                                    ret_val = ICF_FAILURE;
                                                }
                                                else
                                                {
                                                    sip_freeSipParam(p_param);
                                                    sip_freeSipParam(p_param_1);

                                                }
                                            }
                                        }
                                    }
                                default:
                                    ICF_PRINT(("\n[SSA]: Neither a Sip"\
                                                "Request/Response Message"));

                                    break;
                                }
                        }
                     
                    }
#endif

                    if ((ICF_TRUE == ready_to_send) && ICF_FAILURE != ret_val\
                            && 
						    (Sdf_co_fail == 
						     icf_ssa_initiate_dispatch_sequence(
							     p_ssa_pdb, p_call_obj,
							     p_txn, p_overlap_txn, p_event_context,
							     &local_ecode)))
				    {
					    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in InitiateDispatchSeq!!!"));
					    ret_val = ICF_FAILURE;
				    }
                    else
                    {
#ifdef ICF_DNS_LOOKUP_ENABLED
                        /*Fix for CSR 1_8196703 SPR 20278.
					     * EGT sends the message using the buffered IP, then
						 * EGT shall reset this DNS State otherwise EGT did not 
						 * perform DNS query after purge timer expiry.
						 */
						if (ICF_DNS_RECORD_FETCHED ==
                           (ICF_DNS_RECORD_FETCHED & p_ssa_ctxt->bitmask))
						{
							if (ICF_NULL != p_txn)
							{
								p_txn->dTxnDnsState = Sdf_en_Idle;
							}
							else if(ICF_NULL != p_overlap_txn)
							{
								p_overlap_txn->dTxnDnsState = Sdf_en_Idle;
							}
						}
#endif
#ifdef ICF_TRACE_ENABLE
                    
						if(Sdf_co_success == sdf_ivk_uaIsSdpBodyPresent(
                                        p_sip_msg, p_sdf_error))
                        {
                             p_ssa_pdb->sdp_present = ICF_TRUE;
                        }
                        else
                        {
                              p_ssa_pdb->sdp_present = ICF_FALSE;
                        }
                        icf_ssa_capture_trace(
						       p_ssa_pdb,p_sip_msg, 0);
#endif
                    }
			    }/*retval FIALURE check*/
#ifdef ICF_DNS_LOOKUP_ENABLED
            }/*If the query state indicated that no query was sent
               i.e IP is already present in txn structure*/
#endif
        if ( Sdf_co_null != p_txn)
        {
            sdf_ivk_uaFreeTransaction(p_txn);
        }
        if ( Sdf_co_null != p_overlap_txn)
        {
            sdf_ivk_uaFreeOverlapTransInfo(p_overlap_txn);
        }
        }/*InitEventContext Success leg*/
        sdf_ivk_uaFreeEventContext(p_event_context);
    }/*ret_val != FAILURE*/

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_check_if_ip
 ** DESCRIPTION:  This function checks if the string passed is an IP address
 **               
 **
 ***************************************************************************/
icf_return_t icf_ssa_check_if_ip(icf_uint8_t *p_ip_address)
{
    return icf_port_check_if_ip(p_ip_address);
}

#ifdef ICF_TRACE_ENABLE


/*****************************************************************************
 ** FUNCTION:        icf_ssa_capture_trace
 **
 ** DESCRIPTION:    This function captures the traces at ssa
 **
 **
*****************************************************************************/

icf_void_t
icf_ssa_capture_trace(
          icf_ssa_pdb_st *p_ssa_pdb,
           SipMessage     *p_sip_msg,
           icf_uint8_t    call_dir)
{
                 icf_return_t    ret_val = ICF_SUCCESS;
        en_SipMessageType    dReqRespType;
        Sdf_ty_s8bit         *p_method = Sdf_co_null;
        Sdf_ty_u16bit        dRespCode = 0;
        SipError        sip_error;
                Sdf_st_error    sdf_error;

	   if ((ICF_NULL == p_sip_msg) ||
              (SipFail == sip_getMessageType(p_sip_msg, &dReqRespType,&sip_error))
              || (Sdf_co_fail ==sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg, &p_method,
                  &sdf_error)))
                {
                 ret_val = ICF_FAILURE;
                }/* end of if */
                else
                {
                        p_ssa_pdb->p_method = (icf_uint8_t *)p_method;

                if(dReqRespType == SipMessageRequest)
                {
                if(0 == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"INVITE"))
                {
                        if(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->common_bitmask &
                                        ICF_CALL_CONNECT_DONE)
                        {
                                if(call_dir == 0)
                       			ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_REINVITE_SENT)
                		else if(call_dir == 1)
                       			ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_REINVITE_RECVD)

                	}/* end of if */
			else
                	{
                		if(call_dir == 0)
                   			ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_INVITE_SENT)
                		else if(call_dir == 1)
                    			ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_INVITE_RECVD)
                	}/* end of else */

		}/* end of if */
        	else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"INFO"))
        	{
                	if(call_dir == 0)
                 		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_OTG_INFO)
                	else if(call_dir == 1)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_INC_INFO)
        	} 
        	else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"PRACK"))
        	{
                        if(call_dir == 0)
                        	ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_PRACK_SENT)
                	else if(call_dir == 1)
                        	ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_PRACK_RECVD)
        	}
        	else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"UPDATE"))
        	{
                	if(call_dir == 0)
                        	ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_UPDATE_SENT)
                	else if(call_dir == 1)
                        	ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_UPDATE_RECVD)
        	}
        	else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"BYE"))
        	{
                        if(call_dir == 0)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_BYE_SENT)
                	else if(call_dir == 1)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_BYE_RECVD)
        	}      
        	else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"ACK"))
        	{
                        if(call_dir == 0)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_ACK_SENT)
                	else if(call_dir == 1)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_ACK_RECVD)
        	}      
        	else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"CANCEL"))
        	{
                        if(call_dir == 0)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_CANCEL_SENT)
                	else if(call_dir == 1)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_CANCEL_RECVD)
        	}
                /* If OPTIONS is sent on network then handle it and no traces should be printed */
                /* Fix for SPR 17649 */
                else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"OPTIONS"))
                {
                }           

 		else if((0 != icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"REGISTER")) &&
                        (0 != icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"SUBSCRIBE")))
        	{
                	if(call_dir == 0)
                 		ICF_SSA_APP_TRACE(p_ssa_pdb,
                                                ICF_TRACE_OUT_OF_DIALOG_MESSAGE_SENT)
                	else if(call_dir == 1)
                        	ICF_SSA_APP_TRACE(p_ssa_pdb,
                                                ICF_TRACE_OUT_OF_DIALOG_MESSAGE_RECVD)
        	}
        	}/* end of if */

        	else if(dReqRespType ==  SipMessageResponse)
        	{
        	if (Sdf_co_fail == sdf_ivk_uaGetRespCodeFromSipMessage(
                        p_sip_msg, &dRespCode, &sdf_error))
        	{
            		ret_val = Sdf_co_fail;
        	}/* end of if */
        	else
        	{
                        p_ssa_pdb->resp_code = dRespCode;
                	switch (dRespCode)
                	{
            			case 100:
                 			if(call_dir == 0)
                      				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_100_SENT)
               				else if(call_dir == 1)
                  				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_100_RECVD)
                     			break;    

            			case 180:
                       			p_ssa_pdb->sdp_present = 1;

               				if(call_dir == 0)
               	      				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_180_SENT)
               				else if(call_dir == 1)
                      				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_180_RECVD)
               	     			break;

            			case 183:
                               		 p_ssa_pdb->sdp_present = 1;
               				if(call_dir == 0)
                      				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_183_SENT)
               				else if(call_dir == 1)
                      				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_183_RECVD)
               	    			break;
	   			case 200:
              				if(call_dir == 0)
                     				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_200_SENT)
              				else if(call_dir == 1)
                    				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_200_RECVD)
                     			 break;

             			case 202:
                       			if(call_dir == 0)
                    				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_202_SENT)
               				else if(call_dir == 1)
                    				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_202_RECVD)
              	 			break;

             			default:
                        	
                        		if (dRespCode >100 && dRespCode <= 199)
            				{
               					if(call_dir == 0)
                                			ICF_SSA_APP_TRACE(p_ssa_pdb,
                                                		ICF_TRACE_PROVISIONAL_RESP_SENT)
               					else if(call_dir == 1)
                                    			ICF_SSA_APP_TRACE(p_ssa_pdb,
                                                		ICF_TRACE_PROVISIONAL_RESP_RECVD)
            				}/* end of if */

                        		else if (dRespCode >=300 && dRespCode <= 399)
            				{
                				if(call_dir == 0)
                     					ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_302_SENT)
                				else if(call_dir == 1)
                     					ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_302_RECVD)
            				}/* end of else if */

                    			else if (dRespCode >=400 && dRespCode <= 699)
            				{
                 				if(call_dir == 0)
                      					ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_FAILURE_RESP_SENT)
                 				else if(call_dir == 1)
                               				ICF_SSA_APP_TRACE(p_ssa_pdb,ICF_TRACE_FAILURE_RESP_RECVD)
            				}/* end of else if */
            				else
                 				ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Response code not valid."))
                         		
					break;
                        	
          }/* end of switch */
       }/* end of else */
     }/* end of else if */
    else
               ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Neither a Sip Request/Response Message"));
   }/* end of else */

}/* end of function */

#endif


/*******************************************************************************
 * 
 * FUNCTION:        icf_ssa_send_register_req
 *
 * DESCRIPTION:     This function constructs and sends REGISTER req on network.
 *                  1.Update the profile of the call object and set the 
 *                  transport scheme(TCP/UDP) in the transaction.
 *                  2.Set the To header and then invoke the API 
 *                  sdf_ivk_uaSetDefaultRegistrar which sets the registrar
 *                  address on the basis of the registrar addr configured on
 *                  that line.
 *                  3.All the contact addresses for which a binding needs
 *                  to be added are as stored in the contact address
 *                  list stored in the call object profile.
 *                  4.This contact addr list is cloned and passed as a
 *                  parameter to the sdf_ivk_uaMakeRegister API if this
 *                  is an initial registn request,else invoke the
 *                  sdf_ivk_uaDeleteRegistration API to make the appr.
 *                  de-registration request.
 *                  5.If the transport type is TCP,fetch a new connection
 *                  DB node and populate it with the requisite information
 *                  (registrar addr,sock fd etc)
 *                  6.If there is a failure in sending the message on TCP,
 *                  call utility function icf_ssa_revert_to_udp which sends
 *                  the message on UDP.
 *
 ******************************************************************************/
 icf_return_t icf_ssa_send_register_req(
     INOUT    icf_ssa_pdb_st       *p_ssa_pdb)
 {
     icf_return_t             ret_val = ICF_SUCCESS;
     icf_ssa_ctxt_st          *p_ssa_ctxt = ICF_NULL;
     Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;
     Sdf_st_error                sdf_error;
     Sdf_ty_s8bit                proto[ICF_MAX_SIZE_INT_USAGE_STR];
     Sdf_ty_s8bit                duration[ICF_MAX_SIZE_INT_USAGE_STR];
     Sdf_ty_slist                contact_addr_list;
     SipOptions                  sip_options;
     icf_uint8_t                 reg_addr[ICF_MAX_STR_LEN] = "";
     
     icf_uint16_t                reg_port = 0,default_port=ICF_NULL;
     icf_boolean_t               contact_list_valid = ICF_TRUE;
     /*Fix done for SPR-18722 : CSR-1-6068965*/
     icf_int8_t                 *p_content_type = ICF_NULL;
     

#ifdef ICF_IPSEC_ENABLED
     icf_config_data_st  *p_cfg_data = p_ssa_pdb->p_glb_cfg_data;
     icf_uint16_t        port_num = ICF_NULL;
     icf_uint8_t         *p_value = ICF_NULL;
     SipMessage             *p_otg_sip_msg = ICF_NULL;
#endif
      ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
 
      /* UMR fix */
      icf_port_memset(
          (icf_void_t *)&sdf_error,
          0,
          ICF_PORT_SIZEOF(Sdf_st_error));

      /* Copy the ssa ctxt pointer locally */
      p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
      ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))
      p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;       

 

        
         if (ICF_NULL == p_ssa_pdb->p_glb_cfg_data)
         {
             /* Request the DBM for getting pointer to config data structure */
             ret_val = icf_dbm_get_module_glb_data(
                 p_ssa_pdb->p_glb_pdb,
                 (icf_int_module_id_t)(ICF_INT_MODULE_CFG),
                 (icf_void_t **)(&(p_ssa_pdb->p_glb_cfg_data)),
                 p_ssa_pdb->p_ecode);     
             
             ICF_ASSERT(
                 p_ssa_pdb->p_glb_pdb,
                 (ICF_NULL != p_ssa_pdb->p_glb_cfg_data))
         }/* get pointer to global cfg data if NULL already */

        /* Set the transport mode in local variable */
    if (((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_ssa_ctxt->transport) ||
            (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_ssa_ctxt->transport))
        && (ICF_NULL == (p_ssa_ctxt->bitmask & 
                               ICF_SSA_RGM_PREV_TRANS_TYPE_UDP)))
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP"); 
        icf_port_strcpy(p_ssa_pdb->trans_param, (icf_uint8_t *)"TCP");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport) 
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
        default_port = ICF_DEFAULT_SIPS_SERVER_PORT;
    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
#ifdef ICF_P_CSCF_DISCOVERY_ENABLED
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
/* We will net the transport mode to none for P-CSCF Discovery */
    icf_port_strcpy(proto,"");
ICF_CHECK_IMS_END
#endif
#endif
         
        /* Copy the registrar address in local variables */
        /* for IMS network registrar address is same as proxy address */
         if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
             p_ssa_pdb->p_line_data->registrar_addr.addr.addr_type)
         {
             icf_port_strcpy(reg_addr,
                 p_ssa_pdb->p_line_data->registrar_addr.addr.addr.domain.str);
         }
         else
         {
              icf_ssa_convert_to_IP_addr(
                 &(p_ssa_pdb->p_line_data->registrar_addr),
                 reg_addr);
         }
                 

#ifdef ICF_IPSEC_ENABLED
        if (ICF_TRUE == p_cfg_data->ipsec_enabled )
        {
            /* extract the reg ctxt and the relevant SA and save in 
             * the ssa_pdb. These parameters are required to update 
             * the protected server ports in VIA and Contact. Also 
             * required to increase the transaction count after sending 
             * out the message */
            p_ssa_pdb->p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;

            if ((((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context != ICF_NULL) &&
            (((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->is_active == 
                ICF_TRUE))
            {
                p_ssa_pdb->p_sa_context = 
                    ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
            }
            else if (((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context != NULL)
            {
                p_ssa_pdb->p_sa_context = 
                        ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context;
            }
            if (ICF_NULL == p_ssa_pdb->p_sa_context)
            {
                port_num = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_security_client_params->port_s;
                /*reg_port = p_ssa_pdb->p_rgm_context->p_security_client_params->port_s;*/
            }
            else
            {
                port_num = p_ssa_pdb->p_sa_context->p_ue_security_params->port_s;
                reg_port = p_ssa_pdb->p_sa_context->p_proxy_security_params->port_s;
            }

            p_ssa_ctxt->ssa_sa_context.p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;
            p_ssa_ctxt->ssa_sa_context.p_sa_context = 
                    ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;

            p_ssa_pdb->p_sa_context = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
            p_ssa_pdb->p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;

        }
        else
        {
#endif

#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
        /* for IMS network registrar address is same as proxy address */
        reg_port = p_ssa_pdb->p_line_data->proxy_addr.port_num;
ICF_CHECK_IMS_END
#endif

#ifdef NON_IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_FALSE)
        reg_port = p_ssa_pdb->p_line_data->registrar_addr.port_num;
ICF_CHECK_IMS_END
#endif

#ifdef ICF_IPSEC_ENABLED
        }
#endif

         if (Sdf_co_fail == sdf_listInit(
             &contact_addr_list,
             __sdf_fn_uaFreeCompleteHeader,
             Sdf_co_false,
             &sdf_error))
         {
             /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
             sdf_ivk_uaClearTransaction(
                 p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                 p_overlap_trans_info,
                 "REGISTER",
                 Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
             contact_list_valid = ICF_FALSE;
         }
         else if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
             p_ssa_pdb->p_ssa_ctxt->p_call_obj,
             &p_overlap_trans_info,
             "REGISTER",
             &sdf_error))
         {
             /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
             ret_val = ICF_FAILURE;
         }
         /* this only updates the protocol in the call Obj */
         else if (Sdf_co_fail == sdf_ivk_uaSetTransportSchemeInTransaction(
             p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction,
             p_overlap_trans_info,
             proto,
             &sdf_error))
         {
             /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
             sdf_ivk_uaClearTransaction(
                 p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                 p_overlap_trans_info,
                 "REGISTER",
                 Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
         }
         else if (ICF_FAILURE == icf_ssa_update_callobj_for_profile(p_ssa_pdb))
         {
             /* incase if IPsec is enabled, the ports for Contact and Via will
              * be updated to the protected server port at UE. */ 
             sdf_ivk_uaClearTransaction(
                 p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                 p_overlap_trans_info,
                 "REGISTER",
                 Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
         }
         /* Add profile headers now */
         else if (ICF_FAILURE == icf_ssa_make_profile_for_reg(
             p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,            
             p_ssa_pdb))
         {
             /* incase if IPsec is enabled, the ports for Contact and Via will
              * be updated to the protected server port at UE. */ 
             sdf_ivk_uaClearTransaction(
                 p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                 p_overlap_trans_info,
                 "REGISTER",
                 Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
         }


         /* To header will be set only at the first time */    
        else if ((ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask) &&
                (ICF_FAILURE == icf_ssa_set_to_in_reg_callobj(p_ssa_pdb)))
        {
             sdf_ivk_uaClearTransaction(
                 p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                 p_overlap_trans_info,
                 "REGISTER",
                 Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
         }
         else if (Sdf_co_fail == sdf_ivk_uaSetDefaultRegistrar(
             p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
             (icf_int8_t *)reg_addr,
#ifndef ICF_DNS_LOOKUP_ENABLED
             /* fix - default port 5060 should not go in header */
             ((reg_port == default_port)?ICF_NULL:reg_port),
#else
            reg_port,
#endif
             &sdf_error))
         {
             sdf_ivk_uaClearTransaction(
                 p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                 p_overlap_trans_info,
                 "REGISTER",
                 Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
         }
#ifdef ICF_SECURE_SUPPORT
     else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)
     {
         if (ICF_NULL != p_ssa_pdb->p_glb_cfg_data->p_tls_init_data)
         {
             p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData->pTransport->dPort =
                 p_ssa_pdb->p_glb_cfg_data->p_tls_init_data->tls_sip_serv_port_num;
         }
         else
         {
             ICF_PRINT(("\n Error : TLS data not configured"));
             ret_val = ICF_FAILURE;
         }
     }    
#endif
         if ((ICF_SUCCESS == ret_val) && 
                 (!(ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask)))
         {
             /* Register request which is not the initial one should 
              * not contain the to tag : So remove the to tag
              */
            Sdf_ty_u32bit dCount = 0;

            if(sip_getTagCountFromToHdr(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pCommonInfo->pTo,&dCount,\
                        (SipError *)&(sdf_error.stkErrCode))==SipFail)
            {
                ret_val = ICF_FAILURE;
            }
            if (dCount != 0)
            {
                Sdf_ty_u32bit dIndex=0;
                for(dIndex=0;dIndex<dCount;dIndex++)
                {
                    if(sip_deleteTagAtIndexInToHdr(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pCommonInfo->pTo,
                                dIndex,\
                                (SipError *)&(sdf_error.stkErrCode))==SipFail)
                    {
                        ret_val = ICF_FAILURE;
                        break;
                    }
                }
            }

         }
         if ((ICF_SUCCESS == ret_val) && 
             (ICF_SSA_RGM_REQ_TYPE & p_ssa_pdb->common_bitmask))
     {
         /* Make the Register Request */ 
         if(ICF_FAILURE == icf_ssa_make_contact_list_for_reg(
                     p_ssa_pdb,
                     &contact_addr_list))
         {
             /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
             sdf_ivk_uaClearTransaction(
                     p_ssa_ctxt->p_call_obj,
                     p_overlap_trans_info,
                     "REGISTER",
                     Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
         }
         else
         {

             sdf_fn_uaSprintf(duration,"%lu",
                     p_ssa_ctxt->p_rgm_ctxt->rgm_duration/1000);
             if (Sdf_co_fail == sdf_ivk_uaMakeRegister(
                         p_ssa_ctxt->p_call_obj,
                         duration,
                         &contact_addr_list,
                         p_overlap_trans_info,
                         &sdf_error))
             {
                 sdf_ivk_uaClearTransaction(
                         p_ssa_ctxt->p_call_obj,
                         p_overlap_trans_info,
                         "REGISTER",
                         Sdf_en_uacTransaction);
                 ret_val = ICF_FAILURE;
             }
         }
     }
         if ((ICF_SUCCESS == ret_val) && 
             (!(ICF_SSA_RGM_REQ_TYPE & p_ssa_pdb->common_bitmask)))
         {
#if 1 /*ZySEL , Jason , [RD Internal] #347*/
	         /* Make the DE-Register Request */ 
             /* CSR_1-8389294 changes start */
             if(ICF_TRUE == p_ssa_ctxt->p_rgm_ctxt->dereg_specific_contact)
             {
	         if(ICF_FAILURE == icf_ssa_make_contact_list_for_reg(
	                     p_ssa_pdb,
	                     &contact_addr_list))
	         {
	             /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
	             sdf_ivk_uaClearTransaction(
	                     p_ssa_ctxt->p_call_obj,
	                     p_overlap_trans_info,
	                     "REGISTER",
	                     Sdf_en_uacTransaction);
	             ret_val = Sdf_co_fail;
	         }
	         if(ICF_FAILURE != ret_val)  
	         {
				
	             /* Make the DE-Register Request */
	             if (Sdf_co_fail == sdf_ivk_uaDeleteRegistration(
	                 p_ssa_ctxt->p_call_obj,
	                 &contact_addr_list,
	                 p_overlap_trans_info,
	                 &sdf_error))
	             {
	                 sdf_ivk_uaClearTransaction(
	                     p_ssa_ctxt->p_call_obj,
	                     p_overlap_trans_info,
	                     "REGISTER",
	                     Sdf_en_uacTransaction);
	                 ret_val = ICF_FAILURE;
	             }
	         }
             }
             /* CSR_1-8389294 changes end */
             else
             {                 
                 if (Sdf_co_fail == sdf_ivk_uaDeleteRegistration(
                     p_ssa_ctxt->p_call_obj,
                     Sdf_co_null,
                     p_overlap_trans_info,
                     &sdf_error))
                 {
                     sdf_ivk_uaClearTransaction(
                         p_ssa_ctxt->p_call_obj,
                         p_overlap_trans_info,
                         "REGISTER",
                         Sdf_en_uacTransaction);
                     ret_val = ICF_FAILURE;
                 }
             }
#else		 
             /* Make the DE-Register Request */
             if (Sdf_co_fail == sdf_ivk_uaDeleteRegistration(
                 p_ssa_ctxt->p_call_obj,
                 Sdf_co_null,
                 p_overlap_trans_info,
                 &sdf_error))
             {
                 sdf_ivk_uaClearTransaction(
                     p_ssa_ctxt->p_call_obj,
                     p_overlap_trans_info,
                     "REGISTER",
                     Sdf_en_uacTransaction);
                 ret_val = ICF_FAILURE;
             }
#endif			 
         }
                            
         if (ICF_SUCCESS == ret_val)
         {
             /* ret_val SUCCESS begins */
#ifdef IMS_CLIENT
ICF_4_0_CRM_START
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
             if (ICF_IMS_AUTH_OPTION == p_ssa_pdb->p_glb_cfg_data->auth_type)
             {
                 /* Make the authorization header for IMS scenario */
                 if (ICF_FAILURE == icf_ssa_make_ims_auth_hdr(p_ssa_pdb,
                             p_overlap_trans_info->pSipMsg))
        
                 {
                             sdf_ivk_uaClearTransaction(
                                 p_ssa_ctxt->p_call_obj,
                                 p_overlap_trans_info,
                                 "REGISTER",
                                 Sdf_en_uacTransaction);
                             ret_val = ICF_FAILURE;
                             
                             ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                                 ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
                                 
                                 ret_val = ICF_FAILURE;
    
                 }
             }/* IMS option ends for authorization header */
    /* To add the P-Access-Network Info header to the SipMsg */
             if ((ICF_FAILURE == ret_val)||
                 (ICF_FAILURE == icf_ssa_form_and_insert_access_nw_info_hdr(
                 p_ssa_pdb,p_overlap_trans_info->pSipMsg)))
             {
                 /* Error during addition of P-Access-Info Header */
                 ret_val = ICF_FAILURE;
             }
ICF_CHECK_IMS_END
#endif

 
              /* To add the additional tags/headers/msg_body to REGISTER 
             * as received from the application data */
             if ((ICF_FAILURE == ret_val)||
                 (ICF_FAILURE == icf_ssa_add_rgm_app_data(
                 p_ssa_pdb,p_overlap_trans_info)))
             {
                 /* Error during addition of app_data tags/hdrs/msg bodies */
                 ret_val = ICF_FAILURE;
                 
             }
             /*Message body header changes Start*/

             /* Get the Content Type from the Message Body List to be used to 
          * fill in the SIP general Content-Type Header.
          */
             icf_get_content_type_from_msg_body(p_ssa_pdb,&p_content_type);
             
             /* To move the added message bodies onto the SIP message */
             if (ICF_FAILURE == icf_ssa_SetAllMsgBody(Sdf_co_null,
                 p_overlap_trans_info,(icf_int8_t *)p_content_type,&sdf_error))
             {
                 ret_val = ICF_FAILURE;
             }
         }/* ret_val SUCCESS ends */
    /*Message body header changes Ends*/
    
    if(ICF_TRUE == contact_list_valid)
        sdf_listDeleteAll(&contact_addr_list, &sdf_error);
    
    sip_options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;
    
    if (ICF_SUCCESS == ret_val)
    {
        if (ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask)
        {
            icf_ssa_add_callid_callobj_map(
                p_ssa_pdb,
                p_ssa_ctxt,
                p_ssa_pdb->p_ecode);
        }
        
#ifdef ICF_IPSEC_ENABLED
        /* now insert the security header information in the UA Callobj. This 
         * header will go as unknown header in the message */

        /* derive the SIP message from the OverlapTransaction on which we have 
         * invoked the Start Transaction UATK function */
        p_otg_sip_msg = p_overlap_trans_info->pSipMsg;
        if (ICF_TRUE == p_cfg_data->ipsec_enabled)
        {
            /* insert Security Client Header */
            if (ICF_NULL != 
                ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_security_client_params)
            {
                if (ICF_FAILURE == icf_ssa_get_sec_client_string(
                                        p_ssa_pdb,
                                        &p_value, 
                                        ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_security_client_params))
                {
                    ret_val = ICF_FAILURE;
                }
                else if (ICF_FAILURE ==     
                    icf_ssa_insert_unknown_hdr_in_sip_msg (p_ssa_pdb,
                    (icf_uint8_t*)"Security-Client",
                    p_value, p_overlap_trans_info->pSipMsg ))
                {
                    ICF_PRINT(("\nFailed to insert unknown header \
                        (Security-Client)"));
                    ret_val = ICF_FAILURE;
                }

                if (ICF_SUCCESS == ret_val )
                {
                    ICF_PRINT(("\nSecurity Client Header inserted to \
                                    outgoing Register "));
                }

                if (ICF_NULL != p_value)
                {
                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_value,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                }

            }

            /* set the sa_ctxt and rgm_ctxt in p_ssa_sa_ctxt in p_ssa_ctxt */
            /* used for setting the prot port in VIA and contact */
            p_ssa_ctxt->ssa_sa_context.p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;
            p_ssa_ctxt->ssa_sa_context.p_sa_context = 
                    ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;

            p_ssa_pdb->p_sa_context = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
            p_ssa_pdb->p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;
        }
#endif
        /* ------------------------------------------------------------------ */
        /* Send request to peer */
        /*TCPM Additions*/
        
        if ((0 == icf_port_strcmp((icf_uint8_t *)proto, (icf_uint8_t *)"TCP")) ||
            (0 == icf_port_strcmp((icf_uint8_t *)proto, (icf_uint8_t *)"TLS")))
        {
            icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->dest_ip,(icf_uint8_t *)reg_addr);

            p_ssa_pdb->dest_port = reg_port;

            if ( Sdf_co_fail == 
                sdf_ivk_uaSetTransportSchemeInTransaction(
                    p_ssa_ctxt->p_call_obj->pUacTransaction, 
                    p_overlap_trans_info, 
                    proto,
                    &sdf_error))
        {
            ret_val = ICF_FAILURE;
        }

        if (ICF_TRANSPORT_TYPE_TLS == 
                p_ssa_ctxt->transport)
        {
            p_ssa_ctxt->bitmask |= ICF_SSA_TLS_TRANSPORT;
        }
        else
        {
            p_ssa_ctxt->bitmask |= ICF_SSA_TCP_TRANSPORT;
        }

        if (ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask)
        {
            ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                    ICF_SSA_EXPLICIT_CONNECT_REQ)
        }
        }
    if (ICF_SUCCESS == ret_val)
    {
        if ( ICF_FAILURE == icf_ssa_send_to_peer(
                    p_ssa_pdb,
                    p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info->pSipMsg,
                    &sip_options,
                    &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                    p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == sdf_ivk_uaEndTransaction(
                    p_ssa_ctxt->p_call_obj,
                    Sdf_co_null,
                    "REGISTER",
                    &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                    p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
            ret_val = ICF_FAILURE;
        }
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} /* End of icf_ssa_send_register_req() */
/*******************************************************************************
 * 
 * FUNCTION:        icf_ssa_send_register_req_with_auth
 *
 *                  Authentication info on network.Only DIGEST scheme is
 *                  supported.
 *                  1.Initialize the UAC auth info list 
 *                  2.Iterate through the authorization params list
 *                  stored in the SSA ctxt.This list was returned when
 *                  the REGISTRAR challenged us with 401/407 response 
 *                  asking for authorization parameters.
 *                  3.If the scheme present in the elements of this list
 *                  is "Digest",populate the authorization parameters from
 *                  that configured on the line and append the same to the
 *                  UAC auth info list initialized earlier. 
 *                  4. Set the transport scheme in transaction and invoke
 *                  sdf_ivk_uaFormRequestWithAuthorization with the
 *                  authorization paramters and send the request to peer.
*
 ******************************************************************************/
icf_return_t icf_ssa_send_register_req_with_auth(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb)

{
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;
    Sdf_st_overlapTransInfo             *p_overlap_trans_info = Sdf_co_null;
    Sdf_st_error                        sdf_error, *pErr = &sdf_error;
    Sdf_ty_s8bit                        proto[ICF_MAX_SIZE_INT_USAGE_STR];
    SipOptions                          sip_options;
    Sdf_ty_slist                        *p_uac_auth_info_list = Sdf_co_null;
    Sdf_ty_u32bit                       index = 0;
    
#ifdef ICF_IPSEC_ENABLED
    icf_transport_address_st     *p_transport_address = ICF_NULL;
    icf_uint8_t                  p_transp_addr_str[ICF_MAX_STR_LEN]= "";
    icf_uint16_t                 reg_port = ICF_NULL, port_us = ICF_NULL;
    icf_uint8_t                  reg_addr[ICF_MAX_STR_LEN] = "";
    icf_uint16_t                 proxy_port = ICF_NULL;
    icf_uint8_t                  proxy_addr[ICF_MAX_STR_LEN] = "";
#endif

    Sdf_st_error                sdf_err;

     Sdf_ty_slist               contact_addr_list;

    SipHeader                           *p_exp_hdr = SIP_NULL;
    icf_uint32_t                        tVal = 0;
    SipError                            sip_err;
    icf_error_t                         ecode;
#ifdef ICF_IPSEC_ENABLED
    icf_config_data_st                  *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
#endif
    /*Fix done for SPR-18722 : CSR-1-6068965*/
    icf_int8_t                         *p_content_type = ICF_NULL;
    icf_transport_address_st            self_addr ;
    

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    ICF_SSA_INIT_TRANS_ADDR(&self_addr)

    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))

    if(ICF_NULL == p_ssa_ctxt)
    {
        return ICF_FAILURE;
    }
    p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;
    /* DNS Lookup is not required while sending:
     * - De/REGSITER with credentials on getting challenge from 
     * Registrar
     */
    /* Set the bit indicating that this request is being sent on receiving 
     * 401/407. This will be used to make sure there is no name server refetch
     * needed.
     */
    ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->common_bitmask, ICF_SSA_NO_NAMESERVER_REFRESH)
    tVal = p_ssa_ctxt->p_rgm_ctxt->rgm_duration/1000;

        if (ICF_NULL == p_ssa_pdb->p_glb_cfg_data)
        {
            /* Request the DBM for getting pointer to config data structure */
            ret_val = icf_dbm_get_module_glb_data(
                p_ssa_pdb->p_glb_pdb,
                (icf_int_module_id_t)(ICF_INT_MODULE_CFG),
                (icf_void_t **)(&(p_ssa_pdb->p_glb_cfg_data)),
                p_ssa_pdb->p_ecode);     
            
            ICF_ASSERT(
                p_ssa_pdb->p_glb_pdb,
                (ICF_NULL != p_ssa_pdb->p_glb_cfg_data))
        }/* get pointer to global cfg data if NULL already */

   /*If per line self transport then copy address from line_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE ==
        p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                        sizeof(icf_transport_address_st));
    }
    else
    {
        icf_port_memcpy(&self_addr,
                        &(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                        sizeof(icf_transport_address_st));
    }
    

    /* Initialize the uac auth info list */
    ICF_MEMGET(
        p_ssa_pdb->p_glb_pdb,
    ICF_PORT_SIZEOF(Sdf_ty_slist),
    ICF_MEM_COMMON,
    p_uac_auth_info_list,
    ICF_RET_ON_FAILURE,
    p_ssa_pdb->p_ecode,
    ret_val)

    if (Sdf_co_fail == sdf_listInit(
                            p_uac_auth_info_list,
                            __sdf_fn_uaFreeUacAuthInfo,
                            Sdf_co_false,
                            &sdf_error))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {/* outermost else begins */
        for (index = 0; index < p_ssa_ctxt->auth_params_list_size; index++)
        {
            Sdf_st_authenticationParams     *p_auth_params = Sdf_co_null;
            Sdf_st_uacAuthInfo              *p_uac_auth_info = Sdf_co_null;
           
            /* get the auth param list element */ 
            if (Sdf_co_fail == sdf_listGetAt(
                                    p_ssa_ctxt->p_auth_params_list,
                                    index,
                                    (Sdf_ty_pvoid *)&p_auth_params,
                                    &sdf_error))
            {
                sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_uac_auth_info_list,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
                ret_val = ICF_FAILURE;
            }
            else if ((ICF_SUCCESS == ret_val) && 
                    (0 == Sdf_mc_strcasecmp(p_auth_params->pScheme, "Digest")))
            {/* scheme supported: begins */

                /* initialize uac auth info list element */
                if (Sdf_co_fail == 
                        sdf_ivk_uaInitUacAuthInfo(&p_uac_auth_info,pErr))
                {
                    sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_uac_auth_info_list,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                    ret_val = ICF_FAILURE;
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                    return ret_val;
                }
                if (ICF_FAILURE == icf_ssa_fill_uac_auth(p_ssa_pdb,
                                        p_uac_auth_info))
                {
                    sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_uac_auth_info_list,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                    ret_val = ICF_FAILURE;
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                    return ret_val;
                    
                }
                
            /* add the uac info element to list */
                if (Sdf_co_fail == sdf_listAppend(
                            p_uac_auth_info_list,
                            (Sdf_ty_pvoid)p_uac_auth_info,
                            pErr))
                {
                    sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_uac_auth_info_list,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                    ret_val = ICF_FAILURE;
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                    return ret_val;
                }
            } /* End if(p_auth_params->pScheme) */
            else
            {
                /* Authentication scheme not supported */
                sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_uac_auth_info_list,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
                ret_val = ICF_FAILURE;
                ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                return ret_val;
            } /* End else(p_auth_params->pScheme) */
        } /* End for(index) */

        /*
         * Now form a request with authorization. The list of
         * authentication params and uac auth info structures
         * are passed to this API
         */
        /* Set the transport mode in local variable */
        if (((ICF_TRANSPORT_TYPE_TCP == 
        p_ssa_pdb->p_ssa_ctxt->transport) ||
             (ICF_TRANSPORT_MODE_BOTH == 
                    p_ssa_pdb->p_ssa_ctxt->transport)) &&
              (ICF_NULL == (p_ssa_ctxt->bitmask & 
                               ICF_SSA_RGM_PREV_TRANS_TYPE_UDP)))
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
            icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->trans_param, (icf_uint8_t *)"TCP");
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
        }
#ifdef ICF_P_CSCF_DISCOVERY_ENABLED
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
/* We will net the transport mode to none for P-CSCF Discovery */
    icf_port_strcpy(proto,"");
ICF_CHECK_IMS_END
#endif
#endif


        if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                                p_ssa_ctxt->p_call_obj,
                                &p_overlap_trans_info,
                                "REGISTER",
                                &sdf_error))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/ 
            sdf_listDeleteAll(p_uac_auth_info_list, pErr);
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_uac_auth_info_list,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_ivk_uaSetTransportSchemeInTransaction(
                                    p_ssa_ctxt->p_call_obj->pUacTransaction,
                                    p_overlap_trans_info,
                                    proto,
                                    &sdf_error))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            sdf_listDeleteAll(p_uac_auth_info_list, pErr);
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_uac_auth_info_list,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            sdf_ivk_uaClearTransaction(
                    p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
            ret_val = ICF_FAILURE;
        }
#ifdef ICF_IPSEC_ENABLED
        /* If IPSec is enabled, set the port in Via and Contact headers to 
         * be the UE protected server port, for subsequent protected 
         * messages */
        else if ((ICF_TRUE == p_glb_cfg_data->ipsec_enabled) &&
            (ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context))
        {
        /* For Registration message, rgm ctxt would have been already 
        * copied in ssa pdb from ssa ctxt. 
            */
            if (ICF_NULL != 
                ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
                p_ue_security_params)
            {
                /* set the SA context in the SSA context */
                p_ssa_ctxt->ssa_sa_context.p_sa_context = 
                            ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
                p_ssa_ctxt->ssa_sa_context.p_rgm_context = 
                            p_ssa_ctxt->p_rgm_ctxt ;

                /* this means an SA exists */
                port_us = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
                    p_ue_security_params->port_s;
                
                    /* this code for getting p_transp_addr_str has been copied 
                    * from the function icf_ssa_process_open_nw_servers()
                */
                
                p_transport_address = &(self_addr);
                if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                    p_transport_address->addr.addr_type)
                {
                    icf_port_strcpy(p_transp_addr_str, 
                        p_transport_address->addr.addr.domain.str);
                }
                else if (ICF_TRANSPORT_ADDRESS_IPV4_ADDR == 
                    p_transport_address->addr.addr_type)
                {
                    icf_ssa_convert_to_IP_addr(p_transport_address,
                        p_transp_addr_str);
                }
#ifdef ICF_IPV6_ENABLED
                else if(ICF_TRANSPORT_ADDRESS_IPV6_ADDR == 
                    p_transport_address->addr.addr_type)
                {
                    icf_ssa_convert_to_IP_addr(p_transport_address,
                        p_transp_addr_str);
                    if( (0 == icf_port_strcmp("",p_transp_addr_str)) ||
                        (0 == icf_port_strcmp("::",p_transp_addr_str)))
                    {
                        ret_val = icf_ssa_get_and_populate_self_ip(
                            p_ssa_pdb,
                            p_transport_address,
                            p_transp_addr_str);
                    }
                }
#endif
                else
                {
                    /*Raise A Major Error here-SDF PROCESSING FAILURE*/
                    sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_uac_auth_info_list,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                        sdf_ivk_uaClearTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                    ret_val = ICF_FAILURE;
                }
                
                if (ICF_FAILURE != ret_val)
                {
                    Sdf_st_initData *pInitData = ICF_NULL;
                    sdf_ivk_uaGetInitDataFromCallObject(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj, 
                        &pInitData,
                        pErr);
                    
                    /* change the Via header in the default profile */
                    if (Sdf_co_fail == sdf_ivk_uaSetDefaultTransport(
                        pInitData,     
                        (Sdf_ty_s8bit *)p_transp_addr_str,
                        port_us,
                        &sdf_error))
                    {
                        /*Raise A Major Error here-SDF PROCESSING FAILURE*/
                        sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                        ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_uac_auth_info_list,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                            sdf_ivk_uaClearTransaction(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            p_overlap_trans_info,
                            "REGISTER",
                            Sdf_en_uacTransaction);
                        ret_val = ICF_FAILURE;
                    }
                    /* change the registrar IP and port also */
                  
                    reg_port = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
                        p_proxy_security_params->port_s;

                    /* copy the Registrar address locally */
                    if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                        p_ssa_pdb->p_line_data->registrar_addr.addr.addr_type)
                    {
                        icf_port_strcpy(reg_addr,
                            p_ssa_pdb->p_line_data->registrar_addr.addr.addr.domain.str);
                    }
                    else
                    {
                        icf_ssa_convert_to_IP_addr(
                            &(p_ssa_pdb->p_line_data->registrar_addr),
                            reg_addr);
                    }

                    proxy_port = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
                        p_proxy_security_params->port_s;

                    /* copy the Proxy address locally */
                    if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                        p_ssa_pdb->p_line_data->proxy_addr.addr.addr_type)
                    {
                        icf_port_strcpy(proxy_addr,
                            p_ssa_pdb->p_line_data->proxy_addr.addr.addr.domain.str);
                    }
                    else
                    {
                        icf_ssa_convert_to_IP_addr(
                            &(p_ssa_pdb->p_line_data->proxy_addr),
                            proxy_addr);
                    }

                    if (Sdf_co_fail == sdf_ivk_uaSetDefaultRegistrar(
                        pInitData,
                        reg_addr,
#ifndef ICF_DNS_LOOKUP_ENABLED
                        /* fix - default port 5060 should not go in header */
                        ((reg_port == 5060)?ICF_NULL:reg_port),
#else
                        reg_port,
#endif
                        &sdf_error))
                    {
                        sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                        ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_uac_auth_info_list,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                            sdf_ivk_uaClearTransaction(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            p_overlap_trans_info,
                            "REGISTER",
                            Sdf_en_uacTransaction);

                        sdf_ivk_uaClearTransaction(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            p_overlap_trans_info,
                            "REGISTER",
                            Sdf_en_uacTransaction);
                        ret_val = ICF_FAILURE;
                    }    
                    
                    
                    /* need to set the pre-loaded route set, so that
                     * subsequent Register goes to the peer protected
                     * server port. Thus we need to first delete the 
                     * existing route header value and then add the 
                     * desired route header in the otg Register
                     */
                    icf_ssa_checkNdeleteRouteHdr(p_ssa_pdb->p_ssa_ctxt->p_call_obj);

#ifdef ICF_SIGCOMP_SUPPORT
                    if(ICF_PEER_SUPPORTS_SIGCOMP == 
                        p_ssa_pdb->p_line_data->sigcomp_support_by_proxy)
                    {
                        if ( Sdf_co_fail == 
                            sdf_ivk_uaAddDefaultPreLoadedRoute(
                            pInitData,
                            Sdf_co_null,
                            proxy_addr,
                            proxy_port,
                            "lr;comp=sigcomp",/*pParam*/
                            ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)?"sips":"sip"),
                            &sdf_error))
                        {
                            /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                            ret_val = ICF_FAILURE;
                        }
                    }
                    else
                    {
                        if ( Sdf_co_fail == 
                            sdf_ivk_uaAddDefaultPreLoadedRoute(
                            pInitData,
                            Sdf_co_null,
                            proxy_addr,
                            proxy_port,
                            "lr",/*pParam*/
                            ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)?"sips":"sip"),
                            &sdf_error))
                        {
                            /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                            ret_val = ICF_FAILURE;
                        }
                        
                    }
#else
                    if(ICF_FAILURE == ret_val)
                    {
                        /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                        
                    }
                    else if ( Sdf_co_fail == 
                        sdf_ivk_uaAddDefaultPreLoadedRoute(
                        pInitData,
                        Sdf_co_null,
                        proxy_addr,
                        proxy_port,
                        "lr",/*pParam*/
                        "sip",
                        &sdf_error))
                    {
                        /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                        ret_val = ICF_FAILURE;
                    }
#endif
                    /* Free the local reference */
                    sdf_ivk_uaFreeInitData(pInitData);
                }
            }
        } /* End if(ipsec_enabled) */
#endif
        if ((ICF_SUCCESS == ret_val) && 
            (!(ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask)))
        {
        /* Register request which is not the initial one should 
        * not contain the to tag : So remove the to tag
            */
            Sdf_ty_u32bit dCount = 0;
            
            if(sip_getTagCountFromToHdr(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pCommonInfo->pTo,&dCount,\
                (SipError *)&(sdf_error.stkErrCode))==SipFail)
            {
                ret_val = ICF_FAILURE;
            }
            if (dCount != 0)
            {
                Sdf_ty_u32bit dIndex=0;
                for(dIndex=0;dIndex<dCount;dIndex++)
                {
                    if(sip_deleteTagAtIndexInToHdr(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pCommonInfo->pTo,
                        dIndex,\
                        (SipError *)&(sdf_error.stkErrCode))==SipFail)
                    {
                        ret_val = ICF_FAILURE;
                        break;
                    }
                }
            }
            
        }
    if ( ICF_FAILURE == ret_val)
    {
    }
    else if (ICF_FAILURE == icf_ssa_make_profile_for_reg(
             p_ssa_ctxt->p_call_obj->pInitData,            
             p_ssa_pdb))
         {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                sdf_ivk_uaClearTransaction(
                        p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
         }
        else if(sdf_ivk_uaAddExtraHeaders(p_ssa_ctxt->p_call_obj,
            p_overlap_trans_info,"REGISTER", \
            pErr) == Sdf_co_fail)
        {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                sdf_ivk_uaClearTransaction(
                        p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
            ret_val = ICF_FAILURE;
        }

        else if ((ICF_SUCCESS == ret_val) && 
            (Sdf_co_fail == sdf_ivk_uaFormRequestWithAuthorization(
                                    p_ssa_ctxt->p_call_obj,
                                    p_overlap_trans_info,
                                    "REGISTER",
                                    Sdf_co_false,
                                    p_ssa_ctxt->p_auth_params_list,
                                    p_uac_auth_info_list,
                                    pErr)))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE == icf_ssa_chk_n_append_auts(p_ssa_pdb,
                        p_overlap_trans_info))
        {/* If AUTS appending fails: end transaction */
            ret_val = ICF_FAILURE;
        }/* For IMS: AUTS added if present in auth_data_sent of rgm_context */    
        else
        {

           /*
            * The list of pAuthenticationParams and pUacAuthInfo are no longer
            * required and can be freed at this stage.
            */
            /*sdf_listDeleteAll(p_ssa_ctxt->p_auth_params_list, pErr);*/
            sdf_listDeleteAll(p_uac_auth_info_list, pErr);
            
            /* this should be freed in sdf_ivk_ua_FreeApplicationData */

            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_uac_auth_info_list,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
                
        }

        if (ret_val == ICF_FAILURE)
        {
            sdf_listDeleteAll(p_uac_auth_info_list, pErr);
            
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_uac_auth_info_list,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
                
            sdf_ivk_uaClearTransaction(
                p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "REGISTER",
                Sdf_en_uacTransaction);
            
            return ret_val;
        }

        else
        {
          /* ret_val : SUCCESS : Begins */

         /* Expire header addition */
                            
            if (ICF_FAILURE == sip_initSipHeader(
                        &p_exp_hdr, SipHdrTypeExpiresSec, &sip_err))
            {
                        sdf_ivk_uaClearTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                        ret_val = ICF_FAILURE;

                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                                        ICF_MEM_COMMON, &ecode, ret_val)
                        ret_val = ICF_FAILURE;
            }

            else if (ICF_FAILURE == sip_setSecondsInExpiresHdr(
                            p_exp_hdr, tVal, &sip_err))
            {
                        sdf_ivk_uaClearTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                        ret_val = ICF_FAILURE;

                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                                        ICF_MEM_COMMON, &ecode, ret_val)
                        sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
                        ret_val = ICF_FAILURE;
           }
           else if (ICF_FAILURE == sip_setHeader(
                          p_overlap_trans_info->pSipMsg, 
                          p_exp_hdr, &sip_err))
           {
                        sdf_ivk_uaClearTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                        ret_val = ICF_FAILURE;

                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                                        ICF_MEM_COMMON, &ecode, ret_val)
                        ret_val = ICF_FAILURE;
           }
           else
           {
               sip_freeSipHeader(p_exp_hdr);
               ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_exp_hdr,\
                                            ICF_MEM_COMMON, &ecode, ret_val)
           }
        }

    if ( ICF_FAILURE == ret_val)
    {
    }
    else if(0 == tVal)
        {
#if 1 /*ZySEL , Jason , [RD Internal] #347*/
            /* This is the case of sending 
             * Authenticated deregister request */

            /* CSR_1-8389294 changes start */
            if(ICF_TRUE == p_ssa_ctxt->p_rgm_ctxt->dereg_specific_contact)
            {
                if (Sdf_co_fail == sdf_listInit(
                &contact_addr_list,
                __sdf_fn_uaFreeCompleteHeader,
                Sdf_co_false,
                &sdf_error))
            {
                /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
                sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
                
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                    ICF_MEM_COMMON, &ecode, ret_val)
                    ret_val = ICF_FAILURE;
            }            
            else if(ICF_FAILURE == icf_ssa_make_contact_list_for_reg(
                p_ssa_pdb,
                &contact_addr_list))
            {
                sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
                
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                    ICF_MEM_COMMON, &ecode, ret_val)
                    ret_val = ICF_FAILURE;
            }
            else if(ICF_FAILURE == 
                icf_ssa_add_ContactHeaderToSipMsg(
                                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                                &contact_addr_list,p_overlap_trans_info,
                                &sdf_err))
            {
                sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
                
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                    ICF_MEM_COMMON, &ecode, ret_val)
                   ret_val = ICF_FAILURE;
            } 
			sdf_listDeleteAll(&contact_addr_list, pErr);
            }
            /* CSR_1-8389294 changes end */
            else
            {
                Sdf_ty_s8bit dContact[] = "Contact: *";
                if(sip_insertHeaderFromStringAtIndex(p_overlap_trans_info->pSipMsg,\
                    SipHdrTypeContactWildCard,dContact,(Sdf_ty_u32bit)0,\
                    (SipError *)&(pErr->stkErrCode))==SipFail)
                {
                    ret_val = Sdf_co_fail;
                }
            }
#else
			 /* This is the case of sending 
             * Authenticated deregister request */
            Sdf_ty_s8bit dContact[] = "Contact: *";
 
            if(sip_insertHeaderFromStringAtIndex(p_overlap_trans_info->pSipMsg,\
                SipHdrTypeContactWildCard,dContact,(Sdf_ty_u32bit)0,\
                (SipError *)&(pErr->stkErrCode))==SipFail)
            {
                ret_val = Sdf_co_fail;
            }   
#endif		
        }
        else
        {        
  
            if(ICF_FAILURE == ret_val)
            {
                
            }
            else if (Sdf_co_fail == sdf_listInit(
                &contact_addr_list,
                __sdf_fn_uaFreeCompleteHeader,
                Sdf_co_false,
                &sdf_error))
            {
                /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
                sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
                
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                    ICF_MEM_COMMON, &ecode, ret_val)
                    ret_val = ICF_FAILURE;
            }
            
            else if(ICF_FAILURE == icf_ssa_make_contact_list_for_reg(
                p_ssa_pdb,
                &contact_addr_list))
            {
                sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
                
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                    ICF_MEM_COMMON, &ecode, ret_val)
                    ret_val = ICF_FAILURE;
            }
            
            
            else if(ICF_FAILURE == 
                icf_ssa_add_ContactHeaderToSipMsg(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,&contact_addr_list,p_overlap_trans_info,&sdf_err))
            {
                sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
                
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                    ICF_MEM_COMMON, &ecode, ret_val)
                   ret_val = ICF_FAILURE;
            }
            sdf_listDeleteAll(&contact_addr_list, pErr);

        }/* If Tval is not 0 make the contact address */
        
        if ((ICF_FAILURE == ret_val)||
            (ICF_FAILURE == icf_ssa_add_rgm_app_data(
            p_ssa_pdb,p_overlap_trans_info)))
        {
            /* Error during addition of app_data tags/hdrs/msg bodies */
            ret_val = ICF_FAILURE;
            
        }
        /* To add the P-Access-Network Info header to the SipMsg */
    else if ((ICF_FAILURE == ret_val)||
            (ICF_FAILURE == icf_ssa_form_and_insert_access_nw_info_hdr(
            p_ssa_pdb,p_overlap_trans_info->pSipMsg)))
        {
            /* Error during addition of P-Access-Info Header */
            ret_val = ICF_FAILURE;
        }
        /* To move the added message bodies onto the SIP message */
    else
    {
        /*Message body header changes Start*/
        icf_get_content_type_from_msg_body(p_ssa_pdb,&p_content_type);    
              if ((ICF_FAILURE == ret_val)||\
            (ICF_FAILURE == icf_ssa_SetAllMsgBody(Sdf_co_null,\
             p_overlap_trans_info,(icf_int8_t *)p_content_type,&sdf_err)))
        {
            ret_val = ICF_FAILURE;
        }
        /*Message body header changes Ends*/
    }   
        
#ifdef ICF_IPSEC_ENABLED

    /* SSA needs to insert Security-Verify header in all REG requests except for
     * initial REG request */
    if ((!(ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask)) ||
        ((ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask) && 
         (ICF_RGM_ONCE_REGISTERED & p_ssa_pdb->p_rgm_context->indicator)))
    {
    /* if SA exists, all messages will go protected */
    if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled) &&
        /* if SA exits */
        (ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context))
    {
        icf_uint8_t            *p_value = ICF_NULL;

        /* insert Security Client Header */
        if (ICF_NULL != 
            ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_security_client_params)
        {
            if (ICF_FAILURE == icf_ssa_get_sec_client_string(
                                    p_ssa_pdb,
                                    &p_value, 
                                    ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_security_client_params))
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_FAILURE ==     
                icf_ssa_insert_unknown_hdr_in_sip_msg (p_ssa_pdb,
                (icf_uint8_t*)"Security-Client",
                p_value, 
                p_overlap_trans_info->pSipMsg ))
            {
                ICF_PRINT(("\nFailed to insert unknown header \
                    (Security-Client)"));
                ret_val = ICF_FAILURE;
            }

            if (ICF_SUCCESS == ret_val )
            {
                ICF_PRINT(("\nSecurity Client Header inserted to \
                                outgoing Register "));
            }
            if (ICF_NULL != p_value)
            {
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_value,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            }
        }

        /* insert security-verify header in the otg Register (with Auth) */
        if (ICF_FAILURE == icf_ssa_get_sec_verify_string(
                                p_ssa_pdb,
                                &p_value,
                                ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context))
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE ==     
          icf_ssa_insert_unknown_hdr_in_sip_msg (
              p_ssa_pdb,
              (icf_uint8_t*)"Security-Verify",
              p_value, 
              p_overlap_trans_info->pSipMsg))
        {
            ICF_PRINT(("\nFailed to insert unknown header \
                    (Security-Verify)"));
            ret_val = ICF_FAILURE;
        }
        if (ICF_NULL != p_value)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_value,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        }
        if (ICF_SUCCESS == ret_val )
        {
            ICF_PRINT(("\nSecurity Verify Header inserted to \
                            outgoing REGISTER with Auth "));
        }
    }
    }
#endif
            
        if(ICF_FAILURE != ret_val)
        {
            sip_options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;
            
#ifdef ICF_IPSEC_ENABLED
            p_ssa_pdb->p_sa_context =  ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
            p_ssa_pdb->p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;

            p_ssa_ctxt->ssa_sa_context.p_sa_context = 
                ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
            p_ssa_ctxt->ssa_sa_context.p_rgm_context = 
                p_ssa_ctxt->p_rgm_ctxt;
#endif
            /* Send request to peer */
         if (ICF_FAILURE == icf_ssa_send_to_peer(p_ssa_pdb,
                                        p_ssa_ctxt->p_call_obj,
                                        p_overlap_trans_info->pSipMsg,
                                        &sip_options,
                                        &sdf_error))
            {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                sdf_ivk_uaClearTransaction(
                        p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
            }
            else if (Sdf_co_fail == sdf_ivk_uaEndTransaction(
                        p_ssa_ctxt->p_call_obj,
                        Sdf_co_null,
                        "REGISTER",
                        &sdf_error))
            {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                sdf_ivk_uaClearTransaction(
                        p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
            }
        } /* End if */
    } /* outermost else  Ends  */

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;

} /* End of icf_ssa_send_register_req_with_auth() */

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_status_frm_notify
 * DESCRIPTION:     This function checks the given SipMessage for Fragmented
 *                  Sip body and then checks it for the response code
 *                  It returns TRUE if a 200 OK is found, FALSE if any non 2xx
 *                  is found or no message body is found at all
 ******************************************************************************/
icf_return_t icf_ssa_get_status_frm_notify(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT      SipMessage              *p_sip_message,
              OUT     icf_boolean_t        *p_status,
                OUT     icf_boolean_t        *p_indicate_service)

{
    icf_return_t         ret_val = ICF_SUCCESS;

    Sdf_st_error            sdf_error;
    SIP_U32bit              counter = 0,body_count = 0;


    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /*
     * Here I am setting the status as success, in the code below i will
     * check for presence of a non 2xx response in the sip message body.
     * if it is there then this status is changed to false.
     * In allother cases, that is when there is no sip message body ( there
     * could be otehr bodies), or the sip message body is there with 200 OK
     * we do not modify the status
     */
    *p_status = ICF_TRUE;

    /*This is a flag that will decide whether service is to be indicated of
     *this notify or not. This will be set to FALSE when the sip frag body
     *contains a provisional response*/

    *p_indicate_service=ICF_TRUE;

    if (SipFail == sip_getMsgBodyCount(p_sip_message, &body_count, 
                (SipError*)&(sdf_error.errCode)))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sip_getMsgBodyCount"));
        ret_val = ICF_FAILURE;
        *p_status = ICF_FALSE;
    }
    else
    {
        /*
         * If message body is absent,SSA sets the status as FALSE
         */
        if (ICF_NULL == body_count)
        {
            *p_status = ICF_FALSE;
        }
        for (counter = 0; counter < body_count; counter++)
        {
            /*Loop pver all the message bodies looking for sip fragmen body
             * Once that is found, extract the sip frag message, then get the
             * response code from sip frag message ad decide the status code 
             * value to be returned*/
            en_SipMsgBodyType  msg_body_type;
            if (SipFail == sip_getMsgBodyTypeAtIndex(p_sip_message,
                        &msg_body_type, counter,
                        (SipError*)&(sdf_error.errCode)))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sip_getMsgBodyTypeAtIndex"));
                ret_val = ICF_FAILURE;
                *p_status = ICF_FALSE;
                break;
            }
            else if (SipAppSipBody == msg_body_type)/*for SIP fragment*/
            {
                SipMsgBody      *p_sip_msg_body = SIP_NULL;
                SipMessage      *p_sip_frag_message = SIP_NULL;
                Sdf_ty_u16bit   frag_resp_code;
                /*
                 * Retreive the message  body so as to get access to 
                 * SipFragMessage in it
                 */
                if (SipFail == sip_getMsgBodyAtIndex(
                            p_sip_message, &p_sip_msg_body,
                            counter, (SipError*)&(sdf_error.errCode)))
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sip_getMsgBodyAtIndex"));
                    ret_val = ICF_FAILURE;
                    *p_status = ICF_FALSE;
                    break;
                }
                /*Now get the SipMessage Fragment from the SipMessageBody*/
                else if (SipFail == sip_getSipMessageFromMsgBody(p_sip_msg_body,
                            &p_sip_frag_message,
                            (SipError*)&(sdf_error.errCode)))
                {
                    sip_freeSipMsgBody(p_sip_msg_body);
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sip_getSipMessageFromMsgBody"));
                    ret_val = ICF_FAILURE;
                    *p_status = ICF_FALSE;
                    break;
                }
                /*Now get the response code from SipMessage Fragment*/
                else if (Sdf_co_fail == sdf_ivk_uaGetRespCodeFromSipMessage(
                            p_sip_frag_message,&frag_resp_code,&sdf_error))
                {
                    sip_freeSipMessage(p_sip_msg_body->u.pAppSipMessage);
                    sip_freeSipMsgBody(p_sip_msg_body);
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sdf_ivk_uaGetRespCodeFromSipMessage"));
                    ret_val = ICF_FAILURE;
                    *p_status = ICF_FALSE;
                    break;
                }
                else
                {
                    sip_freeSipMessage(p_sip_msg_body->u.pAppSipMessage);
                    sip_freeSipMsgBody(p_sip_msg_body);
                    if ((100 <= frag_resp_code)&&(199 >= frag_resp_code))
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:provisional response code in SipMessageFragment"));
                        *p_indicate_service = ICF_FALSE;
                    }

                    /*2XX should be treated as 200 OK*/
                    if (( 200 > frag_resp_code)||(299 < frag_resp_code))
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Non200 response code in SipMessageFragment"));
                        *p_status = ICF_FALSE;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }/*End of block for SipAppSipBody*/
    }/*End of for loop for traversing the message bodies*/

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/**********************************************************************
 * FUNCTION:        icf_ssa_get_div_count
 * DESCRIPTION:     This routine traverses the Route header structure 
 * slParam and looks for diversion counter. If it is not there
 * it set the default value from configuration into it
 **********************************************************************/
icf_return_t icf_ssa_get_div_count(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT      SipRouteHeader          *p_route_hdr,
        OUT     icf_diversion_info_st  *p_div_info)
{
    icf_return_t             ret_val = ICF_SUCCESS;

    Sdf_ty_u32bit           param_list_size = 0, count = 0;
    Sdf_st_error            sdf_error;
    SipParam                *p_sip_param = SIP_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (Sdf_co_fail == sip_listSizeOf(
                &(p_route_hdr->slParam),&param_list_size,\
                (SipError*)&(sdf_error.stkErrCode)))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureListSizeOf of Param in DivHdr"));
        return ICF_FAILURE;
    }
    for ( count = 0; count < param_list_size; count++)
    {
        if (Sdf_co_fail == sip_listGetAt(
                    &(p_route_hdr->slParam),
                    count,(Sdf_ty_pvoid *)&p_sip_param,\
                    (SipError*)&(sdf_error.stkErrCode)))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureListGetAt in Param for DivHdr"));
            ret_val = ICF_FAILURE;
        }
        else
        {
            if ( ICF_NULL ==
                    icf_port_strcmp((icf_uint8_t *)p_sip_param->pName,(icf_uint8_t *)"counter"))
            {/*Now we have to get the value string for counter
               and convert it to string. The values are also
               as a List of S8bit.  We will index into the list
               to get the first value ( index )*/
                SIP_S8bit       *p_counter_val = SIP_NULL;
                if (Sdf_co_fail == sip_listGetAt(
                            &(p_sip_param->slValue),0,
                            (Sdf_ty_pvoid *)&p_counter_val,\
                            (SipError*)&(sdf_error.stkErrCode)))
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureListGetAt for CounterVal"));
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    p_div_info->no_of_hops =
                        (icf_uint8_t )icf_port_atoi(p_counter_val);
                    break;
                }
            }
        }
        if ( ICF_FAILURE == ret_val)
        {
            break;
        }
    }
    if ((ICF_FAILURE != ret_val) &&
        param_list_size == count)
    {
        p_div_info->no_of_hops = 
            p_ssa_pdb->p_glb_cfg_data->max_num_of_call_forwarding_hops;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/**********************************************************************
 * FUNCTION:        icf_ssa_populate_div_hdr
 * DESCRIPTION:     This routine traverses the list of unknown headers
 *                  and extracts the diversion header(s) and populates 
 *                  the p_diversion_header_list field of the call context
 *                  on the basis of the diversion headers.
 *                  1.The diversion header(s) are parsed similarly to
 *                  the From header as the syntax of both are the same.
 *                  2. If there are multiple diversion headers,they are
 *                  appended to the p_diversion_header_list 
 *                  of call context.
 **********************************************************************/
icf_return_t icf_ssa_populate_div_hdr(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT    SipMessage              *p_sip_msg)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_diversion_info_st    *p_div_info = ICF_NULL;
    icf_diversion_data_st    *p_div_data = ICF_NULL;

    Sdf_st_error            sdf_error;
    Sdf_ty_u32bit           unp_hdr_list_size = 0, count = 0;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (Sdf_co_fail == sip_listSizeOf(
                &(p_sip_msg->
                    pGeneralHdr->slUnknownHdr),&unp_hdr_list_size,
                (SipError*)&(sdf_error.stkErrCode)))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Failure in getting size of UnknownHdrList"));
        return ICF_FAILURE;
    }
    for ( count = 0 ; count < unp_hdr_list_size; count++)
    {
        SipUnknownHeader    *p_unknown_hdr = SIP_NULL;
        if (Sdf_co_fail == sip_listGetAt(
                    &(p_sip_msg->
                        pGeneralHdr->slUnknownHdr),
                    count,(Sdf_ty_pvoid *)&p_unknown_hdr,
                    (SipError*)&(sdf_error.stkErrCode)))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Failure in getting the pHeader from list"));
            ret_val = ICF_FAILURE;
            break;
        }
        else if ( ICF_NULL ==
#ifdef ICF_WITH_MUATK_2_2
                icf_port_strcmp((icf_uint8_t *)p_unknown_hdr->pStr1, (icf_uint8_t *)"Diversion"))
#else
                icf_port_strcmp(p_unknown_hdr->pName, "Diversion"))
#endif
        {
            /*We will invoke the parseFromHeader API to get the Name, 
             * pAddrSpec and the parameter list*/
#ifdef ICF_WITH_MUATK_2_2
            SIP_S8bit       *p_start = p_unknown_hdr->pStr2;
#else
            SIP_S8bit       *p_start = p_unknown_hdr->pBody;
#endif
            SipError        sip_error;
            SipHeader  *p_route_hdr = SIP_NULL;


            if ( SipFail == 
                    sip_initSipHeader( 
                        &p_route_hdr, SipHdrTypeRoute, &sip_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Failure in Init of Sip Route Header"));
                ret_val = ICF_FAILURE;
                break;
            }
            else if (SIP_NULL == p_route_hdr)
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Failure in Init of Sip Route Header"));
                ret_val = ICF_FAILURE;
                break;
            }
            else
            {
                SipAddrSpec     *p_addr_spec = SIP_NULL;
                en_AddrType     addr_type;
                Sdf_ty_u32bit   buf_count = 0;
#ifdef ICF_WITH_MUATK_2_2
                buf_count=icf_port_strlen((icf_uint8_t *)p_unknown_hdr->pStr2);
#else
                buf_count=icf_port_strlen(p_unknown_hdr->pBody);
#endif
                if (SipFail == sip_parseFromHeader(
                            p_start, p_start+buf_count-1, p_route_hdr,
                            SipHdrTypeRoute, &sip_error))
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]: FailureInit of SipRouteHeader"));
                    sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_route_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE;
                    break;
                }
                else if(SipFail == sip_getAddrSpecFromRouteHdr(
                            p_route_hdr,&p_addr_spec, &sip_error))
                {
                    sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_route_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE;
                    break;
                }
                else if ( SipFail == sip_getAddrTypeFromAddrSpec(
                            p_addr_spec, &addr_type, &sip_error))
                {
                    sip_freeSipAddrSpec(p_addr_spec);
                    sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_route_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE;
                    break;
                }
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        ICF_PORT_SIZEOF(icf_diversion_data_st),
                        ICF_MEM_COMMON,
                        p_div_data,
                        ICF_DONOT_RET_ON_FAILURE,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                if (ICF_FAILURE == ret_val || ICF_NULL == p_div_data)
                {
                    sip_freeSipAddrSpec(p_addr_spec);
                    sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_route_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE;
                    break;
                }
                p_div_data->bitmask = ICF_NULL;
                p_div_data->p_next = ICF_NULL;

                if (SIP_NULL != 
#ifdef ICF_WITH_MUATK_2_2
                        ((SipRouteHeader*)(p_route_hdr->pHeader))->pStr1)
#else
                        ((SipRouteHeader*)(p_route_hdr->pHeader))->pDispName)
#endif
                {
                    icf_port_strcpy(p_div_data->diverted_frm_name.str, 
#ifdef ICF_WITH_MUATK_2_2
                            (icf_uint8_t *)((SipRouteHeader*)(p_route_hdr->pHeader))->pStr1);
#else
                            ((SipRouteHeader*)(p_route_hdr->pHeader))->pDispName);
#endif
                    p_div_data->diverted_frm_name.str_len = 
                        (icf_uint16_t)icf_port_strlen(p_div_data->
                                diverted_frm_name.str);

                    p_div_data->bitmask|=ICF_DIVERTERD_NAME_PRESENT;      
                }
                if(SipAddrSipUri == addr_type)
                {
                    SipUrl          *p_sip_url = SIP_NULL;
                    if(SipFail == sip_getUrlFromAddrSpec(
                                p_addr_spec, &p_sip_url, &sip_error))
                    {
                        sip_freeSipAddrSpec(p_addr_spec);
                        sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_route_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_div_data,ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                            ret_val = ICF_FAILURE;
                        break;
                    }
                    else
                    {
                        p_div_data->diverted_frm_addr.addr_type =
                            ICF_ADDRESS_PLAN_SIP_URI;
                        if(ICF_NULL != p_sip_url->pUser)
                        {
                        icf_port_strcpy(p_div_data->
                                diverted_frm_addr.addr_val.str,
                                (icf_uint8_t *)(p_sip_url->pUser));
                        icf_port_strcat((icf_uint8_t *)p_div_data->
                                diverted_frm_addr.addr_val.str,(icf_uint8_t *)"@");
                        }
                        icf_port_strcat(p_div_data->diverted_frm_addr.
                                addr_val.str,(icf_uint8_t *)p_sip_url->pHost);

                        if ( ICF_NULL != p_sip_url->dPort)
                        {
                            icf_uint8_t  p_div_hdr_port[6] = "\0";
                            icf_port_strcat((icf_uint8_t *)p_div_data->
                                diverted_frm_addr.addr_val.str,(icf_uint8_t *)":");
                            
                            icf_port_sprintf(
                                    (icf_int8_t *)p_div_hdr_port,"%d",
                                    *(p_sip_url->dPort));
                            icf_port_strcat(
                                    p_div_data->diverted_frm_addr.addr_val.str,
                                    p_div_hdr_port);
                        }
                        p_div_data->diverted_frm_addr.addr_val.str_len = 
                            (icf_uint16_t)icf_port_strlen(p_div_data->
                                    diverted_frm_addr.addr_val.str);
                        
                        sip_freeSipUrl(p_sip_url);
                    }
                }
                else
                    /*Assuming Tel URI*/
                {
                    SIP_S8bit   *p_sip_uri = SIP_NULL;
                    if (SipFail == sip_getUriFromAddrSpec (
                                p_addr_spec, &p_sip_uri, &sip_error))
                    {
                        sip_freeSipAddrSpec(p_addr_spec);
                        sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_route_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_div_data,ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                            ret_val = ICF_FAILURE;
                        break;
                    }
                    else
                    {
                        icf_uint8_t  *p_temp= ICF_NULL, 
                                        p_temp2[ICF_MAX_STR_LEN] = "\0",
                                        str[ICF_MAX_STR_LEN] = "\0";
                                        
                        p_div_data->diverted_frm_addr.addr_type =
                            ICF_ADDRESS_PLAN_TEL_URI;

                        icf_port_strcpy((icf_uint8_t *)str, (icf_uint8_t *)p_sip_uri);
                        p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)str,":");
                        if(ICF_NULL != p_temp)
                        {
                            p_temp = (icf_uint8_t *)icf_port_strtok(0,":");
                            if (ICF_NULL != p_temp)
                            {
                                icf_port_strcpy(p_temp2, p_temp);
                                if (' ' == p_temp2[0])
                                {
                                    p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)p_temp2, " ");
                                }

                                if(ICF_NULL != p_temp)
                                    icf_port_strcpy(
                                        p_div_data->diverted_frm_addr.addr_val.str,
                                        p_temp);
                            }
                            else
                            {
                                icf_port_strcpy(
                                    p_div_data->diverted_frm_addr.addr_val.str,
                                    str);
                            }
                            p_div_data->diverted_frm_addr.addr_val.str_len = 
                           (icf_uint16_t)icf_port_strlen(p_div_data->
                                    diverted_frm_addr.addr_val.str);
                        }
                    }
                }
                /* Reaching this point means that we have successfully
                 * retreived one diversion header, allocated memory
                 * for it, and populated it with SipPdu info*/
                /*Now we allocate the diversion information struct for Cctxt*/

                if ( ICF_NULL == 
                        p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list)
                {
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                            ICF_PORT_SIZEOF(icf_diversion_info_st),
                            ICF_MEM_COMMON, p_div_info,
                            ICF_DONOT_RET_ON_FAILURE,
                            p_ssa_pdb->p_ecode, ret_val);
                    if ( ICF_FAILURE == ret_val || ICF_NULL == p_div_info)
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:MemgetFailure for Div hdr"));
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_div_data,ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                            ret_val = ICF_FAILURE;
                        break;
                    }
                    p_div_info->no_of_diversion_data = 0;
                    p_div_info->no_of_hops = 0;
                    p_div_info->p_contact_addr = ICF_NULL;
                    p_div_info->p_contact_name = ICF_NULL;
                    p_div_info->p_diversion_data = ICF_NULL;
                    p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list = 
                        p_div_info;

                    if(ICF_FAILURE == 
                            icf_ssa_get_div_count( p_ssa_pdb,
                                (SipRouteHeader*)(p_route_hdr->pHeader),p_div_info))
                    {
                        sip_freeSipAddrSpec(p_addr_spec);
                        sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_route_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_div_data,ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                            ret_val = ICF_FAILURE;
                        break;
                    }
                }
                if (ICF_SUCCESS == ret_val)
                {
                    sip_freeSipAddrSpec(p_addr_spec);
                    sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_route_hdr,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                }

                if (ICF_NULL != p_div_info)
                {
                    ICF_SSA_ADD_DIV_DATA_TO_DIV_INFO(p_div_info,p_div_data)
                }
                /* Klocwork warning removal.*/ 
                else
                {
                   ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_div_data,ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                   ret_val = ICF_FAILURE;
                   break;                     
                }                
            }
        }/*Handling of unknonw header for "Diversion"*/
    }/*end of loop block for all the SipUnknownHeaders*/
    if ((ICF_FAILURE == ret_val) &&
            (ICF_NULL != 
             p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list) &&
         (ICF_NULL != p_div_info))
    {
        ICF_SSA_FREE_DIV_DATA_LIST(p_ssa_pdb, p_div_info)
        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_div_info,ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        ret_val = ICF_FAILURE;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_hostname_str_frm_trans_addr
 * DESCRIPTION:    This function returns the host name string corresponding
 *                 to the transport address passed to it. 
 ******************************************************************************/
icf_return_t icf_ssa_get_hostname_str_frm_trans_addr(
        icf_ssa_pdb_st       *p_ssa_pdb,
        icf_transport_address_st     *p_transp_addr,
        icf_uint8_t          *p_hostname)
{
    icf_return_t             ret_val = ICF_SUCCESS;

    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }
    
    p_ssa_pdb=p_ssa_pdb;
        
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)


    if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
            p_transp_addr->addr.addr_type)
    {
        icf_port_strcpy(p_hostname,
                p_transp_addr->addr.addr.domain.str);
    }
    else/*Assumption that it will be IPV4*/
    {
        icf_uint8_t remote_ip[16];

        if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                    p_transp_addr, remote_ip))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            icf_port_strcpy(p_hostname, remote_ip);
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_form_and_insert_div_hdr
 * DESCRIPTION:     This function forms and insert the diversion header
 *                  in the SIP message passed to it on the basis of the
 *                  p_diversion_header_list field of the call context.
 *                  1. One diversion header is added for every entry in 
 *                  the p_diversion_header_list.
 *                  2. These headers are added as Unknown headers as the
 *                  micro SIP stack doesn't recognize them.
 ******************************************************************************/
icf_return_t icf_ssa_form_and_insert_div_hdr(
        icf_ssa_pdb_st   *p_ssa_pdb,
        SipMessage      *p_otg_sip_msg)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_diversion_info_st            *p_div_info =
        p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list;
    icf_diversion_data_st            *p_div_data = ICF_NULL;
     icf_uint16_t            port_num=0;
    icf_uint8_t                      div_counter = 0,
                            addr_str[ICF_MAX_STR_LEN] = "\0", 
                                scheme[ICF_MAX_SIZE_INT_USAGE_STR] = "\0";

    SipHeader  *p_sip_header = SIP_NULL;
    SipUnknownHeader  *p_unknown_header = SIP_NULL;
    SipError        sip_error;
    icf_transport_address_st     self_addr ;
    
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Fix For SPR:19788*/
    if (ICF_NULL == p_div_info)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Diversion Info is not present"));
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;           
    }
    
    ICF_SSA_INIT_TRANS_ADDR(&self_addr)

    div_counter = p_div_info->no_of_hops;

    p_div_data = p_div_info->p_diversion_data;

    /*If per line self transport then copy address from line_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE == 
        p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                        sizeof(icf_transport_address_st));
    }
    else
    {
        icf_port_memcpy(&self_addr, 
                        &(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                        sizeof(icf_transport_address_st));
    }
    
    while ((ICF_NULL != p_div_data) && (ICF_SUCCESS == ret_val))
    {
        /* copy the display name */
        icf_port_strcpy(addr_str, (icf_uint8_t *)"\0");
        /* Check if bitmask for diversion name is present */
        if (ICF_DIVERTERD_NAME_PRESENT == 
           (ICF_DIVERTERD_NAME_PRESENT & p_div_data->bitmask))
        {
            icf_port_strcat(addr_str,p_div_data->diverted_frm_name.str);
        }           

        if (ICF_ADDRESS_PLAN_E164 == p_div_data->diverted_frm_addr.addr_type)
        {
            icf_uint8_t      hostname[ICF_MAX_STR_LEN];
            
            icf_port_strcat(addr_str, (icf_uint8_t *)"<sip:");
            icf_port_strcat(
                    addr_str, p_div_data->diverted_frm_addr.addr_val.str);
            
            if ( ICF_FAILURE == 
                    icf_ssa_get_hostname_str_frm_trans_addr(p_ssa_pdb, 
                        &(self_addr),
                        hostname))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in address conversion"));
                ret_val = ICF_FAILURE; 
            }
            else
            {
                if ( ICF_NULL != icf_port_strcmp(hostname,(icf_uint8_t *) "0.0.0.0"))
                {
                    icf_port_strcat(addr_str, (icf_uint8_t *)"@");
                    icf_port_strcat(addr_str, hostname);
                    port_num = self_addr.port_num;
                    icf_port_strcpy(scheme, (icf_uint8_t *)"sip");
                }
                else
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Self IP not configured"));
                    ret_val = ICF_FAILURE; 
                }
            }
        }/*E164 handling ends*/
        else if (ICF_ADDRESS_PLAN_SIP_URI == 
                p_div_data->diverted_frm_addr.addr_type)
        {
            icf_uint8_t      *p_temp= ICF_NULL, 
                                host_name[ICF_MAX_STR_LEN] = "\0",
                                str[ICF_MAX_STR_LEN] = "\0",
                                user_name[ICF_MAX_STR_LEN] = "\0";

            icf_port_strcat(addr_str, (icf_uint8_t *)"<sip:");
            icf_port_strcpy(str, p_div_data->diverted_frm_addr.addr_val.str);
            p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)str,"@");
            if(ICF_NULL != p_temp)
            {
                icf_port_strcpy(user_name, p_temp);
                p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)0,":");
                if ( ICF_NULL == p_temp)
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:InvalidDivertedFromAddress"));
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    icf_port_strcpy(host_name, p_temp);
                        p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)0,":");
                    if (ICF_NULL != p_temp)
                    {
                        port_num = (icf_uint16_t)icf_port_atoi((const icf_int8_t *)p_temp);
                    }
                    icf_port_strcat(addr_str, user_name);
                    icf_port_strcat(addr_str, (icf_uint8_t *)"@");
                    icf_port_strcat(addr_str, host_name);
                    icf_port_strcpy(scheme, (icf_uint8_t *)"sip");
                    }
            }
            else
            {
                ret_val = ICF_FAILURE;
            }
        }
        else if (ICF_ADDRESS_PLAN_TEL_URI == 
                p_div_data->diverted_frm_addr.addr_type)
        {
            icf_port_strcat(addr_str, (icf_uint8_t *)"<tel:");
            icf_port_strcat(
                    addr_str, p_div_data->diverted_frm_addr.addr_val.str);
            icf_port_strcpy(scheme, (icf_uint8_t *)"tel");
            port_num = 0;
        }
        else
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Invalid Address type for DiversionInfo"));
            return ICF_FAILURE;
        }

        /*Data from IPPHONE DB collated, now we fill the SIP UATK
         * constructs*/
        if ( ICF_FAILURE != ret_val)
        {
            if(SipFail == 
                    sip_initSipHeader(
                        &p_sip_header, SipHdrTypeUnknown, &sip_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failed to init unknown Sip header"));
                return ICF_FAILURE;
            }
            else if (ICF_NULL == p_sip_header)
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failed to init unknown Sip header"));
                return ICF_FAILURE;
            }
            else
            {
                icf_uint16_t      size;
                p_unknown_header = (SipUnknownHeader*)(p_sip_header->pHeader);
                /*Get the memory for "Diversion" string.
                 * This will be assigned to the pName pointer
                 * in the Unknown header body.  The memory will
                 * be freed when the header is freed on invocationof
                 * freeSipHeader API*/
#ifdef ICF_WITH_MUATK_2_2
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        10,/*size of "Diversion" +1 */
                        ICF_MEM_COMMON,
                        p_unknown_header->pStr1,
                        ICF_DONOT_RET_ON_FAILURE,
                        p_ssa_pdb->p_ecode,
                        ret_val)
#else
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        10,/*size of "Diversion" +1 */
                        ICF_MEM_COMMON,
                        (icf_void_t *)
                        p_unknown_header->pName,
                        ICF_DONOT_RET_ON_FAILURE,
                        p_ssa_pdb->p_ecode,
                        ret_val)
#endif
                if ( ICF_FAILURE == ret_val)
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Memget failure for Diversion"));
                    sip_freeSipHeader(p_sip_header);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_sip_header,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    icf_uint8_t  counter_str[4] = "\0";

                    /* SPR 19121: Populate the counter string first and calculate the
                     * size of diversion header string using the lenght of counter_str
                     */
                    icf_port_sprintf((icf_int8_t *)counter_str,"%d",div_counter);
                    icf_port_strcat(addr_str, (icf_uint8_t *)">");
#ifdef ICF_WITH_MUATK_2_2
                    icf_port_strcpy( (icf_uint8_t *)p_unknown_header->pStr1,(icf_uint8_t *)"Diversion");
#else
                    icf_port_strcpy( p_unknown_header->pName,"Diversion");
#endif
                    /* SPR 19121 : The magic number 13 was used with the assumption that
                     * the hop counter will be of single digit. Since there is no such
                     * restriction, therfore strlen of counter_str is used to caluculate
                     * the size of diversion header value.
                     */
                    size = (icf_uint8_t)(icf_port_strlen(addr_str) +
                           icf_port_strlen(counter_str) +
                        12)/* ";counter:<1spce><2bytes>,1byte for newline*/;
                    if ( ICF_MAX_STR_LEN < size)
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:max diversion str size exceeded!!"));
                        sip_freeSipHeader(p_sip_header);
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_sip_header,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                        ret_val = ICF_FAILURE;
                    }
                    else
                    {
#ifdef ICF_WITH_MUATK_2_2
                        ICF_MEMGET(p_ssa_pdb->p_glb_pdb,size,
                                ICF_MEM_COMMON,
                                p_unknown_header->pStr2,
                                ICF_DONOT_RET_ON_FAILURE,
                                p_ssa_pdb->p_ecode,
                                ret_val)
#else
                        ICF_MEMGET(p_ssa_pdb->p_glb_pdb,size,
                                ICF_MEM_COMMON,
                                (icf_void_t *)(p_unknown_header->pBody),
                                ICF_DONOT_RET_ON_FAILURE,
                                p_ssa_pdb->p_ecode,
                                ret_val)
#endif
                        if ( ICF_FAILURE == ret_val)
                        {
                            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Memget failure for Diversion"));
                            sip_freeSipHeader(p_sip_header);
                            ICF_MEMFREE(
                                    p_ssa_pdb->p_glb_pdb,
                                    p_sip_header,
                                    ICF_MEM_COMMON,
                                    p_ssa_pdb->p_ecode,
                                    ret_val)
                            ret_val = ICF_FAILURE;
                        }
                        else
                        {
                            SIP_U32bit  hdr_index = 0;

#ifdef ICF_WITH_MUATK_2_2
                            icf_port_memset(
                                    (icf_void_t *)(p_unknown_header->pStr2),
                                    0, size);
                            
                            icf_port_strcat((icf_uint8_t *)p_unknown_header->pStr2,
                                    (icf_uint8_t *)addr_str);
                            icf_port_strcat((icf_uint8_t *)p_unknown_header->pStr2,
                                    (icf_uint8_t *)";counter= ");
                            icf_port_strcat((icf_uint8_t *)p_unknown_header->pStr2,
                                    (icf_uint8_t *)counter_str);
                            p_unknown_header->pStr2[size-1]='\n';
#else
                            icf_port_memset(
                                    (icf_void_t *)(p_unknown_header->pBody),
                                    0, size);
                            
                            icf_port_strcat(p_unknown_header->pBody,
                                    addr_str);
                            icf_port_strcat(p_unknown_header->pBody,
                                    ";counter= ");
                            icf_port_strcat(p_unknown_header->pBody,
                                    counter_str);
                            p_unknown_header->pBody[size-1]='\n';
#endif                
                            sip_getHeaderCount(
                                        p_otg_sip_msg,
                                        SipHdrTypeUnknown,
                                        &hdr_index,&sip_error);
                            
                            if (SipFail == sip_insertHeaderAtIndex(
                                        p_otg_sip_msg,p_sip_header,
                                        hdr_index,&sip_error))
                            {
                                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure Diversion Header List Append"));
                                sip_freeSipHeader(p_sip_header);
                                ICF_MEMFREE(
                                        p_ssa_pdb->p_glb_pdb,
                                        p_sip_header,
                                        ICF_MEM_COMMON,
                                        p_ssa_pdb->p_ecode,
                                        ret_val)
                                ret_val = ICF_FAILURE;
                            }
                            else
                            {
                                sip_freeSipHeader(p_sip_header);
                                ICF_MEMFREE(
                                        p_ssa_pdb->p_glb_pdb,
                                        p_sip_header,
                                        ICF_MEM_COMMON,
                                        p_ssa_pdb->p_ecode,
                                        ret_val)
                            }
                        }
                    }/*memget for unknown jdr body successful*/
                }
            }/*Instance of Unknown Header Init successfully*/
        }
        p_div_data = p_div_data->p_next;
        div_counter--;
    }/*loop for the different Diversion Data instances*/
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_populate_address_from_sip_addr_spec
 ** DESCRIPTION:  This function populates the icf_address_st structure
 **               from the SipAddrSpec structure passed to it
 **               
 **
 ***************************************************************************/
icf_return_t icf_ssa_populate_address_from_sip_addr_spec(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT SipAddrSpec            *p_sip_addr_spec,
        INOUT  icf_address_st   *p_addr)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    SipError                            sip_error;
    icf_uint16_t                     addr_val_len = 0;    

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb);
/* Patch taken for BUG-947 CERT */    
  	if(ICF_NULL == p_sip_addr_spec)
	{
		ret_val = ICF_FAILURE;
    	ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
	    return ret_val;
	}
    icf_port_strcpy(p_addr->addr_val.str,(icf_uint8_t *)"");

    if ((p_sip_addr_spec->dType == SipAddrSipUri) || \
        (p_sip_addr_spec->dType == SipAddrSipSUri))
    /* Address is a SIP Uri, so more dissection */
    {
        SipUrl *pSipUrl = p_sip_addr_spec->u.pSipUrl;

        if (p_sip_addr_spec->dType == SipAddrSipUri)
        {
            /* Populate the addr type */
            p_addr->addr_type = 
                ICF_ADDRESS_PLAN_SIP_URI ;
        }
        else
        {

                      if(ICF_NULL == p_ssa_pdb->p_glb_cfg_data->p_tls_init_data)
                       {
                             p_ssa_pdb->p_ssa_ctxt->failure_bitmask |=
                                    ICF_SSA_FAILURE_RESP_CODE_416;
                             ret_val = ICF_FAILURE;
                       }
                       else    
                       {
                /* Populate the addr type */
                p_addr->addr_type = 
                    ICF_ADDRESS_PLAN_SIPS_URI ;
               }
        }
                              
		/* ARICENT_BLR fix for CERT bug 945 to avoid overflow in strcat  -start */
		if(ICF_NULL != pSipUrl->pUser)
                	addr_val_len = (icf_uint16_t)(addr_val_len + icf_port_strlen((icf_uint8_t *)pSipUrl->pUser) +1);
		if(SIP_NULL != pSipUrl->pPassword)
			addr_val_len = (icf_uint16_t)(addr_val_len + icf_port_strlen((icf_uint8_t *)pSipUrl->pPassword) +1);
		if(ICF_NULL != pSipUrl->pHost)
			addr_val_len  = (icf_uint16_t)(addr_val_len + icf_port_strlen((icf_uint8_t *)pSipUrl->pHost));
		if(SIP_NULL != pSipUrl->dPort)
			addr_val_len += 7;
                if (ICF_FALSE == p_ssa_pdb->addr_param_not_reqd)
                 {
                     if(SIP_NULL != pSipUrl->pHeader)
                         addr_val_len = (icf_uint16_t )(addr_val_len + icf_port_strlen((icf_uint8_t *)pSipUrl->pHeader) +1);
                 } 
        if(addr_val_len >= ICF_MAX_STR_LEN)
      	{
                p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= ICF_SSA_FAILURE_RESP_CODE_414;
   	        ret_val = ICF_FAILURE;
           	ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
           	return ret_val;
       	}
		else
		{
			
			/* 
			 * Check if the parameters present in the URL do not cause the length to 
			 * exceed.
			 */
			SIP_U32bit	listIter = 0;
			SIP_U32bit	listSize = 0;

			(void)sip_listSizeOf(&pSipUrl->slParam, &listSize, &sip_error);
			listIter = 0;
			while (listIter < listSize)
			{
				SipParam		*pParam;
				SIP_U32bit		valueSize;
				SIP_S8bit		*value;
				SIP_U32bit		valueIter=0;

				(void)sip_listGetAt(&pSipUrl->slParam, listIter, (SIP_Pvoid *)&pParam, &sip_error);
				if (listIter!=0)
					addr_val_len += 1;
		
				addr_val_len = (icf_uint16_t)(addr_val_len + icf_port_strlen((icf_uint8_t *)pParam->pName));
				sip_listSizeOf( &(pParam->slValue), &valueSize, &sip_error);

				if (valueSize >= 1)
				{
					(void)sip_listGetAt(&(pParam->slValue), valueIter, \
					(SIP_Pvoid *) &value, &sip_error);
					if (value != SIP_NULL)
					{
						addr_val_len += 1;
						while (valueIter < valueSize)
						{
							if (valueIter > 0)
								addr_val_len += 1;
							(void)sip_listGetAt(&(pParam->slValue), valueIter, \
							(SIP_Pvoid *) &value, &sip_error);
							addr_val_len = (icf_uint16_t)(addr_val_len + icf_port_strlen((icf_uint8_t *)value));
							valueIter++;
						}
					}
				}
				listIter++;
		        if(addr_val_len >= ICF_MAX_STR_LEN)
		      	{
		   	        p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= ICF_SSA_FAILURE_RESP_CODE_414;  
                                ret_val = ICF_FAILURE;
		           	ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
		           	return ret_val;
		       	}
			} /* while */
		} /* else */
        /* ARICENT_BLR fix for CERT bug 945 -end */

        if( ICF_NULL != pSipUrl->pUser)
        {
            Sdf_ty_s8bit dHexConvertedName1[Sdf_co_smallBufferSize];
            (void)sdf_fn_uaConvertHexEncodedString(pSipUrl->pUser, dHexConvertedName1,\
                   Sdf_co_smallBufferSize);
            icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)p_addr->addr_val.str,
                              (icf_uint8_t *)dHexConvertedName1);

            if (pSipUrl->pPassword != SIP_NULL)
            {
                icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)p_addr->addr_val.str,
                        (icf_uint8_t *)(SIP_S8bit*)":");
                icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)p_addr->addr_val.str,
                        (icf_uint8_t *)pSipUrl->pPassword);
            }

            icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)p_addr->addr_val.str,
                    (icf_uint8_t *)(SIP_S8bit*)"@");
        }

        icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)p_addr->addr_val.str,
                (icf_uint8_t *)pSipUrl->pHost);

        /* see if its pHost or pHost:dPort */
        if (pSipUrl->dPort != SIP_NULL)
        {
            SIP_S8bit porttext[6]={0}; /* max val of dPort = 65535 */
            porttext[0]='\0';
            icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)p_addr->addr_val.str,
                    (icf_uint8_t *)(SIP_S8bit*)":");
            sip_snprintf((SIP_S8bit *)porttext, 6, "%u", *(pSipUrl->dPort) );
            porttext[5]='\0';
            icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)p_addr->addr_val.str,(icf_uint8_t *)porttext);
        }

        sip_formSipParamList((SIP_S8bit *)p_addr->addr_val.str, &(pSipUrl->slParam), \
                (SIP_S8bit *)";",1, &sip_error);
       if (ICF_FALSE == p_ssa_pdb->addr_param_not_reqd)
        {
            /* Now parse Header */
            if (pSipUrl->pHeader !=SIP_NULL)
            {
                icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)p_addr->addr_val.str,
                        (icf_uint8_t *)(SIP_S8bit*)"?");
                icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)p_addr->addr_val.str,
                         (icf_uint8_t *)pSipUrl->pHeader);
            }
        }
        p_ssa_pdb->addr_param_not_reqd = ICF_FALSE;
       
    } /*End of if (ch->pAddrSpec->dType == SipAddrSipUri/SipAddrSipSUri) */
    else
    {
        /* Check whether addr type is TEL */
        if(SipFail != sip_isTelUrl(
                    p_sip_addr_spec,&sip_error))
        {
            icf_uint8_t *p_tel_uri =
                            (icf_uint8_t *)(p_sip_addr_spec->u.pUri+icf_port_strlen((icf_uint8_t *)"tel:"));
        
            /* Populate the addr type */
            p_addr->addr_type = 
                ICF_ADDRESS_PLAN_TEL_URI;
            /* Copy the entire URI after tel:*/
            icf_port_strcpy(
                p_addr->addr_val.str,p_tel_uri);
        }
        else
        {
            /*Address Type cannot be identified here */
            /* Populate the addr type */
            p_addr->addr_type = 
                ICF_ADDRESS_PLAN_UNDEFINED;
            /* Copy the entire URI */
            icf_port_strcpy(
                (icf_uint8_t *)p_addr->addr_val.str,
                (icf_uint8_t *)p_sip_addr_spec->u.pUri);
        }
    }
     p_addr->addr_val.str_len =
                (icf_uint16_t )icf_port_strlen(
                p_addr->addr_val.str);

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_form_and_insert_ref_by_hdr
 ** DESCRIPTION:  This function forms and inserts a referred by header 
 **               in the SipMsg passed to it
 **
 ***************************************************************************/

icf_return_t icf_ssa_form_and_insert_ref_by_hdr(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  SipMessage          *p_sip_msg)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_address_st           *p_icf_address = ICF_NULL;
    icf_uint8_t              ref_by_addr_str[ICF_MAX_STR_LEN];
    icf_config_data_st       *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    icf_call_ctx_st          *p_call_ctxt = 
                                    p_ssa_pdb->p_glb_pdb->p_call_ctx;
    icf_transport_address_st    *p_icf_trans_addr = ICF_NULL;

    Sdf_ty_u16bit               port_num_to_be_set = 0;
    SipHeader                   *p_referred_by_hdr = SIP_NULL;
    SipError                    sip_error;
    Sdf_ty_s8bit                tpt_scheme[ICF_MAX_STR_LEN];
    SipAddrSpec                 *p_addr_spec = SIP_NULL;
    Sdf_st_error                sdf_error;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Get the pointer to referred by party addr */
    p_icf_address = p_call_ctxt->p_referred_party_addr;
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
            (ICF_NULL != p_icf_address))

    icf_port_strcpy(ref_by_addr_str,
            p_call_ctxt->p_referred_party_addr->addr_val.str);

    if ( (ICF_ADDRESS_PLAN_SIP_URI == 
                p_icf_address->addr_type) ||
            (ICF_ADDRESS_PLAN_E164 ==
             p_icf_address->addr_type))
    {
        icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"sip");
    }
    else if (ICF_ADDRESS_PLAN_TEL_URI == 
            p_icf_address->addr_type)
    {
        icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"tel");
    }

    /*
     * If referred by party addr_type is E164,
     * append the self ip adress 
     * to make it a SIP URI
     */
    if ( ICF_ADDRESS_PLAN_E164 == p_icf_address->addr_type)
    {
       /*If per line self transport then copy address from line_data*/
       if (ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
       {
           p_icf_trans_addr = &(p_ssa_pdb->p_line_data->self_addr);
       }
       else
       {    
           p_icf_trans_addr = &(p_glb_cfg_data->self_ip_address);
       }
        if ( ICF_FAILURE == 
                icf_ssa_form_sip_uri_frm_e164(
                    p_ssa_pdb, ref_by_addr_str, 
                    p_icf_trans_addr,&port_num_to_be_set))
        {
            ret_val = ICF_FAILURE;
        }
    }/*Formation of SIP URI from E164 ends here*/

    /* Set reffered by header */
    if (Sdf_co_fail == sdf_ivk_uaMakeAddrSpecFromConstituents(
                &p_addr_spec,
                (icf_int8_t *)ref_by_addr_str,
                port_num_to_be_set,
                (icf_int8_t *)tpt_scheme,
                &sdf_error))
    {
        /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
    else if(SipFail == sip_initSipHeader(
                (SipHeader**)(&p_referred_by_hdr),
                SipHdrTypeReferredBy,\
                (SipError*)(&sip_error)))
    {
        /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
    else if ( SipFail == sip_setReferrerInReferredByHdr(
                p_referred_by_hdr,
                p_addr_spec, (SipError *)(&sip_error)))
    {
        /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
    /*
     * As there is no bitmask to identify the presence of
     * refered by party name,we are checking whether
     * the pointer is NULL
     */
    if ( (ICF_FAILURE != ret_val) &&
            (ICF_NULL != p_call_ctxt->p_referred_party_name))
    {
        if (SipFail == sip_setDispNameInReferredByHdr(
                    p_referred_by_hdr,
                    Sdf_mc_strdupCT((const icf_int8_t *)p_call_ctxt->p_referred_party_name->str),
                    (SipError *)(&sip_error)))
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
            /*we are not freeing the header here as that is done
             * while exiting this routine. So no direct return calls
             * are to be added in this code.*/
        }
    }
    /*This Free is to be hit whether some opeartion above succeeded
     * or failed*/
    if (SipFail == sip_insertHeaderAtIndex(
                p_sip_msg,p_referred_by_hdr,
                0,&sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure Referred By Header List Append"));
        ret_val = ICF_FAILURE;
    }
    /* Now free the header and the addr spec memory */
    sip_freeSipAddrSpec(p_addr_spec);
    /*
     * The SipHeader structure contains 2 fields,one being the
     * type of header and second being a void pointer
     * The call to sip_freeSipHeader fress the memory corresponding
     * to the specific header according to the type but
     * doesn't free the top level structure.
     * Hence,invoke a memfree on the top level structure
     */
    if (SIP_NULL != p_referred_by_hdr)
    {
        sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_referred_by_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_form_and_insert_replaces_hdr
 * DESCRIPTION:  This function forms and inserts a Replaces header 
 *               in the SipMsg passed to it
 *               1. Invoke the sdf_ivk_uaFormReplacesHeader header
 *               with replaces callid,from tag and to tag stored in 
 *               call context.
 *               2. Insert the header into the SIP message
 ***************************************************************************/

icf_return_t icf_ssa_form_and_insert_replaces_hdr(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  SipMessage          *p_sip_msg)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_call_ctx_st          *p_call_ctxt = 
                                     p_ssa_pdb->p_glb_pdb->p_call_ctx;

    SipHeader                   *p_replaces_hdr = SIP_NULL;
    SipError                    sip_error;
    Sdf_st_error                sdf_error;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
            (ICF_NULL != p_call_ctxt->p_replaces_header))

    /*
     * Invoke sdf_ivk_uaFormReplacesHeader with
     * call object pointer as NULL as we want to form
     * the Replaces header with the call id ,from tag and
     * to tag stored in the call context
     */
    if (Sdf_co_fail ==sdf_ivk_uaFormReplacesHeader (
                Sdf_co_null,
                Sdf_mc_strdupSdp(
                 (const icf_int8_t *)p_call_ctxt->p_replaces_header->replace_nw_call_id.nw_call_id),
                Sdf_mc_strdupSdp(
            (const icf_int8_t *)p_call_ctxt->p_replaces_header->to_tag.str),
                Sdf_mc_strdupSdp(
                        (const icf_int8_t *)p_call_ctxt->p_replaces_header->from_tag.str),
                &p_replaces_hdr,
                &sdf_error))
    {
        /*Set/RaiseError:UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == sip_insertHeaderAtIndex(
                p_sip_msg,p_replaces_hdr,
                0,&sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure Replaces header Header List Append"));
        ret_val = ICF_FAILURE;
    }
    /*
     * The SipHeader structure contains 2 fields,one being the
     * type of header and second being a void pointer
     * The call to sip_freeSipHeader fress the memory corresponding
     * to the specific header according to the type but
     * doesn't free the top level structure.
     * Hence,invoke a memfree on the top level structure
     */
    if (SIP_NULL != p_replaces_hdr)
    {
        sip_freeSipHeader(p_replaces_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_replaces_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_form_and_send_response
 * DESCRIPTION:  This function forms and sends a response to peer
 *               1. The response code is passes as a paramter   
 *               2. If p_overlap_txn is not null, the response is made
 *               on the overlap transaction,else on the UAS transaction
 *               3.Invoke icf_ssa_send_to_peer
 ***************************************************************************/

icf_return_t icf_ssa_form_and_send_response(
        INOUT  icf_ssa_pdb_st         *p_ssa_pdb,
        INOUT    icf_uint16_t           resp_code,
        INOUT  Sdf_st_callObject         *p_call_obj,
        INOUT  Sdf_st_overlapTransInfo   *p_overlap_txn,
        INOUT    Sdf_ty_s8bit              *p_method,
        INOUT    Sdf_ty_bool               rel_resp)
{
    Sdf_st_error            sdf_error;
    SipOptions                dOptions ;
    SipMessage              *p_sip_msg = Sdf_co_null;

    icf_return_t         ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (Sdf_co_fail == sdf_ivk_uaFormResponse(
                resp_code,p_method,p_call_obj,p_overlap_txn,
                rel_resp, &sdf_error))
    {
        ret_val = ICF_FAILURE ;
    }
    else
    {
        if (Sdf_co_null == p_overlap_txn)
        {
            p_sip_msg = p_call_obj->pUasTransaction->pSipMsg;
        } /* if (Sdf_co_null == p_overlap_t... */
        else
        {
            p_sip_msg = p_overlap_txn->pSipMsg;
        }
        /* 
         * Specify the stack options
         * SIP_OPT_CLEN : A Content-Length header with the 
         * correct length is inserted in the message being
         * formed.
         * SIP_OPT_FULLFORM : All header names will appear
         * in full.
         */
        dOptions.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;
        /* 
         * This API is used to send a message to the 
         * peer entity
         */
     if (ICF_FAILURE == icf_ssa_form_and_insert_unknown_hdr(
                    p_ssa_pdb,(icf_uint8_t *)"User-Agent",
                    p_ssa_pdb->p_ssa_glb_data->user_agent_str.str,
                    p_sip_msg))
        {
            ret_val = ICF_FAILURE ;
        }
        else if (ICF_FAILURE == icf_ssa_send_to_peer(p_ssa_pdb,
                    p_call_obj,
                    p_sip_msg,&dOptions,&sdf_error))
        {
            ret_val = ICF_FAILURE ;
        }
         /* If Notify received was out of dialog then reset the bitmask in ssa ctxt
         * and invoke API for freeing call object.
         */  
        if (p_ssa_pdb->p_ssa_ctxt->bitmask_1 & ICF_MSG_RECVD_OUT_OF_DIALOG)
        {
           p_ssa_pdb->p_ssa_ctxt->bitmask_1 &= ~(ICF_MSG_RECVD_OUT_OF_DIALOG);
           sdf_ivk_uaFreeCallObject(&p_call_obj); 
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
       
/*****************************************************************************
 ** FUNCTION:        icf_ssa_formStatusLineMessage
 ** 
 ** DESCRIPTION:    This function forms SipResponseMessage only with StatusLine
 **
 *****************************************************************************/
icf_return_t icf_ssa_formStatusLineMessage(
        INOUT  SipMessage    **p_p_sip_msg,
        INOUT    Sdf_ty_u16bit    resp_code,
        INOUT  Sdf_st_error    *pError)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    
    Sdf_ty_s8bit            *pReason=Sdf_co_null,*pTmpVal=Sdf_co_null;
    SipStatusLine            *pStatLine=Sdf_co_null;

    sdf_fn_uaGetReasonFromTable(resp_code, &pReason, pError);
    pTmpVal = Sdf_mc_strdupCallHandler("SIP/2.0");

    /*got from the global table */
    
    if (SipFail == sip_initSipMessage(
                p_p_sip_msg, SipMessageResponse,
                (SipError *)&(pError->stkErrCode)))
    {
        sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&pReason,pError);
        ret_val = ICF_FAILURE ;
    }
    /* Setting the Status Line */
    else if (SipFail == sip_initSipStatusLine(
                &pStatLine,(SipError *)&(pError->stkErrCode)))
    {
        sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&pReason,pError);
        sip_freeSipMessage(*p_p_sip_msg);
        ret_val = ICF_FAILURE ;
    }
    else if (SipFail == sip_setReasonInStatusLine(
                pStatLine, pReason,
                (SipError *)&(pError->stkErrCode)))
    {
        sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&pReason,pError);
        sip_freeSipMessage(*p_p_sip_msg);
        ret_val = ICF_FAILURE ;
    }    

    else if (SipFail == sip_setVersionInStatusLine(
                pStatLine, pTmpVal,
                (SipError *)&(pError->stkErrCode)))
    {
        sip_freeSipMessage(*p_p_sip_msg);
        ret_val = ICF_FAILURE ;
    }    
    else if (SipFail == sip_setStatusCodeNumInStatusLine(
                pStatLine,resp_code,
                (SipError *)&(pError->stkErrCode)))
    {
        sip_freeSipMessage(*p_p_sip_msg);
        ret_val = ICF_FAILURE ;
    }    
    else if (SipFail == sip_setStatusLineInSipRespMsg (
                *p_p_sip_msg, pStatLine,
                (SipError *)&(pError->stkErrCode)))
    {
        sip_freeSipMessage(*p_p_sip_msg);
        ret_val = ICF_FAILURE ;
    }    
    /* Free the Local Reference */
    sip_freeSipStatusLine(pStatLine);

    return ret_val ;
}

/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_validate_via
 * DESCRIPTION:  This function validates the via header value in an incoming 
 *               request.
 *               1.If the topmost Via header of the incoming request has the
 *                IP/port which is the same as the local IP,
 *                the message should be discarded. Else, this 
 *                user agent would end up sending a response to itself.
 ******************************************************************************/
Sdf_ty_messageValidity icf_ssa_validate_via(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  Sdf_st_callObject   *p_call_obj,
        OUT Sdf_st_error          *pErr)

{
    icf_return_t                     ret_val = ICF_SUCCESS;
    en_SipMessageType                   dReqRespType;
    Sdf_ty_s8bit                        pLocal[30]="\0";
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (SipFail == sip_getMessageType(p_call_obj->pUasTransaction->pSipMsg,
        &dReqRespType, (SipError*)&(pErr->stkErrCode)))
    {
        pErr->errCode=Sdf_en_headerManipulationError;
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return Sdf_en_failed;
    }

    if (dReqRespType == SipMessageRequest)
    {
        SipHeader dTempHeader;
        Sdf_ty_s8bit *pRemoteIp = Sdf_co_null, *pSentBy = Sdf_co_null;
        Sdf_ty_s8bit *pHostAddress = Sdf_co_null, *pHostPort = Sdf_co_null;
        Sdf_ty_s8bit *p_local_ip = Sdf_co_null;
        Sdf_ty_u16bit dPort;
        Sdf_ty_s8bit dTempSentby[Sdf_co_mediumBufferSize]={'\0'};

        /* 
         * If the topmost Via header of the incoming request has the IP/port 
         * set in this profile, the message should be discarded. Else, this 
         * user agent would end up sending a response to itself.
         */
        if (SipFail == sip_getHeaderAtIndex(
                    p_call_obj->pUasTransaction->pSipMsg, SipHdrTypeVia,
                    &dTempHeader, 0, (SipError*)&(pErr->stkErrCode)))
        {
            pErr->errCode=Sdf_en_headerManipulationError;
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return Sdf_en_failed;
        }

        if (SipFail == sip_getSentByFromViaHdr(
                        &dTempHeader, &pSentBy, (SipError*)&(pErr->stkErrCode)))
        {        
            sip_freeSipHeader(&dTempHeader);
            pErr->errCode=Sdf_en_headerManipulationError;
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return Sdf_en_failed;
        }    

        Sdf_mc_strcpy(dTempSentby, pSentBy);

        pHostAddress = Sdf_mc_strtokr(dTempSentby, ":",&pHostPort);

        if (Sdf_co_null == pHostAddress)
        {
            sip_freeSipHeader(&dTempHeader);
            pErr->errCode=Sdf_en_invalidParamError;
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return Sdf_en_failed;            
        }
        /* resolve the hostname into ip addr */
        if (Sdf_co_fail == 
                (sdf_fn_uaGetHostIp(pHostAddress, &pRemoteIp, pErr)))
        {
            sip_freeSipHeader(&dTempHeader);
            pErr->errCode=Sdf_en_invalidParamError;
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return Sdf_en_failed;
        }

        /* resolve the local hostname into ip addr */
        if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
        {
            if (Sdf_co_fail == (sdf_fn_uaGetHostIp(
                (icf_int8_t *)p_ssa_pdb->p_glb_cfg_data->self_ip_address.
                    addr.addr.domain.str, 
                &p_local_ip, 
                pErr)))
            {
                if (ICF_NULL != p_local_ip)
                {
                   sdf_memfree(Sdf_mc_callHandlerMemId, 
                    (Sdf_ty_pvoid*)&(p_local_ip),pErr);
                }
                sip_freeSipHeader(&dTempHeader);
                pErr->errCode=Sdf_en_invalidParamError;
                ret_val = ICF_FAILURE;
                ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
                return Sdf_en_failed;
            }
            icf_port_strcpy((icf_uint8_t *)pLocal, (icf_uint8_t *)p_local_ip);
            sdf_memfree(Sdf_mc_callHandlerMemId, 
                    (Sdf_ty_pvoid*)&(p_local_ip),pErr);
        }
        else 
        {
            icf_ssa_convert_to_IP_addr(
                    &(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                    (icf_uint8_t *)pLocal);
        }

        if (pHostPort != NULL)
            dPort = (icf_uint16_t)icf_port_atoi(pHostPort);
        else
            dPort = 5060;

        /* 
         * If the IP/port in the topmost Via header matches with that in the 
         * user profile's transport information, the message should be 
         * discarded 
         */
        if ( (Sdf_mc_strcmp(pRemoteIp, pLocal) == 0) && 
            (dPort == p_ssa_pdb->p_glb_cfg_data->self_ip_address.port_num) )
        {
            sip_freeSipHeader(&dTempHeader);
            sdf_memfree(Sdf_mc_callHandlerMemId, 
                (Sdf_ty_pvoid*)&(pRemoteIp), pErr);
            pErr->errCode=Sdf_en_invalidParamError;
            
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return Sdf_en_discarded;
        }

        /* Free the local reference */

        sip_freeSipHeader(&dTempHeader);
        sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(pRemoteIp),pErr);

    } /* if (dReqRespType == SipMessage... */

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return Sdf_en_valid;
}

/*******************************************************************************
 * FUNCTION:     icf_ssa_form_and_insert_priv_hdr
 * DESCRIPTION:  This function forms and inserts a privacy header into the SIP
 *               message .
 *               1. Currently we are only sending Privacy header with
 *               the value "id"
 ******************************************************************************/
icf_return_t icf_ssa_form_and_insert_priv_hdr(
        INOUT      icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT    SipMessage          *p_otg_sip_msg)
{
    icf_return_t                     ret_val = ICF_SUCCESS;

    SipHeader  *p_sip_header = SIP_NULL;
    SipUnknownHeader  *p_unknown_header = SIP_NULL;
    SipError        sip_error;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if(SipFail == 
            sip_initSipHeader(
                &p_sip_header, SipHdrTypeUnknown, &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failed to init unknown Sip header"));
        return ICF_FAILURE;
    }
    else if (ICF_NULL == p_sip_header)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failed to init unknown Sip header"));
        return ICF_FAILURE;
    }
    else
    {
        icf_uint8_t      size;
        p_unknown_header = (SipUnknownHeader*)(p_sip_header->pHeader);
        /*
         * Get the memory for "Privacy" string.
         * This will be assigned to the pName pointer
         * in the Unknown header body.  The memory will
         * be freed when the header is freed on invocationof
         * freeSipHeader API
         */
#ifdef ICF_WITH_MUATK_2_2
        ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                8,/*size of "Privacy" +1 */
                ICF_MEM_COMMON,
                p_unknown_header->pStr1,
                ICF_DONOT_RET_ON_FAILURE,
                p_ssa_pdb->p_ecode,
                ret_val)
#else
        ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                8,/*size of "Privacy" +1 */
                ICF_MEM_COMMON,
                (icf_void_t *)
                p_unknown_header->pName,
                ICF_DONOT_RET_ON_FAILURE,
                p_ssa_pdb->p_ecode,
                ret_val)
#endif
        if ( ICF_FAILURE == ret_val)
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Memget failure for Privacy"));
            sip_freeSipHeader(p_sip_header);
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_sip_header,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            ret_val = ICF_FAILURE;
        }
        else
        {
            size = 3;/* 2 bytes for id parameter and 1 newline */ 
#ifdef ICF_WITH_MUATK_2_2
            icf_port_strcpy( (icf_uint8_t *)p_unknown_header->pStr1,(icf_uint8_t *)"Privacy");
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb,size,
                    ICF_MEM_COMMON,
                    p_unknown_header->pStr2,
                    ICF_DONOT_RET_ON_FAILURE,
                    p_ssa_pdb->p_ecode,
                    ret_val)
#else
            icf_port_strcpy( p_unknown_header->pName,"Privacy");
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb,size,
                    ICF_MEM_COMMON,
                    (icf_void_t *)(p_unknown_header->pBody),
                    ICF_DONOT_RET_ON_FAILURE,
                    p_ssa_pdb->p_ecode,
                    ret_val)
#endif
            if ( ICF_FAILURE == ret_val)
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Memget failure for privacy hdr body"));
                sip_freeSipHeader(p_sip_header);
                ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_sip_header,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                ret_val = ICF_FAILURE;
            }
            else
            {
                SIP_U32bit  hdr_index = 0;
#ifdef ICF_WITH_MUATK_2_2
                icf_port_memset(
                        (icf_void_t *)(p_unknown_header->pStr2),
                        0, size);
                icf_port_strcat((icf_uint8_t *)p_unknown_header->pStr2,
                        (icf_uint8_t *)"id");
#else
                icf_port_memset(
                        (icf_void_t *)(p_unknown_header->pBody),
                        0, size);
                icf_port_strcat(p_unknown_header->pBody,
                        "id");
#endif
                sip_getHeaderCount(
                        p_otg_sip_msg,
                        SipHdrTypeUnknown,
                        &hdr_index,&sip_error);
                if (SipFail == sip_insertHeaderAtIndex(
                            p_otg_sip_msg,p_sip_header,
                            hdr_index,&sip_error))
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure Privacy Hdr List Append"));
                    ret_val = ICF_FAILURE;
                }
                sip_freeSipHeader(p_sip_header);
                ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_sip_header,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
             }
        }
    }/*Instance of Unknown Header Init successfully*/
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_parse_privacy_header
 ** DESCRIPTION:  This function iterates through all the unknown headers
 **               If it doesn't find privacy header,it returns
 **               failure.
 **               Otherwise,if the privacy hdr is present,SSA
 **               will parse it like an unknown header.If privacy header
 **               contains the value "id",then return SUCCESS.
 **               In all other cases failure is returned.In case UATK failure
 **               occurs,ecode is set as ICF_ERROR_UATK_FAILURE
 **
 ***************************************************************************/

icf_return_t icf_ssa_parse_privacy_header(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  Sdf_st_callObject   *p_call_obj)

{
    icf_return_t         ret_val = ICF_FAILURE;

    Sdf_ty_u32bit           iterator=0,count=0;
    SipError                err;
    SipHeader               dHeader;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* get the unknown header count */
    if(SipFail == sip_getHeaderCount(
                p_call_obj->pUasTransaction->pSipMsg,
                SipHdrTypeUnknown,&count,
                &err))
    {
        *(p_ssa_pdb->p_ecode) = ICF_ERROR_UATK_FAILURE ;
        ret_val = ICF_FAILURE ;
    }
    /* Iterate through all the unknown headers*/
    for(iterator=0 ; iterator<count ; iterator++)
    {
        SIP_S8bit           *pUnkHdrName = SIP_NULL,
                            *pBuffer = SIP_NULL ;

        if(SipFail == sip_getHeaderAtIndex(
                    p_call_obj->pUasTransaction->pSipMsg,
                    SipHdrTypeUnknown, &dHeader,
                    iterator,&err))
        {
            /*In this case we continue to try to fetch other unknown headers*/
            continue;
        }
        if(SipFail == sip_getNameFromUnknownHdr(
                    &dHeader,&pUnkHdrName,&err))
        {
            /*In this case we continue to try to fetch other unknown headers*/
            sip_freeSipHeader(&dHeader);
            continue;
        }
        /* Check for the P-Asserted-Identity header */
        if(0 == sip_strcasecmp(pUnkHdrName,"Privacy"))
        {
            icf_uint8_t  seps[] = " ;";
            icf_uint8_t  *token = ICF_NULL;
            /*buf_count=icf_port_strlen(((SipUnknownHeader *)
                        (dHeader.pHeader))->pBody); */
            pBuffer = (((SipUnknownHeader *)
#ifdef ICF_WITH_MUATK_2_2
                        (dHeader.pHeader))->pStr2);
#else
                        (dHeader.pHeader))->pBody);
#endif

            token = (icf_uint8_t *)icf_port_strtok(pBuffer,(const icf_int8_t *)seps);
            while(ICF_NULL != token)
            {
                /* On encountering an id parameter we return SUCCESS */
                if (ICF_NULL == icf_port_strcmp(
                            token,(icf_uint8_t *)"id"))
                {
                    sip_freeSipHeader(&dHeader);
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                    return ICF_SUCCESS;
                }
                /* Get next token */
                token = (icf_uint8_t *)icf_port_strtok(ICF_NULL,(const icf_int8_t *)seps);
            }
        }
        sip_freeSipHeader(&dHeader);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/*
 * Following routines are used for addition/deletion of PDU nodes from 
 * the link list maintained in the TCP conn SM blocks.
 * PDUs are inserted at the end of the list and are removed from the 
 * start of the list when they have to be sent on the network.
 */
/*******************************************************************************
 * FUNCTION:        icf_ssa_add_to_pdu_array
 * DESCRIPTION:    This routine adds the given pdu at the end of array
 ******************************************************************************/
icf_return_t icf_ssa_add_to_pdu_array(
        INOUT    icf_ssa_pdb_st   *p_ssa_pdb,
        OUT     icf_uint8_t      *p_pdu)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st     *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    icf_uint8_t      counter = 0;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    while ( counter < ICF_MAX_PENDING_PDU_PER_CONN)
    {
        if (ICF_NULL != p_ssa_ctxt->p_pending_pdu[counter])
        {
            counter++;
        }
        else
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FreeLocation found in pdu ptr array"));
            p_ssa_ctxt->p_pending_pdu[counter] = p_pdu;
            p_ssa_ctxt->no_of_pending_pdu++;
            break;
        }
    }
    if ( ICF_MAX_PENDING_PDU_PER_CONN == counter)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:NoFreeLocation found in pdu ptr array"));
        ret_val = ICF_FAILURE;
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


/*******************************************************************************
 * FUNCTION:        icf_ssa_revert_to_udp
 * DESCRIPTION:   This function is used to revert the callobject from TCP
 *          to UDP. Don;t Know if a clear transaction is required prior to the
 *          second the MakeCal ( in this call)
 ******************************************************************************/
icf_return_t icf_ssa_revert_to_udp(
        INOUT    icf_ssa_pdb_st   *p_ssa_pdb,
        Sdf_st_callObject   *p_call_obj, 
        Sdf_st_overlapTransInfo     **p_p_overlap_txn,
        icf_uint8_t      *p_method,
        Sdf_st_error                *p_error)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st  *p_ssa_ctxt = 
        (icf_ssa_ctxt_st*)(p_call_obj->pAppData->pData);
    SipMessage          *p_sip_msg = Sdf_co_null;
    Sdf_ty_messageType  msg_type;
    SipError            sip_error;
    icf_uint8_t  proto[5]="UDP";
    SipList             contact_hdr_list_in_SipMsg;
    Sdf_ty_slist        contact_hdr_list_in_CommonInfo;    


    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }   
    p_ssa_pdb=p_ssa_pdb;    
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /*ICF_SSA_TRACE((p_ssa_pdb,ICF_TRACE_TRANS_MODE_REVERT_TO_UDP));*/

#ifdef ICF_P_CSCF_DISCOVERY_ENABLED
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
/* We will net the transport mode to none for P-CSCF Discovery */
    proto[0]='\0';
ICF_CHECK_IMS_END
#endif
#endif
    
    if ( Sdf_co_fail == 
            sdf_ivk_uaSetTransportSchemeInTransaction(
                p_call_obj->pUacTransaction, 
                *p_p_overlap_txn, (icf_int8_t *)proto, p_error))
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:FailureInSettingTransportToUdp\n"));
        ret_val = ICF_FAILURE;
    }
    if (ret_val == ICF_SUCCESS)
    {
        sdf_fn_uaGetMethodNameAsEnum((const icf_int8_t *)p_method, &msg_type, p_error);
        switch (msg_type)
        {
        case Sdf_en_invite:
            p_sip_msg = p_call_obj->pUacTransaction->pSipMsg;
            break;
        case Sdf_en_register:
            p_sip_msg = (*p_p_overlap_txn)->pSipMsg;
            p_ssa_ctxt->bitmask |= ICF_SSA_RGM_PREV_TRANS_TYPE_UDP;
            break;
        case Sdf_en_subscribe:
        case Sdf_en_refer:
        case Sdf_en_message:
        case Sdf_en_options:
            p_sip_msg = (*p_p_overlap_txn)->pSipMsg;
            break;
        default:
            if (0 == (icf_port_strcmp((icf_uint8_t *)"PUBLISH", p_method)))
            {
                p_sip_msg = (*p_p_overlap_txn)->pSipMsg;
            }
            else
            {
                ICF_PRINT(((icf_uint8_t *)"[SSA]:NoValidMethodToBeReverted!!"));
                ret_val = ICF_FAILURE;
            }
            break;
        }
    }
    /*as per UATK team*/
    /*delete the old via header which contains the failed transport scheme*/
    if ( ICF_FAILURE != ret_val)
    {
        if(SipFail == sip_deleteHeaderAtIndex(
                    p_sip_msg, SipHdrTypeVia,0, &sip_error))
        {
            ICF_PRINT(((icf_uint8_t *)"[SSA]:FailureInDeletingSipViaHeader\n"));
            ret_val = ICF_FAILURE;
        }

        /*generate the new via header to reflect the new 
         * transport scheme selected*/
        else if(Sdf_co_fail == sdf_fn_uaFormViaHeader(p_call_obj,
                    *p_p_overlap_txn,msg_type,p_sip_msg, p_error))
        {
            ICF_PRINT(((icf_uint8_t *)"[SSA]:FailureInMakingNewViaHeader\n"));
            ret_val = ICF_FAILURE;
        }

    }

    if (ICF_NULL == p_sip_msg)
    {
       return ICF_FAILURE;
    }

    /*deleting the transport parameter from To header in the sip message*/
    if(ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
           p_sip_msg->pGeneralHdr->pToHdr->pAddrSpec,(icf_uint8_t *)"transport"))
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Parameter from To header\n"));
        ret_val = ICF_FAILURE;
    }

    /*Iterating and deleting the transport parameter from Contact header(s) in the sip message*/
    if(0 != p_sip_msg->pGeneralHdr->slContactHdr.size)
    {
        contact_hdr_list_in_SipMsg = p_sip_msg->pGeneralHdr->slContactHdr;
        /*iterating through the list and passing each list element's pAddrSpec for deletion*/ 
        while(contact_hdr_list_in_SipMsg.head)
        {
            if(ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
               ((SipCommonHeader*)contact_hdr_list_in_SipMsg.head->pData)->pAddrSpec,(icf_uint8_t *)"transport"))
            {
                ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Parameter from Contact header\n"));
                ret_val = ICF_FAILURE;
            }
            contact_hdr_list_in_SipMsg.head = contact_hdr_list_in_SipMsg.head->next;
        }
    }
    else
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:Empty contact list in Sip Message\n"));
    }

    /*deleting the transport parameter from Request Line in the sip message*/
    if(ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
           p_sip_msg->u.pRequest->pRequestLine->pAddrSpec,(icf_uint8_t *)"transport"))
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Parameter from Request Line\n"));
        ret_val = ICF_FAILURE;
    }
  
    /* deleting transport parameter from Common Info*/

    /*deleting the transport parameter from Request Line in Common Info*/
    if((ICF_NULL != p_call_obj->pCommonInfo->pRequestUri) &&
       (ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
           p_call_obj->pCommonInfo->pRequestUri,(icf_uint8_t *)"transport")))
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Parameter from Request Line\n"));
        ret_val = ICF_FAILURE;
    }

    /*Iterating and deleting the transport parameter from Contact header(s) in the Common Info*/
    if(0 != p_call_obj->pCommonInfo->slContact.size)
    {
        contact_hdr_list_in_CommonInfo = p_call_obj->pCommonInfo->slContact;
        /*iterating through the list and passing each list element's pAddrSpec for deletion*/
        while(contact_hdr_list_in_CommonInfo.head)
        {
            if(ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
               ((SipCommonHeader*)contact_hdr_list_in_CommonInfo.head->pData)->pAddrSpec,(icf_uint8_t *)"transport"))
            {
                ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Parameter from Contact header\n"));
                ret_val = ICF_FAILURE;
            }
            contact_hdr_list_in_CommonInfo.head = contact_hdr_list_in_CommonInfo.head->next;
        }
    }
    else
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:Empty contact list in Common Info\n"));
    }
  
    /*deleting the transport parameter from To header in the Common Info*/
    if(ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
           ((SipCommonHeader *)p_call_obj->pCommonInfo->pTo->pHeader)->pAddrSpec,(icf_uint8_t *)"transport"))
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Parameter from To header\n"));
        ret_val = ICF_FAILURE;
    }
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_send_dialog_initiator_msg
 * DESCRIPTION:   
 ******************************************************************************/
icf_return_t icf_ssa_send_dialog_initiator_msg(
        INOUT    icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_ssa_tcpm_conn_data_st  *p_conn_db_node = 
        p_ssa_pdb->p_conn_table_entry;
    icf_uint8_t      method[ICF_MAX_SIZE_INT_USAGE_STR];

    Sdf_st_callObject           *p_call_obj = 
        p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;
    Sdf_st_transaction         *p_txn = Sdf_co_null;
/* p_sip_msg is not being used in this function, but value to it is
 * being assigned from p_overlap_trans_info that is resulting in klocwork
 * error, so i am removing it.
 */ 
/*    SipMessage                  *p_sip_msg = SIP_NULL;*/
    Sdf_st_error                sdf_error;
    SipOptions                  options;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb);


    options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

   if (ICF_SSA_INVITE_PENDING == (ICF_SSA_INVITE_PENDING & 
                p_ssa_pdb->p_ssa_ctxt->bitmask))
   {
        icf_port_strcpy(method,(icf_uint8_t *)"INVITE");
        p_txn = p_call_obj->pUacTransaction;
   }
   else
   {
       icf_ssa_get_method_name(p_ssa_pdb->p_ssa_ctxt->bitmask,
               method);         
       if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_pending_txn)
       {
           p_overlap_trans_info = (Sdf_st_overlapTransInfo*)
              (p_ssa_pdb->p_ssa_ctxt->p_pending_txn);
       }
       if (ICF_SSA_SUBS_PENDING & p_ssa_pdb->p_ssa_ctxt->bitmask)
       {
           p_ssa_pdb->p_ssa_ctxt->bitmask &= ~ICF_SSA_SUBS_PENDING;
       }
       else if (ICF_SSA_REG_PENDING & p_ssa_pdb->p_ssa_ctxt->bitmask)
       {
           p_ssa_pdb->p_ssa_ctxt->bitmask &= ~ICF_SSA_REG_PENDING;
       }
       else if (ICF_SSA_REFER_PENDING & p_ssa_pdb->p_ssa_ctxt->bitmask)
       {
           p_ssa_pdb->p_ssa_ctxt->bitmask &= ~ICF_SSA_REFER_PENDING;
       }
       else if (ICF_SSA_OPTION_PENDING & p_ssa_pdb->p_ssa_ctxt->bitmask)
       {
           p_ssa_pdb->p_ssa_ctxt->bitmask &= ~ICF_SSA_OPTION_PENDING;
       }
   }
   
    if ( ICF_NULL == 
       (ICF_SSA_TCP_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask))
    {
            
        if (ICF_TRUE == p_ssa_pdb->p_ssa_ctxt->revert_mode)
        {
            /*p_overlap_trans_info =  p_conn_db_node->p_ssa_ctxt->p_pending_txn;*/

            /*Indicates that a TCP connect attempt failed here.
             * So going for UDP transport to start the transaction*/
            if ( ICF_FAILURE == icf_ssa_revert_to_udp(
                        p_ssa_pdb, p_call_obj, &p_overlap_trans_info,
                        method, &sdf_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInRevertingToUdp\n"));
                ret_val = ICF_FAILURE;
            }
            /* this is to tell that for subsequent requests
             * we will not change the transport mode 
             */
            p_ssa_pdb->p_ssa_ctxt->trans_mode_reverted = ICF_TRUE;
          }
        else
        {
            ret_val = ICF_FAILURE;
        }

    }
    else
    {
        /*If connection is established then update call_obj*/
       p_call_obj->pUacTransaction->dSocket.dSockfd =
            p_conn_db_node->conn_fd;
#ifdef ICF_SECURE_SUPPORT                
       if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)
       {
            p_call_obj->pUacTransaction->dSocket.dProtocol
                = Sdf_en_protoTls;
       }
       else
       {
#endif       
            p_call_obj->pUacTransaction->dSocket.dProtocol
                = Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
       }
#endif 
    }

    if ( ICF_FAILURE != ret_val)
    {
        Sdf_st_eventContext *p_event_context = Sdf_co_null;
        if (Sdf_co_fail ==
                sdf_ivk_uaInitEventContext(&p_event_context, &sdf_error))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInInitEventCtxt in SendDialogInitiator"));
            ret_val = ICF_FAILURE;
        }
        else if (ICF_NULL == p_event_context)
        {
            ICF_PRINT(((icf_uint8_t *)"(icf_uint8_t *)\n[SSA]:FailureInInitEventCtxt in SendDialogInitiator"));
            ret_val = ICF_FAILURE;
        }
        else
        {
            p_event_context->pData = p_ssa_pdb->p_ssa_ctxt;
            if (ICF_FAILURE == icf_ssa_initiate_dispatch_sequence(
                        p_ssa_pdb, p_call_obj,
                        p_txn, p_overlap_trans_info,
                        p_event_context,
                        p_ssa_pdb->p_ecode))
            {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                sdf_ivk_uaClearTransaction(p_call_obj, 
                        p_overlap_trans_info,(const icf_int8_t *)method, 
                        Sdf_en_uacTransaction);
                /*Not freeing CallObject here as a failure from
                 * this routine will trigger Generic call clear
                 * or clear reg object from app mode*/
                ret_val = ICF_FAILURE;
            }
            else if ( Sdf_co_fail ==
                    sdf_ivk_uaEndTransaction(p_call_obj,
                        p_overlap_trans_info, (const icf_int8_t *)method, &sdf_error))
            {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                sdf_ivk_uaClearTransaction(p_call_obj, 
                        p_overlap_trans_info,(const icf_int8_t *)method, 
                        Sdf_en_uacTransaction);
                /*Not freeing CallObject here as a failure from
                 * this routine will trigger Generic call clear
                 * or clear reg object from app mode*/
                ret_val = ICF_FAILURE;
            }
        }
       if  ( Sdf_co_null != p_event_context)
       {
           sdf_ivk_uaFreeEventContext(p_event_context);
       }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
    return ret_val;
}
/*******************************************************************************
 * FUNCTION:        icf_ssa_dispatch_pdu_to_es
 * DESCRIPTION:    The ppdu memory is allocated to this function
 * by athe calling routine and then it frees it.
 ******************************************************************************/
icf_return_t icf_ssa_dispatch_pdu_to_es(
        INOUT icf_glb_pdb_st   *p_glb_pdb,
        INOUT icf_ssa_ctxt_st  *p_ssa_ctxt,
        INOUT SipTranspAddr    *pTranspaddr,
        INOUT Sdf_ty_protocol  dTransptype,
        INOUT icf_uint8_t      *p_pdu,
        INOUT icf_uint32_t     pdu_len,
        IN    icf_line_id_t    line_id,
        OUT   icf_error_t      *p_ecode)
{
    icf_return_t     ret_val = ICF_FAILURE;
    icf_return_t     dummy_ret_val;
    icf_uint32_t     outgoing_msg_len = 0;
    icf_msg_st       *p_outgoing_msg = ICF_NULL;
    icf_nw_interface_info_st *p_nw_interface_info = ICF_NULL;
    icf_config_data_st   *p_config_data = ICF_NULL;
    icf_line_data_st     *p_line_data = ICF_NULL;
    icf_uint16_t         server_index = 0;
    #ifdef ICF_TRACE_ENABLE
    icf_global_port_info_st  *p_glb_port_data =
                                   (icf_global_port_info_st *)p_glb_pdb->p_glb_data->p_glb_port_info;
    #endif
    /* To remove warnings */
    p_ssa_ctxt=p_ssa_ctxt;

    ICF_FUNCTION_ENTER(p_glb_pdb)
   /* get the pointer to CFG data: to check for GPRS state */
    ret_val = icf_dbm_get_module_glb_data(
                p_glb_pdb,
                (icf_int_module_id_t)(ICF_INT_MODULE_CFG),
                (icf_void_t **)(&(p_config_data)),
                p_ecode);     

    ICF_ASSERT(p_glb_pdb,
            (ICF_NULL != p_config_data))
    if (ICF_CFG_SELF_ADDR_PER_LINE ==
        p_config_data->self_addr_per_line)
    {
        if ( ICF_FAILURE ==
            icf_dbm_fetch_line_cntxt_blk(
                p_glb_pdb, line_id,
                &p_line_data, p_ecode))
        {
            return ICF_FAILURE;
        }
        server_index = p_line_data->server_index[ICF_WIN_UDP_SIP_SERVER];
    }
    else
    {
        server_index = p_config_data->server_index[ICF_WIN_UDP_SIP_SERVER];
    }
        

/* Start for SIP DSCP parameter */
 if (ICF_SUCCESS == ret_val)
 {
   if (ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk( p_glb_pdb,
                                                    line_id,
                                                    (&p_line_data),
                                                    p_ecode ) )
    {
      ret_val = ICF_FAILURE;
    }
 }   
 /* End for SIP DSCP parameter */
#ifdef ICF_NW_ACTIVATE 
    if (ICF_TRUE == p_config_data->gprs_suspended)
    {
        ICF_MEMFREE(p_glb_pdb, p_pdu, ICF_MEM_COMMON,\
                p_ecode, ret_val)
        return ICF_SUCCESS;
    }
#endif
#ifdef ICF_TRACE_ENABLE
    if (ICF_NULL != p_ssa_ctxt->p_ssa_pdb)
    {

        p_ssa_ctxt->p_ssa_pdb->p_buf = p_pdu;
        p_ssa_ctxt->p_ssa_pdb->len = pdu_len;
        p_ssa_ctxt->p_ssa_pdb->p_glb_pdb=p_glb_pdb;
      /* SPR 17555 Fix: Call Direction send to app trace
       * function to be used to send to application
       */
	p_ssa_ctxt->p_ssa_pdb->call_direction = ICF_CALL_DIRECTION_OUTGOING;
        ICF_SSA_APP_TRACE(p_ssa_ctxt->p_ssa_pdb , ICF_TRACE_SIP_PDU)
    }
#endif
/*Jason , syslog*/
#ifdef VOIP_SYSLOG
	icf_print_pdu(p_glb_pdb, (icf_uint8_t *)p_pdu, (icf_uint8_t *)pTranspaddr->pHost, 
		          pTranspaddr->dPort, pdu_len,1);
#else
	icf_print_pdu(p_glb_pdb, (icf_uint8_t *)p_pdu, (icf_uint8_t *)pTranspaddr->pHost, 
		          pTranspaddr->dPort, pdu_len);
#endif
    outgoing_msg_len = ICF_PORT_SIZEOF(icf_msg_st) + 
        ICF_PORT_SIZEOF(icf_nw_interface_info_st) - 1;

    ICF_MEMGET(p_glb_pdb, outgoing_msg_len, ICF_MEM_COMMON,\
            p_outgoing_msg,ICF_RET_ON_FAILURE,\
            p_ecode, ret_val)

    p_outgoing_msg->hdr.api_id = 0;
    p_outgoing_msg->hdr.app_id = 0;
    p_outgoing_msg->hdr.call_id = 0;
    p_outgoing_msg->hdr.source_id = ICF_MODULE_ICF;
    p_outgoing_msg->hdr.destination_id = ICF_MODULE_SIP_NW;
    p_outgoing_msg->hdr.api_length = (icf_uint16_t)(pdu_len + 
        ICF_PORT_SIZEOF(icf_nw_interface_info_st));

    p_nw_interface_info = (icf_nw_interface_info_st*)
        p_outgoing_msg->payload;

    p_nw_interface_info->p_sip_msg = p_pdu;
    p_nw_interface_info->pdu_len = (icf_uint16_t) pdu_len;
    if(ICF_NULL != p_line_data)
    p_nw_interface_info->sip_dscp = p_line_data->sip_dscp;
    if (dTransptype == Sdf_en_protoUdp)
    {
        p_nw_interface_info->bitmap = ICF_INTF_INFO_PROTOCOL_UDP;
        p_nw_interface_info->remote_port_num = pTranspaddr->dPort;
        icf_port_strcpy(p_nw_interface_info->remote_ip_addr, 
                ((icf_uint8_t *)pTranspaddr->pHost));
        p_nw_interface_info->curr_server_index = server_index;
	
    }
#ifdef ICF_SECURE_SUPPORT                
    else if(dTransptype == Sdf_en_protoTls)
    {
        p_nw_interface_info->bitmap = ICF_INTF_INFO_PROTOCOL_TLS;
        p_nw_interface_info->receiver_fd = pTranspaddr->dSockFd;
    }
#endif
    else
    {
        p_nw_interface_info->bitmap = ICF_INTF_INFO_PROTOCOL_TCP;
        p_nw_interface_info->receiver_fd = pTranspaddr->dSockFd;
    }

    ICF_SEND(p_glb_pdb, p_outgoing_msg, ret_val, p_ecode);
#ifdef ICF_TRACE_ENABLE
    if( ICF_FAILURE == ret_val)
    {
	if( dTransptype == Sdf_en_protoUdp )
	{
	    p_glb_port_data->icf_trace_ipc_info.self_mode = ICF_TRANSPORT_TYPE_UDP;
            p_glb_port_data->icf_trace_ipc_info.remote_port = pTranspaddr->dPort;
            icf_port_strcpy(p_glb_port_data->icf_trace_ipc_info.remote_ip,
                                                p_nw_interface_info->remote_ip_addr);
            /* fix for csr-5286119*/
	    ICF_CMN_APP_TRACE(p_glb_pdb, ICF_TRACE_UDP_SEND_ERROR,p_outgoing_msg)

	}
#ifdef ICF_SECURE_SUPPORT
	else if( dTransptype == Sdf_en_protoTls )
	{
	    p_glb_port_data->icf_trace_ipc_info.self_mode = ICF_TRANSPORT_TYPE_TLS;
	    ICF_CMN_APP_TRACE(p_glb_pdb, ICF_TRACE_TLS_SEND_ERROR, p_outgoing_msg)
	}
#endif /*#ifdef ICF_SECURE_SUPPORT*/
	else
        {
            p_glb_port_data->icf_trace_ipc_info.self_mode = ICF_TRANSPORT_TYPE_TCP;
	    ICF_CMN_APP_TRACE(p_glb_pdb, ICF_TRACE_TCP_SEND_ERROR, p_outgoing_msg)
        }
	
    }
#endif /*#ifdef ICF_TRACE_ENABLE*/

    ICF_MEMFREE(p_glb_pdb, p_pdu, ICF_MEM_COMMON,\
                p_ecode, dummy_ret_val)
    ICF_MEMFREE(p_glb_pdb, p_outgoing_msg, ICF_MEM_COMMON,\
                    p_ecode, dummy_ret_val)
     
    /*Code for stat collection*/

    if( ret_val == ICF_FAILURE)
    {
    if(dTransptype == Sdf_en_protoUdp)
    {
        ICF_STATS(p_glb_pdb->p_stats_info->
            stat_udp_connections.stats_send_failures)
    }
#ifdef ICF_SECURE_SUPPORT
    else if(dTransptype == Sdf_en_protoTls)
    {
        ICF_STATS(p_glb_pdb->p_stats_info->
                        stat_tls_connections.stats_send_failures)
    }
#endif
    else
    {
        ICF_STATS(p_glb_pdb->p_stats_info->
                        stat_tcp_connections.stats_send_failures)
    }

     }


    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}
/*******************************************************************************
 * FUNCTION:        icf_ssa_send_failure_to_app_module
 * DESCRIPTION:    This routine is invoked in case there is a failure either in
 * the handling of a successful open conn resp or there is a failure response
 * for a pending open connection request.  The routine forms and sends appr.
 * failure message to the module whose request resulted in a tcp conn attempt 
 ******************************************************************************/
icf_return_t icf_ssa_send_failure_to_app_module(
        icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t     ret_val = ICF_FAILURE;
    icf_ssa_intrnl_intf_ut   internal_msg_payload;

    icf_ssa_ctxt_st  *p_ssa_ctxt = ICF_NULL;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* As message is coming from MRM, there should not be anything
     * in the payload part of the internal message, so we are over-
     * writing the pointer here.
     */

    p_ssa_pdb->p_internal_msg->p_msg_data  = (icf_uint8_t*)
    (&internal_msg_payload);
    p_ssa_pdb->p_internal_msg->msg_hdr.payload_length  = 
        ICF_PORT_SIZEOF(icf_ssa_intrnl_intf_ut);

    p_ssa_pdb->p_internal_msg->msg_hdr.p_glb_pdb = p_ssa_pdb->p_glb_pdb;
#if 0
    p_root =  icf_dbm_fetch_all_ssa_ctxt_from_hash_table(p_ssa_pdb->p_glb_pdb);
    for (p_temp = p_root; ICF_NULL != p_temp; p_temp = p_temp->p_next)
    {
        for (p_ssa_list = (icf_ssa_ctxt_list_st *)p_temp->p_data; ICF_NULL != p_ssa_list ;
                p_ssa_list = p_ssa_list->p_next)
        {
            p_ssa_ctxt = p_ssa_list->p_ssa_ctxt;
            if ((p_ssa_ctxt->p_conn_table_req_entry == p_conn_db_node) ||
                    (p_ssa_ctxt->p_conn_table_resp_entry == p_conn_db_node))
            {
                break;
            }
            else
                p_ssa_ctxt = ICF_NULL;
        }
    }
   icf_ssa_free_list(p_ssa_pdb, p_root);
#endif
   p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
   if (ICF_NULL == p_ssa_ctxt )
   {
       ICF_PRINT(((icf_uint8_t *)"No ssa context for this connection found. Returning\n"))
       ret_val = ICF_FAILURE;
   }
   else if(ICF_SSA_INVITE_PENDING == 
       (ICF_SSA_INVITE_PENDING & p_ssa_ctxt->bitmask))
    {
        p_ssa_pdb->p_internal_msg->p_msg_data = ICF_NULL;/*no payload*/
        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = 
            ICF_GENERIC_CALL_CLEAR;
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 0;
        p_ssa_pdb->p_internal_msg->msg_hdr.p_glb_pdb->p_call_ctx = 
            p_ssa_ctxt->p_call_ctxt;
        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CM;
    /*Send the message to original module*/
        icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);
    }
    else if(ICF_SSA_REG_PENDING == 
    (ICF_SSA_REG_PENDING & p_ssa_ctxt->bitmask))
    {
        icf_rgm_nw_resp_st*      p_rgm_msg = ICF_NULL;

        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = ICF_NW_INC_REG_RESP;
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 
            ICF_PORT_SIZEOF(icf_rgm_nw_resp_st);

        /* Populate the internal message payload */
        p_rgm_msg = (icf_rgm_nw_resp_st *)
            (p_ssa_pdb->p_internal_msg->p_msg_data);

        p_rgm_msg->p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;

        p_rgm_msg->status = ICF_RGM_SSA_NW_FAILURE;

        p_rgm_msg->ecode = ICF_RGM_SSA_FAIL_REATTEMPT;

        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CFG;
        /* Send the message to original module */
    icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);
    }
    else
    {    
#if 0
    p_ssa_pdb->p_internal_msg->p_msg_data = ICF_NULL;/*no payload*/
        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = 
            ICF_GENERIC_CALL_CLEAR;
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 0;
        p_ssa_pdb->p_internal_msg->msg_hdr.p_glb_pdb->p_call_ctx = 
            p_conn_db_node->p_ssa_ctxt->p_call_ctxt;
        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CM;
#endif
        ICF_SSA_DEBUG(("[SSA]:InvalidMarkForPendingMsg!!\n"));
        ret_val = ICF_FAILURE;
    }
    /*Send the message to original module*/
/*    icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);*/
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/*******************************************************************************
 * FUNCTION:        icf_ssa_start_purge_timer
 * DESCRIPTION:    This routine is used for starting the purge timer
 ******************************************************************************/
icf_return_t icf_ssa_start_purge_timer(
        INOUT  icf_ssa_pdb_st*    p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_timer_id_t           timer_id = ICF_TIMER_ID_INVALID;
    icf_timer_data_st        *p_timer_data = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
#if 0
    if ( ICF_FAILURE == icf_dbm_create_timer_block(
                p_ssa_pdb->p_glb_pdb,(icf_void_t **)&p_timer_data, 
#endif
    if ( ICF_FAILURE == icf_dbm_get_mem_from_pool(
                p_ssa_pdb->p_glb_pdb, ICF_MEM_TIMER,
                (icf_void_t **)&p_timer_data, 
                p_ssa_pdb->p_ecode))
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:FailureInAllocatingTimerBlockForPurgeTimer\n"));
        ret_val = ICF_FAILURE;
    }
    else
    {
        /* fill the timer data structure */
        p_timer_data->timer_type = ICF_SSA_PURGE_TIMER_TYPE;
        p_timer_data->module_id = ICF_INT_MODULE_SSA;

        /*In case of timer expiry, eshell will pass the p_timer_data
         * to SSA.SSA will then get the p_ssa_timer_data and invoke
         * UATK callback
         */
        p_timer_data->p_timer_buffer = 
            (icf_void_t*)p_ssa_pdb->p_ssa_glb_data;
        p_timer_data->p_glb_pdb = p_ssa_pdb->p_glb_pdb;
        /*If the purge timer duration is 0 start a default purge timer 
          (ICF_DEFAULT_PURGE_TIMER_DURATION)define in icf_port.h
          (in common module) 
        */
        if( 0!= ICF_PURGE_TIMER_DURATION)
        {
            ICF_START_TIMER(p_ssa_pdb->p_glb_pdb, 
                    p_timer_data, timer_id,
                    ICF_PURGE_TIMER_DURATION, 
                    p_ssa_pdb->p_ecode, ret_val)
        }
        else
        {
            ICF_START_TIMER(p_ssa_pdb->p_glb_pdb, 
                    p_timer_data, timer_id,
                    ICF_DEFAULT_PURGE_TIMER_DURATION, 
                    p_ssa_pdb->p_ecode, ret_val)
        } 
            if ( ICF_FAILURE == ret_val)
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure!!InStartingPurgeTimer"));
                /*Free the allocated timer block here*/
#if 0        
                icf_dbm_free_timer_block(p_ssa_pdb->p_glb_pdb, 
#endif
                icf_dbm_ret_mem_to_pool(p_ssa_pdb->p_glb_pdb, 
                        ICF_MEM_TIMER,
                        p_timer_data, p_ssa_pdb->p_ecode);
                p_ssa_pdb->p_ssa_glb_data->purge_timer_id =
                    ICF_NULL;
                p_ssa_pdb->p_ssa_glb_data->p_purge_timer =
                    ICF_NULL;
            }
            else
            {
                p_ssa_pdb->p_ssa_glb_data->purge_timer_id =
                    timer_id;
                p_ssa_pdb->p_ssa_glb_data->p_purge_timer =
                    p_timer_data;
            }
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

#ifdef IMS_CLIENT

/*****************************************************************************
 ** FUNCTION:           headerListFreeFunction
 **
 ** DESCRIPTION:        This function free memeory allocated for SIP Header.
 **
 *****************************************************************************/
void headerListFreeFunction(void *pData)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_error_t                ecode;
    sip_freeSipHeader((SipHeader *)pData);
    ICF_MEMFREE(p_persistent_glb_pdb,pData,ICF_MEM_COMMON, &ecode, ret_val)
}


/*****************************************************************************
 ** FUNCTION:        icf_ssa_get_reg_body
 ** 
 ** DESCRIPTION:    This function gets the non-SDP/ISUP buffers and returns
 **                    "application/reginfo+xml" message body.
 **
 *****************************************************************************/
icf_return_t icf_ssa_get_reg_body (
            INOUT        SipMessage               *pMessage,
             OUT        Sdf_ty_s8bit             **pp_Buffer,
            OUT        Sdf_ty_u32bit             *pBufLength,
            INOUT     icf_error_t           *p_ecode)
{
  Sdf_st_error              Err;
  SipError                  error;
  Sdf_ty_u32bit             i, dCount = 0;
  SipHeader                    dHeader;
  
  ICF_PRINT(("\nExtracting Unknown Message Body"));
  /* To remove warning */
 p_ecode=p_ecode;

  if (pMessage == ICF_NULL)
  {
    ICF_PRINT(("\nInvalid SipMessage passed to function"));
    return ICF_FAILURE;
  }

  if (sip_getMsgBodyCount(pMessage, &dCount, &error) == SipFail)
  {
    ICF_PRINT(("\nFailed to get MsgBodyCount from SipMessage"));
    return ICF_FAILURE;
  }
  for (i = 0; i < dCount; i++)
  {

    if(sdf_ivk_uaGetUnknownBodyFromSipMessage(pMessage, i, \
          pp_Buffer, pBufLength, &Err) == Sdf_co_success)
    {
      /*
       * Retrieved an non-SDP/ISUP body. Add the body to the temporary
       * array and update the mgc_tunnel_element_st structure with
       * remaining parameters. 
       */
      Sdf_ty_s8bit *pMediaType = ICF_NULL;
      Sdf_ty_u32bit    BufLength = *pBufLength;
      
      Sdf_ty_s8bit *pLastChar=(Sdf_ty_s8bit *)(*pp_Buffer)+BufLength -1 ;
      if(*pLastChar == '\n') *pLastChar = '\0';
      
      /*if(*pp_Buffer[*pBufLength-1] == '\n')
        *pp_Buffer[*pBufLength-1] = '\0';
        */

       /*
       * Set the msg_type of the buffer_info element depending
       * on the type of the message body
       */

        

        if (sip_getHeader(pMessage, SipHdrTypeContentType, \
              &dHeader, &error) == SipFail)
        {
          ICF_PRINT(("\nFailed to get Content-Type Header"));
          return ICF_FAILURE;
        }
        if (sip_getMediaTypeFromContentTypeHdr(&dHeader, &pMediaType,\
              &error) == SipFail)
        {
          ICF_PRINT(("\nFailed to get media-type from "
                "Content-Type Header"));
          sip_freeSipHeader(&dHeader);
          return ICF_FAILURE;
        }
        if (Sdf_mc_strcasecmp(pMediaType, "application/reginfo+xml") == 0)
        {
          ICF_PRINT(("\nMedia Type: application/reginfo+xml"));
          sip_freeSipHeader(&dHeader);
          break;
        }
        else
        {
          ICF_PRINT(("\nMessage Type: UNKNOWN"));
        }
        /* Free the local reference */
        sip_freeSipHeader(&dHeader);
  
    }
  }

  return ICF_SUCCESS;
}


/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_set_ValInUnknownHdr
 *
 * DESCRIPTION:     This function creates Unknown header.
 *
 ******************************************************************************/
icf_return_t icf_ssa_set_ValInUnknownHdr(
        INOUT        icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT     SipHeader            *pHeader,
        INOUT      Sdf_ty_s8bit        *pHdr,
        INOUT      Sdf_ty_s8bit        *pVal)
{
    Sdf_ty_s8bit    *pHdrName=ICF_NULL;
    Sdf_ty_s8bit    *pHdrBody=ICF_NULL;
    Sdf_ty_s32bit   HdrBodyLen=0;
    SipError        SipErr;
    Sdf_ty_retVal   ret_val = Sdf_co_success;


    /* Inserting the Header name in the unknown Header */
    Sdf_mc_strdup(pHdrName,pHdr);
    
    if ( ICF_NULL == pHdrName )
    {
        return ICF_FAILURE;
    }

    if (sip_setNameInUnknownHdr(pHeader,pHdrName,&SipErr) == SipFail)
    {
        ICF_PRINT(("\nFailed to Set name"));

            ICF_MEMFREE(
            p_ssa_pdb->p_glb_pdb,
            pHdrName,
            ICF_MEM_COMMON,
            p_ssa_pdb->p_ecode,
            ret_val)

        return ICF_FAILURE;
    }
    /* Calculating the Header Body */
    HdrBodyLen += Sdf_mc_strlen(pVal) + 1;

    ICF_MEMGET(
                   p_ssa_pdb->p_glb_pdb,
                   HdrBodyLen,
                   ICF_MEM_COMMON,
                   pHdrBody,
                   ICF_RET_ON_FAILURE,
                   p_ssa_pdb->p_ecode,
                   ret_val)

    if(ICF_NULL == pHdrBody) 
    {
        sip_freeSipHeader(pHeader);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                pHdrName,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)

        return ICF_FAILURE;
    }
    /* Preparing the Message Body */

    icf_port_strcpy(pHdrBody, pVal);

    if (sip_setBodyInUnknownHdr(pHeader,pHdrBody,&SipErr) == SipFail)
    {
        ICF_PRINT(("\nFailed to set body"));
        return ICF_FAILURE;
    }

    return ICF_SUCCESS;
}
#endif /* #ifdef IMS_CLIENT */


/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_parse_unknown_header_like_from_hdr
 ** DESCRIPTION:  This function iterates through all the unknown headers
 **               If it doesn't find the required header,it returns
 **               success.
 **               Otherwise,if the required header is present,SSA
 **               will parse it like an FROM header and pass it as 
 **               p_p_parsed_hdr.
 **
 ***************************************************************************/
icf_return_t icf_ssa_parse_unknown_header_like_from_hdr(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  SipMessage          *pSipMessage,
        INOUT    Sdf_ty_s8bit        *p_reqd_hdr_name,
        INOUT  SipHeader           **p_p_parsed_hdr)

{
    icf_return_t         ret_val = ICF_SUCCESS;

    Sdf_ty_u32bit           iterator=0,count=0;
    SipError                err;
    SipHeader               dHeader;
    icf_boolean_t        match_found = ICF_FALSE;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* get the unknown header count */
    if(SipFail == sip_getHeaderCount(
                pSipMessage,
                SipHdrTypeUnknown,&count,
                &err))
    {
        /*ICF_SSA_TRACE(("\nFailed to get Header Count "))*/
        ret_val = ICF_FAILURE ;
    }
    /* Iterate through all the unknown headers*/
    for(iterator=0 ; ((iterator<count)&&(ICF_FALSE == match_found)); 
           iterator++)
    {
        SIP_S8bit           *pUnkHdrName = SIP_NULL,
                            *pBuffer = SIP_NULL ;
        Sdf_ty_u32bit         buf_count = 0;

        if(SipFail == sip_getHeaderAtIndex(
                    pSipMessage,
                    SipHdrTypeUnknown, &dHeader,
                    iterator,&err))
        {
            /*In this case we continue to try to fetch other unknown headers*/
            continue;
        }
        if(SipFail == sip_getNameFromUnknownHdr(
                    &dHeader,&pUnkHdrName,&err))
        {
            /*In this case we continue to try to fetch other unknown headers*/
            sip_freeSipHeader(&dHeader);
            continue;
        }
        /* Check for the Required header */
        if(0 == sip_strcasecmp(pUnkHdrName, p_reqd_hdr_name))
        {
            match_found = ICF_TRUE;
            if (SipFail ==sip_initSipHeader(
                        p_p_parsed_hdr,SipHdrTypeFrom,&err))
            {
                /*ICF_SSA_TRACE(("\nInit SipHeader Faoled"))*/
                ret_val = ICF_FAILURE ;
            }
            else
            {
#ifdef ICF_WITH_MUATK_2_2
                buf_count=icf_port_strlen((icf_uint8_t *)((SipUnknownHeader *)
                        (dHeader.pHeader))->pStr2);
                pBuffer = (((SipUnknownHeader *)
                            (dHeader.pHeader))->pStr2);
#else
                buf_count=icf_port_strlen(((SipUnknownHeader *)
                        (dHeader.pHeader))->pBody);
                pBuffer = (((SipUnknownHeader *)
                            (dHeader.pHeader))->pBody);
#endif
                /* parse the Required header as per From Header */
                if(SipFail == sip_parseFromHeader(
                            pBuffer,pBuffer+buf_count-1,
                            *p_p_parsed_hdr,
                            SipHdrTypeFrom,&err))
                {
                    sip_freeSipHeader(*p_p_parsed_hdr);
                    /*
                     * The SipHeader structure contains 2 fields,one being the
                     * type of header and second being a void pointer
                     * The call to sip_freeSipHeader fress the memory
                     * corresponding to the specific header according to 
                     * the type but doesn't free the top level structure.
                     * Hence,invoke a memfree on the top level structure
                     */
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            *p_p_parsed_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE ;
                }
            }
        }
        sip_freeSipHeader(&dHeader);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_dealloc_call_cntxt_blk
 *
 * DESCRIPTION: The function would free the msgbodylist,tags,headers 
 *                in call context and then frees hash mapping for outgoing call 
 *              and adds the block to free blocks list
 *
 * RETURNS: icf_return_t (SUCCESS)
 *
************************************************************************/  
icf_return_t 
icf_ssa_dealloc_call_cntxt_blk(
       INOUT  icf_glb_pdb_st                    *p_glb_pdb,
       INOUT     icf_call_ctx_st                   *p_call_ctxt,
       OUT   icf_error_t                       *p_ecode)
{
    icf_return_t        ret_val = ICF_SUCCESS;
#ifdef ICF_QOS_SUPPORT
#ifdef IMS_CLIENT
#ifdef ICF_NW_ACTIVATE
    icf_return_t        memfree_retval = ICF_SUCCESS;
#endif
#endif
#endif

    ICF_FUNCTION_ENTER(p_glb_pdb)
    /* free the list of additional headers */
    icf_cmn_free_header_list(p_glb_pdb, 
                &(p_call_ctxt->header_list),
                p_ecode);

    /* free the list of additional tags */
    icf_cmn_free_tag_list(p_glb_pdb, 
                &(p_call_ctxt->tag_list),
                p_ecode);

    /* free the list of additional message bodies */
    icf_cmn_free_msg_body_list(p_glb_pdb, 
                &(p_call_ctxt->body_list),
                p_ecode);

    /* reset the list of additional streams */
    icf_cmn_free_stream_sdp_info_list(p_glb_pdb, 
                &(p_call_ctxt->p_stream_sdp_info), p_ecode);

#ifdef ICF_QOS_SUPPORT
#ifdef IMS_CLIENT
#ifdef ICF_NW_ACTIVATE
ICF_CHECK_QOS_SUPPORT_START(p_glb_pdb,ICF_TRUE)
ICF_CHECK_IMS_START(p_glb_pdb,ICF_TRUE)
    /* Free memory for P-Media-Authorization header */
    if (ICF_NULL != p_call_ctxt->p_auth_token)
    {
        ICF_MEMFREE(p_glb_pdb, p_call_ctxt->p_auth_token,
            ICF_MEM_COMMON, p_ecode, memfree_retval)

        p_call_ctxt->p_auth_token = ICF_NULL;
    }
ICF_CHECK_IMS_END
ICF_CHECK_QOS_SUPPORT_END
#endif
#endif
#endif

    /* Finally De allocate call context */
     icf_dbm_dealloc_call_cntxt_blk(p_glb_pdb,
                p_call_ctxt->call_id,
                p_ecode);

    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}

#ifdef ICF_QOS_SUPPORT
#ifdef IMS_CLIENT
#ifdef ICF_NW_ACTIVATE
/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_extract_media_authorization_token
 *
 * DESCRIPTION: The function extracts P-Media-Authorization header from
 *                sip message and fills its value in call context.
 *              
 *
 * RETURNS: icf_return_t 
 *
************************************************************************/  
icf_return_t 
icf_ssa_extract_media_authorization_token(
       INOUT  icf_ssa_pdb_st          *p_ssa_pdb,
       INOUT     SipMessage                    *pSipMsg)
{
    en_HeaderType                 dType = SipHdrTypeAny;    
    Sdf_ty_u32bit                dCount = 0;
    icf_uint8_t              header_name[ICF_MAX_STR_LEN] = "P-Media-Authorization"; 
    SipError                    sip_err = 0;
    icf_uint32_t             header_index = ICF_NULL;
    SipUnknownHeader    *p_unknown_hdr = SIP_NULL;
    icf_return_t             ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
     /* Find the header type for the header name */
    icf_ssa_get_hdr_type_from_name(header_name, &dType, &sip_err);
        
    /* There can be multiple hdrs for that type */
    if (SipFail == sip_getHeaderCount(pSipMsg, dType, &dCount,
        (SipError *)&sip_err))
    {
        /*ICF_SSA_TRACE(("\nFailed to get Header Count "))*/
        ret_val  = ICF_FAILURE;
    }
    else if (0 == dCount)
    {
        /*ICF_SSA_TRACE(("\nP-Media-Authorization Header not present "))*/
        ret_val  = ICF_SUCCESS;
    }
    else
    {
        for (header_index = 0; header_index < dCount; header_index++)
        {
            if (Sdf_co_fail == sip_listGetAt(
                &(pSipMsg->
                pGeneralHdr->slUnknownHdr),
                header_index,(Sdf_ty_pvoid *)&p_unknown_hdr,
                &(sip_err)))
            {
                ICF_PRINT(("\n[SSA]: Failure in getting the pHeader from list"));
                ret_val = ICF_FAILURE;
                break;
            }
            else if ( ICF_NULL ==
#ifdef ICF_WITH_MUATK_2_2
                icf_port_strcmp(p_unknown_hdr->pStr1, header_name))
#else
                icf_port_strcmp(p_unknown_hdr->pName, header_name))
#endif
            {

#ifdef ICF_WITH_MUATK_2_2
                icf_uint8_t       *p_value = p_unknown_hdr->pStr2;
#else
                icf_uint8_t       *p_value = p_unknown_hdr->pBody;
#endif
                /* If header is being allocated for the first time */
                if (ICF_NULL == p_ssa_pdb->p_glb_pdb->p_call_ctx->p_auth_token)
                {
                    /* Allocate memory for header value in call context */
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        ICF_PORT_SIZEOF(icf_nm_auth_token_st),
                        ICF_MEM_COMMON, 
                        (icf_void_t*)(p_ssa_pdb->p_glb_pdb->p_call_ctx->p_auth_token),
                        ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)    
                }
                /* Copy authorization token in call context */
                icf_port_strcpy(p_ssa_pdb->p_glb_pdb->p_call_ctx->p_auth_token->octets,
                    p_value);

                p_ssa_pdb->p_glb_pdb->p_call_ctx->p_auth_token->num_of_octets = 
                    icf_port_strlen(p_value);

                ret_val = ICF_SUCCESS;
                break; /* We are taking only first authorization header */
            }
        } /* end of loop on headers */
    } /* End of else */

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
#endif
#endif
#endif

/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_populate_app_specific_hdrs
 *
 * DESCRIPTION: The function populates the application specific headers as  
 *                provided by the application during APP ADD in the call context. 
 *              
 *
 * RETURNS: icf_return_t 
 *
************************************************************************/  
icf_return_t 
icf_ssa_populate_app_specific_hdrs(
       INOUT  icf_ssa_pdb_st                        *p_ssa_pdb,
       INOUT    icf_uint8_t                            module_id,
       INOUT    icf_void_t                            *p_ctx,
       INOUT     SipMessage                                *pSipMsg,       
       OUT   icf_error_t                            *p_ecode)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_app_conf_st*            p_app_conf = ICF_NULL;
    icf_uint32_t                iterator1=0,index=0;
    icf_header_st**            p_p_hdr = ICF_NULL;
    icf_header_list_st*        p_hdr_list = ICF_NULL;
    icf_uint8_t*                p_temp_buff = ICF_NULL;
    icf_header_name_st*        p_name = SIP_NULL;
    en_HeaderType                 dType = SipHdrTypeAny;    
    Sdf_ty_u32bit                dCount = 0;
    icf_uint8_t*                p_token = ICF_NULL;
    icf_int8_t*                p_remainingbuff = ICF_NULL;
    SipError                    sip_err = 0;
    /* This is used as a temporary string for storing header name
     * along with a ":" or any one extra character as FSS sip stack
     * inserts "\0" in place of last character.
     */
    icf_uint8_t              pString[ICF_MAX_STR_LEN + 1] = "";
    icf_app_id_t                app_id = 0;
        
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    
        
    if ( ICF_INT_MODULE_CC == module_id)
    {
        app_id = ((icf_call_ctx_st*)p_ctx)->app_id;
        p_hdr_list = &(((icf_call_ctx_st*)p_ctx)->header_list);
    }
    else if( ICF_INT_MODULE_REGM == module_id )
    {
        icf_uint32_t            loop_app= ICF_NULL;
        
        for (loop_app = 0; loop_app < p_ssa_pdb->p_glb_cfg_data->max_applications;
                            loop_app++)
        {
            if (ICF_TRUE == ((icf_rgm_context_st*)p_ctx)->p_app_data_list[loop_app].is_valid)
            {
                if( 
                    ( ( ((icf_rgm_context_st*)p_ctx)->p_app_data_list[loop_app].app_indicator) 
                        & ICF_RGM_APP_CFM_SENT ) == ICF_NULL )
                {
                    app_id = ((icf_rgm_context_st*)p_ctx)->p_app_data_list[loop_app].app_id;
                    p_hdr_list = &(((icf_rgm_context_st*)p_ctx)->p_app_data_list[loop_app].inc_header_list);

                    /*patch*/
                    if( p_hdr_list->count)
                    {
                        /*free the list*/
                        icf_cmn_free_header_list(p_ssa_pdb->p_glb_pdb,
                                p_hdr_list,
                                p_ssa_pdb->p_ecode);
                    }
                    break;
                }
            }

        }/* for loop on app_data_list ends */
        if (ICF_NULL == p_hdr_list)
          return ICF_SUCCESS;
    }


    else if( ICF_INT_MODULE_SIC == module_id )
    {
        app_id = ((icf_sic_ctx_st*)p_ctx)->app_id;
        p_hdr_list = &(((icf_sic_ctx_st*)p_ctx)->header_list);

    }
    else
        return ICF_SUCCESS;
    



    /* Pass the application id to get app specific data from dbm */
    if (ICF_FAILURE == icf_cfg_fetch_app_conf(
        p_ssa_pdb->p_glb_pdb, app_id, &p_app_conf, p_ecode))
    {
/*        ICF_SSA_TRACE(("\nSSA Fetch App Conf Data Func Failed"))*/
            ret_val = ICF_SUCCESS;
    }
    
    /* Assign p_app_conf->call_type to p_call_ctx->call_type if NFS call */
    else if(ICF_NULL != p_app_conf)
    {
        if(( ICF_INT_MODULE_CC == module_id) &&
           ((icf_call_ctx_st*)p_ctx)->call_type == ICF_NULL)
        {
            if(ICF_NULL != p_app_conf->call_type)
            {
            /* Assign default type as specified by app */
            ((icf_call_ctx_st*)p_ctx)->call_type = p_app_conf->call_type;
            }
            else
            {
                ((icf_call_ctx_st*)p_ctx)->call_type = ICF_CALL_TYPE_AUDIO;
            }
        }
        
        /* Take out hdr info, which hdrs are required by application */
        if (p_app_conf->hdr_list.count != 0)
        {
            ret_val = icf_cmn_free_header_list(p_ssa_pdb->p_glb_pdb,
	          				p_hdr_list,
						p_ssa_pdb->p_ecode);
            if (ICF_FAILURE == ret_val)
            {
               return ICF_FAILURE;
            }
                    	
            /* Assign pointers to start of list */
            p_name = p_app_conf->hdr_list.hdr;
            
            /* Iterate through all the headers */ 
            for (p_p_hdr = &(p_hdr_list->hdr) ,iterator1 = 0; 
            iterator1 < p_app_conf->hdr_list.count; 
            iterator1++,p_name = p_name->next)
            {
                
                /* This is a temporary patch due to incorrect behaviour 
                 * of sip stack we have to insert one extra character in name 
                 * before passing it to sip_getTypeFromName.
                 */
                icf_port_strcpy(pString, p_name->hdr_name.str);
				/*Fix done for SPR-18722 : CSR-1-6068965*/
                if(0 == Sdf_mc_strcasecmp((icf_int8_t *)pString,(icf_int8_t *)"req-uri"))
                {
                    icf_string_st req_line;
                    /* Initialize the string */
                    icf_port_strcpy(req_line.str,(icf_uint8_t *)"");
                    /* Extract the req-uri */
                    if(ICF_FAILURE == icf_ssa_get_reqline_as_string(pSipMsg, req_line.str))
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else 
                    {
                        if(0 == icf_port_strcmp(req_line.str,(icf_uint8_t *)""))
                        {
                            /* No request uri extracted, continue */
                            continue;
                        }
                        /* allocate memory for first header node and add to List*/
                        ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                            ICF_PORT_SIZEOF(icf_header_st),
                            ICF_MEM_COMMON, 
                            *p_p_hdr,
                            ICF_DONOT_RET_ON_FAILURE, p_ecode, ret_val)
                        
                    }
                    if (ICF_FAILURE == ret_val)
                    {
                        fast_memfree(0, p_temp_buff, &sip_err);
                        return ICF_FAILURE;
                    }
                    else
                    {
                        (*p_p_hdr)->next = ICF_NULL;
                        /* Increment the node pointer */
                        /* Populate Name/Value for header in call context */                
                        icf_port_strncpy((icf_int8_t *)(*p_p_hdr)->hdr_name.str,(const icf_int8_t *)pString, ICF_MAX_STR_LEN - 2);
                        (*p_p_hdr)->hdr_name.str[ICF_MAX_STR_LEN - 1] = '\0';
                        (*p_p_hdr)->hdr_name.str_len = (icf_uint16_t)icf_port_strlen((*p_p_hdr)->hdr_name.str);
                        
                       
                        icf_port_strncpy((icf_int8_t *)(*p_p_hdr)->hdr_value.str,(const icf_int8_t *)req_line.str, ICF_MAX_LARGE_STR_LEN - 2);
                        (*p_p_hdr)->hdr_value.str[ICF_MAX_LARGE_STR_LEN - 1] = '\0';
                        (*p_p_hdr)->hdr_value.str_len = (icf_uint16_t)icf_port_strlen((*p_p_hdr)->hdr_value.str);
 
                        p_hdr_list->count++;
                        p_p_hdr = &((*p_p_hdr)->next);
                    }
                    continue;
                }

                /* Find the header type for the header name */
                icf_ssa_get_hdr_type_from_name(pString, &dType, &sip_err);
                
                
                /* There can be multiple hdrs for that type */
                if (sip_getHeaderCount(pSipMsg, dType, &dCount, \
                    &sip_err) == SipFail)
                {
                    if (SipMessageResponse == pSipMsg->dType 
                        && SipTrue != isSipReqHeader(dType))
                    {
                        /*ICF_SSA_TRACE(("\nFailed to get Header Count "))*/
                        return ICF_FAILURE;
                    }
                    else
                    {
                        dCount = 0;
                    }
                }
                /* Iterate through the list to get all headers of type dType*/
                for(index = 0; index < dCount; index++)
                {
                    /* Construct Header from SipMessage */
                    sip_getHeaderAsStringAtIndex(pSipMsg,dType,((SIP_S8bit **)&p_temp_buff)\
                                                 ,index, &sip_err);
                    
                    /* Tokenize the : separated string into hdr name/value.*/
                    p_token = (icf_uint8_t *)icf_port_strtokr((icf_int8_t *)p_temp_buff,(const icf_int8_t *)":",&p_remainingbuff); 
                    if (ICF_NULL == p_token)
                    {                    
                        ret_val = ICF_FAILURE;
                    }
                    
                    /* If unknown header compare with the required header.
                    * If matches, allocate memory and store in call ctxt,
                    * else continue with next header from list.
                    */
                    else if ( (dType == SipHdrTypeUnknown) && 
                        (0 != icf_port_strcasecmp((const icf_int8_t *)p_name->hdr_name.str,(const icf_int8_t *)p_token)) )
                    {            
                        /* free the memory allocated for p_temp_buff */
                        fast_memfree(0, p_temp_buff, &sip_err);
                        continue;
                    }
                    
                    else
                    {
                        /* allocate memory for header node and add to List*/
                        ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                            ICF_PORT_SIZEOF(icf_header_st),
                            ICF_MEM_COMMON, 
                            *p_p_hdr,
                            ICF_DONOT_RET_ON_FAILURE, p_ecode, ret_val)
                    }
                    
                    if (ICF_FAILURE == ret_val)
                    {
                        /* free the memory allocated for p_temp_buff */
                        fast_memfree(0, p_temp_buff, &sip_err);
                        return ICF_FAILURE;
                    }
                    
                    
                    /* Increment the header count by one */
                    p_hdr_list->count++;
                    (*p_p_hdr)->next = ICF_NULL;
                    
                    /* Populate Name/Value for header in call context */                
                    icf_port_strncpy((icf_int8_t *)(*p_p_hdr)->hdr_name.str,(const icf_int8_t *)p_token,\
                              ICF_MAX_STR_LEN-2);
                    (*p_p_hdr)->hdr_name.str[ICF_MAX_STR_LEN - 1]='\0';
                    (*p_p_hdr)->hdr_name.str_len = (icf_uint16_t )icf_port_strlen((*p_p_hdr)->hdr_name.str);
                    
                    icf_port_strncpy((icf_int8_t *)(*p_p_hdr)->hdr_value.str,p_remainingbuff, ICF_MAX_LARGE_STR_LEN - 2);
                    (*p_p_hdr)->hdr_value.str[ICF_MAX_LARGE_STR_LEN - 1] = '\0';
                    (*p_p_hdr)->hdr_value.str_len = (icf_uint16_t)icf_port_strlen((*p_p_hdr)->hdr_value.str);

                    /* Move pointer to next node */
                    p_p_hdr = &((*p_p_hdr)->next);
                    
                    /* free the memory allocated for p_temp_buff */
                    fast_memfree(0, p_temp_buff, &sip_err);
                                    
                }
                /* Move forward in app list */
            } /* for ends */
        } /* if ends */
    }
    else if(ICF_NULL == p_app_conf)
    {
        if(( ICF_INT_MODULE_CC == module_id) &&
           ((icf_call_ctx_st*)p_ctx)->call_type == ICF_CALL_TYPE_INVALID)
        {
            /* Assign default type as specified by app */
            ((icf_call_ctx_st*)p_ctx)->call_type = ICF_CALL_TYPE_AUDIO;
        }
    }

    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}





/*****************************************************************************
 * FUNCTION:         icf_ssa_insert_unknown_hdr_in_sip_msg
 *
 * DESCRIPTION:     This function forms and inserts an unknown 
 *                    header into the SIP message passed  to it
 *                    The name of the header and the contents are
 *                    passed to this function.
 * 
 *****************************************************************************/
 icf_return_t icf_ssa_insert_unknown_hdr_in_sip_msg(
         INOUT      icf_ssa_pdb_st   *p_ssa_pdb,
         INOUT      icf_uint8_t      *p_hdr_name,
         INOUT      icf_uint8_t      *p_hdr_contents,
         INOUT    SipMessage          *p_sip_msg)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_return_t memfree_retval;
    SipHeader    *p_sip_header = SIP_NULL;
    SipError    sip_error;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
#ifdef ICF_STRICT_TEST    
    if(ICF_NULL == p_hdr_contents)
    {
        ICF_ALARM(((icf_uint8_t *)" :[SSA]: Invalid Value in unknown header\n"));
        ret_val=ICF_FAILURE;
    }
    else if(ICF_NULL == *p_hdr_contents)
    {
        ICF_ALARM(((icf_uint8_t *)" :[SSA]: Invalid Value in unknown header\n"));
        ret_val = ICF_FAILURE;
    }
    else
#endif
    if (SipFail == sip_initSipHeader(&p_sip_header, SipHdrTypeUnknown, &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to init SIP header"));
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == sip_setNameInUnknownHdr(p_sip_header, sip_strdup((const icf_int8_t *)p_hdr_name, 0), &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to Set name in SIP header"));
        sip_freeSipHeader(p_sip_header);
        ret_val = ICF_FAILURE;
    }
     else if (SipFail == sip_setBodyInUnknownHdr(p_sip_header, sip_strdup((const icf_int8_t *)p_hdr_contents, 0), &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to Set body in SIP header"));
        sip_freeSipHeader(p_sip_header);
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == sip_insertHeaderAtIndex(p_sip_msg, p_sip_header, 0, &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to Set Header at index in SIP header"));
        sip_freeSipHeader(p_sip_header);
        ret_val = ICF_FAILURE;
    }

    sip_freeSipHeader(p_sip_header);
    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, p_sip_header,
        ICF_MEM_COMMON, p_ssa_pdb->p_ecode, memfree_retval)

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;
}







/*****************************************************************************
 * FUNCTION:         icf_ssa_insert_header_list_in_sip_msg
 *
 * DESCRIPTION:         This function inserts the header linked list into a
 *            SIP message passed  to it. The clear_list parameter specifies whether 
 *            the memory associated with this list is to be freed or not
 *            if Set to true the memory is freed.
 * 
 *****************************************************************************/
icf_return_t icf_ssa_insert_header_list_in_sip_msg(
         INOUT      icf_ssa_pdb_st*        p_ssa_pdb,
         INOUT      icf_header_list_st*  p_hdr_list,
         INOUT      icf_boolean_t        clear_list,
         INOUT    SipMessage*             p_sip_msg)
{



    icf_uint16_t list_count    = ICF_NULL;
    icf_header_st* p_hdr = ICF_NULL;
    icf_error_t ecode;
    icf_return_t ret_val = ICF_SUCCESS;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) 

    if (ICF_NULL == p_hdr_list)
    {
        return ICF_SUCCESS;
    }

    list_count = (icf_uint16_t )p_hdr_list->count;
    p_hdr = p_hdr_list->hdr;

    while (list_count > 0 && ICF_NULL != p_hdr) 
    {     
           if(((icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"CSeq"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"Call-ID"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"To"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"From"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"Via"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"Contact"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"Content-Length")))&& 
             (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                  p_ssa_pdb, 
                  p_hdr->hdr_name.str,
                  p_hdr->hdr_value.str,
                  p_sip_msg)))
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header"));
                ret_val = ICF_FAILURE;
                break;
        }
        list_count = (icf_uint16_t)(list_count - 1);
        p_hdr = p_hdr->next;
    }

    
    /* Free this list*/
    if((ICF_TRUE == clear_list) && (p_hdr_list->count > 0))
    {
        if ( ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx)
        {
            icf_cmn_free_header_list(p_ssa_pdb->p_glb_pdb, 
                &(p_ssa_pdb->p_glb_pdb->p_call_ctx->persistent_header_list), 
                &ecode);
            
            icf_cmn_clone_header_list(p_ssa_pdb->p_glb_pdb,
                p_hdr_list,
                &(p_ssa_pdb->p_glb_pdb->p_call_ctx->persistent_header_list),
                &ecode);
        }

        icf_cmn_free_header_list(p_ssa_pdb->p_glb_pdb, p_hdr_list, &ecode);
        
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;

}








/*****************************************************************************
 * FUNCTION:         icf_ssa_insert_tag_list_in_sip_msg
 *
 * DESCRIPTION:         This function inserts the tag linked list into a
 *            SIP message passed  to it. The clear_list parameter specifies whether 
 *            the memory associated with this list is to be freed or not
 *            if Set to true the memory is freed.
 * 
 *****************************************************************************/

icf_return_t icf_ssa_insert_tag_list_in_sip_msg(
        INOUT      icf_ssa_pdb_st*      p_ssa_pdb,
        INOUT      icf_tag_list_st*     p_tag_list,
        INOUT      icf_boolean_t        clear_list,
        INOUT    SipMessage*                p_sip_msg)
{

    
    icf_uint16_t list_count = ICF_NULL;
    icf_tag_st* p_tag = ICF_NULL;
    icf_error_t ecode;
    icf_return_t ret_val = ICF_SUCCESS;
    icf_uint8_t    *p_method=ICF_NULL;
    Sdf_st_error    SdfError;
    en_HeaderType hdr_type = SipHdrTypeAny;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) 
    
    list_count = (icf_uint16_t)p_tag_list->count;
    p_tag = p_tag_list->tag;

    sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg,((Sdf_ty_s8bit **)&p_method),&SdfError);
    
    while (list_count > 0 && ICF_NULL != p_tag) 
    {
	    /*Fix done for SPR-18722 : CSR-1-6068965*/
        if(0 == Sdf_mc_strcasecmp((icf_int8_t *)p_tag->hdr_name.str,(icf_int8_t *)"req-uri"))
        {
            SipReqLine *pReqLine=ICF_NULL;
            SipAddrSpec    *p_addr_spec = SIP_NULL;
            SipError sip_err;
            if (SipFail == sip_getReqLineFromSipReqMsg(p_sip_msg,
                &pReqLine,&sip_err))
            {
                return ICF_FAILURE;
            }
#ifdef ICF_WITH_MUATK_2_2
            p_addr_spec = pReqLine->pAddrSpec;
#else
            p_addr_spec = pReqLine->pRequestUri;
#endif
            if (p_tag->tag_type & ICF_TAG_TYPE_SIP_URI_PARAM)
            {
                icf_ssa_append_sip_uri_param_in_addr_spec(
                    p_ssa_pdb,p_tag->tag_value.str,p_addr_spec);
            }
            else if (p_tag->tag_type & ICF_TAG_TYPE_SIP_URI_HDR_PARAM)
            {
                icf_ssa_append_sip_uri_hdr_param_in_addr_spec(
                    p_ssa_pdb,p_tag->tag_value.str,p_addr_spec);
            }
            else if (p_tag->tag_type & ICF_TAG_TYPE_HDR_PARAM)
            {
                ICF_PRINT(
                    ((icf_uint8_t *)"\n[SSA]: Ignoring Tag-Value=%s,Tag-Type=HDR_PARAM in req-uri\n",
                    p_tag->tag_value.str));
            }
            else
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Ignoring Invalid Tag-Type\n"));
            }
            sip_freeSipReqLine(pReqLine);
        }
        else
        {
            icf_ssa_get_hdr_type_from_name(p_tag->hdr_name.str, &hdr_type,
                (SipError*)&SdfError.stkErrCode);
            
            if((!icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") &&
                ((hdr_type == SipHdrTypeContactNormal)   ||
                (hdr_type == SipHdrTypeContactWildCard) ||
                (hdr_type == SipHdrTypeContactAny)
                )
                )
                )
            {
            /* We will not append the tag to contact list of
            * Register request as while making the contact 
                * address this thing has taken care of */
            }
            
            else if (ICF_FAILURE == icf_append_tag_params_to_hdr(
                p_ssa_pdb, p_tag, p_sip_msg))
                
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to append tag to header"));
                ret_val = ICF_FAILURE;
                break;
            }
        }
        list_count = (icf_uint16_t )(list_count - 1);
        p_tag = p_tag->next;
    }
  
    /* Free this list*/
     if((ICF_TRUE == clear_list) && (p_tag_list->count > 0))
    {
        icf_cmn_free_tag_list(p_ssa_pdb->p_glb_pdb, p_tag_list, &ecode);
    }
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb) 
    return ret_val;  
}


/*****************************************************************************
 * FUNCTION:     icf_ssa_get_hdr_type_from_name
 * DESCRIPTION:  This function gets the Sip Header Type based on the header 
 *               string passed to it
 *****************************************************************************/
icf_void_t icf_ssa_get_hdr_type_from_name
        (icf_uint8_t *pName, en_HeaderType *pType, SipError *pError)
{
    en_HeaderForm     dForm;
    icf_uint8_t       *pTempStr = ICF_NULL;
    icf_uint32_t      dSize = 0;

    if (pName == SIP_NULL)
    {
        *pType = SipHdrTypeUnknown;
        return;
    }

    dSize = sip_strlen((icf_int8_t *)pName);
    pTempStr =(icf_uint8_t *)((char *) fast_memget(ACCESSOR_MEM_ID, dSize+1, SIP_NULL));
    if (pTempStr == SIP_NULL)
    {
        *pType = SipHdrTypeUnknown;
        return;
    }
    sip_strncpy((icf_int8_t *)pTempStr, (icf_int8_t *)pName, dSize);
    pTempStr[dSize]='\0';

    *pType = sip_getHeaderTypeFromString((icf_int8_t *)pTempStr, \
            (icf_int8_t *)(pTempStr + dSize), &dForm);
    
    fast_memfree(0, pTempStr , SIP_NULL);
    *pError = E_NO_ERROR;

}


/*****************************************************************************
 ** FUNCTION:           icf_ssa_validate_sip_uri_param_in_sip_url
 **
 ** DESCRIPTION:        This Function validates uri_parameters 
 **                        in the SipUrl. 
 **
 *****************************************************************************/
icf_return_t icf_ssa_validate_sip_uri_param_in_sip_url(
        icf_ssa_pdb_st    *p_ssa_pdb,
        SipUrl                *p_sip_url,
        icf_uint32_t        dType)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    SipError            dError;
    icf_uint32_t dCount = 0;
    icf_uint32_t index = 0;
    icf_uint8_t  *p_name = ICF_NULL;
    SipParam *p_param = ICF_NULL;
    icf_uint8_t   is_delete_param = ICF_FALSE;

    if(ICF_NULL == p_ssa_pdb)
    {
        return ICF_FAILURE;
    }
    
	p_ssa_pdb=p_ssa_pdb;
	    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    if ( SipFail !=
        sip_getUrlParamCountFromUrl(p_sip_url,&dCount,&dError))
    {
        for ( index = 0; index < dCount;index++)
        {
            /* if a parameter is deleted in previous iteration
             * then number of elements in the parameters List
             * will be reduced by one
             */
            if ( ICF_TRUE == is_delete_param && index != 0)
            {
                index--;
                dCount--;
                is_delete_param = ICF_FALSE;
            }

            if( SipFail !=
                sip_getUrlParamAtIndexFromUrl(p_sip_url,&p_param,index,&dError))
            {
                if( SipFail !=
                    sip_getNameFromSipParam(p_param,((SIP_S8bit **)&p_name),\
                    &dError))
                {
                    if( 0 == icf_port_strcmp((icf_uint8_t *)"ttl",p_name))
                    {
                        if( SipHdrTypeFrom == dType ||
                            SipHdrTypeTo == dType ||
                            SipHdrTypeContactNormal == dType ||
                            SipHdrTypeContactWildCard == dType ||
                            SipHdrTypeContactAny  == dType)
                        {
                            is_delete_param = ICF_TRUE;
                            ICF_ALARM(((icf_uint8_t *)" :[SSA]: ttl not allowed in "
                                "From/To/Contact Headers\n"));
                        }
                    }
                    else if( 0 == icf_port_strcmp((icf_uint8_t *)"maddr",p_name))
                    {
                        if( SipHdrTypeFrom == dType ||
                            SipHdrTypeTo == dType)
                        {
                            is_delete_param = ICF_TRUE;
                            ICF_ALARM(((icf_uint8_t *)"\n[SSA]: maddr not allowed in "
                                "From/To Headers\n"));
                        }
                    }
                    else if( 0 == icf_port_strcmp((icf_uint8_t *)"lr",p_name))
                    {
                        if( SipHdrTypeFrom == dType ||
                            SipHdrTypeTo == dType)
                        {
                            is_delete_param = ICF_TRUE;
                            ICF_ALARM(((icf_uint8_t *)" :[SSA]: lr not allowed in "
                                "From/To Headers\n"));
                        }
                    }
                    else if( 0 == icf_port_strcmp((icf_uint8_t *)"transport",p_name))
                    {
                        if( SipHdrTypeFrom == dType ||
                            SipHdrTypeTo == dType)
                        {
                            is_delete_param = ICF_TRUE;
                            ICF_ALARM(((icf_uint8_t *)" :[SSA]: transport not allowed in "
                                "From/To Headers\n"));
                        }
                    }
                    if ( ICF_TRUE == is_delete_param)
                    {
                        sip_deleteUrlParamAtIndexInUrl(p_sip_url,index,&dError);
                    }
                    sip_freeSipParam(p_param);
                    p_param = ICF_NULL;
                }    
            }
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/*****************************************************************************
 ** FUNCTION:           icf_ssa_append_sip_uri_param_in_sip_hdr
 **
 ** DESCRIPTION:        This Function Appends uri_parameters in the SIP Header
 **
 *****************************************************************************/
icf_return_t icf_ssa_append_sip_uri_param_in_sip_hdr(
        icf_ssa_pdb_st    *p_ssa_pdb,
        icf_uint8_t    *p_sip_uri_param,
        SipHeader        *p_header)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    SipAddrSpec            *p_addr_spec = ICF_NULL;
    SipError            dError;
    SipUrl                *p_sip_url = ICF_NULL;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    switch(p_header->dType)
    {
        case SipHdrTypeFrom:
        case SipHdrTypeRecordRoute:
        case SipHdrTypeReferTo:
        case SipHdrTypeRoute:
        case SipHdrTypeTo:
        case SipHdrTypeContactNormal:
        case SipHdrTypeContactWildCard:
        case SipHdrTypeContactAny:

            if ( SipFail != 
                sip_getAddrSpecFromCommonHdr(p_header,&p_addr_spec,&dError))
            {
                ret_val = icf_ssa_append_sip_uri_param_in_addr_spec(p_ssa_pdb,
                    p_sip_uri_param,p_addr_spec);
                if ( ICF_SUCCESS == ret_val)
                {
                    if ( SipFail != 
                        sip_getUrlFromAddrSpec(p_addr_spec,&p_sip_url,&dError))
                    {
                        icf_ssa_validate_sip_uri_param_in_sip_url(p_ssa_pdb,
                            p_sip_url,p_header->dType);
                        sip_freeSipUrl(p_sip_url);
                    }
                }
                sip_freeSipAddrSpec(p_addr_spec);
            }
            else
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]: SIP_URI paramter Ignored\n"));
                ret_val = ICF_FAILURE;
            }
        break;
        
        default :
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]: SIP_URI paramter Ignored\n"));
            ret_val = ICF_FAILURE;
            break;
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_append_sip_uri_hdr_param
 **
 ** DESCRIPTION:        This Function Appends sip_uri_headers in the SIP Header
 **
 *****************************************************************************/
icf_return_t icf_ssa_append_sip_uri_hdr_param_in_sip_hdr(
        icf_ssa_pdb_st    *p_ssa_pdb,
        icf_uint8_t        *p_sip_uri_hdr_param,
        SipHeader            *p_header)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    SipAddrSpec            *p_addr_spec = ICF_NULL;
    SipError            dError;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    switch(p_header->dType)
    {
        case SipHdrTypeRecordRoute:
        case SipHdrTypeReferTo:
        case SipHdrTypeRoute:
        case SipHdrTypeContactNormal:
        case SipHdrTypeContactWildCard:
        case SipHdrTypeContactAny:

            if ( SipFail != 
                sip_getAddrSpecFromCommonHdr(p_header,&p_addr_spec,&dError))
            {
                ret_val = icf_ssa_append_sip_uri_hdr_param_in_addr_spec(
                    p_ssa_pdb,p_sip_uri_hdr_param,p_addr_spec);
                sip_freeSipAddrSpec(p_addr_spec);
            }
            else
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]: SIP_URI header parameter, Ignored\n"));
                ret_val = ICF_FAILURE;
            }
            break;
        case SipHdrTypeTo:
        case SipHdrTypeFrom:
            ICF_ALARM(((icf_uint8_t *)" :[SSA]: SIP_URI header parameter, not allowed in To/From"));
            break;
        default :
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]: SIP_URI header parameter, Ignored\n"));
            ret_val = ICF_FAILURE;
            break;
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


/*****************************************************************************
 ** FUNCTION:           icf_ssa_append_sip_uri_param_in_addr_spec
 **
 ** DESCRIPTION:        This Function Appends uri_parameters in the addr spec
 **
 *****************************************************************************/
icf_return_t icf_ssa_append_sip_uri_param_in_addr_spec(
        icf_ssa_pdb_st    *p_ssa_pdb,
        icf_uint8_t    *p_sip_uri_param,
        SipAddrSpec        *p_addr_spec)
{
     icf_return_t        ret_val = ICF_SUCCESS;
    SipList                tmpList;
    SipUrl                *p_sip_url = ICF_NULL;
    SipParam            *p_param = ICF_NULL;
    SipError            dError;
    icf_uint32_t        dLength = 0;
    icf_uint32_t        dCount = 0;
    icf_uint32_t        dSize = 0;
    icf_uint32_t        index = 0;

    if(ICF_NULL == p_ssa_pdb)
    {
         return ICF_FAILURE;
    }   
    
	p_ssa_pdb=p_ssa_pdb;    
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /*for pEnd*/
    dLength = icf_port_strlen(p_sip_uri_param);
    dLength--;
    if ( p_addr_spec->dType == SipAddrSipUri ||
         p_addr_spec->dType == SipAddrSipSUri)
    {
        
         /* steps:
          * 1) Get the SipUrl from the Addr-Spec
          * 2) Call sip_parseSipParam to create a SipList
          *    from the tag_value(p_sip_uri_param) passed 
          *    by the application
          * 3) Extract each SipParam from the SipList and 
          *    append into SipUrl's SipList for uri-params
          */
        if ( SipFail !=
            sip_getUrlFromAddrSpec(p_addr_spec,&p_sip_url,&dError))
        {
            sip_listInit(&tmpList, __sip_freeSipParam, &dError);
            
            if( SipFail != sip_parseSipParam(&tmpList,
                (SIP_S8bit*)p_sip_uri_param,
                (SIP_S8bit*)(p_sip_uri_param+dLength),
                SipFalse,(SIP_S8bit)';',&dError))
            {
                sip_listSizeOf(&tmpList,&dSize,&dError);
                
                sip_getUrlParamCountFromUrl(p_sip_url,&dCount,&dError);
                
                for ( index = 0; index < dSize; index++)
                {
                    sip_listGetAt(
                        &tmpList,index,(SIP_Pvoid*)&p_param,&dError);
                    sip_listInsertAt(
                        (SipList*)&(p_sip_url->slParam),index+dCount,
                        (SIP_Pvoid*)p_param,&dError);
                }
                /* sip_listDeleteAll will call freefunc of SipParam and frees the */
                /* SipParam since dRefCount is One.*/
                tmpList.freefunc = ICF_NULL;
                sip_listDeleteAll(&tmpList,&dError);
                
            }
            else
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Tag-Value: %s,Parsing Failed\n",
                    p_sip_uri_param));
                ret_val = ICF_FAILURE;
            }
            sip_freeSipUrl(p_sip_url);
        }
        else
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Tag-Value: %s,Tag-Type=SIP_URI_PARAM,Ignored\n",
                p_sip_uri_param));
            ret_val = ICF_FAILURE;
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
        
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_append_sip_uri_hdr_param_in_addr_spec
 **
 ** DESCRIPTION:        This Function Appends uri_parameters in addr_spec
 **
 *****************************************************************************/
icf_return_t icf_ssa_append_sip_uri_hdr_param_in_addr_spec(
        icf_ssa_pdb_st    *p_ssa_pdb,
        icf_uint8_t    *p_sip_uri_hdr_param,
        SipAddrSpec        *p_addr_spec)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    icf_return_t        dummy_retval = ICF_SUCCESS;
    SipUrl                *p_sip_url = ICF_NULL;
    SipError            dError;
    icf_uint32_t        dHdrLength = 0;
    icf_uint32_t        dLength = 0;
    icf_uint8_t        *p_tmp_hdr = ICF_NULL;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    if ( p_addr_spec->dType == SipAddrSipUri ||
         p_addr_spec->dType == SipAddrSipSUri)
    {

        if ( SipFail !=
            sip_getUrlFromAddrSpec(p_addr_spec,&p_sip_url,&dError))
        {
            /* If p_sip_uri->pHeader is not NULL then
             * Some header params already exist in the SipUrL.
             * So Append & (header seperator) and then 
             * Append new header params. if p_sip_uri->pHeader
             * is NULL then copy the new header contents into 
             * pHeader.
             */
            if ( ICF_NULL != p_sip_url->pHeader)
            {
                dHdrLength = icf_port_strlen((icf_uint8_t *)p_sip_url->pHeader);
                dLength = icf_port_strlen(p_sip_uri_hdr_param);
                dLength += dHdrLength + 2;
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                    dLength,ICF_MEM_COMMON,
                    p_tmp_hdr,
                    ICF_DONOT_RET_ON_FAILURE,
                    p_ssa_pdb->p_ecode,dummy_retval);
            
                if(ICF_NULL != p_tmp_hdr)
                {    
                    icf_port_strcpy((icf_uint8_t *)p_tmp_hdr,(icf_uint8_t *)p_sip_url->pHeader);
                
                    icf_port_strcat(p_tmp_hdr,(icf_uint8_t *)"&");
                
                    icf_port_strcat(p_tmp_hdr,p_sip_uri_hdr_param);
                }

            }
            else
            {
                dLength = icf_port_strlen(p_sip_uri_hdr_param);
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                    dLength+1,ICF_MEM_COMMON, 
                    p_tmp_hdr,ICF_DONOT_RET_ON_FAILURE, 
                    p_ssa_pdb->p_ecode, dummy_retval)

                if(ICF_NULL != p_tmp_hdr)
                {
                    icf_port_strcpy(p_tmp_hdr,p_sip_uri_hdr_param);
                }
            }
            sip_setHeaderInUrl(p_sip_url,(icf_int8_t *)p_tmp_hdr,&dError);
            
            sip_freeSipUrl(p_sip_url);
        }
        else
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Tag-Value: %s,Tag-Type=SIP_URI_HDR_PARAM,Ignored\n",p_sip_uri_hdr_param));
            ret_val = ICF_FAILURE;
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*****************************************************************************
 * FUNCTION:     icf_append_tag_params_to_hdr
 * DESCRIPTION:  This function adds a new tag passed to it to a known header
 *                value, which is also passed as a parameter
 *****************************************************************************/
icf_return_t icf_append_tag_params_to_hdr(
        INOUT     icf_ssa_pdb_st*        p_ssa_pdb,
        INOUT        icf_tag_st*            p_tag_st,
        INOUT     SipMessage*                p_sip_msg)
{

    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_ty_u32bit        count=0;
    SipError                err;
    SipHeader               dHeader;
    Sdf_st_error        Error;

    en_HeaderType hdr_type = 0;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Get the ENUM Type of the Header*/
    icf_ssa_get_hdr_type_from_name(p_tag_st->hdr_name.str, &hdr_type, &err);

     /* get the header count 
     * For future
     */

    if (hdr_type == SipHdrTypeUnknown)
    {
        /* Unknown Header Tag handling is not supported for this Phase */
    }
    else if((hdr_type == SipHdrTypeContactNormal)   ||
            (hdr_type == SipHdrTypeContactWildCard) ||
            (hdr_type == SipHdrTypeContactAny))
    {
        /* Temporary code for inserting param to Contact header
         * has to be verified 
         */
/*        if(Sdf_co_fail == icf_ssa_AddParamToContactHdrList(
            &(p_sip_msg->pGeneralHdr->slContactHdr),
            p_tag_st->tag_value.str,
            &Error))
        {
            ret_val = ICF_FAILURE ;
        }

        return ret_val;
 */
    }

    if(ICF_FAILURE == ret_val)
    {
    }
    else if(SipFail == sip_getHeaderCount(p_sip_msg, hdr_type, &count, &err))
    {
        ret_val = ICF_FAILURE ;
    }
    /* If multiple headers of same type is found, we choose the first header
     * index 0 and insert the tags to that header, currently this is a doubt-
     * ful issue
     */
    else if(SipFail != sip_getHeaderAtIndex(p_sip_msg, hdr_type, &dHeader, 0, &err))
    {

        if ( p_tag_st->tag_type & ICF_TAG_TYPE_SIP_URI_PARAM)
        {
            icf_ssa_append_sip_uri_param_in_sip_hdr(
                            p_ssa_pdb,p_tag_st->tag_value.str,&dHeader);

        }
        else if ( p_tag_st->tag_type & ICF_TAG_TYPE_SIP_URI_HDR_PARAM)
        {
            icf_ssa_append_sip_uri_hdr_param_in_sip_hdr(
                p_ssa_pdb,p_tag_st->tag_value.str,&dHeader);

        }
        else if ( p_tag_st->tag_type & ICF_TAG_TYPE_HDR_PARAM)
        {
            Sdf_ty_slist        sList;
            if(sdf_listInit(&sList, __sdf_fn_uaFreeString, Sdf_co_false, &Error)             
                == Sdf_co_fail)
            {
                ret_val = ICF_FAILURE ;
            }
            /* We are fooling the system here, instead of sending a list of values
             * corresponding to a tag in a list we send the entire tag=value portion
             * as a string to InsertHeaderParam, thus the second argument.
             */

            if (sdf_ivk_uaInsertHeaderParam (&dHeader,  (icf_int8_t *)p_tag_st->tag_value.str,  
                &sList, 0, &Error) == Sdf_co_fail)
            {
                ret_val = ICF_FAILURE ;
            }
            sdf_listDeleteAll(&sList, &Error);
        } 
        else 
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Ignoring Invalid Tag Type\n"));
        }
        sip_freeSipHeader(&dHeader);
        
    }
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}




/*****************************************************************************
 * FUNCTION:         icf_ssa_insert_body_list_in_sdf_list
 *
 * DESCRIPTION:         This function inserts the message body linked list into 
 *            a Message body list passed  to it. The clear_list parameter specifies
 *          whether the memory associated with this list is to be freed or not
 *            if Set to true the memory is freed.
 * 
 *****************************************************************************/
icf_return_t icf_ssa_insert_body_list_in_sdf_list(
         INOUT     icf_ssa_pdb_st*          p_ssa_pdb,
         INOUT     icf_msg_body_list_st*    p_body_list,
         INOUT     icf_boolean_t            clear_list,
         INOUT   Sdf_ty_slist*            p_list)
{

 /*Message body header changes  Start */


    icf_uint16_t     list_count = ICF_NULL;

    icf_msg_body_st* p_body = ICF_NULL;

    icf_error_t      ecode;
    icf_return_t     ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) 

    list_count = (icf_uint16_t )p_body_list->count;
    p_body = p_body_list->body;
    
    while (list_count > 0 && ICF_NULL != p_body) 
    {
        if (ICF_FAILURE == icf_add_body_to_list(
            p_ssa_pdb, p_body, p_list))
            
        {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to add body to sip message"));
                ret_val = ICF_FAILURE;
                break;
        }
        list_count = (icf_uint16_t )(list_count - 1);
        p_body = p_body->next;
    }
    
    /* Free this list*/
    if(ICF_TRUE == clear_list && p_body_list->count > 0)
    {
        icf_cmn_free_msg_body_list(p_ssa_pdb->p_glb_pdb, p_body_list, &ecode);
    }
    
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb) 

    return ret_val;  
}


/*****************************************************************************
 * FUNCTION:     icf_add_body_to_list
 * DESCRIPTION:  This function adds a Message body to an Existing Message body
 *                 list.
 *****************************************************************************/
icf_return_t icf_add_body_to_list(
        INOUT     icf_ssa_pdb_st*        p_ssa_pdb,
        INOUT       icf_msg_body_st*       p_body,
        INOUT     Sdf_ty_slist*          p_body_list)
{
    Sdf_ty_u8bit    dAddMimeHeader = Sdf_co_false;
    Sdf_ty_s8bit*   pTextBuf;
    Sdf_st_error    error;
    SipMsgBody      *pMsgBody = NULL;
    icf_uint16_t     body_length;
    icf_return_t     memfree_retval;
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_uint8_t      *p_media_type = ICF_NULL;
    icf_uint8_t      count = 0;
    SipHeader        *pHeader=Sdf_co_null;
    Sdf_ty_s8bit      *p_ctype=Sdf_co_null;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) 
    body_length = (icf_uint16_t)(p_body->length + 1);
    count = (icf_uint8_t)p_body->msg_body_hdr_list.count;
    
    if(ICF_NULL != p_body->value)
    {
        pTextBuf = (char*)sdf_memget(0, body_length, &error);
        if(ICF_NULL == pTextBuf)
        {
            return ICF_FAILURE;
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)pTextBuf, (icf_uint8_t *)p_body->value);
        }
    }
    else
    {
        return ICF_FAILURE;
    }
    
    /* Get the media_type from the Content-Type header */
    if(0 != icf_port_strcmp((icf_uint8_t *)"",p_body->content_type.str))
    {
        Sdf_mc_strdup(p_ctype,p_body->content_type.str);

        if(ICF_FAILURE == icf_ssa_get_media_type_from_content_type(p_body->\
                    content_type.str,((Sdf_ty_s8bit ** )&p_media_type)))
        {
            ICF_PRINT(((icf_uint8_t *)"Could not get the media type from content-type"\
                        " header from body header\n"));
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, pTextBuf, ICF_MEM_COMMON,\
                    p_ssa_pdb->p_ecode, memfree_retval)
                ret_val = ICF_FAILURE;
        }
    }
    if((ICF_FAILURE != ret_val) && 
    (Sdf_co_fail == sdf_ivk_uaCreateMessageBodyFromBuffer(&pMsgBody,\
            (Sdf_ty_s8bit *)p_media_type, pTextBuf, p_body->length,\
            dAddMimeHeader,&error)))
    {
        ICF_PRINT(((icf_uint8_t *)"\n Could not add Text Message Body \n"));
        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, \
            pTextBuf, ICF_MEM_COMMON, p_ssa_pdb->p_ecode, memfree_retval)

        ret_val = ICF_FAILURE;
    }
    /* Changes done to remove CRLF : Customer Service Request (CSR) Number :-  1-3571773*/
    else if((0 != count && ICF_NULL != p_body->msg_body_hdr_list.hdr) ||
        (0 != icf_port_strcmp((icf_uint8_t *)"",p_body->content_type.str)))
    {

        if(SipFail == sip_bcpt_initSipMimeHeader(&pMsgBody->pMimeHeader,
                    (SipError*)&(error.stkErrCode)))
        {
            /* Failed to initialize SIP Mime Header */
            ret_val = ICF_FAILURE;
        }

        /* Fill Content-Type header in MIME Header */
        if(0 != icf_port_strcmp((icf_uint8_t *)"",p_body->content_type.str))
        {
            if(sip_initSipHeader(&pHeader,SipHdrTypeContentType,\
                        (SipError*)&(error.stkErrCode))==SipFail)
            {
                sip_bcpt_freeSipMimeHeader(pMsgBody->pMimeHeader);
                sip_freeSipMsgBody(pMsgBody);

                error.errCode=Sdf_en_msgBodyError;
                ret_val = ICF_FAILURE;
            }         

            else if(sip_setMediaTypeInContentTypeHdr(pHeader, p_ctype,\
                        (SipError*)&(error.stkErrCode))==SipFail)
            {
                sip_bcpt_freeSipMimeHeader(pMsgBody->pMimeHeader);
                sip_freeSipMsgBody(pMsgBody);
                error.errCode=Sdf_en_msgBodyError;
                ret_val = ICF_FAILURE;
            }

            else if(sip_bcpt_setContentTypeInMimeHdr(pMsgBody->pMimeHeader,pHeader,\
                        (SipError*)&(error.stkErrCode))==SipFail)
            {
                sip_bcpt_freeSipMimeHeader(pMsgBody->pMimeHeader);
                sip_freeSipMsgBody(pMsgBody);
                error.errCode=Sdf_en_msgBodyError;
                ret_val = ICF_FAILURE;
            }

        }
        /* If message body header list is present then insert the message body 
         * headers 
         */
        if(0 < count && ICF_NULL != p_body->msg_body_hdr_list.hdr)
        {
            ret_val = icf_ssa_fill_msg_body_hdrs(p_ssa_pdb,&(p_body->
                        msg_body_hdr_list),pMsgBody);
            if(ICF_FAILURE == ret_val)
            {
                ICF_PRINT(((icf_uint8_t *)"Could not insert message body headers in"\
                            " Sip message\n"));
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, \
                        pTextBuf, ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode, memfree_retval)

                    sip_bcpt_freeSipMimeHeader(pMsgBody->pMimeHeader);
                sip_freeSipMsgBody(pMsgBody);
                ret_val =  ICF_FAILURE;
            }
        }
    }/*end of Changes done to remove CRLF*/
    if(ret_val != ICF_FAILURE && pMsgBody != NULL)
    {
        if (sdf_listAppend(p_body_list, pMsgBody,&error) == SipFail)
        {
            ICF_PRINT(((icf_uint8_t *)"\nUnable to append the msgbody into the callobject's"\
                        " message body list"));
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, \
            pTextBuf, ICF_MEM_COMMON, p_ssa_pdb->p_ecode, memfree_retval)
            sip_bcpt_freeSipMimeHeader(pMsgBody->pMimeHeader);
            sip_freeSipMsgBody(pMsgBody);
            ret_val = ICF_FAILURE;
        }
    }
    if(pHeader)
    {
        sip_freeSipHeader(pHeader);
        sdf_memfree(Sdf_mc_callHandlerMemId, 
                (Sdf_ty_pvoid*)&pHeader,Sdf_co_null);
    } 
    if(ICF_NULL != p_media_type)
    {
        sdf_memfree(Sdf_mc_callHandlerMemId, 
            (Sdf_ty_pvoid*)&p_media_type,Sdf_co_null);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb) 
    return ret_val;
}
/*Message body header changes Ends*/


/*******************************************************************************
 * FUNCTION:     icf_ssa_form_and_insert_pref_identity_hdr
 * DESCRIPTION:  This function forms and inserts a P-Preferred identity header
 *               into the SIP message .
 ******************************************************************************/
icf_return_t icf_ssa_form_and_insert_pref_identity_hdr(
        INOUT      icf_ssa_pdb_st*    p_ssa_pdb,
        INOUT    SipMessage*            p_otg_sip_msg)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_string_st                 addr_val;



    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

        if(ICF_NULL == p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity)
        {
            /* Its a incoming call so preferd_identity is null */
            return ICF_SUCCESS;
        }

        if( p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_SIP_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sip:");
            icf_port_strcat( addr_val.str, p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity->addr_val.str );
            icf_port_strcat( addr_val.str, (icf_uint8_t *)">");


        }
        else if( p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_TEL_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"tel:");
            icf_port_strcat( addr_val.str, p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity->addr_val.str );
        }
        else
        {
            icf_port_strcpy( addr_val.str, p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity->addr_val.str );
        }




    if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                p_ssa_pdb, 
                (icf_uint8_t*)"P-Preferred-Identity",
                addr_val.str,
                p_otg_sip_msg))
    {
        ICF_DEBUG_PRINT(("\nFailed to insert unknown header (P-Preferred-Identity)"));
        ret_val = ICF_FAILURE;
    }


    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;

}


/*******************************************************************************
 * FUNCTION:     icf_ssa_form_and_insert_request_disposition_hdr
 * DESCRIPTION:  This function forms and inserts a Request-Disposition header
 *               into the SIP message .
 ******************************************************************************/

icf_return_t icf_ssa_form_and_insert_request_disposition_hdr(
        INOUT      icf_ssa_pdb_st*    p_ssa_pdb,
        INOUT    SipMessage*            p_otg_sip_msg)
{
    icf_return_t                     ret_val = ICF_SUCCESS;

    icf_uint8_t hdr[]="Request-Disposition";


    if(0 != p_ssa_pdb->p_glb_cfg_data->sip_compact_hdrs)
    {
      /* Compact headers is on, use the compact form */
        icf_port_strcpy(hdr,(icf_uint8_t *)"d");
    }

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
        p_ssa_pdb, 
        hdr,
        (icf_uint8_t *)"no-fork", /* for SPR 9864 */
        p_otg_sip_msg))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header (Request-Disposition)"));
        ret_val = ICF_FAILURE;
    }


    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;
}


/*****************************************************************************
 * FUNCTION:     icf_ssa_form_and_insert_access_nw_info_hdr
 * DESCRIPTION:  This function forms and inserts a P-Access-Network-Info 
 *               header into the SIP message.
 *****************************************************************************/
icf_return_t icf_ssa_form_and_insert_access_nw_info_hdr(
        INOUT      icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT    SipMessage          *p_otg_sip_msg)
{
    icf_return_t        ret_val = ICF_SUCCESS;

   if(ICF_NULL == p_ssa_pdb)
   {
       return ICF_FAILURE;
   }   
   
	p_ssa_pdb=p_ssa_pdb;   
   
   ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

#ifdef NON_IMS_CLIENT
/* To remove warnings */
 p_otg_sip_msg=p_otg_sip_msg;
#endif 

#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
#if 0
    icf_internal_msg_st* p_internal_msg = ICF_NULL;
    icf_nm_global_st    *p_nm_ptr = ICF_NULL;
    icf_nm_pnwacs_info* p_nwacs_info = ICF_NULL;
    icf_error_t ecode;
    char buff[64];


    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
        sizeof(icf_internal_msg_hdr_st) + sizeof(icf_nm_pnwacs_info_st)
        ICF_MEM_COMMON, (icf_void_t*)p_internal_msg,
        ICF_DONOT_RET_ON_FAILURE, p_ssa_pdb->p_ecode, &ecode)


    p_internal_msg->msg_hdr.msg_id = ICF_NM_P_NW_INFO;


/*    The global NM pointer needs to be put into nm_acs_info after fetching it from DBM: */
    ret_val = icf_dbm_get_module_glb_data(
        p_glb_pdb,
        (icf_int_module_id_t)(ICF_INT_MODULE_NM),
        (icf_void_t **)(&p_nm_ptr),
        p_ecode);     

    p_nwacs_info = (icf_nm_pnwacs_info* )p_internal_msg->p_msg_data;

    p_nwacs_info->nm_ptr = p_nm_ptr;

    icf_nm_process_mesg(p_internal_msg, &ecode);

/*
        icf_uint8_t        access_type;
        icf_uint8_t        mcc[3]; 
        icf_mnc_t        mnc;    
        icf_uint16_t        lac; 
        icf_uint16_t        ci; 
        icf_uint32_t        umts_c
*/

    sprintf(buff, "%d%d%d%x", p_nwacs_info->mcc[0], p_nwacs_info->mcc[1], 
        p_nwacs_info->mcc[2], p_nwacs_info->lac);

#endif

        if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
            p_ssa_pdb,
            (icf_uint8_t*)"P-Access-Network-Info",
            "3GPP-GERAN;cgi-3gpp=123456CAFEFACE",
            p_otg_sip_msg))
        {
            ICF_PRINT(("\nFailed to insert unknown header (P-Access-Network-Info)"));
            ret_val = ICF_FAILURE;
            
        }
ICF_CHECK_IMS_END
#endif
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}





/*****************************************************************************
 * FUNCTION:     icf_insert_header_tag_body_list
 * DESCRIPTION:  This function inserts header/tag/body list collectively
 *               into either a SIP message or SIP transaction.
 *****************************************************************************/
icf_return_t icf_insert_header_tag_body_list(
        INOUT      icf_ssa_pdb_st*          p_ssa_pdb,
        INOUT      icf_boolean_t            clear_list,
        INOUT     Sdf_st_transaction*            p_txn,
        INOUT    Sdf_st_overlapTransInfo*    p_overlap_txn)
{


    SipMessage*         p_sip_msg   = ICF_NULL;
    Sdf_ty_slist*       p_slist = ICF_NULL;   


    icf_header_list_st*        p_hdr_list  = ICF_NULL;
    icf_tag_list_st*            p_tag_list  = ICF_NULL;
    icf_msg_body_list_st*    p_body_list = ICF_NULL;


    icf_return_t ret_val = ICF_SUCCESS;


    if (ICF_NULL != p_txn)
    {
        p_sip_msg = p_txn->pSipMsg;
        p_slist   = &(p_txn->slMsgBodyList);
    }
    else if (ICF_NULL != p_overlap_txn)
    {
        p_sip_msg = p_overlap_txn->pSipMsg;
        p_slist   = &(p_overlap_txn->slMsgBodyList);
    }

    if (ICF_INVALID_CALL_ID == 
        p_ssa_pdb->p_glb_pdb->p_call_ctx->replace_initiated_call_id)
    {
        p_hdr_list = &(p_ssa_pdb->p_glb_pdb->p_call_ctx->header_list);
        p_tag_list = &(p_ssa_pdb->p_glb_pdb->p_call_ctx->tag_list);
        p_body_list = &(p_ssa_pdb->p_glb_pdb->p_call_ctx->body_list);

        if (ICF_NULL < p_hdr_list->count)
        {
            if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
                        p_ssa_pdb, p_hdr_list, clear_list, p_sip_msg))
            {
                ret_val = ICF_FAILURE;
            }
        }
    }
    else
    {
        p_hdr_list = &(p_ssa_pdb->p_glb_pdb->p_call_ctx->persistent_header_list);

        if (ICF_NULL < p_hdr_list->count)
        {
            if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
                        p_ssa_pdb, p_hdr_list, ICF_FALSE, p_sip_msg))
            {
                ret_val = ICF_FAILURE;
            }
        }
    }

    if (ICF_INVALID_CALL_ID == 
           p_ssa_pdb->p_glb_pdb->p_call_ctx->replace_initiated_call_id)
    {
        if (ICF_NULL < p_tag_list->count)
        {
            if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
                p_ssa_pdb, p_tag_list, clear_list, p_sip_msg))
            {
                ret_val = ICF_FAILURE;
            }

        }
        if (ICF_NULL < p_body_list->count)
        {
            if (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
                p_ssa_pdb, p_body_list, clear_list, p_slist))
            {
                ret_val = ICF_FAILURE;
            }
        }
    }
    return ret_val;

}





/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_extract_challenge
 *
 * DESCRIPTION: The function extracts the challenge from the auth_params_lis
 *              for the header type sepcified by the calling function.
 *              It also extracts the nonce and stores it in the ssa context
 *              to be used by the function icf_ssa_validate_challenge for
 *              stale parameter processing.
 *              
 * RETURNS: icf_return_t 
 *
************************************************************************/ 
icf_return_t icf_ssa_extract_challenge(
       INOUT  icf_ssa_pdb_st                    *p_ssa_pdb,
       INOUT     icf_uint8_t                          header_type)
       
{
    icf_uint32_t        list_size = ICF_NULL;
    Sdf_st_error            err;
    icf_uint32_t        loop_list = ICF_NULL;
    Sdf_ty_pvoid        p_list_member;
    icf_uint8_t        *p_temp_string = ICF_NULL;        
    icf_return_t        ret_val = ICF_FAILURE, dummy_ret_val = ICF_SUCCESS;
    icf_uint8_t        *p_temp_unq_string = ICF_NULL; /* unquoted string */
    icf_uint32_t        temp_len = 0;
    icf_rgm_context_st    *p_rgm_context;
    icf_string_st    temp_unq_algo, temp_unq_scheme, temp_unq_realm;
    icf_string_st    temp_unq_opaque, temp_unq_qop;
     icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;
    Sdf_ty_slist                          *p_auth_params_list;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
         
    /* Copy the ssa ctxt pointer locally */
     p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
     ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))
         
    /* Copy the rgm_context pointer locally */
    p_rgm_context = (icf_rgm_context_st *)(p_ssa_ctxt->p_rgm_ctxt);
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_rgm_context))

    
    /* Assert on auth_params_list */
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
            (ICF_NULL != p_ssa_ctxt->p_auth_params_list))
    p_auth_params_list = p_ssa_ctxt->p_auth_params_list;

    sdf_listSizeOf(p_auth_params_list, &list_size,
                                &err);

    for (loop_list = 0; loop_list < list_size; loop_list++ )
    {
        /* for loop: begin processing */
        if (Sdf_co_fail == sdf_listGetAt (p_auth_params_list,
            loop_list,
            &p_list_member, 
            &err))
        {
            continue;
            
        }
        else
        {
            /* else: auth_params member read safely: processing begins */
            
            if(header_type == ((Sdf_st_authenticationParams *)(p_list_member))->
                dHdrType)
            {
            /* We have found the header type we were looking for:
                * Now copy the challenge and run out of the loop */
                
                if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pNonce) 
                {/* Non null Nonce begins*/

                    /* Clear the contents of old auth_recd in p_rgm_context */
                    /*Fix done for SPR-18722 : CSR-1-6068965*/
                    /* memfree the nonce string */
                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_rgm_context->auth_data_recd.p_nonce,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode, dummy_ret_val)

                    p_rgm_context->auth_data_recd.p_nonce = ICF_NULL;
                    p_rgm_context->auth_data_recd.nonce_len = 0;
                    icf_port_memset(
                        (icf_void_t*)&(p_rgm_context->auth_data_recd),
                        (icf_uint8_t)ICF_NULL,
                        (icf_uint32_t) ICF_PORT_SIZEOF(icf_rgm_auth_data_st));                    
                     
                    /* Clear the contents of old nonce in ssa context */
                    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_old_nonce)
                    {
					    /*Fix done for SPR-18722 : CSR-1-6068965*/
                        /* memfree the nonce string */
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                       p_ssa_pdb->p_ssa_ctxt->p_old_nonce,
                                       ICF_MEM_COMMON,
                                       p_ssa_pdb->p_ecode,
                                       dummy_ret_val)
                        p_ssa_pdb->p_ssa_ctxt->p_old_nonce = ICF_NULL;
                    }

                    /* Start processing the new set of challenge */

                    p_temp_string =  
                        (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pNonce;
                    
                    temp_len = icf_port_strlen(p_temp_string);
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        temp_len+1,
                        ICF_MEM_COMMON, p_temp_unq_string,
                        ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                        
                    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
                        (ICF_NULL != p_temp_unq_string))

                    
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        temp_len+1,
                        ICF_MEM_COMMON, 
                                (p_rgm_context->auth_data_recd.p_nonce),
                        ICF_DONOT_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                     
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        temp_len+1,
                        ICF_MEM_COMMON,
                        (p_ssa_pdb->p_ssa_ctxt->p_old_nonce),
                        ICF_RET_ON_FAILURE,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                    
                    if (ICF_FAILURE == ret_val) 
                    {
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                    p_temp_unq_string, 
                                    ICF_MEM_COMMON, 
                                    p_ssa_pdb->p_ecode, 
                                    ret_val) 
                        return ICF_FAILURE;
                    }
                        
                    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
                        (ICF_NULL != p_rgm_context->auth_data_recd.p_nonce))
                
                    sdf_fn_uaUnq((icf_int8_t *)p_temp_string,(icf_int8_t *) p_temp_unq_string);


                    icf_port_strcpy(p_rgm_context->auth_data_recd.p_nonce, \
                                p_temp_unq_string);
                    
                    /* copying the nonce in ssa context */
                    icf_port_strcpy(p_ssa_pdb->p_ssa_ctxt->p_old_nonce, \
                                p_temp_unq_string);
    
                    p_rgm_context->auth_data_recd.nonce_len= temp_len;
                    p_rgm_context->auth_data_recd.auth_data_present |=
                                                ICF_AUTH_NONCE_PRESENT;
                    

                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_temp_unq_string, 
                        ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)

                    /* copy other parameters */
                    if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pAlgorithm)
                    {
                        p_temp_string =  
                        (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pAlgorithm;
                        sdf_fn_uaUnq((icf_int8_t *)p_temp_string, (icf_int8_t *)temp_unq_algo.str);
                        icf_port_strcpy(p_rgm_context->auth_data_recd.algo.str, \
                                temp_unq_algo.str);
                        p_rgm_context->auth_data_recd.algo.str_len = 
                                    (icf_uint16_t) icf_port_strlen(p_rgm_context->auth_data_recd.algo.str);
                        p_rgm_context->auth_data_recd.auth_data_present |=
                                                ICF_AUTH_ALGO_PRESENT;
                    }/* Algorithm filled */

                    if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pRealm)
                    {
                        p_temp_string =  
                        (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pRealm;
                        sdf_fn_uaUnq((icf_int8_t *)p_temp_string, (icf_int8_t *)temp_unq_realm.str);
                        icf_port_strcpy(p_rgm_context->auth_data_recd.realm.str, \
                                temp_unq_realm.str);
                        p_rgm_context->auth_data_recd.realm.str_len = 
                                   (icf_uint16_t) icf_port_strlen(p_rgm_context->auth_data_recd.realm.str);
                        p_rgm_context->auth_data_recd.auth_data_present |=
                                                ICF_AUTH_REALM_PRESENT;

                    }/* realm Filled */
                    
                    if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pScheme)
                    {
                        p_temp_string =  
                        (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pScheme;
                        sdf_fn_uaUnq((icf_int8_t *)p_temp_string, (icf_int8_t *)temp_unq_scheme.str);
                        icf_port_strcpy(p_rgm_context->auth_data_recd.scheme.str, \
                                temp_unq_scheme.str);
                        p_rgm_context->auth_data_recd.scheme.str_len = 
                            (icf_uint16_t )icf_port_strlen(p_rgm_context->auth_data_recd.scheme.str);
                        p_rgm_context->auth_data_recd.auth_data_present |=
                                                ICF_AUTH_SCHEME_PRESENT;

                    }/* Scheme filled */

                    if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pOpaque)
                    {
                        p_temp_string =  
                        (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pOpaque;
                        sdf_fn_uaUnq((icf_int8_t *)p_temp_string, (icf_int8_t *)temp_unq_opaque.str);
                        icf_port_strcpy(p_rgm_context->auth_data_recd.opaque.str, \
                                temp_unq_opaque.str);
                        p_rgm_context->auth_data_recd.opaque.str_len = 
                            (icf_uint16_t )icf_port_strlen(p_rgm_context->auth_data_recd.opaque.str);
                        p_rgm_context->auth_data_recd.auth_data_present |=
                                                ICF_AUTH_OPAQUE_PRESENT;

                    }/* Opaque Filled */

                    if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pQop)
                    {
                        p_temp_string =  
                        (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pQop;
                        sdf_fn_uaUnq((icf_int8_t *)p_temp_string, (icf_int8_t *)temp_unq_qop.str);
                        icf_port_strcpy(p_rgm_context->auth_data_recd.qop.str, \
                                temp_unq_qop.str);
                        p_rgm_context->auth_data_recd.qop.str_len = 
                            (icf_uint16_t )icf_port_strlen(p_rgm_context->auth_data_recd.qop.str);
                        p_rgm_context->auth_data_recd.auth_data_present |=
                                            ICF_AUTH_QOP_PRESENT;

                    }/* QoP filled */


                    ret_val = ICF_SUCCESS;
                    break;
                } 
                else 
                {
                    /* Nonce as NULL received */
                    ret_val = ICF_FAILURE;
                    break;
                }
            }
            else
            {/* hdr type not matched yet: continue */
                continue;
            }
            
            
        }/* else: auth_params member read safely: processing ends */
        
    }/* for loop: ends*/
    
    return ret_val;/* if not found then FAILURE is returned */
    
}/* Function icf_ssa_extract_challenge() ends here */

#ifdef ICF_SSA_UT_NR_CODE

/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_extract_qop
 *
 * DESCRIPTION: The function extracts the QoP from the auth_params_lis
 *                for the header type sepcified by the calling function.
 *              
 *
 * RETURNS: icf_return_t 
 *
************************************************************************/  
icf_return_t icf_ssa_extract_qop(
       INOUT  icf_ssa_pdb_st                    *p_ssa_pdb,
       INOUT  icf_string_st                      *p_qop,       
       INOUT  Sdf_ty_slist                          *p_auth_params_list,
       INOUT     icf_uint8_t                          header_type,
       OUT   icf_error_t                       *p_ecode)
{
    icf_uint32_t        list_size = ICF_NULL;
    Sdf_st_error            err;
    icf_uint32_t        loop_list = ICF_NULL;
    Sdf_ty_pvoid        p_list_member;
    icf_uint8_t        *p_temp_string = ICF_NULL;        
    icf_return_t        ret_val = ICF_FAILURE;
    icf_uint8_t        *p_temp_unq_string = ICF_NULL; /* unquoted string */
    icf_uint32_t        temp_len = 0;
    

    /* This function is not called on an empty list
     * hence we will not check for the empty ness of the list */
    sdf_listSizeOf(p_auth_params_list, &list_size,
                                &err);

    for (loop_list = 0; loop_list < list_size; loop_list++ )
    {
        /* for loop: begin processing */
        if (Sdf_co_fail == sdf_listGetAt (p_auth_params_list,
            loop_list,
            &p_list_member, 
            &err))
        {
            continue;
            
        }
        else
        {
            /* else: auth_params member read safely: processing begins */
            
            if(header_type == ((Sdf_st_authenticationParams *)(p_list_member))->
                dHdrType)
            {
            /* We have found the header type we were looking for:
                * Now copy the challenge and run out of the loop */
                
                /* Check for presence of qop */
                if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pQop) 
                {
                    

                    p_temp_string =  
                        ((Sdf_st_authenticationParams *)(p_list_member))->pQop;
                    
                    temp_len = icf_port_strlen(p_temp_string);
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        temp_len+1,
                        ICF_MEM_COMMON, p_temp_unq_string,
                        ICF_RET_ON_FAILURE, p_ecode, ret_val)
                        
                    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
                        (ICF_NULL != p_temp_unq_string))
                                    
                
                    sdf_fn_uaUnq(p_temp_string, p_temp_unq_string);


                    icf_port_strcpy(p_qop->str, p_temp_unq_string);
                        
                    p_qop->str_len = icf_port_strlen(p_qop->str);
                    

                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_temp_unq_string, 
                        ICF_MEM_COMMON, p_ecode, ret_val)

                    ret_val = ICF_SUCCESS;
                    break;
                }/* Non Null qop: Ends here */ 
                else 
                {
                    ret_val = ICF_FAILURE;
                    break;
                }
            }
            else
            {
                continue;
            }
            
            
        }/* else: auth_params member read safely: processing ends */
        
    }/* for loop: ends*/
    
    return ret_val;
    
}/* Function icf_ssa_extract_qop() ends here */
#endif

/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_compute_nc
 *
 * DESCRIPTION: The function computes the nc string from nonce_count
 *              
 *
 * RETURNS: icf_return_t 
 *
************************************************************************/  
icf_return_t icf_ssa_compute_nc(
       INOUT  icf_glb_pdb_st                      *p_glb_pdb,
       INOUT  icf_ssa_ctxt_st                   *p_ssa_ctxt,
       INOUT  icf_string_st                      *p_nc,
       INOUT  icf_uint32_t                      nonce_count,
       OUT   icf_error_t                       *p_ecode)
{
    icf_return_t        ret_val = ICF_SUCCESS;

    icf_uint8_t str[100] = {0}; 
    icf_uint8_t newstr[100] = {0}; 
    icf_uint32_t j; 

    /* To remove warnings */
    p_glb_pdb=p_glb_pdb;
    p_ssa_ctxt=p_ssa_ctxt;
    p_ecode=p_ecode;

    str[0]='\0';
    newstr[0]='\0';

    j = icf_port_sprintf((icf_int8_t *)str, "%x", nonce_count);
    for ( ; 8-(j) > 0 ; j++)
    {
        icf_port_strcat(newstr, (icf_uint8_t *)"0"); 
    }
    icf_port_strcat(newstr, str);
    
    icf_port_strcpy(p_nc->str,newstr);
    p_nc->str_len =
            (icf_uint16_t)icf_port_strlen(p_nc->str);

    /*ICF_PRINT(("newstr = %s [%d]\n", newstr, icf_port_strlen(newstr))); */

    return ret_val;
}/* Function icf_ssa_compute_nc() ends here */

#ifdef ICF_SIGCOMP_SUPPORT
/******************************************************************************
 ** FUNCTION:         icf_ssa_checkForSigCompParam
 **
 ** DESCRIPTION:     This function checks the target address spec for 
 **                 compressing the Outgoing Message.
 **                 For A request Message It checks the TopMost Route
 **                 Header If present or to the Request Uri line whether
 **                 it contains comp=sigcomp parameter or not
 **                 
 **                 For A response message it checks the topmost Via
 **                 header field.If it contains comp_sigcomp then the
 **                 response will be compressed.
 **
 **                 Refer RFC 3486: Section 2:
 **
 **                 ["The presence of the parameter (comp=sigcomp) in a 
 **                  URI indicates that the request has to be compressed 
 **                  using SigComp.The presence of comp=sigcomp in a Via 
 **                  header field indicates that the response has to be 
 **                  compressed using SigComp.]
 **
 **                 Refer RFC 3486: Section 5:
 **
 **                 [If the topmost Via header field contains the 
 **                 parameter comp=sigcomp, the response SHOULD be compressed.
 **                 Otherwise, the response MUST NOT be compressed.]
 **                    
 ******************************************************************************/
static icf_return_t
icf_ssa_checkForSigCompParam(
     INOUT     Sdf_st_callObject              *pObject,
     INOUT     SipMessage                     *pMessage, 
     OUT    icf_boolean_t               *p_isSigcompParamPres,
     OUT    icf_error_t                 *p_ecode)

{
    Sdf_st_error            SdfErr,*pError=&SdfErr;
    SipError                SipErr;
    en_SipMessageType        dType;
    Sdf_st_transaction         *pTransaction=Sdf_co_null;
    Sdf_ty_s8bit               *pTmpVal = Sdf_co_null;
    SipAddrSpec               *pAddrSpec=Sdf_co_null;
    SipAddrSpec                *pRouteAddrSpec = Sdf_co_null;
    SipAddrSpec                *pReqLineAddrSpec = Sdf_co_null;
    Sdf_ty_bool               dIsPresentLr=Sdf_co_false;
    Sdf_ty_u32bit             dCount=0;
    Sdf_ty_s8bit              *pTempHost = Sdf_co_null;
    Sdf_ty_s8bit              *pHost = Sdf_co_null;
       SipReqLine                 *pReqLine = Sdf_co_null;
    en_AddrType                dSchemeType = SipAddrSipUri;
    icf_return_t         ret_val = ICF_FAILURE;

    if (sip_getMessageType(pMessage, &dType, (SipError*)\
        &(SipErr)) ==  SipFail)
     {
        return ret_val ;
    }
    if (dType == SipMessageRequest)
    {
        if (sip_getReqLine(pMessage, &pReqLine, \
                (SipError *)&(SipErr)) == SipFail)
        {
               return ret_val;
           }
            
           if (sip_getAddrSpecFromReqLine(pReqLine, &pReqLineAddrSpec, \
               (SipError *)&(SipErr)) == SipFail)
           {
               sip_freeSipReqLine(pReqLine);
               return ret_val;
           }

           sip_freeSipReqLine(pReqLine);
        dSchemeType = pReqLineAddrSpec->dType;

        sip_getHeaderCount(pMessage,SipHdrTypeRoute, &dCount, \
            (SipError *)&(SipErr));

        if(dCount !=0)
        {
            Sdf_ty_slist     slRouteHeaderList;
            Sdf_st_headerList *pHeaderList = Sdf_co_null;
            SipHeader *pRouteHeader = Sdf_co_null;


            /* Check whether the top most route entry is lr or not */
            
            sdf_ivk_uaGetHeaderListByCorrelation( \
                &(pObject->slPersistentHeaders), \
                (Sdf_ty_s8bit *)"uat-routeset",    &slRouteHeaderList, pError);

            sdf_listGetAt(&slRouteHeaderList, 0, \
                    (Sdf_ty_pvoid *)&pHeaderList, pError);

            sdf_listGetAt(&(pHeaderList->slHeaders), 0, \
                    (Sdf_ty_pvoid *)&pRouteHeader, pError);

            if (sip_getAddrSpecFromRouteHdr(pRouteHeader, &pRouteAddrSpec, \
                    (SipError *)&(SipErr)) == SipFail)
            {
                sdf_listDeleteAll(&slRouteHeaderList, pError);
                   return ret_val;
            }
            sdf_listDeleteAll(&slRouteHeaderList, pError);

            sdf_fn_uaCheckLrParameter(pRouteAddrSpec, &dIsPresentLr,pError);
        }

        if(dIsPresentLr == Sdf_co_true)
        {
            pAddrSpec = pRouteAddrSpec;
            sip_freeSipAddrSpec(pReqLineAddrSpec);
        }
        else
        {
            pAddrSpec = pReqLineAddrSpec;
            sip_freeSipAddrSpec(pRouteAddrSpec);
        }

        if(pAddrSpec->dType != SipAddrReqUri)
        {
            Sdf_ty_u32bit dUrlParamCount = 0;
            SipUrl        *pUrl = Sdf_co_null;

            if(sdf_ivk_uaGetUrlFromAddrSpec(pAddrSpec, &pUrl,\
                        pError) == Sdf_co_fail)
            {
                sip_freeSipAddrSpec(pAddrSpec);
                   return ret_val;
            }
            if (sip_getUrlParamCountFromUrl(pUrl, &dUrlParamCount, \
                (SipError*)&(SipErr)) == SipFail)
            {
                sip_freeSipUrl(pUrl);
                sip_freeSipAddrSpec(pAddrSpec);
                   return ret_val;
            }

            if (dUrlParamCount > 0)
            {
                Sdf_ty_u32bit dIndex;
                for (dIndex = 0; dIndex < dUrlParamCount; dIndex++)
                {
                    SipParam *pUrlParam;
                    Sdf_ty_s8bit *pName;
                    
                    if (sip_getUrlParamAtIndexFromUrl(pUrl, &pUrlParam,\
                        dIndex, (SipError*)&(SipErr)) == SipFail)
                    {
                        sip_freeSipUrl(pUrl);
                        sip_freeSipAddrSpec(pAddrSpec);
                         return ret_val;
                    }

                    if (sip_getNameFromSipParam(pUrlParam, &pName, \
                            (SipError*)&(SipErr)) == SipFail)
                    {
                        sip_freeSipParam(pUrlParam);
                        sip_freeSipUrl(pUrl);
                        sip_freeSipAddrSpec(pAddrSpec);
                         return ret_val;
                    }

                    if (Sdf_mc_strcmp(pName, "comp") == 0)
                    {
                        Sdf_ty_s8bit *pTempCompType = Sdf_co_null;

                        if (sip_getValueAtIndexFromSipParam(pUrlParam, \
                            &pTempCompType, 0, (SipError*) \
                            &(SipErr)) == SipFail)
                        {
                            sip_freeSipParam(pUrlParam);
                            sip_freeSipUrl(pUrl);
                            sip_freeSipAddrSpec(pAddrSpec);
                             return ret_val;
                        }
                        /*
                         * If a Compression parameter exists, check whether
                         * the value is sigcomp or not
                         */
                        if (Sdf_mc_strcasecmp(pTempCompType, "sigcomp") == 0)
                        {
                            *p_isSigcompParamPres = ICF_TRUE;
                            break;
                        }
                    }
                        
                    sip_freeSipParam(pUrlParam);
                } /* End of the for loop */
            }
            /*
             * If any header params are present in the URL, remove that
             * as well (acc. to RFC, method and header params should
             * not be present in Request-URI.
             */
            sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&\
                (pUrl->pHeader),pError);
            /* Free the local reference here. */
            sip_freeSipUrl(pUrl);
       }
       sip_freeSipAddrSpec(pAddrSpec);
    }
    else if (dType == SipMessageResponse)
    {
        SipHeader dTempHeader;
        SipParam     *pViaParam;
        Sdf_ty_u32bit dViaParamCount=0, dIndex=0;

        if (sip_getHeaderAtIndex(pMessage, SipHdrTypeVia, \
            &dTempHeader, 0, (SipError*)&(SipErr)) == SipFail)
        {
            return ret_val;
        }

        if (sip_getViaParamCountFromViaHdr(&dTempHeader, &dViaParamCount, \
            (SipError *)&(SipErr)) == SipFail)
        {
            sip_freeSipHeader(&dTempHeader);
            return ret_val;
        }
        for (dIndex=0; dIndex<dViaParamCount; dIndex++)
        {
            Sdf_ty_s8bit *pParamName  = Sdf_co_null;
            Sdf_ty_s8bit *pParamValue = Sdf_co_null;

            if (sip_getViaParamAtIndexFromViaHdr(&dTempHeader, &pViaParam, \
                (Sdf_ty_u32bit)dIndex, (SipError *)&(SipErr)) \
                == SipFail)
            {
                sip_freeSipHeader(&dTempHeader);
                return ret_val;
            }
            if (sip_getNameFromSipParam(pViaParam, &pParamName, \
                (SipError *)&(SipErr)) == SipFail)
            {
                sip_freeSipHeader(&dTempHeader);
                sip_freeSipParam(pViaParam);
                return ret_val;
            }
            if (sip_getValueAtIndexFromSipParam(pViaParam, &pParamValue, \
                (Sdf_ty_u32bit)0, (SipError *)&(SipErr)) == SipFail)
            {
                sip_freeSipParam(pViaParam);
                if((SipErr != Sdf_en_noExistError) && \
                    (SipErr != Sdf_en_invalidIndexError))
                {
                    sip_freeSipHeader(&dTempHeader);
                    return ret_val;
                }
                else
                {
                    continue;
                }
            }
            if (Sdf_mc_strcmp(pParamName, "comp") == 0)
            {
                /*
                 * If a Compression parameter exists, check whether
                 * the value is sigcomp or not
                 */
                if (Sdf_mc_strcasecmp(pParamValue, "sigcomp") == 0)
                {
                    *p_isSigcompParamPres = ICF_TRUE;
                    break;
                }
            }
            sip_freeSipParam(pViaParam);
        }/* End of for Loop */
        
        sip_freeSipHeader(&dTempHeader);
    }
    ret_val = ICF_SUCCESS;
    return ret_val;
}

/******************************************************************************
 ** FUNCTION:         icf_ssa_find_sigsa_ctxt_from_sip_msg
 **
 ** DESCRIPTION:     This function coding the decodes the 
 **                 SIP message and if decode is successfull then
 **                 it fetches the callObject from the map by passing the
 **                 call id,If the CallObject exists then it fetches the actual
 **                 SSA context and sends the SIGSA context stored in it. 
 **                 if the SSA context does not exist then 
 **                    
 ******************************************************************************/
icf_return_t icf_ssa_find_sigsa_ctxt_from_sip_msg(
                              OUT           icf_void_t   **p_p_sigsa_ctxt,
                              INOUT            icf_uint8_t   *pDecompMsg,
                              INOUT            icf_uint32_t  dDecompMsgLen,
                              INOUT            icf_void_t    *p_AppData,
                              OUT           icf_error_t   *p_ecode)
{
    Sdf_st_eventContext       *p_event_ctxt =
                                   (Sdf_st_eventContext*) p_AppData;

    icf_ssa_ctxt_st        *p_ssa_ctxt = 
                                 (icf_ssa_ctxt_st*)p_event_ctxt->pData;

    icf_ssa_pdb_st         *p_ssa_pdb =
                               (icf_ssa_pdb_st*)p_ssa_ctxt->p_ssa_pdb;
    
    icf_ssa_ctxt_st        *p_actual_ssa_ctxt = ICF_NULL;

    Sdf_st_callObject         *p_call_obj = p_ssa_ctxt->p_call_obj;
    icf_uint8_t            *p_current_sip_pdu = pDecompMsg;
    icf_uint8_t            *p_next_msg = ICF_NULL;
    SipOptions                 sip_options ;
    icf_return_t            ret_val = ICF_FAILURE;
    SipError                   SipErr;

    /*
    * Following stops SIP stack from stopping txn timer 
    * on it's own(HSSUA)
    */
/*Jason , syslog*/    
#ifdef VOIP_SYSLOG
    icf_print_pdu(p_ssa_pdb->p_glb_pdb,
        p_current_sip_pdu,p_event_ctxt->pTranspAddr->pHost, 
        p_event_ctxt->pTranspAddr->dPort, dDecompMsgLen,1);

#else    
    icf_print_pdu(p_ssa_pdb->p_glb_pdb,
        p_current_sip_pdu,p_event_ctxt->pTranspAddr->pHost, 
        p_event_ctxt->pTranspAddr->dPort, dDecompMsgLen);
#endif
    sip_options.dOption = SIP_OPT_NOTIMER | SIP_OPT_BADMESSAGE;
   
    p_ssa_pdb->msg_type = sdf_ivk_uaDecodeMessage(
                        p_call_obj, p_current_sip_pdu, \
                        &sip_options, dDecompMsgLen, &p_next_msg,
                        p_event_ctxt,
                        &(p_ssa_pdb->sdf_error));
   if (ICF_NULL != p_next_msg)
   {
       /* Another message is there to be processed.
        * So we invoke ES/port interface to read the processed
        * bytes from the connection and then we set the pointer
        * for current_sip_pdu to the p_next_msg*/
       p_ssa_pdb->processed_bytes =
           icf_port_strlen(p_current_sip_pdu) - 
           icf_port_strlen(p_next_msg);
   }
   else
   {
       p_ssa_pdb->processed_bytes = 
           icf_port_strlen(p_current_sip_pdu);
   }
    
    ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->common_bitmask,\
                ICF_SSA_SIP_MSG_DECODED_BY_UATK);
    *p_p_sigsa_ctxt = ICF_NULL;

    if((ICF_NULL != p_call_obj->pCommonInfo) &&
       (ICF_NULL != p_call_obj->pCommonInfo->pCallid))
    {
        /* Message decoded for fetching ssa_ctxt by the CallId */
        if( ICF_FAILURE != icf_ssa_map_nw_callid(
                    p_ssa_pdb, p_call_obj->pCommonInfo->pCallid,
                    &p_actual_ssa_ctxt,p_ecode))
        {
#ifdef ICF_IPSEC_ENABLED
            if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
            {
                icf_rgm_glb_data_st         *p_rgm_glb_data  = ICF_NULL;

                if (ICF_FAILURE == \
                        icf_dbm_get_module_glb_data(p_ssa_pdb->p_glb_pdb,\
                        ICF_INT_MODULE_REGM, 
                        (icf_void_t **)(p_rgm_glb_data),
                        p_ssa_pdb->p_ecode))
                {
                    /*ICF_SIGSA_TRACE(("\nFailure while getting RGM Global Data in SIGSA\n"));*/
                    return ICF_FAILURE;
                }
                *p_p_sigsa_ctxt = &(p_rgm_glb_data->p_sigsa_ctxt);
            }
            else
            {
                /* Ssa Context Fetched from the Map */
                *p_p_sigsa_ctxt = p_actual_ssa_ctxt->p_sigsa_ctxt;
                /* Set this Sigsa Context to the temporary ssa context */
                p_ssa_ctxt->p_sigsa_ctxt = *p_p_sigsa_ctxt;    
            }
#else
            /* Ssa Context Fetched from the Map */
            *p_p_sigsa_ctxt = p_actual_ssa_ctxt->p_sigsa_ctxt;
            /* Set this Sigsa Context to the temporary ssa context */
            p_ssa_ctxt->p_sigsa_ctxt = *p_p_sigsa_ctxt;
#endif

            if(ICF_NULL != *p_p_sigsa_ctxt)
            {
                /* In crement the reference Counter */
                icf_sigsa_incr_ref_count_to_sigsa_ctxt(*p_p_sigsa_ctxt);
            }


            ret_val = ICF_SUCCESS;

        }
        else
        {
            /* A new call Has been received or a stray response received
             * Where the SSA context has been deleted from the map
             */
            /* Check whether Message has been successfully decoded */
            if((Sdf_en_success == p_ssa_pdb->msg_type) || 
               (Sdf_en_strayMessage == p_ssa_pdb->msg_type))
            {
                SipHeader               *p_called_hdr = SIP_NULL;
                SipToHeader             *pToHeader = SIP_NULL;
                icf_address_st       *p_address = SIP_NULL;
                SipAddrSpec             *p_addr_spec = SIP_NULL;
                icf_rgm_context_st   *p_rgn_cntxt_blk = SIP_NULL;
                SipMessage              *pMessage = SIP_NULL;
                en_SipMessageType        dType;
                /* The Message has been successfully decoded */

                if (ICF_NULL != p_call_obj->pUasTransaction)
                {
                    pMessage = p_call_obj->pUasTransaction->pSipMsg;
                }
                else if (ICF_NULL != p_call_obj->pUacTransaction)
                {
                    pMessage = p_call_obj->pUacTransaction->pSipMsg;
                }

                if(ICF_NULL == pMessage) 
                {
                    /* Failure condition */
                }
                else if(SipFail == sip_getMessageType(pMessage, &dType,
                                   (SipError*)&SipErr))
                {
                     /* Failure condition */

                }
                /* The MessageType has successfully Fetch */
                else if (dType == SipMessageRequest)
                {
                   /* For reuest Type Message
                    * Get the Request Uri from P-Called-Party Header(if present)
                    * else get the Request Uri from the To header */
                    icf_ssa_parse_unknown_header_like_from_hdr(
                        p_ssa_pdb,
                        pMessage,
                        "P-Called-Party-ID",
                        &p_called_hdr);

                    if(ICF_NULL == p_called_hdr)
                    {
                        pToHeader = (SipToHeader *)
                            (p_call_obj->pCommonInfo->pTo->pHeader);
                    }
                    else
                    {
                        pToHeader = (SipToHeader *)(p_called_hdr->pHeader);
                    }
                }
                else if(dType == SipMessageResponse)
                {
                    /* For response Type Message
                     * Get the Request Uri from P-Called-Party Header(if present)
                     * else get the Request Uri from the From header stored */
                    icf_ssa_parse_unknown_header_like_from_hdr(
                        p_ssa_pdb,
                        pMessage,
                        "P-Asserted-Identity",
                        &p_called_hdr);

                    if(ICF_NULL == p_called_hdr)
                    {
                        pToHeader = (SipToHeader *)
                            (p_call_obj->pCommonInfo->pFrom->pHeader);
                    }
                    else
                    {
                        pToHeader = (SipToHeader *)(p_called_hdr->pHeader);
                    }

                }

                if(ICF_NULL != pToHeader)
                {
                   ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        ICF_PORT_SIZEOF(icf_address_st),
                        ICF_MEM_COMMON, (icf_void_t*)p_address,
                        ICF_RET_ON_FAILURE, p_ecode, ret_val)

                    p_addr_spec = ((SipToHeader *)(pToHeader))->pAddrSpec;
                       
                   if ( ICF_FAILURE ==
                       icf_ssa_populate_address_from_sip_addr_spec(
                       p_ssa_pdb,
                       p_addr_spec,
                       p_address))
                   {
                       /*Raise/Set Error:UATK_PROCESSING_FAILURE*/
                   }
                    /* Fetch the Registration Context by giving the Request URI */
                   else if (ICF_FAILURE ==
                               icf_rgm_fetch_ctxt_for_uri(p_ssa_pdb->p_glb_pdb,
                                p_address,&p_rgn_cntxt_blk,
                                p_ecode))
                   {
                   }
                   /* If regisration block fetched successfully */
                   /* then Get SSA context from the Registration Context */
                   /* Return the SIGSA context from the SSA contxt */
                   else 
                   {
#ifdef ICF_IPSEC_ENABLED
                       if (ICF_TRUE == 
                                p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
                       {
                            icf_rgm_glb_data_st         *p_rgm_glb_data  = ICF_NULL;

                            if (ICF_FAILURE == \
                                    icf_dbm_get_module_glb_data(
                                            p_ssa_pdb->p_glb_pdb,\
                                            ICF_INT_MODULE_REGM, 
                                            (icf_void_t **)(p_rgm_glb_data),
                                            p_ssa_pdb->p_ecode))
                            {
                                /*ICF_SIGSA_TRACE(("\nFailure while getting RGM Global Data in SIGSA\n"));    */
                                return ICF_FAILURE;
                            }
                            *p_p_sigsa_ctxt = &(p_rgm_glb_data->p_sigsa_ctxt);
                        }
                        else
                        {
                            *p_p_sigsa_ctxt = ((icf_ssa_ctxt_st*)
                                           (p_rgn_cntxt_blk->p_ssa_ctxt))->
                                                        p_sigsa_ctxt;
                        }
#else
                       *p_p_sigsa_ctxt = ((icf_ssa_ctxt_st*)
                                           (p_rgn_cntxt_blk->p_ssa_ctxt))->
                                                        p_sigsa_ctxt;
                       /* Set this Sigsa Context to the temporary ssa context */
                       p_ssa_ctxt->p_sigsa_ctxt = *p_p_sigsa_ctxt;
#endif

                       if(ICF_NULL != *p_p_sigsa_ctxt)
                       {
                          /* In crement the reference Counter */
                          icf_sigsa_incr_ref_count_to_sigsa_ctxt(*p_p_sigsa_ctxt);
                       }


                       ret_val = ICF_SUCCESS;
                   }
                   
                   if(ICF_NULL != p_address)
                   {

                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_address,
                           ICF_MEM_COMMON, p_ecode, ret_val)
                   }

                }
                /* else return Failure */
            }/* For Successfully decoded message */
        }/* SSA context is not found in the Map */
    }/* Call id is present in the decoded code */
    return ret_val;
}

/****************************************************************************
 * FUNCTION:           icf_ssa_send_create_comp_req_to_sigsa
 *
 * DESCRIPTION:        This routine Sends CREATE_COMP_REQUEST TO
 *                     SIGSA for Creating the compartment for sending
 *                     Compressed Message
 *****************************************************************************/
icf_return_t icf_ssa_send_create_comp_req_to_sigsa(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_internal_msg_st      temp_internal_msg;
    icf_create_comp_req_st   create_comp_req;

    temp_internal_msg.msg_hdr.msg_id = ICF_CREATE_COMP_REQ;
    temp_internal_msg.msg_hdr.p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    temp_internal_msg.msg_hdr.payload_length = 
                                ICF_PORT_SIZEOF(icf_create_comp_req_st);
    temp_internal_msg.msg_hdr.status = 0;
    create_comp_req.p_rgm_ctxt = 
        ((icf_ssa_ctxt_st*)p_ssa_pdb->p_ssa_ctxt)->p_rgm_ctxt;
    
    temp_internal_msg.p_msg_data = (icf_uint8_t*)&create_comp_req;

    ret_val = icf_sigsa_process_mesg(&temp_internal_msg);
    return ret_val;

}


/****************************************************************************
 * FUNCTION:           icf_ssa_send_delete_comp_ind_to_sigsa
 *
 * DESCRIPTION:        This routine Sends ICF_DELETE_COMP_IND TO
 *                     SIGSA for deleting the compartment 
 *****************************************************************************/
icf_return_t icf_ssa_send_delete_comp_ind_to_sigsa(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_internal_msg_st      temp_internal_msg;
    icf_delete_comp_ind_st   delete_comp_ind;

    temp_internal_msg.msg_hdr.msg_id = ICF_DELETE_COMP_IND;
    temp_internal_msg.msg_hdr.p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    temp_internal_msg.msg_hdr.payload_length = 
                                ICF_PORT_SIZEOF(icf_delete_comp_ind_st);
    temp_internal_msg.msg_hdr.status = 0;

    delete_comp_ind.p_rgm_ctxt = 
        ((icf_ssa_ctxt_st*)p_ssa_pdb->p_ssa_ctxt)->p_rgm_ctxt;
    
    temp_internal_msg.p_msg_data = (icf_uint8_t*)&delete_comp_ind;

    ret_val = icf_sigsa_process_mesg(&temp_internal_msg);

    return ret_val;
}
#endif

/****************************************************************************
 * FUNCTION:           icf_ssa_add_param_in_contact_hdr
 *
 * DESCRIPTION:        This routine fetch contact headers from InitData
 *                     Adds comp=sigcomp paramater in contact header
 * 
 *****************************************************************************/
icf_return_t   icf_ssa_AddParamToContactHdrList(
        Sdf_ty_slist             *pContactHdrList,
        icf_uint8_t           *p_param,
        Sdf_st_error *             pError)
{
    icf_return_t       ret_val = ICF_SUCCESS;
    icf_uint32_t        dSize = 0;
    SipHeader             *pContactHeader = Sdf_co_null;
    icf_uint8_t        iterator1 = 0;
    Sdf_ty_s8bit          *pName = ICF_NULL;
    Sdf_ty_s8bit          *p_value = ICF_NULL;
    SipError error;
    Sdf_ty_s8bit *pDupValue = Sdf_co_null;
    Sdf_ty_s8bit          temp_buff[32]={'\0'}; 

    if(ICF_NULL == p_param)
    {
        ret_val = ICF_FAILURE;
    }
    /*Get the Size of Conatact Header List*/
    if(Sdf_co_fail == sdf_listSizeOf(pContactHdrList,&dSize,pError))
    {
        ret_val = ICF_FAILURE;
    }
    /*If list contains elements*/
    else if(dSize !=0)
    {
        icf_port_strcpy((icf_uint8_t *)temp_buff,(icf_uint8_t *)p_param);
        pName = icf_port_strtokr(temp_buff,"=",&p_value);
       /*Fetch all the Contact headers from initdata*/
        for(iterator1=0; iterator1<dSize; iterator1++)
        {
            SipParam *pSipParam                 = SIP_NULL;
            if(Sdf_co_fail == sdf_listGetAt(pContactHdrList,
                iterator1, (Sdf_ty_pvoid *)&pContactHeader,pError))
            {
                ret_val = ICF_FAILURE;
                break;
            }
            else if(SipFail == sip_initSipParam(&pSipParam, &error))
            {      
                ret_val = ICF_FAILURE;
                break;
            }
            else
            {
                SipAddrSpec       *pSipAddrSpec = ICF_NULL;
                if(SipFail == 
                    sip_getAddrSpecFromContactHdr(pContactHeader,&pSipAddrSpec,
                    (SipError *)&(pError->stkErrCode)))
                {
                    sip_freeSipParam(pSipParam);
                    ret_val = ICF_FAILURE;
                    break;
                }
                else if((SipAddrSipUri == pSipAddrSpec->dType) ||
            (SipAddrSipSUri == pSipAddrSpec->dType))
                {
                    pSipParam->pName = STRDUPACCESSOR(pName);
                    if (p_value != SIP_NULL)
                    {
                        pDupValue = (SIP_S8bit*)STRDUPACCESSOR(p_value);
                        if ( sip_listAppend(&(pSipParam->slValue),
                            pDupValue,
                            (SipError *)&(pError->stkErrCode)) == SipFail )
                        {
                            sip_freeSipParam(pSipParam);
                            sip_freeSipAddrSpec(pSipAddrSpec);
                            ret_val = ICF_FAILURE;
                            break;
                        }
                    }
                    if (sip_listAppend( 
                        &((pSipAddrSpec->u).pSipUrl->slParam),
                        (SIP_Pvoid)pSipParam, 
                        (SipError *)&(pError->stkErrCode)) == SipFail)
                    {
                        sip_freeSipParam(pSipParam);
                        sip_freeSipAddrSpec(pSipAddrSpec);
                        ret_val = ICF_FAILURE;
                        break;
                    }
                }
                sip_freeSipAddrSpec(pSipAddrSpec);
            }
        } /* for(iterator1=0; iterator1<dSi... */
    } /* if(dSize !=0) */
    return ret_val;
} /* icf_ssa_AddParamToContactHdrList */


ICF_SIC_START

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_send_subscribe_req
 *
 * DESCRIPTION:     This function constructs and sends Subscribe req on network.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_subscribe_req(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    Sdf_ty_s8bit                HdrName[] = "Event";
    Sdf_ty_s8bit 
               EventName[ICF_MAX_STR_LEN];
    
     Sdf_ty_s8bit               proto[ICF_MAX_SIZE_INT_USAGE_STR];

    SipOptions                  options;
    Sdf_st_error                sdf_error;
    Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;
    icf_uint32_t                tVal;
    SipError                    sip_err;
    SipHeader                    *p_exp_hdr = SIP_NULL;
    icf_ssa_ctxt_st          *p_ssa_ctx = p_ssa_pdb->p_ssa_ctxt;
    icf_sic_ctx_st          *p_sic_ctx = p_ssa_ctx->p_sic_ctxt;
    icf_glb_pdb_st           *p_glb_pdb = p_ssa_pdb->p_glb_pdb;
#ifdef ICF_IPSEC_ENABLED
    icf_uint8_t            *p_value = ICF_NULL;
#endif
  SipHeader                    *p_event_hdr = SIP_NULL;
    
    /* this fix is added here to prevent a failure if the string from the
     * application is received with length including the \0
     */
  icf_uint32_t                strlen_len = ICF_NULL;
  icf_config_data_st       *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
  icf_uint8_t              self_ip[16];
  icf_transport_address_st self_addr = {{0,{{0,"\0"}}},0};
  if(ICF_NULL != p_sic_ctx->p_preferred_identity)
  {
      if (ICF_ADDRESS_PLAN_SIP_URI == 
              p_sic_ctx->p_preferred_identity->addr_type)
      {
          strlen_len = icf_port_strlen((icf_uint8_t*)
                  (p_sic_ctx->p_preferred_identity->addr_val.str));

          /* adjust the string length filled by the app */
        if (p_sic_ctx->p_preferred_identity->addr_val.str_len == (strlen_len + 1))
        {
            p_sic_ctx->p_preferred_identity->addr_val.str_len = (icf_uint16_t )strlen_len;
        }
    }
    }
    options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

    /*Fetch subscription duration*/
    tVal = p_sic_ctx->app_requested_duration; 
    if(0 != p_ssa_pdb->p_glb_cfg_data->sip_compact_hdrs)
    {
        /* Compact headers is on, use the compact form */
        icf_port_strcpy((icf_uint8_t *)HdrName,(icf_uint8_t *)"o");
    }
  
    /* Set the transport mode in local variable */
     if (ICF_SSA_SIC_INITIAL_REQ & p_ssa_pdb->common_bitmask)
    {
        if (ICF_FAILURE == icf_ssa_check_for_trans_param(p_ssa_pdb,
                    p_ssa_pdb->p_line_data->transport_mode, ICF_NULL, ICF_TRUE))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSettingTransport&Revert Modes"));
            return ICF_FAILURE;
        }
        if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_line_data->transport_mode) ||
                (ICF_TRANSPORT_MODE_BOTH == 
                 p_ssa_pdb->p_line_data->transport_mode))
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
        ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                ICF_SSA_EXPLICIT_CONNECT_REQ)
        }
        else if (ICF_TRANSPORT_TYPE_TLS == 
                p_ssa_pdb->p_line_data->transport_mode)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
        ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                ICF_SSA_EXPLICIT_CONNECT_REQ)
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
        }
    }
    else 
    {
        if ((ICF_TRUE == p_ssa_pdb->p_ssa_ctxt->trans_mode_reverted) ||
            (ICF_TRANSPORT_TYPE_UDP == 
            p_ssa_pdb->p_line_data->transport_mode))
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
        }
        else if (ICF_TRANSPORT_TYPE_TLS == 
            p_ssa_pdb->p_line_data->transport_mode)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
        }
    }
#ifdef ICF_P_CSCF_DISCOVERY_ENABLED
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
/* We will net the transport mode to none for P-CSCF Discovery */
    icf_port_strcpy(proto,"");
ICF_CHECK_IMS_END
#endif
#endif

    
    icf_port_strcpy((icf_uint8_t *)EventName,(icf_uint8_t *)p_sic_ctx->event_package.str);

    /*IMP: 
     * Updation needed in update_call_obj for ICF_SSA_USER_ADDR_FRM_SIC*/
    if (ICF_FAILURE == 
                icf_ssa_update_callobj_for_profile(p_ssa_pdb))
    {
    /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        return ICF_FAILURE;
    }
    /* IMP: 
     * Updation needed in set_to_in_reg_call_obj for 
     * ICF_SSA_USER_ADDR_FRM_SIC*/
    /* To header will be set */
    else if (
    (ICF_SSA_SIC_INITIAL_REQ & p_ssa_pdb->common_bitmask) &&
    (ICF_FAILURE == icf_ssa_set_to_in_sic_callobj(p_ssa_pdb,
                                            (icf_uint8_t *)proto))
    )
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        return ICF_FAILURE;
    }
#if 0
    /*Request URI to be set as destination address*/
    else if (Sdf_co_fail == 
                sdf_ivk_uaMakeAddrSpecFromConstituents(
                    &pAddrSpec, (Sdf_ty_s8bit*)server_addr, 
                    (Sdf_ty_s32bit)server_port,
                    pScheme, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        return ICF_FAILURE;
    }

    else if (Sdf_co_fail == sdf_ivk_uaChangeRequestURI(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                pAddrSpec, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
        return ICF_FAILURE;
    }
#endif

#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_TRUE)
    if (ICF_FAILURE != ret_val)
    {
        /* Fill Route Header from Service Route if stored for user-id while 
            registering*/
        if(ICF_FAILURE == 
        icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                p_sic_ctx->p_preferred_identity,
               p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
    }
ICF_CHECK_IMS_END
#endif
#ifdef NON_IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_FALSE)
    if (ICF_FAILURE != ret_val)
    {
        if(ICF_FAILURE == 
            icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                ICF_NULL,
               p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
    }
ICF_CHECK_IMS_END
#endif
    if (ICF_FAILURE == ret_val)
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        return ICF_FAILURE;
    }
    else if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                &p_overlap_trans_info,
                "SUBSCRIBE",
                &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
        return ICF_FAILURE;
    }

    else if ( Sdf_co_fail == 
            sdf_ivk_uaSetTransportSchemeInTransaction(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction, 
            p_overlap_trans_info,
            proto, &sdf_error))
        {
        
        sdf_ivk_uaClearTransaction(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            p_overlap_trans_info,
            "SUBSCRIBE",
            Sdf_en_uacTransaction);
        
        return ICF_FAILURE;
    }
    else if (Sdf_co_fail == sdf_ivk_uaMakeTransaction(
                (Sdf_ty_s8bit *)"SUBSCRIBE", 
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);

        return ICF_FAILURE;
    }
    else
    {
          /*If application does not want ICF to send expires header*/
      /* Fix for CSR 1-8400252: SPR 20336 */
      /* Expires header should be sent for UnSubscribe irrespective
       * of App setting.  */

         if ((!(ICF_SIC_EXPIRES_HDR_NOT_TO_BE_SEND & p_sic_ctx->bitmask)) ||
			 (ICF_NULL == p_sic_ctx->app_requested_duration))

         {
             /*Insert Expire header*/
             if (ICF_FAILURE == sip_initSipHeader(
                         &p_exp_hdr, SipHdrTypeExpiresSec, &sip_err))
             {
                 /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

                 sdf_ivk_uaClearTransaction(
                         p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                         p_overlap_trans_info,
                         "SUBSCRIBE",
                         Sdf_en_uacTransaction);

                 return ICF_FAILURE;
             }
             else if (ICF_FAILURE == sip_setSecondsInExpiresHdr(
                            p_exp_hdr, p_sic_ctx->app_requested_duration, &sip_err))
             {
                 sdf_ivk_uaClearTransaction(
                         p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                         p_overlap_trans_info,
                         "SUBSCRIBE",
                         Sdf_en_uacTransaction);

                 /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

                 sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);

                 return ICF_FAILURE;
             }
             else if (ICF_FAILURE == sip_setHeader(
                         p_overlap_trans_info->pSipMsg, 
                         p_exp_hdr, &sip_err))
             {
                 sdf_ivk_uaClearTransaction(
                         p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                         p_overlap_trans_info,
                         "SUBSCRIBE",
                         Sdf_en_uacTransaction);

                 /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
                 sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
                 return ICF_FAILURE;
             }
         }
    }
    /*Insert Event header*/
 /***** fix for event header: ROHIT *********/
    /* Insert Event header as SipHdrTypeEvent instead of SipHdrTypeUnknown */
    if (ICF_FAILURE == ret_val)
    {
        /*Do nothing*/
    }
    else if (ICF_FAILURE == sip_initSipHeader(
                &p_event_hdr, SipHdrTypeEvent, &sip_err))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);

        return ICF_FAILURE;
    }
    else if (ICF_FAILURE == sip_setEventTypeInEventHdr(
                p_event_hdr,Sdf_mc_strdupCT(EventName), &sip_err))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);
        if (ICF_NULL != p_event_hdr->pHeader)
        {
            sip_freeSipEventHeader((SipEventHeader*)p_event_hdr->pHeader);      
        }
        sip_freeSipHeader((SIP_Pvoid)p_event_hdr);

        return ICF_FAILURE;
    }
    else if (ICF_FAILURE == sip_setHeader(
                p_overlap_trans_info->pSipMsg, 
                p_event_hdr, &sip_err))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        sip_freeSipEventHeader((SipEventHeader*)p_event_hdr->pHeader);
        sip_freeSipHeader((SIP_Pvoid)p_event_hdr);

        return ICF_FAILURE;
    }
    else if ( ICF_FAILURE == 
                icf_ssa_form_and_insert_access_nw_info_hdr(
                p_ssa_pdb, p_overlap_trans_info->pSipMsg))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        sip_freeSipEventHeader((SipEventHeader*)p_event_hdr->pHeader);
        sip_freeSipHeader((SIP_Pvoid)p_event_hdr);
        return ICF_FAILURE;
    }
    if (ICF_NULL != p_event_hdr)
    {

        sip_freeSipEventHeader((SipEventHeader*)p_event_hdr->pHeader);

        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_event_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)

    }
    sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_exp_hdr,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)

#ifdef ICF_IPSEC_ENABLED
    /* if SA exists, all messages will go protected */
    if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled) &&
        /* if SA exits */
        (ICF_NULL != p_ssa_pdb->p_sa_context))
    {
        /* insert security-verify header in the otg Subscribe */
        if (ICF_FAILURE == icf_ssa_get_sec_verify_string (p_ssa_pdb,&p_value,
            p_ssa_pdb->p_sa_context))
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE ==     
          icf_ssa_insert_unknown_hdr_in_sip_msg (
              p_ssa_pdb,
              (icf_uint8_t*)"Security-Verify",
              p_value, 
              p_overlap_trans_info->pSipMsg))
        {
            ICF_PRINT(("\nFailed to insert unknown header \
                    (Security-Verify)"));
            ret_val = ICF_FAILURE;
        }
        if (ICF_NULL != p_value)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_value,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        }
        if (ICF_SUCCESS == ret_val )
        {
            ICF_PRINT(("\nSecurity Verify Header inserted to \
                            outgoing SUBSCRIBE "));
        }
    }
#endif
   if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
    {
        icf_string_st                 addr_val;

        if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_SIP_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sip:");
            icf_port_strcat( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                p_preferred_identity->addr_val.str );
            icf_port_strcat( addr_val.str, (icf_uint8_t *)">");


        }
        else if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_TEL_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"tel:");
            icf_port_strcat( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                p_preferred_identity->addr_val.str );
        }
        else if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_E164)
        {
            icf_port_strcpy(addr_val.str,(icf_uint8_t *)"<sip:");

            icf_port_strcat(addr_val.str,
                    p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                    p_preferred_identity->addr_val.str );

            icf_port_strcat(addr_val.str,(icf_uint8_t *)"@");

            /* now appending the self IP/domain */
            /*If per line self transport then copy address from line_data*/
            if(ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
            {
                if(ICF_NULL != p_ssa_pdb->p_line_data)
                {
                    icf_port_memcpy(&self_addr,
                                &(p_ssa_pdb->p_line_data->self_addr),
                                sizeof(icf_transport_address_st));
                }
                else
                {
                    ret_val = ICF_FAILURE;
                }
            }
            else
            {
                icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                                sizeof(icf_transport_address_st));
                }
            if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                           self_addr.addr.addr_type)
            {
                icf_port_strcat(addr_val.str,self_addr.addr.addr.domain.str);
            }
            else/*Assumption that it will be IPV4*/
            {
                if(ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                                      &(self_addr),self_ip))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    icf_port_strcat(addr_val.str,self_ip);
                }
            }
            icf_port_strcat(addr_val.str, (icf_uint8_t *)">");
        }
        else
        {
            icf_port_strcpy( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                p_preferred_identity->addr_val.str );
        }


        if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                p_ssa_pdb, 
                (icf_uint8_t*)"P-Preferred-Identity",
                addr_val.str,
                p_overlap_trans_info->pSipMsg ))
        {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header \
                                    (P-Preferred-Identity)"));
                sdf_ivk_uaClearTransaction(
                                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                                p_overlap_trans_info,
                                "SUBSCRIBE",
                                Sdf_en_uacTransaction);

                /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

                return ICF_FAILURE;
        }
    }


    /* Insert Header/Tag/Body if any given by the application */

    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count)
    {
        if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list),
            ICF_TRUE, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
    }
    
    
    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list.count)
    {
        if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list),
            ICF_FALSE, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
        
    }
    
        if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.count)
    {
        /*Message body header changes Starts*/
        if (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
                    p_ssa_pdb,&(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list) , 
                    ICF_TRUE, &(p_overlap_trans_info->slMsgBodyList)))
        {
            sdf_ivk_uaClearTransaction(\
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                    p_overlap_trans_info, "SUBSCRIBE",\
                    Sdf_en_uacTransaction);

            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                        p_ssa_ctxt->p_call_obj));*/

            return ICF_FAILURE;
        }
        else if ( ICF_FAILURE == icf_ssa_SetAllMsgBody(\
                    Sdf_co_null, p_overlap_trans_info,\
                    (icf_int8_t *)p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.\
                    content_type.str, &sdf_error))
        {
            sdf_ivk_uaClearTransaction(\
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                    p_overlap_trans_info, "SUBSCRIBE",\
                    Sdf_en_uacTransaction);

            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                        p_ssa_ctxt->p_call_obj));*/

            return ICF_FAILURE;
        }
    }/*p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.count*/

    if (ICF_SUCCESS == ret_val)
    {
        if ( ICF_FAILURE == icf_ssa_send_to_peer(
            p_ssa_pdb,
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            p_overlap_trans_info->pSipMsg,
            &options,
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == sdf_ivk_uaEndTransaction(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            Sdf_co_null,
            "SUBSCRIBE",
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
    }
    return ret_val;
} /* icf_ssa_send_subscribe_req */



/****************************************************************************
 * FUNCTION:           icf_ssa_init_ssa_context
 *
 * DESCRIPTION:        This routine initializes SSA Context
 * 
 *****************************************************************************/
icf_void_t   icf_ssa_init_ssa_context(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT   icf_ssa_ctxt_st  *p_ssa_ctxt)
{
ICF_CRM_START
    Sdf_st_error                    sip_err;
ICF_CRM_END
    icf_uint16_t                 i;

    if (ICF_NULL != p_ssa_ctxt)
    {
        icf_port_memset(p_ssa_ctxt,0,sizeof(icf_ssa_ctxt_st));
        
        p_ssa_ctxt->callobj_map_index = ICF_SSA_MAX_OPTIONS_CALL_OBJ;        
        p_ssa_ctxt->options_map_index = ICF_SSA_MAX_OPTIONS_CALL_OBJ;
        p_ssa_ctxt->p_conn_table_resp_entry = ICF_NULL;
        p_ssa_ctxt->p_conn_table_req_entry = ICF_NULL;
        p_ssa_ctxt->p_ssa_glb_data = p_ssa_pdb->p_ssa_glb_data;
        p_ssa_ctxt->p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    p_ssa_ctxt->p_hash_key = ICF_NULL;
        /* Fix for SPR 17158 */
        p_ssa_ctxt->bitmask &= ~ICF_SSA_OPTIONS_RECVD_OUT_OF_DIALOG;

ICF_CRM_START
        if (ICF_NULL != p_ssa_ctxt->p_auth_params_list)
        {
                sdf_listDeleteAll(
                    p_ssa_ctxt->p_auth_params_list,
                    &sip_err);
        }
ICF_CRM_END
        p_ssa_ctxt->p_auth_params_list = Sdf_co_null;
        p_ssa_ctxt->auth_params_list_size = 0;
        for (i = 0; i < ICF_MAX_PENDING_PDU_PER_CONN; i++)
        {
            p_ssa_ctxt->p_pending_pdu[i] = ICF_NULL;
        }
        p_ssa_ctxt->no_of_pending_pdu = 0;
#ifdef ICF_SESSION_TIMER
    p_ssa_ctxt->session_timer_expired_refresh = ICF_FALSE;
    p_ssa_ctxt->refresher_method_type    = ICF_SSA_REFRESHER_METHOD_NONE;
#endif
#ifdef ICF_IPSEC_ENABLED
        p_ssa_ctxt->ssa_sa_context.p_sa_context = ICF_NULL;
        p_ssa_ctxt->ssa_sa_context.p_rgm_context = ICF_NULL;
#endif
        p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;
        p_ssa_ctxt->p_ssa_pdb = p_ssa_pdb;        
        p_ssa_pdb->p_ssa_ctxt->sdp_o_version = ICF_START_SDP_O_VERSION;

        p_ssa_pdb->p_ssa_ctxt->nc = 0;
        p_ssa_pdb->p_ssa_ctxt->dns_srv_count = 0;

        p_ssa_pdb->p_ssa_ctxt->timer_count = 0;
#ifdef ICF_NAT_RPORT_SUPPORT
        p_ssa_pdb->p_ssa_ctxt->rport_bitmask = ICF_NULL;
#endif
#ifdef ICF_DNS_LOOKUP_ENABLED
     p_ssa_pdb->p_ssa_ctxt->p_transaction = ICF_NULL;
     p_ssa_pdb->p_ssa_ctxt->p_overlap_transaction = ICF_NULL;
     p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr = ICF_NULL;
     p_ssa_ctxt->p_dns_resp_timer_data = ICF_NULL;
#endif

     /********** Changes for Forking & Multiple Answer Start (Rel7.0) *********/

      p_ssa_ctxt->forked_resp_counter = ICF_NULL;

     /********** Changes for Forking & Multiple Answer End (Rel7.0) ***********/

    }
} /* icf_ssa_init_ssa_context */

/*******************************************************************************
 * FUNCTION:        icf_ssa_handle_notify_for_subs
 *
 * DESCRIPTION:     This function parses NOTIFY req received for SUBSCRIPTION
 *
 ******************************************************************************/
icf_return_t   icf_ssa_handle_notify_for_subs(
        icf_ssa_pdb_st              *p_ssa_pdb,
        icf_nw_inc_notify_ind_st    *p_notify_ind,
        Sdf_st_overlapTransInfo        *pOverlapTransInfo,
        SipMessage                     *pSipMsg)
{
    icf_return_t    ret_val = ICF_SUCCESS;
    /* NOTIFY crash fix for p_subs_state = "" */
    SipHeader          subs_header = {SipHdrTypeSubscriptionState, SIP_NULL}, 
                       content_type_hdr = {SipHdrTypeContentType, SIP_NULL};
    Sdf_st_error       sdf_error;
    SipError           sip_error = 0;
    SIP_S8bit          *p_subs_state = SIP_NULL;
    SIP_U32bit         param_count = 0;
    SipError           error;
    SipParam           *p_param_list = ICF_NULL;
    SIP_U32bit         count = 0;
    icf_uint8_t     reason_code[15]="\0", *p_param_val;
    icf_uint16_t    retry_after = 0;
    icf_uint32_t    expires = 0;
    
    
    /* Initializing the members of notify_ind structure. */
    p_notify_ind->bitmask = ICF_NULL;
    p_notify_ind->duration = ICF_NULL;
    p_notify_ind->reason_code = ICF_NULL;
    p_notify_ind->subs_state = ICF_NULL;


    if (ICF_SSA_APP_CTX_DELINKED ==
        (ICF_SSA_APP_CTX_DELINKED & p_ssa_pdb->p_ssa_ctxt->bitmask))
    {
        ret_val = icf_ssa_form_and_send_response(
                      p_ssa_pdb, 200, p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                      pOverlapTransInfo, "NOTIFY", Sdf_co_false);
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }

    
    /*Fetch Subscription-State header*/
    if (SipFail == sip_getHeader(pSipMsg, 
                SipHdrTypeSubscriptionState,&subs_header, 
                (SipError*)&(sdf_error.stkErrCode)))
    {
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == 
            sip_impp_getSubStateFromSubscriptionStateHdr(
                &subs_header,&p_subs_state,
                (SipError*)&(sdf_error.stkErrCode)))
    {
        sip_freeSipHeader(&subs_header);
        return ICF_FAILURE;
    }
    else
    {
        /*Get Parameters in Subscription Header*/
        param_count = 
                              
#ifdef ICF_WITH_MUATK_2_2
            ((SipSubscriptionStateHeader*)(subs_header.pHeader))->slParam.size;
#else
            ((SipSubscriptionStateHeader*)(subs_header.pHeader))->slParams.size;
#endif                
        while (count < param_count)
        {
            if (SipSuccess == 
                    sip_impp_getParamAtIndexFromSubscriptionStateHdr(
                        &subs_header, &p_param_list, count, &error))
            {
                sip_listGetAt(&(p_param_list->slValue), 0, 
                        (SIP_Pvoid *)&p_param_val, &error);
                
                if ( 0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"reason"))
                {
                    icf_port_strcpy(reason_code, p_param_val);
                }
                else if (0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"retry-after"))
                {
                    retry_after = (icf_uint16_t)icf_port_atoi((const icf_int8_t *)p_param_val);
                }
                else  if (0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"expires"))
                {
                    expires = icf_port_atoi((const icf_int8_t *)p_param_val);
                }
                sip_freeSipParam(p_param_list);
            }

            count++;
        } /* while (count < param_count) */
    } /* else */
    /* NOTIFY crash fix for p_subs_state = "" */
	/* In case no Subscription-State header is received in NOTIFY, ICF will
	 * respond with 400 failure response */

	if (ICF_NULL == p_subs_state)
    {
        ICF_PRINT(((icf_uint8_t *)"\nNOTIFY received without Subscription-State header\n"));

        ret_val = icf_ssa_form_and_send_response(
              p_ssa_pdb, 400, p_ssa_pdb->p_ssa_ctxt->p_call_obj,
              pOverlapTransInfo, "NOTIFY", Sdf_co_false);

        /* Free the local reference */
        sip_freeSipHeader(&subs_header);

        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }
    else if ((0 == icf_port_strcmp((icf_uint8_t *)p_subs_state, (icf_uint8_t *)"active")) ||
            (0 == icf_port_strcmp((icf_uint8_t *)p_subs_state, (icf_uint8_t *)"pending")))
    {
        /*If subscription-state is active or pending then mark subs_state
         * = ICF_SUBS_STATE_ACTIVE*/
        p_notify_ind->subs_state = ICF_SUBS_STATE_ACTIVE;

        /*If expires parameter is present then copy to duration and mark
         * bitmask as duration_present*/
        if (0 != expires)
        {
            p_notify_ind->duration = expires * 1000;

            p_notify_ind->bitmask = ICF_NW_INC_SUBS_DURATION_PRESENT;
        }
    } /* (0 == icf_port_strcmp(p_sub... */
    else
    {
        /*Otherwise mark subs_state = ICF_SUBS_STATE_TERMINATED*/
        p_notify_ind->subs_state = ICF_SUBS_STATE_TERMINATED;

        if ((0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"rejected")) ||
                (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"noresource")))
        {
            p_notify_ind->reason_code = ICF_NW_INC_NOTIFY_NO_RETRY;
                /*ICF_NW_INC_SUBS_RESP_NO_RETRY;*/
        }
        else if (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"giveup"))
        {
            if (0 != retry_after)
            {
                p_notify_ind->duration = retry_after;

                p_notify_ind->bitmask = ICF_NW_INC_SUBS_DURATION_PRESENT;

                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_AFTER;
            }
            else
            {
                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_IMM;
            }
        } /* else if (0 == icf_port_strc... */
        else if ((0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"deactivated")) ||
                (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"timeout")))
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_NOTIFY_RETRY_IMM;
        }
        else if (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"probation"))
        {
            if (0 != retry_after)
            {
                p_notify_ind->duration = retry_after;
                
                p_notify_ind->bitmask = ICF_NW_INC_SUBS_DURATION_PRESENT;
                
                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_AFTER;
            }
            else  
            {
                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_NO_RETRY;
            }
        }
        else  
        {
            /* kodiak 18 Feb fix for default behavior */
            p_notify_ind->reason_code = 
                ICF_NW_INC_NOTIFY_NO_RETRY;
            
        }
    } /* else */
    /* Free the local reference */

    /*CSR 1-6179301: Moved the APP_TRACE after the decision making for 
      subs_state*/ 
#ifdef ICF_TRACE_ENABLE
     /* Fix to fetch expires duration so that correct value gets printed 
        for ICF_TRACE_NOTIFY_FOR_SUBS */
     p_ssa_pdb->notify_duration = expires;
     p_ssa_pdb->p_subs_state = p_subs_state;
     ICF_SSA_APP_TRACE(p_ssa_pdb,ICF_TRACE_NOTIFY_FOR_SUBS)
#endif

    sip_freeSipHeader(&subs_header);
                
    /*Fetch Content-Type header from SIP message*/
    /*If Content-Type is application/simple-message-summary then
     * fetch message body*/
    if (ICF_SUCCESS == ret_val)
    {
        icf_uint8_t        *p_media_type;
        en_SipMessageType  dReqRespType;
ICF_SIC_START
        Sdf_ty_s8bit        *p_buffer = Sdf_co_null;
        Sdf_ty_u32bit        bufLength = 0;
        Sdf_ty_u32bit       dCount = 0;
        icf_msg_body_st    *p_msg_body = ICF_NULL;
        /*Fix done for SPR-18722 : CSR-1-6068965*/
        icf_int8_t        *p_ContentTypeVal = ICF_NULL;
ICF_SIC_END

        p_notify_ind->p_sic_ctx->body_list.count=0;

        if (SipFail == sip_getMsgBodyCount(pOverlapTransInfo->pSipMsg, &dCount, &error))
        {
            /*ICF_SSA_TRACE(("\nFailed to get MsgBodyCount from SipMessage"))*/
            return ICF_FAILURE;
        }

        if(dCount)
        {

            if(dCount == 1)
            {

                if (sip_getHeader(pOverlapTransInfo->pSipMsg, 
                            SipHdrTypeContentType,
                            &content_type_hdr, &error) == SipFail)
                {
                    ICF_PRINT(((icf_uint8_t *)"\nFailed to get Content-Type Header"));
                    return ICF_FAILURE;
                }
                else if (sip_getMediaTypeFromContentTypeHdr(&content_type_hdr, 
                            (SIP_S8bit **)&p_media_type,\
                            &error) == SipFail)
                {
                    sip_freeSipHeader(&content_type_hdr);
                    ICF_PRINT(((icf_uint8_t *)"\nFailed to get media-type from "
                                "Content-Type Header"));

                    return ICF_FAILURE;
                }
                /* Free the local reference */
                sip_freeSipHeader(&content_type_hdr);

                if(sdf_ivk_uaGetUnknownBodyFromSipMessage(pOverlapTransInfo->pSipMsg, 0, \
                        &p_buffer, &bufLength, &sdf_error) == Sdf_co_success)
                {                              
            
                    /* allocate memory for a msg body list node and add to List*/
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        ICF_PORT_SIZEOF(icf_msg_body_st),
                        ICF_MEM_COMMON, 
                        p_msg_body,
                        ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                
                     p_notify_ind->p_sic_ctx->body_list.body = p_msg_body;   
            
                    /* Increment the msg body count by one */
                    p_notify_ind->p_sic_ctx->body_list.count++;
                    p_msg_body->next = ICF_NULL;
            
                    /*
                    * Set the content type of the unknown msg body to null
                    * we do not parse unknown msg bodies at present.
                    */               
                    p_msg_body->content_type.str_len = (icf_uint16_t)strlen((const icf_int8_t *)p_media_type);
                    icf_port_strcpy(p_msg_body->content_type.str,p_media_type);

            
                    p_msg_body->length= bufLength;
                    /* Allocate memory for message body value and copy the recvd msg body*/
                    if (ICF_NULL != p_msg_body->length)
                    {
                        ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                            (bufLength + 1),
                            ICF_MEM_COMMON,
                            p_msg_body->value,
                            ICF_RET_ON_FAILURE,
                            p_ssa_pdb->p_ecode, ret_val)
                    
                            icf_port_memcpy(p_msg_body->value,(char*)p_buffer,bufLength);
                            p_msg_body->value[bufLength] = '\0';
                
                    }                 
                }
            }/*if(dCount == 1)*/
            else
            {
                icf_uint8_t     iterator1=0;

                for (iterator1 = 0; iterator1 < (icf_uint16_t)dCount; iterator1++)
                {
        
                    if(sdf_ivk_uaGetUnknownBodyFromSipMessage(pOverlapTransInfo->pSipMsg, iterator1, \
                        &p_buffer, &bufLength, &sdf_error) == Sdf_co_success)
                    { 
                        SipMsgBody        *pTempMsgBody=Sdf_co_null;
                        if (p_notify_ind->p_sic_ctx->body_list.count == 0)
                        {
                            /* allocate memory for a msg body list node and add to List*/
                            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                                ICF_PORT_SIZEOF(icf_msg_body_st),
                                ICF_MEM_COMMON, 
                                p_msg_body,
                                ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                        
                                p_notify_ind->p_sic_ctx->body_list.body = p_msg_body;   
                        }
                        else
                        {
                            /* allocate memory for a msg body list node and add to List*/
                            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                                ICF_PORT_SIZEOF(icf_msg_body_st),
                                ICF_MEM_COMMON, 
                                p_msg_body->next,
                                ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                        
                                p_msg_body = p_msg_body->next;                     
                        }
                        /* Increment the msg body count by one */
                        p_notify_ind->p_sic_ctx->body_list.count++;
                        p_msg_body->next = ICF_NULL;
                
                        /*
                        * Set the content type of the unknown msg body to null
                        * we do not parse unknown msg bodies at present.
                        */               
                        /*p_msg_body->content_type.str_len = 0;*/
                        /*icf_port_strcpy(p_msg_body->content_type.str,"\0");*/

                        
                        sip_listGetAt(
                            &(pOverlapTransInfo->pSipMsg->slMessageBody),\
                            iterator1,(SIP_Pvoid *)&pTempMsgBody,\
                            &sip_error);

                        if(pTempMsgBody)
                        {
                            ret_val =  icf_ssa_get_mime_hdrs_from_sip_msg(\
                                        SipMessageRequest,
                                        p_ssa_pdb,pTempMsgBody,p_msg_body);
                         p_msg_body->content_type.str_len = 
                        (icf_uint16_t)icf_port_strlen(p_msg_body->content_type.str);
                        }
                        else
                        {
                            p_msg_body->content_type.str_len = 0;
                            icf_port_strcpy(p_msg_body->content_type.str,(icf_uint8_t *)"\0");
                        }
                
                        p_msg_body->length= bufLength;
                        /* Allocate memory for message body value and copy the recvd msg body*/
                        if (ICF_NULL != p_msg_body->length)
                        {
                            ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                                bufLength,
                                ICF_MEM_COMMON,
                                p_msg_body->value,
                                ICF_RET_ON_FAILURE,
                                p_ssa_pdb->p_ecode, ret_val)
                        
                                icf_port_memcpy(p_msg_body->value,(char*)p_buffer,bufLength);
                    
                        }                 
                    }  
                    
                }/*for*/
            }/*if(dCount > 1)*/

             /* Support Fix : Fill the top level Content Type Header in message body.
            */
            
            if (SipFail == sip_getHeader(pOverlapTransInfo->pSipMsg,\
                SipHdrTypeContentType,&content_type_hdr, &sip_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to get Content-Type Header"));
                ret_val = ICF_FAILURE;
            }
            else if (SipFail == sip_getMessageType(pOverlapTransInfo->pSipMsg, 
                    &dReqRespType, &sip_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to get Content-Type Header"));
                ret_val = ICF_FAILURE;
            }
            else if(ICF_FAILURE == icf_ssa_get_content_type_frm_msg(\
                dReqRespType,p_ssa_pdb,&content_type_hdr,\
                &p_ContentTypeVal))
            {
                ICF_PRINT(((icf_uint8_t *)"Failed to get Content-Type Header from SIP"\
                    " message\n"));
                if(ICF_NULL != p_ContentTypeVal)
                {
                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_ContentTypeVal,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                }
                /* Free the local reference */
                sip_freeSipHeader(&content_type_hdr);
                ret_val = ICF_FAILURE;
            }
            else
            {
                /* Klocwork warning removal.*/
                if(ICF_NULL != p_ContentTypeVal)
                {           
                /*Fix done for SPR-18722 : CSR-1-6068965*/
                icf_port_strcpy(p_notify_ind->p_sic_ctx->body_list.content_type.str,
                    (icf_uint8_t *)p_ContentTypeVal);
                p_notify_ind->p_sic_ctx->body_list.content_type.str_len =
                    (icf_uint16_t)icf_port_strlen((icf_uint8_t *)p_ContentTypeVal);

                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_ContentTypeVal,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
                }
                sip_freeSipHeader(&content_type_hdr);                
            }
            /* End of Support Fix : Top level Content Type Header.*/
            
            
        }/*if(dCount)*/


ICF_SIC_END

        
        if (ICF_FAILURE != ret_val)
        {
            p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = 
                ICF_NW_INC_NOTIFY_IND;

            p_ssa_pdb->p_internal_msg->msg_hdr.payload_length =
                ICF_PORT_SIZEOF(icf_nw_inc_notify_ind_st);

            p_ssa_pdb->dest_module_id = ICF_INT_MODULE_SIC;
        }
    }

    return ret_val;
} /* icf_ssa_handle_notify_for_subs */

/*******************************************************************************
 * FUNCTION:        icf_ssa_handle_notify_for_refer
 *
 * DESCRIPTION:     This function parses NOTIFY req received for REFER
 *
 ******************************************************************************/
icf_return_t   icf_ssa_handle_notify_for_refer(
        icf_ssa_pdb_st              *p_ssa_pdb,
        icf_nw_inc_notify_ind_st    *p_notify_ind,
        Sdf_st_overlapTransInfo        *pOverlapTransInfo,
        SipMessage                     *pSipMsg)
{
    icf_return_t    ret_val = ICF_SUCCESS;
    SipHeader          subs_header, content_type_hdr;
    Sdf_st_error       sdf_error;
    SIP_S8bit          *p_subs_state = SIP_NULL;
    SIP_U32bit         param_count = 0;
    SipError           error;
    SipParam           *p_param_list = ICF_NULL;
    SIP_U32bit         count = 0;
    icf_uint8_t     reason_code[15]="\0", *p_param_val;
    icf_uint16_t    retry_after = 0;
    icf_uint16_t    expires = 0;
    icf_boolean_t   notification_status = ICF_TRUE;
    SipError           sip_error;
    icf_uint8_t      prov_notify_resp = ICF_FALSE;
    icf_boolean_t   indicate_service = ICF_TRUE;

       
    /*Fetch Subscription-State header*/
    if (SipFail == sip_getHeader(pSipMsg, 
                SipHdrTypeSubscriptionState,&subs_header, 
                (SipError*)&(sdf_error.stkErrCode)))
    {
        ret_val = icf_ssa_form_and_send_response(
                p_ssa_pdb,400,
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                pOverlapTransInfo,
                "NOTIFY", Sdf_co_false);

        return ICF_FAILURE;
    }
    else if (SipFail == 
            sip_impp_getSubStateFromSubscriptionStateHdr(
                &subs_header,&p_subs_state,
                (SipError*)&(sdf_error.stkErrCode)))
    {
        sip_freeSipHeader(&subs_header);
        return ICF_FAILURE;
    }
    else
    {
        /*Get Parameters in Subscription Header*/
        param_count = 
                
#ifdef ICF_WITH_MUATK_2_2
            ((SipSubscriptionStateHeader*)(subs_header.pHeader))->slParam.size;
#else
            ((SipSubscriptionStateHeader*)(subs_header.pHeader))->slParams.size;
#endif                
               
        while (count < param_count)
        {
            if (SipSuccess == 
                    sip_impp_getParamAtIndexFromSubscriptionStateHdr(
                        &subs_header, &p_param_list, count, &error))
            {
                sip_listGetAt(&(p_param_list->slValue), 0, 
                        (SIP_Pvoid *)&p_param_val, &error);
                
                if ( 0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"reason"))
                {
                    icf_port_strcpy(reason_code, p_param_val);
                }
                else if (0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"retry-after"))
                {
                    retry_after = (icf_uint16_t )icf_port_atoi((const icf_int8_t *)p_param_val);
                }
                else  if (0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"expires"))
                {
                    expires = (icf_uint16_t)icf_port_atoi((const icf_int8_t *)p_param_val);
                }
                sip_freeSipParam(p_param_list);
            }

            count++;
        } /* while (count < param_count) */
    } /* else */


    if ((0 == icf_port_strcmp((icf_uint8_t *)p_subs_state, (icf_uint8_t *)"active")) ||
            (0 == icf_port_strcmp((icf_uint8_t *)p_subs_state, (icf_uint8_t *)"pending")))
    {
        /*If subscription-state is active or pending then mark subs_state
         * = ICF_SUBS_STATE_ACTIVE*/
        p_notify_ind->subs_state = ICF_SUBS_STATE_ACTIVE;

        /*If expires parameter is present then copy to duration and mark
         * bitmask as duration_present*/
        if (0 != expires)
        {
            p_notify_ind->duration = expires * 1000;

            p_notify_ind->bitmask = ICF_NW_INC_SUBS_DURATION_PRESENT;
        }
    } /* (0 == icf_port_strcmp(p_sub... */
    else
    {
        /*Otherwise mark subs_state = ICF_SUBS_STATE_TERMINATED*/
        p_notify_ind->subs_state = ICF_SUBS_STATE_TERMINATED;

        if ((0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"rejected")) ||
                (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"noresource")))
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_SUBS_RESP_NO_RETRY;
        }
        else if (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"giveup"))
        {
            if (0 != retry_after)
            {
                p_notify_ind->duration = retry_after;

                p_notify_ind->bitmask = ICF_NW_INC_SUBS_DURATION_PRESENT;

                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_AFTER;
            }
            else
            {
                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_IMM;
            }
        } /* else if (0 == icf_port_strc... */
        else if ((0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"deactivated")) ||
                (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"timeout")))
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_NOTIFY_RETRY_IMM;
        }
        else if (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"probation"))
        {
            if (0 != retry_after)
            {
                p_notify_ind->duration = retry_after;

                p_notify_ind->bitmask = ICF_NW_INC_SUBS_DURATION_PRESENT;
            }

            p_notify_ind->reason_code = 
                ICF_NW_INC_NOTIFY_RETRY_AFTER;
        }
        else  
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_SUBS_RESP_NO_RETRY;
        }
    } /* else */
    /* Free the local reference */
    sip_freeSipHeader(&subs_header);
                
    /*Fetch Content-Type header from SIP message*/
    /*If Content-Type is application/simple-message-summary then
     * fetch message body*/
    if (ICF_SUCCESS == ret_val)
    {
        icf_uint8_t        *p_media_type;
        en_SipMessageType  dReqRespType;
ICF_SIC_START
        Sdf_ty_s8bit        *p_buffer = Sdf_co_null;
        Sdf_ty_u32bit        bufLength = 0;
        Sdf_ty_u32bit       dCount = 0;
        icf_msg_body_st    *p_msg_body = ICF_NULL;
        SipMsgBody            *pTempMsgBody=Sdf_co_null;
		/*Fix done for SPR-18722 : CSR-1-6068965*/
        icf_int8_t         *p_ContentTypeVal = ICF_NULL;
ICF_SIC_END

        if (ICF_NULL != p_notify_ind->p_sic_ctx)
            p_notify_ind->p_sic_ctx->body_list.count=0;

        if (SipFail == sip_getMsgBodyCount(pOverlapTransInfo->pSipMsg, &dCount, &error))
        {
            /*ICF_SSA_TRACE(("\nFailed to get MsgBodyCount from SipMessage"))*/
            return ICF_FAILURE;
        }

        if(dCount)
        {

            if (sip_getHeader(pOverlapTransInfo->pSipMsg, 
                        SipHdrTypeContentType,
                        &content_type_hdr, &error) == SipFail)
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to get Content-Type Header"));
                return ICF_FAILURE;
            }
            else if (sip_getMediaTypeFromContentTypeHdr(&content_type_hdr, 
                        (SIP_S8bit **)&p_media_type,\
                        &error) == SipFail)
            {
                sip_freeSipHeader(&content_type_hdr);
                ICF_PRINT(((icf_uint8_t *)"\nFailed to get media-type from "
                            "Content-Type Header"));

                return ICF_FAILURE;
            }
            /* Support Fix : Fill the top level Content Type Header in message body.
             */
            else if (SipFail == sip_getMessageType(pOverlapTransInfo->pSipMsg, 
                    &dReqRespType, &error))
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to get message type"));
                ret_val = ICF_FAILURE;
            }
            else if(ICF_FAILURE == icf_ssa_get_content_type_frm_msg(\
                    dReqRespType,p_ssa_pdb,&content_type_hdr,\
                    &p_ContentTypeVal))
            {
                ICF_PRINT(((icf_uint8_t *)"Failed to get Content-Type Header from SIP"\
                   " message\n"));
                /* Free the local reference */
                sip_freeSipHeader(&content_type_hdr);
                ret_val = ICF_FAILURE;
            }
            else if(ICF_NULL == p_ContentTypeVal)
            {
                 /* Free the local reference */
                 sip_freeSipHeader(&content_type_hdr);
                ret_val = ICF_FAILURE;
                  return ret_val;
            }
            /* End of Support Fix: for top level content type header.*/
            /* Free the local reference */
            sip_freeSipHeader(&content_type_hdr);

  /*If NOTIFY is received for REFER and message body contains
             *sip fragmented body*/
			/*Fix done for SPR-18722 : CSR-1-6068965*/
            if (0 == 
                Sdf_mc_strcasecmp((icf_int8_t *)p_media_type, 
                (icf_int8_t *)"message/sipfrag"))
            {
                if ( ICF_FAILURE == 
                    icf_ssa_get_status_frm_notify(p_ssa_pdb, 
                    pOverlapTransInfo->pSipMsg,
                    &notification_status,
                    &indicate_service))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    if ((100 <= p_ssa_pdb->resp_code) &&
                            (199 >= p_ssa_pdb->resp_code))
                    {
                        /* Added for sendint traces */
                        ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_NOTIFY_FOR_REFER_RECVD)
                        prov_notify_resp = ICF_TRUE;
                    }

                    p_notify_ind->status = notification_status;
                }
            }
        
ICF_SIC_START

  else 
  {

    if ((ICF_FAILURE != ret_val) && 
            (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt))
        {
            icf_uint8_t        iterator1=0;
        
            /* Support Fix : Fill the top level content type header in the body list
             */
            if(ICF_NULL != p_ContentTypeVal)
            {
			    /*Fix done for SPR-18722 : CSR-1-6068965*/
                icf_port_strcpy(p_notify_ind->p_sic_ctx->body_list.content_type.str,
                    (icf_uint8_t *)p_ContentTypeVal);
                p_notify_ind->p_sic_ctx->body_list.content_type.str_len =
                    (icf_uint16_t)icf_port_strlen((icf_uint8_t *)p_ContentTypeVal);  
            }

            /*
            icf_port_strcpy(p_notify_ind->p_sic_ctx->body_list.content_type.str,
                p_media_type);
            p_notify_ind->p_sic_ctx->body_list.content_type.str_len =
                icf_port_strlen(p_media_type);
            */

            for (iterator1 = 0; iterator1 < (icf_uint16_t)dCount; iterator1++)
            {
                /*Changes Start for Message Body Header SPR 10934*/

                SipMimeHeader         *pMime = Sdf_co_null;
                SipHeader             *pContentType = Sdf_co_null;
                Sdf_ty_s8bit          *pMediaType = ICF_NULL;
                
                /* Get Content Type from Message Body
                 */
               sip_listGetAt(
                            &(pOverlapTransInfo->pSipMsg->slMessageBody),
                            iterator1,(SIP_Pvoid *)&pTempMsgBody, &sip_error);

               if(SipFail != sip_bcpt_getMimeHeaderFromMsgBody(pTempMsgBody\
                   ,&pMime,&sip_error))
               {
                 /* Get Content-Type Header from Message Body
                  */
                   
                 if (sip_initSipHeader(&pContentType, SipHdrTypeAny, \
                         (SipError*)&(sdf_error.stkErrCode)) == SipFail)
                 {
                     return ICF_FAILURE;
                 }
                 else if (sip_bcpt_getContentTypeFromMimeHdr(pMime,\
                      &pContentType, &(sip_error)) \
                     == SipFail)
                 {    
                     sip_bcpt_freeSipMimeHeader(pMime);
                     ret_val = ICF_FAILURE;
                 }
                  /* Extract the content - type header values from the
                   * Sip message body.
                   */
                   else if (sip_getMediaTypeFromContentTypeHdr(pContentType, &pMediaType,\
                          &error) == SipFail)
                   {
                       ICF_PRINT(((icf_uint8_t *)"\nFailed to get media-type from Content-Type "\
                                "Header"));
                       sip_freeSipHeader(pContentType);
                       sip_bcpt_freeSipMimeHeader(pMime);
                       ret_val = ICF_FAILURE;
                   }
                           
                   else if(0 == Sdf_mc_strcasecmp(pMediaType,\
                             "message/sipfrag"))
                   {
                     if ( ICF_FAILURE == 
                               icf_ssa_get_status_frm_notify_from_mime_body(p_ssa_pdb, 
                              pTempMsgBody,&notification_status))
                    {
                          ret_val = ICF_FAILURE;
                          sip_freeSipHeader(pContentType);
                          sdf_memfree(Sdf_mc_callHandlerMemId, \
                            (Sdf_ty_pvoid *)&pMediaType,\
                                Sdf_co_null);
                          sip_bcpt_freeSipMimeHeader(pMime);
                          continue;
                     }
                     else
                     {
                          p_notify_ind->status = notification_status;
                          sip_freeSipHeader(pContentType);
                          sdf_memfree(Sdf_mc_callHandlerMemId, \
                           (Sdf_ty_pvoid *)&pMediaType,\
                                Sdf_co_null);
                          sip_bcpt_freeSipMimeHeader(pMime);
                          continue;
                     }
                   }
                   else
                   {
                       sip_freeSipHeader(pContentType);
                       sdf_memfree(Sdf_mc_callHandlerMemId, \
                           (Sdf_ty_pvoid *)&pMediaType,\
                                Sdf_co_null);
                       sip_bcpt_freeSipMimeHeader(pMime);

                   }
               }
                
                /*Changes Ends for Message Body Header SPR : 10934        */
                
                if(sdf_ivk_uaGetUnknownBodyFromSipMessage(pOverlapTransInfo->pSipMsg,\
                    iterator1, &p_buffer, &bufLength, &sdf_error) == \
                    Sdf_co_success)
                { 
                        if (p_notify_ind->p_sic_ctx->body_list.count == 0)
                        {
                            /* allocate memory for a msg body list node and add to List*/
                            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                                ICF_PORT_SIZEOF(icf_msg_body_st),
                                ICF_MEM_COMMON, 
                                p_msg_body,
                                ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                        
                                p_notify_ind->p_sic_ctx->body_list.body = p_msg_body;   
                            p_msg_body->next = ICF_NULL;
                            p_msg_body->length= bufLength;
                        }
                        else if(ICF_NULL != p_msg_body)
                        {
                            /* allocate memory for a msg body list node and add to List*/
                            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                                ICF_PORT_SIZEOF(icf_msg_body_st),
                                ICF_MEM_COMMON, 
                                p_msg_body->next,
                                ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                        
                                p_msg_body = p_msg_body->next;                     
                            p_msg_body->next = ICF_NULL;
                            p_msg_body->length= bufLength;
                        }
                        /* Increment the msg body count by one */
                        p_notify_ind->p_sic_ctx->body_list.count++;
                        
                         /* Allocate memory for message body value and copy the recvd msg body*/
                        if ((ICF_NULL != p_msg_body) &&
                                (ICF_NULL != p_msg_body->length))
                        {
                            ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                            bufLength,
                            ICF_MEM_COMMON,
                            p_msg_body->value,
                             ICF_RET_ON_FAILURE,
                             p_ssa_pdb->p_ecode, ret_val)
                    
                            icf_port_memcpy(p_msg_body->value,(char*)p_buffer,bufLength);
                     
                        }       
                        
                        if(pTempMsgBody)
                        {
                            ret_val = icf_ssa_get_mime_hdrs_from_sip_msg(\
                                /*p_ssa_pdb->p_ssa_ctxt->p_call_obj*/SipMessageRequest,
                                p_ssa_pdb,pTempMsgBody,p_msg_body);

                            
                         p_msg_body->content_type.str_len = 
                              (icf_uint16_t)icf_port_strlen(p_msg_body->content_type.str);
                         
                        }
            
                }
                
            } /*End of For loop for multiple message bodies*/
            
                         
            }
}
ICF_SIC_END
        }
       if(ICF_NULL != p_ContentTypeVal)
       {
          fast_memfree(0,p_ContentTypeVal,&sip_error);
          p_ContentTypeVal = ICF_NULL; 
        }
    }

    if (ICF_FAILURE != ret_val)
    {
        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = 
            ICF_NW_INC_NOTIFY_IND;
        
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length =
            ICF_PORT_SIZEOF(icf_nw_inc_notify_ind_st);
        
        if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt)
        {   
            p_ssa_pdb->dest_module_id = ICF_INT_MODULE_SIC;
        }
        else
        {
            if ((ICF_SUBS_STATE_TERMINATED != p_notify_ind->subs_state)||
                (ICF_FALSE == indicate_service))

            {
                /*Send a 200 OK*/
                if (ICF_FAILURE == icf_ssa_form_and_send_response(
                            p_ssa_pdb,200,
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            pOverlapTransInfo,
                            "NOTIFY", Sdf_co_false))
                {
                    ret_val = ICF_FAILURE;
                }
            }
            else
            {
                p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CM;
            }
        }
    }

  


    return ret_val;
} /* icf_ssa_handle_notify_for_refer */

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_send_message_req
 *
 * DESCRIPTION:     This function constructs and sends MESSAGE req on network.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_message_req(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
     icf_return_t             ret_val = ICF_SUCCESS;
     SipOptions                  options;
    Sdf_st_error                sdf_error;
    Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;
    Sdf_ty_s8bit               proto[ICF_MAX_SIZE_INT_USAGE_STR];

    icf_ssa_ctxt_st          *p_ssa_ctx = p_ssa_pdb->p_ssa_ctxt;
    icf_sic_ctx_st          *p_sic_ctx = p_ssa_ctx->p_sic_ctxt;
    icf_glb_pdb_st           *p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    /* code change for CSR-1-4816176/SPR 16075 - not tested */
    icf_config_data_st       *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    icf_uint8_t              self_ip[16];
    icf_transport_address_st self_addr = {{0,{{0,"\0"}}},0};
    /* end code change for CSR-1-4816176/SPR 16075 */
#ifdef ICF_IPSEC_ENABLED
    icf_uint8_t              *p_value = ICF_NULL;
#endif

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

    if (ICF_FAILURE == icf_ssa_check_for_trans_param(p_ssa_pdb,
                p_ssa_pdb->p_line_data->transport_mode, ICF_NULL, ICF_TRUE))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSettingTransport&Revert Modes"));
        return ICF_FAILURE;
    }
    if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_line_data->transport_mode) ||
            (ICF_TRANSPORT_MODE_BOTH == 
             p_ssa_pdb->p_line_data->transport_mode))
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
    }
    else if (ICF_TRANSPORT_TYPE_TLS == 
            p_ssa_pdb->p_line_data->transport_mode)
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");

    }
#ifdef ICF_P_CSCF_DISCOVERY_ENABLED
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
/* We will net the transport mode to none for P-CSCF Discovery */
    icf_port_strcpy(proto,"");
ICF_CHECK_IMS_END
#endif
#endif


    if (((ICF_ADDRESS_PLAN_SIPS_URI == p_sic_ctx->dest_addr.addr_type) &&
                (ICF_TRANSPORT_TYPE_TLS != p_ssa_ctx->transport)) || 
            ((ICF_ADDRESS_PLAN_SIP_URI == p_sic_ctx->dest_addr.addr_type) &&
             (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctx->transport)))
    {
        ret_val = ICF_FAILURE;
        return ret_val;
    }
    /*IMP: 
     * Updation needed in update_call_obj for ICF_SSA_USER_ADDR_FRM_SIC*/
    if (ICF_FAILURE == 
            icf_ssa_update_callobj_for_profile(p_ssa_pdb))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
    /* IMP: 
     * Updation needed in set_to_in_reg_call_obj for 
     * ICF_SSA_USER_ADDR_FRM_SIC*/
    /* To header will be set */
    else if ((ICF_FAILURE == icf_ssa_set_to_in_sic_callobj(p_ssa_pdb,
                    (icf_uint8_t *)proto)))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj)); */

        ret_val = ICF_FAILURE;
    }
#if 0
    /*Request URI to be set as destination address*/
    else if (Sdf_co_fail == 
            sdf_ivk_uaMakeAddrSpecFromConstituents(
                &pAddrSpec, (Sdf_ty_s8bit*)server_addr, 
                (Sdf_ty_s32bit)server_port,
                pScheme, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj)); */

        ret_val = ICF_FAILURE;
    }

    else if (Sdf_co_fail == sdf_ivk_uaChangeRequestURI(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                pAddrSpec, &sdf_error))
    {
        /* sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj)); */

        ret_val = ICF_FAILURE;
    }
#endif

#ifdef IMS_CLIENT
    ICF_CHECK_IMS_START(p_glb_pdb,ICF_TRUE)
        if (ICF_FAILURE != ret_val)
        {
            /* Fill Route Header from Service Route if stored for user-id while 
               registering*/
            if(ICF_FAILURE == 
                    icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                        p_sic_ctx->p_preferred_identity,
                        p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
            {
                ret_val = ICF_FAILURE;
            }
        }
    ICF_CHECK_IMS_END
#endif
#ifdef NON_IMS_CLIENT
        ICF_CHECK_IMS_START(p_glb_pdb,ICF_FALSE)
        if (ICF_FAILURE != ret_val)
        {
            if(ICF_FAILURE == 
                    icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                        ICF_NULL,
                        p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
            {
                ret_val = ICF_FAILURE;
            }
        }
    ICF_CHECK_IMS_END
#endif
        if (ICF_FAILURE == ret_val)
        {
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    &p_overlap_trans_info,
                    "MESSAGE",
                    &sdf_error))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == 
                sdf_ivk_uaSetTransportSchemeInTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction, 
                    p_overlap_trans_info,
                    proto, &sdf_error))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "MESSAGE",
                    Sdf_en_uacTransaction);

            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_ivk_uaMakeTransaction(
                    (Sdf_ty_s8bit *)"MESSAGE", 
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    &sdf_error))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "MESSAGE",
                    Sdf_en_uacTransaction);

            ret_val = ICF_FAILURE;
        }

        else if ( ICF_FAILURE == 
                icf_ssa_form_and_insert_access_nw_info_hdr(
                    p_ssa_pdb, p_overlap_trans_info->pSipMsg))
        {
            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "MESSAGE",
                    Sdf_en_uacTransaction);

            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

            ret_val = ICF_FAILURE;
        }
        /*    sip_freeSipAddrSpec(pAddrSpec);*/

        if(ret_val != ICF_FAILURE)
        {
            if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
            {
                icf_string_st                 addr_val;
#ifdef ICF_IPSEC_ENABLED
                /* check if SA exists */
                if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
                {
                    /* get the corresponding REG context and populate the SSA ctxt and 
                     * SSA pdb with SA ctxt and REGM ctxt structure pointers 
                     */
                    ret_val = icf_ssa_set_sa_ctxt_for_otg_req(p_ssa_pdb,
                            p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity);

                }
#endif
                if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                        == ICF_ADDRESS_PLAN_SIP_URI)
                {
                    icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sip:");
                    icf_port_strcat( addr_val.str, 
                            p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                            p_preferred_identity->addr_val.str );
                    icf_port_strcat( addr_val.str, (icf_uint8_t *)">");


                }
                else if( 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                        == ICF_ADDRESS_PLAN_TEL_URI)
                {
                    icf_port_strcpy( addr_val.str, (icf_uint8_t *)"tel:");
                    icf_port_strcat( addr_val.str, 
                            p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                            p_preferred_identity->addr_val.str );
                }
                /* code change for CSR-1-4816176/SPR 16075 - not tested */

                else if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                        == ICF_ADDRESS_PLAN_E164)
                {
                    icf_port_strcpy(addr_val.str,(icf_uint8_t *)"<sip:");

                    icf_port_strcat(addr_val.str,
                            p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                            p_preferred_identity->addr_val.str );

                    icf_port_strcat(addr_val.str,(icf_uint8_t *)"@");

                    /* now appending the self IP/domain */
                    /*If per line self transport then copy address from line_data*/
                    if(ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
                    {
                        if(ICF_NULL != p_ssa_pdb->p_line_data)
                        {
                            icf_port_memcpy(&self_addr,
                                    &(p_ssa_pdb->p_line_data->self_addr),
                                    sizeof(icf_transport_address_st));
                        }
                        else
                        {
                            ret_val = ICF_FAILURE;
                        }
                    }
                    else
                    {
                        icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                                sizeof(icf_transport_address_st));
                    }
                    if (ret_val!= ICF_FAILURE)
                    {
                        if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                                self_addr.addr.addr_type)
                        {
                            icf_port_strcat(addr_val.str,self_addr.addr.addr.domain.str);
                        }
                        else/*Assumption that it will be IPV4*/
                        {
                            if(ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                                        &(self_addr),self_ip))
                            {
                                ret_val = ICF_FAILURE;
                            }
                            else
                            {
                                icf_port_strcat(addr_val.str,self_ip);
                            }
                        }
                        icf_port_strcat(addr_val.str, (icf_uint8_t *)">");
                    }
                }
                /* end of code change for CSR-1-4816176/SPR 16075 - not tested */
                else
                {
                    icf_port_strcpy( addr_val.str, 
                            p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                            p_preferred_identity->addr_val.str );
                }

                /* Klocwork warning removal.*/
                if (ICF_NULL != p_overlap_trans_info)
                { 
                    if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                                p_ssa_pdb, 
                                (icf_uint8_t*)"P-Preferred-Identity",
                                addr_val.str,
                                p_overlap_trans_info->pSipMsg ))
                    {
                        ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header (P-Preferred-Identity)"));
                        sdf_ivk_uaClearTransaction(
                                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                                p_overlap_trans_info,
                                "MESSAGE",
                                Sdf_en_uacTransaction);

                        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

                        return ICF_FAILURE;
                    }
                }
                else
                {
                    return ICF_FAILURE;
                }
            }


            /* Insert Header/Tag/Body if any given by the application */

            if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count)
            {
                if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
                            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list),
                            ICF_TRUE, p_overlap_trans_info->pSipMsg))
                {
                    ret_val = ICF_FAILURE;
                }
            }


            if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list.count)
            {
                if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
                            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list),
                            ICF_TRUE, p_overlap_trans_info->pSipMsg))
                {
                    ret_val = ICF_FAILURE;
                }

            }
#ifdef ICF_IPSEC_ENABLED
            /* if SA exists, send the Securiy-Verify Header in the outgoing MESSAGE */
            if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled) &&
                    /* if SA exits */
                    (ICF_NULL != p_ssa_pdb->p_sa_context))
            {
                /* insert security-verify header in the otg MESSAGE */
                if (ICF_FAILURE == icf_ssa_get_sec_verify_string (p_ssa_pdb,&p_value,
                            p_ssa_pdb->p_sa_context))
                {
                    ret_val = ICF_FAILURE;
                }
                else if (ICF_FAILURE ==     
                        icf_ssa_insert_unknown_hdr_in_sip_msg (
                            p_ssa_pdb,
                            (icf_uint8_t*)"Security-Verify",
                            p_value, 
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg))
                {
                    ICF_PRINT(("\nFailed to insert unknown header \
                                (Security-Verify)"))

                    sdf_ivk_uaClearTransaction(\
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                            p_overlap_trans_info,\
                            "MESSAGE",\
                            Sdf_en_uacTransaction);
                    return ICF_FAILURE;
                }
                if (ICF_NULL != p_value)
                {
                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                            p_value,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                }
                if (ICF_SUCCESS == ret_val )
                {
                    ICF_PRINT(("\nSecurity Verify Header inserted to \
                                outgoing MESSAGE "));
                }
            }
#endif

            if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.count)
            {
                if (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
                            p_ssa_pdb,&(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list) , 
                            ICF_TRUE, &(p_overlap_trans_info->slMsgBodyList)))
                {
                    sdf_ivk_uaClearTransaction(\
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                            p_overlap_trans_info,\
                            "MESSAGE",\
                            Sdf_en_uacTransaction);

                    /* sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                       p_ssa_ctxt->p_call_obj)); */

                    ret_val = ICF_FAILURE;

                }
                /*Message body header changes Start*/
                else if ( ICF_FAILURE == \
                        icf_ssa_SetAllMsgBody(\
                            Sdf_co_null,p_overlap_trans_info,\
                            (icf_int8_t *)p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                            body_list.content_type.str,\
                            &sdf_error))
                {

                    sdf_ivk_uaClearTransaction(\
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                            p_overlap_trans_info,\
                            "MESSAGE",\
                            Sdf_en_uacTransaction);

                    /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                      p_ssa_ctxt->p_call_obj)); */

                    ret_val = ICF_FAILURE;
                }
                /*Message body header changes End*/
            }
            if (ICF_SUCCESS == ret_val)
            {
                if ((ICF_NULL != (ICF_SSA_TCP_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask)) ||
                        (ICF_NULL != (ICF_SSA_TLS_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask)))
                {
                    ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                            ICF_SSA_EXPLICIT_CONNECT_REQ);

                }
                if ( ICF_FAILURE == icf_ssa_send_to_peer(
                            p_ssa_pdb,
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            p_overlap_trans_info->pSipMsg,
                            &options,
                            &sdf_error))
                {
                    /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                    sdf_ivk_uaClearTransaction(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            p_overlap_trans_info,
                            "MESSAGE",
                            Sdf_en_uacTransaction);
                    /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
                    ret_val = ICF_FAILURE;
                }
                else if ( Sdf_co_fail == sdf_ivk_uaEndTransaction(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            Sdf_co_null,
                            "MESSAGE",
                            &sdf_error))
                {
                    /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                    sdf_ivk_uaClearTransaction(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            p_overlap_trans_info,
                            "MESSAGE",
                            Sdf_en_uacTransaction);
                    /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
                    ret_val = ICF_FAILURE;
                }
            }

        }
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;

} /* icf_ssa_send_message_req */

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_send_refer_req
 *
 * DESCRIPTION:     This function constructs and sends REFER req on network.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_refer_req(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS,
                 dummy_ret_val = ICF_SUCCESS;
    SipOptions                  options;
    Sdf_st_error                sdf_error;
    SipError                    sip_err = ICF_NULL;
    

    Sdf_ty_s8bit               proto[ICF_MAX_SIZE_INT_USAGE_STR] = {0};

    icf_ssa_ctxt_st          *p_ssa_ctx = p_ssa_pdb->p_ssa_ctxt;
    icf_sic_ctx_st          *p_sic_ctx = p_ssa_ctx->p_sic_ctxt;
    SipHeader                *p_refer_to_hdr = SIP_NULL;
    Sdf_st_callObject       *p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;

    Sdf_ty_s8bit            tpt_scheme[ICF_MAX_STR_LEN];
    Sdf_ty_u16bit           port_num_to_be_set = 0;
    Sdf_st_overlapTransInfo *p_overlap_txn = Sdf_co_null;
    icf_glb_pdb_st       *p_glb_pdb = p_ssa_pdb->p_glb_pdb;


    icf_call_ctx_st          *p_call_ctxt = p_glb_pdb->p_call_ctx;
    icf_error_t                *p_ecode = ICF_NULL;

#ifdef ICF_IPSEC_ENABLED
    icf_uint8_t            *p_value = ICF_NULL;
#endif
    icf_address_st           *p_icf_address = ICF_NULL;
    icf_nw_otg_refer_req_st  *p_refer_req = ICF_NULL;
    icf_uint8_t              local_addr_str[ICF_MAX_STR_LEN];    
    icf_transport_address_st *p_icf_trans_addr = ICF_NULL;
    icf_config_data_st       *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    SipAddrSpec                 *p_addr_spec = SIP_NULL;
    SipHeader                   *p_replaces_hdr = SIP_NULL;
    SipHeader                   *p_referred_by_hdr = SIP_NULL;
    Sdf_ty_bool                  is_referred_by = Sdf_co_false;

   /* Do not remove this as this causes warnings */
    proto[0]='\0';

    p_refer_req = 
        (icf_nw_otg_refer_req_st *)(p_ssa_pdb->p_internal_msg->p_msg_data);

    /*Fetch sic context from subs_req*/
    p_sic_ctx = p_refer_req->p_sic_ctx;

    /* crash fix when acccessing p_ecode */
    p_ecode = p_ssa_pdb->p_ecode;
    
    options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

#ifdef ICF_TRACE_ENABLE
    if(p_refer_req->bitmask & ICF_NW_OTG_REFER_RELACE_CALL_ID)
    {
         p_ssa_pdb->replace_header_present=1;
         ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_REFER_SENT)
    }
#endif

    if (ICF_NULL != p_sic_ctx)
    {
    /* Set the transport mode in local variable */
    if (p_sic_ctx->bitmask & ICF_SIC_REQUEST_WITHIN_DIALOG)
    {
        /*Since request is within dialog, it is assumed that the
        p_ssa_ctxt->transport has been filled earlier and if a revert was
        required or possible, it has been done*/
        if ((ICF_TRUE == p_ssa_pdb->p_ssa_ctxt->trans_mode_reverted) ||
            (ICF_TRANSPORT_TYPE_UDP == 
            p_ssa_pdb->p_line_data->transport_mode))
        {
            icf_port_strcpy((icf_uint8_t *)proto,(icf_uint8_t *) "UDP");
        }
        else if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_ssa_ctxt->transport) ||
                (ICF_TRANSPORT_MODE_BOTH == 
                 p_ssa_pdb->p_ssa_ctxt->transport))
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
        }
        else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
        }
        else
        {
            return ICF_FAILURE;
        }
    }
    else 
    {
        if (ICF_FAILURE == icf_ssa_check_for_trans_param(p_ssa_pdb,
                    p_ssa_pdb->p_line_data->transport_mode, ICF_NULL, ICF_TRUE))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSettingTransport&Revert Modes"));
            return ICF_FAILURE;
        }
        if(ICF_TRANSPORT_TYPE_UDP == 
            p_ssa_pdb->p_line_data->transport_mode)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
        }
        else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_line_data->transport_mode)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
        }
    }
#ifdef ICF_P_CSCF_DISCOVERY_ENABLED
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
/* We will net the transport mode to none for P-CSCF Discovery */
    icf_port_strcpy(proto,"");
ICF_CHECK_IMS_END
#endif
#endif

        if (((ICF_ADDRESS_PLAN_SIPS_URI == p_sic_ctx->dest_addr.addr_type) &&
        (ICF_TRANSPORT_TYPE_TLS != p_ssa_ctx->transport)) || 
        ((ICF_ADDRESS_PLAN_SIP_URI == p_sic_ctx->dest_addr.addr_type) &&
        (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctx->transport)))
    {
        ret_val = ICF_FAILURE;
    }
        
    else if(
        !( p_sic_ctx->bitmask & ICF_SIC_REQUEST_WITHIN_DIALOG) &&
        (ICF_FAILURE == icf_ssa_update_callobj_for_profile(p_ssa_pdb))
        )
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            
        ret_val = ICF_FAILURE;
    }
    /* IMP: 
     * Updation needed in set_to_in_reg_call_obj for 
     * ICF_SSA_USER_ADDR_FRM_SIC*/
    /* To header will be set */
    else if (
        !( p_sic_ctx->bitmask & ICF_SIC_REQUEST_WITHIN_DIALOG) &&
        (ICF_FAILURE == icf_ssa_set_to_in_sic_callobj(p_ssa_pdb,
                                (icf_uint8_t *)proto))
        
                )
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_TRUE)
    if (ICF_FAILURE != ret_val)
    {
    /* Fill Route Header from Service Route if stored for user-id while 
        registering*/
        if(ICF_FAILURE == 
        icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                p_sic_ctx->p_preferred_identity,
                p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
    }
ICF_CHECK_IMS_END
#endif
#ifdef NON_IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_FALSE)
    if (ICF_FAILURE != ret_val)
    {
        if(ICF_FAILURE == 
            icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
            ICF_NULL,
            p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
    }
ICF_CHECK_IMS_END
#endif
        if (ICF_FAILURE == ret_val)    
        {
            return ICF_FAILURE;
        }
    }
   /*Check if referred-by header to be sent with refer request*/
    if (ICF_NULL != 
            (ICF_NW_OTG_REFER_REF_BY & p_refer_req->bitmask))
    {
        p_icf_address = &(p_call_ctxt->local_address);
        ICF_ASSERT(p_ssa_pdb->p_glb_pdb, p_icf_address)

        icf_port_strcpy(local_addr_str,
                p_call_ctxt->local_address.addr_val.str);

        is_referred_by = Sdf_co_true;
        /* Start: change for SPR14505 */
        if (ICF_NULL == p_icf_address)
        {
         ret_val = ICF_FAILURE;
        }/* if (ICF_NULL == p_address) */
        else if ((ICF_FAILURE == icf_cmn_validate_sip_addr(p_ssa_pdb->p_glb_pdb,
                    p_icf_address, p_ssa_pdb->p_ecode)))
        {
          ret_val = ICF_FAILURE;
        }
        /* End: change for SPR14505 */
        else
        {
          if ( (ICF_ADDRESS_PLAN_SIP_URI == 
                    p_icf_address->addr_type) ||
                (ICF_ADDRESS_PLAN_E164 ==
                 p_icf_address->addr_type))
           {
             icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"sip");
           }
          else if (ICF_ADDRESS_PLAN_TEL_URI == 
                p_icf_address->addr_type)
           {
             icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"tel");
           }

          if ( ICF_NULL != 
                (ICF_ADDRESS_PLAN_E164 & 
                 p_icf_address->addr_type))
           {/* We need to make the SIP URI using the local address
             * and the self address*/
              if (ICF_CFG_SELF_ADDR_PER_LINE == 
                  p_glb_cfg_data->self_addr_per_line)
               {
                 p_icf_trans_addr = &(p_ssa_pdb->p_line_data->self_addr);
               }
              else
               {
                  p_icf_trans_addr = &(p_glb_cfg_data->self_ip_address);
               }

              if ( ICF_FAILURE == 
                     icf_ssa_form_sip_uri_frm_e164(
                        p_ssa_pdb, local_addr_str, 
                        p_icf_trans_addr,&port_num_to_be_set))
               {
                 ret_val = ICF_FAILURE;
               }
            }/*Formation of SIP URI from E164 ends here*/
        /* Set reffered by header */
        if (Sdf_co_fail == sdf_ivk_uaMakeAddrSpecFromConstituents(
                    &p_addr_spec,
                    (icf_int8_t *)local_addr_str,
                    port_num_to_be_set,
                    (icf_int8_t *)tpt_scheme,
                    &sdf_error))
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE == 
                 icf_ssa_insert_params_frm_address_st(
                     p_ssa_pdb,p_addr_spec,p_icf_address))
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
        else if(sip_initSipHeader(
                    (SipHeader**)(&p_referred_by_hdr),
                    SipHdrTypeReferredBy,\
                    (SipError*)(&sip_err))==SipFail)
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
        else if ( SipFail == sip_setReferrerInReferredByHdr(
                    p_referred_by_hdr,
                    p_addr_spec, (SipError *)(&sip_err)))
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
      } 
        if ( (ICF_FAILURE != ret_val) &&
                (ICF_NULL != (ICF_LOCAL_NAME_PRESENT &
                                 p_call_ctxt->common_bitmask)))
        {
            if (SipFail == sip_setDispNameInReferredByHdr(
                        p_referred_by_hdr,
                        Sdf_mc_strdupCT((const icf_int8_t *)p_call_ctxt->local_name.str),
                        (SipError *)(&sip_err)))
            {
                /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
                ret_val = ICF_FAILURE;
                /*we are not freeing the header here as that is done
                 * while exiting this routine. So no direct return calls
                 * are to be added in this code.*/
            }
        }
        /*This Free is to be hit whether some opeartion above succeeded
         * or failed*/
        sip_freeSipAddrSpec(p_addr_spec);
    }

    /* Insert Replaces header, if services set the bitmask,
     * this will only be set in case of request received from
     * services*/
    if ( ICF_FAILURE != ret_val)
    {
        if(ICF_NULL != ICF_SSA_GET_COMMON_BITMASK(
                    p_refer_req->bitmask, ICF_NW_OTG_REFER_RELACE_CALL_ID))
        {
            icf_call_ctx_st      *p_replaced_call_ctxt = ICF_NULL ;

            if ( ICF_FAILURE == icf_dbm_find_call_cntxt_blk(
                        p_glb_pdb,
                        p_refer_req->replace_call_id,
                        &p_replaced_call_ctxt,
                        p_ecode))
            {
                /*Set/Raise Error:INVALID_CALL_ID*/
                ret_val = ICF_FAILURE;
            }
            /*
             * Invoke sdf_ivk_uaFormReplacesHeader with
             * pointer to call object stored in the
             * replaced call context.
             */
            else if (Sdf_co_fail ==sdf_ivk_uaFormReplacesHeader (
                        ((icf_ssa_ctxt_st *)
                        p_replaced_call_ctxt->p_sip_ctx)->p_call_obj,
                        Sdf_co_null,Sdf_co_null,Sdf_co_null,
                        &p_replaces_hdr,
                        &sdf_error))
            {
                /*Set/RaiseError:UATK_PROCESSING_FAILURE*/
                ret_val = ICF_FAILURE;
            }
        }
    }
    
    if ( ICF_FAILURE != ret_val)
    {
        icf_uint8_t                refer_to_addr_str[ICF_MAX_STR_LEN + ICF_MAX_LARGE_STR_LEN];
        icf_address_st            *p_icf_address = ICF_NULL;
        icf_transport_address_st    *p_icf_trans_addr = ICF_NULL;
        SipAddrSpec                    *p_addr_spec = SIP_NULL;
      
        if (ICF_NULL != p_sic_ctx)
    {
        icf_port_strcpy(refer_to_addr_str,
                p_sic_ctx->refer_to.addr_val.str);
        p_icf_address = &(p_sic_ctx->refer_to);
    }
    else
    {
        icf_port_strcpy(refer_to_addr_str,
                p_refer_req->p_referred_to->addr_val.str);
        p_icf_address = p_refer_req->p_referred_to;
    }
    /* Start: change for SPR14505 */
    if (ICF_NULL == p_icf_address)
    {
      ret_val = ICF_FAILURE;
    }/* if (ICF_NULL == p_address) */
    else if ((ICF_FAILURE == icf_cmn_validate_sip_addr(
					p_ssa_pdb->p_glb_pdb,
					p_icf_address, p_ssa_pdb->p_ecode)))
    {
      ret_val = ICF_FAILURE;
    }
    else
    {
      /* End: change for SPR14505 */
        if ( (ICF_ADDRESS_PLAN_SIP_URI == 
                    p_icf_address->addr_type) ||
                (ICF_ADDRESS_PLAN_E164 ==
                 p_icf_address->addr_type))
        {
            icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"sip");
        }
        else if (ICF_ADDRESS_PLAN_TEL_URI == 
                p_icf_address->addr_type)
        {
            icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"tel");
        }
        else if (ICF_ADDRESS_PLAN_NOT_PRESENT == 
                p_icf_address->addr_type)
        {
            /*Here we need to extract the transport scheme from the address*/
            /*received from application*/
            icf_uint8_t      temp_str[ICF_MAX_STR_LEN];
            icf_int8_t        *p_remaining_str=ICF_NULL;

            icf_port_strcpy(temp_str,refer_to_addr_str );
            icf_port_strtokr((icf_int8_t *)temp_str,":",&p_remaining_str);
            icf_port_strcpy((icf_uint8_t *)tpt_scheme,(icf_uint8_t *)temp_str);
            /* Added the NULL check on p_remaining_str for SPR14505 */
            if(p_remaining_str != ICF_NULL)
              icf_port_strcpy(refer_to_addr_str,(icf_uint8_t *)p_remaining_str);
        }
        /*if ( ICF_NULL != */
        /*        (ICF_ADDRESS_PLAN_E164 & */
        /*         p_icf_address->addr_type))*/
        if (ICF_ADDRESS_PLAN_E164 == 
                p_icf_address->addr_type)
        {/* We need to make the SIP URI using the local address
          * and the self address*/
          /*  The code was removed from here because sic context will
           *  be null when IPTK would be sending the refer as
           *  this refer is triggered by Services*/

            p_icf_trans_addr = &(p_ssa_pdb->p_line_data->proxy_addr);

            if ( ICF_FAILURE == 
                    icf_ssa_form_sip_uri_frm_e164(
                        p_ssa_pdb, refer_to_addr_str, 
                        p_icf_trans_addr,&port_num_to_be_set))
            {
                /*Even is referred by was not set, this call will not
                 * result in crash as stack code checks for null value
                 * of the argument*/

                ret_val = ICF_FAILURE;
            }
        }/*Formation of SIP URI from E164 ends here*/
        if(ICF_NULL != port_num_to_be_set)
        {
            icf_uint8_t  temp[6];
            /*Append port to the address*/
            icf_port_strcat(refer_to_addr_str,(icf_uint8_t *)":");
            icf_port_itoa(port_num_to_be_set,&temp[0]);
            icf_port_strcat(refer_to_addr_str,temp);
            port_num_to_be_set = 0;
        }
        if(ICF_REFER_TO_ADDNL_URI_PARAMTR_PRES & p_refer_req->bitmask)
        {
            icf_port_strcat(refer_to_addr_str,(icf_uint8_t *)";");
            icf_port_strcat(refer_to_addr_str,p_refer_req->p_uri_parameter->str);
        }

        if(SipFail == sip_initSipHeader(
                    (SipHeader**)(&p_refer_to_hdr),
                    SipHdrTypeReferTo,\
                    (SipError*)(&sip_err)))
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_ivk_uaMakeAddrSpecFromConstituents(
                    &p_addr_spec,
                    (icf_int8_t *)refer_to_addr_str,
                    port_num_to_be_set,
                    (icf_int8_t *)tpt_scheme,
                    &sdf_error))
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
            ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_refer_to_hdr,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        dummy_ret_val)

            ret_val = ICF_FAILURE;
        }
        else if (ICF_NULL == p_addr_spec)
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
            ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_refer_to_hdr,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        dummy_ret_val)

            ret_val = ICF_FAILURE;
        }
        else
        { 
          if(p_refer_req->bitmask & ICF_NW_OTG_REFER_METHOD_BYE)
          {
            icf_ssa_insert_param_in_addr_spec(
                    p_ssa_pdb,
                    p_addr_spec,
                     (icf_uint8_t *)"method", (icf_uint8_t *)"BYE", &sdf_error);

          }

          if(SipFail == sip_setAddrSpecInReferToHdr(
                    (SipHeader*)p_refer_to_hdr,
                    p_addr_spec,
                    &sip_err))
          {
            sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
            ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_refer_to_hdr,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        dummy_ret_val)

            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
          }
        }
        sip_freeSipAddrSpec(p_addr_spec);
      }  
    }

    if ( ICF_FAILURE != ret_val)
    {
        SipOptions          options;
        options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;
        if ( Sdf_co_fail == sdf_ivk_uaStartRegularTransaction(
                    p_call_obj,&p_overlap_txn, "REFER",
                    &sdf_error))
        {
            /*Raise/Set Error: UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
            p_ssa_pdb->p_internal_msg->msg_hdr.ecode = ICF_ECODE_REFER_PENDING;
        } /* set the transport mode to the outgoing REFER*/
        else if ( Sdf_co_fail == 
                sdf_ivk_uaSetTransportSchemeInTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction, 
                p_overlap_txn,
                proto, &sdf_error))
        {
                ret_val = ICF_FAILURE;
        }
        else
        if( Sdf_co_fail == sdf_ivk_uaMakeRefer (p_call_obj, 
                    p_overlap_txn,
                    (SipHeader*)p_refer_to_hdr,
                    (SipHeader*)p_replaces_hdr,
                    is_referred_by,
                    (SipHeader*)p_referred_by_hdr,
                    &sdf_error))
        {
            /*Set/RaiseError:UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearRegularTransaction(
                    p_call_obj,
                    "REFER",
                    p_overlap_txn);
            /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
            ret_val = ICF_FAILURE;
        sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
        ICF_MEMFREE(
            p_ssa_pdb->p_glb_pdb,
            p_refer_to_hdr,
            ICF_MEM_COMMON,
            p_ssa_pdb->p_ecode,
            dummy_ret_val)
        }


    }

       
    if ( ICF_FAILURE != ret_val)
    {
        if (ICF_NULL != p_sic_ctx)
        {
            /* insert Privacy header in BYE request if application requested 
             * it at the time of create_call */
            if ((ICF_NULL != p_sic_ctx->p_call_ctx) && 
                (ICF_PRIVACY_HDR_ALL_REQ & p_sic_ctx->p_call_ctx->common_bitmask))
            {
                if (ICF_FAILURE == icf_ssa_form_and_insert_priv_hdr(
                                        p_ssa_pdb,
                                        p_overlap_txn->pSipMsg))
                {
                    ICF_PRINT(((icf_uint8_t *)"\nFailed to insert Privacy header in BYE request"));
                    sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                    /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                    ret_val = ICF_FAILURE;
                    return ret_val;
                }         
            }
        }

        if (ICF_FAILURE == ret_val)
        {
            /* do nothing here */
        }
        else if ( ICF_FAILURE == icf_ssa_form_and_insert_access_nw_info_hdr(
                    p_ssa_pdb, p_overlap_txn->pSipMsg))
        {
            sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                ret_val  = ICF_FAILURE;
        
            return ICF_FAILURE;
        }
        
#ifdef ICF_IPSEC_ENABLED
        /* Refer needs to go protected if IPSEC is enabled and SA exists */
        if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled) &&
            /* if SA exits */
            (ICF_NULL != p_ssa_pdb->p_sa_context))
        {
            /* insert security-verify header in the otg REFER */
            if (ICF_FAILURE == icf_ssa_get_sec_verify_string (p_ssa_pdb,&p_value,
                p_ssa_pdb->p_sa_context))
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_FAILURE ==     
              icf_ssa_insert_unknown_hdr_in_sip_msg (
                  p_ssa_pdb,
                  (icf_uint8_t*)"Security-Verify",
                  p_value, 
                  p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg))
            {
                ICF_PRINT(("\nFailed to insert unknown header \
                        (Security-Verify)"));
                ret_val = ICF_FAILURE;
            }
            if (ICF_NULL != p_value)
            {
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_value,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            }
            if (ICF_SUCCESS == ret_val )
            {
                ICF_PRINT(("\nSecurity Verify Header inserted to \
                                outgoing Refer "));
            }
        }
#endif
#if 0
        if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
        {
    
            if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                p_ssa_pdb, 
                (icf_uint8_t*)"P-Preferred-Identity",
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_val.str,
                p_overlap_txn->pSipMsg))
            {
                ICF_PRINT(("\nFailed to insert unknown header (P-Preferred-Identity)"));
                sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                ret_val  = ICF_FAILURE;
        
                return ICF_FAILURE;
            }
        }
#endif
        if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt)
        {
            if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
            {
                icf_string_st                 addr_val;
                
                if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_SIP_URI)
                {
                    icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sip:");
                    icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
                    icf_port_strcat( addr_val.str, (icf_uint8_t *)">");
                    
                    
                }
                else if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_TEL_URI)
                {
                    icf_port_strcpy( addr_val.str, (icf_uint8_t *)"tel:");
                    icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
                }
                else
                {
                    icf_port_strcpy( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
                }
                
                
                if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                    p_ssa_pdb, 
                    (icf_uint8_t*)"P-Preferred-Identity",
                    addr_val.str,
                    p_overlap_txn->pSipMsg ))
                {
                    ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header (P-Preferred-Identity)"));
                    sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        (const icf_int8_t *)"REFER",
                        p_overlap_txn);
                    /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                    
                    return ICF_FAILURE;
                }
            }
            
#if 0 /* Remove hard-coded "norefersub" in Require header of REFER request */
            if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->subs_reqd ==0 )
            {
                icf_uint16_t        list_count=p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count;
                icf_boolean_t    require_hdr_present=ICF_FALSE;
                icf_header_st*    p_hdr = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.hdr;
                
                
                /*check if application has already added Require header*/
                
                while (list_count > 0 && ICF_NULL != p_hdr) 
                {
                    if( icf_port_strcmp( p_hdr->hdr_name.str, "Require") == 0)
                    {
                        require_hdr_present = ICF_TRUE;
                        /* Check if 'norefersub' has already been added by application*/
                        if ( ICF_NULL == strstr( p_hdr->hdr_value.str , "norefersub") )
                        {
                            /*We need to append 'norefersub' to it*/
                            icf_port_strcat( p_hdr->hdr_value.str, ",norefersub");
                            
                        }
                    }
                    list_count = list_count - 1;
                    p_hdr = p_hdr->next;
                }
                
                if( require_hdr_present == ICF_FALSE )
                {
                    if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                        p_ssa_pdb, 
                        (icf_uint8_t*)"Require",
                        "norefersub",
                        p_overlap_txn->pSipMsg))
                    {
                        ICF_PRINT(("\nFailed to insert unknown header (P-Preferred-Identity)"));
                        sdf_ivk_uaClearRegularTransaction(
                            p_call_obj,
                            "REFER",
                            p_overlap_txn);
                        /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                        ret_val  = ICF_FAILURE;
                        
                        return ICF_FAILURE;
                    }
                }
            }
#endif /* if 0 for norefersub */
            
            /* Insert Header/Tag/Body if any given by the application */
            
            if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count)
            {
                if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
                    p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list),
                    ICF_TRUE, p_overlap_txn->pSipMsg))
                {
                    ret_val = ICF_FAILURE;
                }
            }
            
            
            if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list.count)
            {
                if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
                    p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list),
                    ICF_TRUE, p_overlap_txn->pSipMsg))
                {
                    ret_val = ICF_FAILURE;
                }
                
            }
            
            if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.count)
            {
                
                               if (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
                    p_ssa_pdb,&(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list) , 
                    ICF_TRUE, &(p_overlap_txn->slMsgBodyList)))
                {
                    sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                    /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                    return ICF_FAILURE;
                    
                }
                
                /*Message body header changes Start*/
                if ( ICF_FAILURE ==icf_ssa_SetAllMsgBody(\
                    Sdf_co_null,p_overlap_txn,\
                    (icf_int8_t *)p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                    body_list.content_type.str,&sdf_error))
                {
                    sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                    /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                    return ICF_FAILURE;
                    
                }
                /*Message body header changes End*/
            }
        }/*end of p_ssa_pdb->p_ssa_ctxt->p_sic_ctx not NULL leg*/ 
        else
        {
            if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->header_list.count)
            {
                if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
                    p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->header_list),
                    ICF_TRUE, p_overlap_txn->pSipMsg))
                {
                    ret_val = ICF_FAILURE;
                }
            }
            
            
            if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->tag_list.count)
            {
                if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
                    p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->tag_list),
                    ICF_TRUE, p_overlap_txn->pSipMsg))
                {
                    ret_val = ICF_FAILURE;
                }
                
            }
            
            if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->body_list.count)
            {
                
                if (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
                    p_ssa_pdb,&(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->body_list) , 
                    ICF_TRUE, &(p_overlap_txn->slMsgBodyList)))
                {
                    sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                    /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                    return ICF_FAILURE;
                    
                }
                /*Message body header changes Start*/
        else if ( ICF_FAILURE ==icf_ssa_SetAllMsgBody(\
                    Sdf_co_null,p_overlap_txn,\
                    (icf_int8_t *)p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->\
                    body_list.content_type.str,&sdf_error))
                {
                    sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                    /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                    return ICF_FAILURE;
                    
                }
                /*Message body header changes End*/
            }/*p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->body_list.count*/
        }/*end of p_ssa_pdb->p_ssa_ctxt->p_sic_ctx NULL leg*/
    }/*retval SUCCESS leg*/
        /**************************************************/
           /* as per the philosophy, we need to check for mode inversion and
         * attempt opening of a new cnnection only if the message is being 
         * sent  out of context, for message being sent within an ongoing
         * context/dialog, we need not do the following 
         * */
    if ((ICF_SUCCESS == ret_val) &&
        (ICF_NULL != p_sic_ctx) && 
        ((ICF_NULL == icf_port_strcmp((icf_uint8_t *)proto, (icf_uint8_t *)"TCP")) ||
        (ICF_NULL == icf_port_strcmp((icf_uint8_t *)proto, (icf_uint8_t *)"TLS"))))
    {
            /*if within dialog, then we don't need explicit conenct
            and we will not revert if some connect fails*/
        if (!(ICF_SIC_REQUEST_WITHIN_DIALOG & p_sic_ctx->bitmask))
        {
            ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                    ICF_SSA_EXPLICIT_CONNECT_REQ)
        }
    }   
        /* In case of SM failure, the connect_req routine
        * has reset the conn db node*/
    
    if (ICF_SUCCESS == ret_val)
    {
        if ( ICF_FAILURE == icf_ssa_send_to_peer(
            p_ssa_pdb,
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            p_overlap_txn->pSipMsg,
            &options,
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_txn,
                "REFER",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == sdf_ivk_uaEndTransaction(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            Sdf_co_null,
            "REFER",
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_txn,
                "REFER",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
    }
    /*Store the ReferredTo as part of Persistent HdrList*/
    if(Sdf_co_fail == icf_ssa_insert_hdr_in_persistent_list_in_call_obj(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            p_refer_to_hdr,
                            SipHdrTypeReferTo,
                            (Sdf_ty_s8bit *)"uat-ReferTo",
                            &sdf_error))
    {
    /*
         * Ignore the failure response here. In case of failure
         * the header would not be added to persistentList so
         * we would fail to the when we would retreive this.
     */
    }

    if (ICF_FAILURE == ret_val)
    {
        if (SIP_NULL != p_refer_to_hdr)
    {
            sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                    p_refer_to_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
    }
    }
    /*Store the ReferredBy as part of Persistent HdrList*/
    if((SIP_NULL != p_referred_by_hdr) &&
                    Sdf_co_fail ==
                    icf_ssa_insert_hdr_in_persistent_list_in_call_obj(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            p_referred_by_hdr,
                            SipHdrTypeReferredBy,
                            (Sdf_ty_s8bit *)"uat-ReferredBy",
                            &sdf_error))
    {
        /*
         * Ignore the failure response here. In case of failure
         * the header would not be added to persistentList so
         * we would fail to the when we would retreive this.
         */
    }
    if (ICF_FAILURE == ret_val)
    {
        if (SIP_NULL != p_referred_by_hdr)
    {
            sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                    p_referred_by_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
    }
    }
    if (SIP_NULL != p_replaces_hdr)
    {
        sip_freeSipHeader(p_replaces_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_replaces_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
    }
    
    return ret_val;

} /* icf_ssa_send_refer_req */

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_send_publish_req
 *
 * DESCRIPTION:     This function constructs and sends PUBLISH req on network.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_publish_req(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_return_t             ret_val1 = ICF_SUCCESS;
    Sdf_ty_s8bit                HdrName[] = "Event";
    Sdf_ty_s8bit                EventName[ICF_MAX_STR_LEN];
    SipOptions                  options;
    Sdf_st_error                sdf_error;
    Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;
    Sdf_ty_s8bit                proto[ICF_MAX_SIZE_INT_USAGE_STR];
    SipError                    sip_err;
    SipHeader                    *p_exp_hdr = SIP_NULL;

    icf_ssa_ctxt_st          *p_ssa_ctx = p_ssa_pdb->p_ssa_ctxt;
    icf_sic_ctx_st           *p_sic_ctx = p_ssa_ctx->p_sic_ctxt;

    icf_glb_pdb_st           *p_glb_pdb = p_ssa_pdb->p_glb_pdb;
   /* code change for CSR-1-4816176/SPR 16075 - not tested */
    icf_config_data_st       *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    icf_uint8_t              self_ip[16];
    icf_transport_address_st self_addr = {{0,{{0,"\0"}}},0};
    /* end code change for CSR-1-4816176/SPR 16075 */

#ifdef ICF_IPSEC_ENABLED
    icf_uint8_t            *p_value = ICF_NULL;
#endif

    options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

    if (ICF_FAILURE == icf_ssa_check_for_trans_param(p_ssa_pdb,
        p_ssa_pdb->p_line_data->transport_mode, ICF_NULL, ICF_TRUE))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSettingTransport&Revert Modes"));
        return ICF_FAILURE;
    }
 
    if(0 != p_ssa_pdb->p_glb_cfg_data->sip_compact_hdrs)
    {
        /* Compact headers is on, use the compact form */
        icf_port_strcpy((icf_uint8_t *)HdrName,(icf_uint8_t *)"o");
    }
     /* Set the transport mode in local variable */
    if ((ICF_TRANSPORT_TYPE_TCP == 
        p_ssa_pdb->p_line_data->transport_mode) ||
       (ICF_TRANSPORT_MODE_BOTH == 
        p_ssa_pdb->p_line_data->transport_mode))
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
    }
    else if (ICF_TRANSPORT_TYPE_TLS ==
        p_ssa_pdb->p_line_data->transport_mode)
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
    }
#ifdef ICF_P_CSCF_DISCOVERY_ENABLED
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
/* We will net the transport mode to none for P-CSCF Discovery */
    icf_port_strcpy(proto,"");
ICF_CHECK_IMS_END
#endif
#endif
    /* Failure will be return if request will contain SIPS URI on 
       non TLS transport mode or SIP URI on TLS*/ 

    if (((ICF_ADDRESS_PLAN_SIPS_URI == p_sic_ctx->dest_addr.addr_type) &&
                (ICF_TRANSPORT_TYPE_TLS != p_ssa_ctx->transport)) ||
            ((ICF_ADDRESS_PLAN_SIP_URI == p_sic_ctx->dest_addr.addr_type) &&
             (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctx->transport)))
    {
        ret_val = ICF_FAILURE;
        return ret_val;
    }

    
    
    /*Fetch Event from p_sic_ctx*/
    icf_port_strcpy((icf_uint8_t *)EventName,(icf_uint8_t *)p_sic_ctx->event_package.str);
    /*
    switch (p_sic_ctx->event_package)
    {
        case ICF_EVENT_PKG_POC_SETTINGS:
            icf_port_strcpy(EventName,"poc-settings");
           
            break;

        default:
            ret_val = ICF_FAILURE;
    }
    */

    /*IMP: 
     * Updation needed in update_call_obj for ICF_SSA_USER_ADDR_FRM_SIC*/
    if (ICF_FAILURE == 
                icf_ssa_update_callobj_for_profile(p_ssa_pdb))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            
        ret_val = ICF_FAILURE;
    }
    /* IMP: 
     * Updation needed in set_to_in_reg_call_obj for 
     * ICF_SSA_USER_ADDR_FRM_SIC*/
    /* To header will be set */
    else if ((ICF_FAILURE == 
                icf_ssa_set_to_in_sic_callobj(p_ssa_pdb,
                            (icf_uint8_t *)proto)))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
#if 0
    /*Request URI to be set as destination address*/
    else if (Sdf_co_fail == 
                sdf_ivk_uaMakeAddrSpecFromConstituents(
                    &pAddrSpec, (Sdf_ty_s8bit*)server_addr, 
                    (Sdf_ty_s32bit)server_port,
                    pScheme, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }

    else if (Sdf_co_fail == sdf_ivk_uaChangeRequestURI(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                pAddrSpec, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
#endif

#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_TRUE)
    if (ICF_FAILURE != ret_val)
    {
        /* Fill Route Header from Service Route if stored for user-id while 
        registering*/
        if(ICF_FAILURE == 
        icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                p_sic_ctx->p_preferred_identity,
               p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
    }
ICF_CHECK_IMS_END
#endif
#ifdef NON_IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_FALSE)
    if (ICF_FAILURE != ret_val)
    {
        if(ICF_FAILURE == 
            icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                ICF_NULL,
               p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
    }
ICF_CHECK_IMS_END
#endif
    if (ICF_FAILURE == ret_val)
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        ret_val = ICF_FAILURE;
    }

    else if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                &p_overlap_trans_info,
                "PUBLISH",
                &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
        ret_val = ICF_FAILURE;
    }
    else if ( Sdf_co_fail == 
                sdf_ivk_uaSetTransportSchemeInTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction, 
                p_overlap_trans_info,
                proto, &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        ret_val = ICF_FAILURE;
    }
    else if (Sdf_co_fail == sdf_ivk_uaMakeTransaction(
                (Sdf_ty_s8bit *)"PUBLISH", 
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        ret_val = ICF_FAILURE;
    }
    /*Insert Expire header*/
    else if (ICF_FAILURE == sip_initSipHeader(
                &p_exp_hdr, SipHdrTypeExpiresSec, &sip_err))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        ret_val = ICF_FAILURE;
    }
    else if (ICF_FAILURE == sip_setSecondsInExpiresHdr(
                p_exp_hdr, p_sic_ctx->duration, &sip_err))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);

        ret_val = ICF_FAILURE;
    }
    else if (ICF_FAILURE == sip_setHeader(
                p_overlap_trans_info->pSipMsg, 
                p_exp_hdr, &sip_err))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
    /*Insert Event header*/
    else if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                p_ssa_pdb, (icf_uint8_t *)HdrName, (icf_uint8_t *)EventName, 
                p_overlap_trans_info->pSipMsg))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
        ret_val = ICF_FAILURE;
    }       
   
    else if ( ICF_FAILURE == 
                icf_ssa_form_and_insert_access_nw_info_hdr(
                p_ssa_pdb, p_overlap_trans_info->pSipMsg))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        ret_val = ICF_FAILURE;
    }
/*    sip_freeSipAddrSpec(pAddrSpec);*/
     sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
     ICF_MEMFREE(
         p_ssa_pdb->p_glb_pdb,
         p_exp_hdr,
         ICF_MEM_COMMON,
         p_ssa_pdb->p_ecode,
         ret_val1)

#ifdef ICF_IPSEC_ENABLED
    if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled) &&
        /* if SA exits */
        (ICF_NULL != p_ssa_pdb->p_sa_context))
    
    {    
        /* insert the SEcurity-Verify Header in the outgoing Publish 
         * Method
         */                
        if (ICF_FAILURE == icf_ssa_get_sec_verify_string (p_ssa_pdb, &p_value,
            p_ssa_pdb->p_sa_context))
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE ==     
          icf_ssa_insert_unknown_hdr_in_sip_msg (
              p_ssa_pdb,
              (icf_uint8_t*)"Security-Verify",
              p_value, 
              p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg))
        {
            ICF_PRINT(("\nFailed to insert unknown header \
                    (Security-Verify)"));
            ret_val = ICF_FAILURE;
        }
        if (ICF_NULL != p_value)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_value,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        }
        if (ICF_SUCCESS == ret_val )
        {
            ICF_PRINT(("\nSecurity Verify Header inserted to \
                            outgoing Publish "));
        }
    }
#endif
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
        (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity))
    
#if 0
    if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
    {
        if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
        p_ssa_pdb, 
        (icf_uint8_t*)"P-Preferred-Identity",
        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_val.str,
        p_overlap_trans_info->pSipMsg))
        {
            ICF_PRINT(("\nFailed to insert unknown header (P-Preferred-Identity)"));
            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "PUBLISH",
                    Sdf_en_uacTransaction);

            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
            return ICF_FAILURE;
        }
    }
#endif

    if (ret_val!= ICF_FAILURE)
    {

    if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
    {
        icf_string_st                 addr_val;

        if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_SIP_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sip:");
            icf_port_strcat( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                p_preferred_identity->addr_val.str );
            icf_port_strcat( addr_val.str,(icf_uint8_t *) ">");


        }
        else if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_TEL_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"tel:");
            icf_port_strcat( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                p_preferred_identity->addr_val.str );
        }
             /* code change for CSR-1-4816176/SPR 16075 - not tested */

        else if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_E164)
            {
                icf_port_strcpy(addr_val.str,(icf_uint8_t *)"<sip:");

                icf_port_strcat(addr_val.str,
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );

                icf_port_strcat(addr_val.str,(icf_uint8_t *)"@");

                /* now appending the self IP/domain */
                /*If per line self transport then copy address from line_data*/
                if(ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
                {
                    if(ICF_NULL != p_ssa_pdb->p_line_data)
                    {
                        icf_port_memcpy(&self_addr,
                                    &(p_ssa_pdb->p_line_data->self_addr),
                                    sizeof(icf_transport_address_st));
                    }
                    else
                    {
                        ret_val = ICF_FAILURE;
                    }
                }
                else
                {
                    icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                                    sizeof(icf_transport_address_st));
                }
                if(ret_val != ICF_FAILURE)
                {
                    if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                            self_addr.addr.addr_type)
                    {
                        icf_port_strcat(addr_val.str,self_addr.addr.addr.domain.str);
                    }
                    else/*Assumption that it will be IPV4*/
                    {
                        if(ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                                    &(self_addr),self_ip))
                        {
                            ret_val = ICF_FAILURE;
                        }
                        else
                        {
                            icf_port_strcat(addr_val.str,self_ip);
                        }
                    }
                    icf_port_strcat(addr_val.str, (icf_uint8_t *)">");
                }
            }
        /* end of code change for CSR-1-4816176/SPR 16075 - not tested */
        else
        {
            icf_port_strcpy( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                p_preferred_identity->addr_val.str );
        }

        /* Klocwork warning removal.*/
        if (ICF_NULL != p_overlap_trans_info)
        { 
            if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                        p_ssa_pdb, 
                        (icf_uint8_t*)"P-Preferred-Identity",
                        addr_val.str,
                        p_overlap_trans_info->pSipMsg ))
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header (P-Preferred-Identity)"));
                sdf_ivk_uaClearTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "PUBLISH",
                        Sdf_en_uacTransaction);

                /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

                return ICF_FAILURE;
            }
        }
        else
        {
            return ICF_FAILURE;
        }  
    }

    /* Insert Header/Tag/Body if any given by the application */

    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count)
    {
        if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list),
            ICF_TRUE, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
    }
    
    
    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list.count)
    {
        if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list),
            ICF_TRUE, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
        
    }
    
    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.count)
    {
        if (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
                    p_ssa_pdb,&(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list) , 
                    ICF_TRUE, &(p_overlap_trans_info->slMsgBodyList)))
        {
            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "PUBLISH",
                    Sdf_en_uacTransaction);

            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                        p_ssa_ctxt->p_call_obj));*/

            ret_val = ICF_FAILURE;
        }

        /*Message body header changes Start*/
       else  if (ICF_FAILURE == icf_ssa_SetAllMsgBody(\
                    Sdf_co_null, p_overlap_trans_info,\
                    (icf_int8_t *)p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                    body_list.content_type.str,&sdf_error))
        {

            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "PUBLISH",
                    Sdf_en_uacTransaction);

            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                        p_ssa_ctxt->p_call_obj));*/

            ret_val = ICF_FAILURE;
        }
        /*Message body header changes Ends*/
    }
    
    if (ICF_SUCCESS == ret_val)
    {
        if ((ICF_NULL != (ICF_SSA_TCP_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask)) ||
                (ICF_NULL != (ICF_SSA_TLS_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask)))
        {
            ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                    ICF_SSA_EXPLICIT_CONNECT_REQ);

        }

        if ( ICF_FAILURE == icf_ssa_send_to_peer(
                    p_ssa_pdb,
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info->pSipMsg,
                    &options,
                    &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "PUBLISH",
                    Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == sdf_ivk_uaEndTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    Sdf_co_null,
                    "PUBLISH",
                    &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "PUBLISH",
                    Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
    }
    }
    return ret_val;
} /* icf_ssa_send_publish_req */

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_send_options_req
 *
 * DESCRIPTION:     This function constructs and sends OPTIONS req on network.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_options_req(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    SipOptions                  options;
    Sdf_st_error                sdf_error;
    Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;


    Sdf_ty_s8bit                proto[ICF_MAX_SIZE_INT_USAGE_STR];

    icf_ssa_ctxt_st          *p_ssa_ctx = p_ssa_pdb->p_ssa_ctxt;
    icf_sic_ctx_st           *p_sic_ctx = p_ssa_ctx->p_sic_ctxt;
    icf_glb_pdb_st           *p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    icf_config_data_st       *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    icf_uint8_t              self_ip[16];
    icf_transport_address_st self_addr = {{0,{{0,"\0"}}},0};


#ifdef ICF_IPSEC_ENABLED
    icf_uint8_t              *p_value = ICF_NULL;
#endif
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

#ifdef ICF_TRACE_ENABLE
         if ( ICF_NULL != p_ssa_ctx->p_call_ctxt) 
         {
                 p_ssa_pdb->dialog_status=1;   /* in dialog */
                 icf_port_strcpy(p_ssa_pdb->remote_addr.addr_val.str,
                       p_sic_ctx->dest_addr.addr_val.str);
                 ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_OTG_OPTIONS);
          }
       else
         {
                 p_ssa_pdb->dialog_status=0;   /* out of dialog */
                 icf_port_strcpy(p_ssa_pdb->remote_addr.addr_val.str,
                           p_sic_ctx->dest_addr.addr_val.str);
                 ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_OTG_OPTIONS);
          }
#endif


    options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

        if (ICF_FAILURE == icf_ssa_check_for_trans_param(p_ssa_pdb,
                    p_ssa_pdb->p_line_data->transport_mode, ICF_NULL, ICF_TRUE))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSettingTransport&Revert Modes"));
            return ICF_FAILURE;
        }
        if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_line_data->transport_mode) ||
                (ICF_TRANSPORT_MODE_BOTH == 
                 p_ssa_pdb->p_line_data->transport_mode))
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
        }
        else if(ICF_TRANSPORT_TYPE_TLS == 
                p_ssa_pdb->p_line_data->transport_mode)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");

        }

    if (((ICF_ADDRESS_PLAN_SIPS_URI == p_sic_ctx->dest_addr.addr_type) &&
                (ICF_TRANSPORT_TYPE_TLS != p_ssa_ctx->transport)) || 
            ((ICF_ADDRESS_PLAN_SIP_URI == p_sic_ctx->dest_addr.addr_type) &&
             (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctx->transport)))
    {
        ret_val = ICF_FAILURE;
        return ret_val;
    }
    /*IMP: 
     * Updation needed in update_call_obj for ICF_SSA_USER_ADDR_FRM_SIC*/
    if (ICF_FAILURE == 
                icf_ssa_update_callobj_for_profile(p_ssa_pdb))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            
        ret_val = ICF_FAILURE;
    }
    /* IMP: 
     * Updation needed in set_to_in_reg_call_obj for 
     * ICF_SSA_USER_ADDR_FRM_SIC*/
    /* To header will be set */
    else if ((ICF_FAILURE == icf_ssa_set_to_in_sic_callobj(p_ssa_pdb,
                    (icf_uint8_t *)proto)))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
#if 0
    /*Request URI to be set as destination address*/
    else if (Sdf_co_fail == 
                sdf_ivk_uaMakeAddrSpecFromConstituents(
                    &pAddrSpec, (Sdf_ty_s8bit*)server_addr, 
                    (Sdf_ty_s32bit)server_port,
                    pScheme, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }

    else if (Sdf_co_fail == sdf_ivk_uaChangeRequestURI(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                pAddrSpec, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
#endif

#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_TRUE)
        if (ICF_FAILURE != ret_val)
        {
            /* Fill Route Header from Service Route if stored for user-id while 
               registering*/
            if(ICF_FAILURE == 
                    icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                        p_sic_ctx->p_preferred_identity,
                        p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
            {
                ret_val = ICF_FAILURE;
            }
        }
ICF_CHECK_IMS_END
#endif
#ifdef NON_IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_FALSE)
        if (ICF_FAILURE != ret_val)
        {
            if(ICF_FAILURE == 
                    icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                        ICF_NULL,
                        p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
            {
                ret_val = ICF_FAILURE;
            }
        }
ICF_CHECK_IMS_END
#endif
        if (ICF_FAILURE == ret_val)
        {
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
    else if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                &p_overlap_trans_info,
                "OPTIONS",
                &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
        ret_val = ICF_FAILURE;
    }
        else if (ICF_NULL == p_overlap_trans_info)
        {
            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == 
                sdf_ivk_uaSetTransportSchemeInTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction, 
                p_overlap_trans_info,
                    proto, &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "OPTIONS",
                Sdf_en_uacTransaction);

        ret_val = ICF_FAILURE;
    }
        else if (Sdf_co_fail == sdf_ivk_uaMakeTransaction(
                    (Sdf_ty_s8bit *)"OPTIONS", 
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    &sdf_error))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "OPTIONS",
                    Sdf_en_uacTransaction);
              
            ret_val = ICF_FAILURE;
        }
   
    else if ( ICF_FAILURE == 
                icf_ssa_form_and_insert_access_nw_info_hdr(
                p_ssa_pdb, p_overlap_trans_info->pSipMsg))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "OPTIONS",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
        return ICF_FAILURE;
    }
/*    sip_freeSipAddrSpec(pAddrSpec);*/
/* KSLOCWORKS */
        else
        {
        if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
        {
            icf_string_st                 addr_val;
#ifdef ICF_IPSEC_ENABLED
            /* check if SA exists */
            if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
            {
                /* get the corresponding REG context and populate the SSA ctxt and 
                 * SSA pdb with SA ctxt and REGM ctxt structure pointers 
                 */
                ret_val = icf_ssa_set_sa_ctxt_for_otg_req(p_ssa_pdb,
                        p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity);

            }
#endif
            if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_SIP_URI)
            {
                icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sip:");
                icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
                icf_port_strcat( addr_val.str, (icf_uint8_t *)">");
            }
            else if( 
                    p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_TEL_URI)
            {
                icf_port_strcpy( addr_val.str, (icf_uint8_t *)"tel:");
                icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
            }
            else if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->
                    addr_type == ICF_ADDRESS_PLAN_E164)
            {
                icf_port_strcpy(addr_val.str,(icf_uint8_t *)"<sip:");

                icf_port_strcat(addr_val.str,
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );

                icf_port_strcat(addr_val.str,(icf_uint8_t *)"@");

                /* now appending the self IP/domain */
                /*If per line self transport then copy address from line_data*/
                if(ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
                {
                    if(ICF_NULL != p_ssa_pdb->p_line_data)
                    {
                        icf_port_memcpy(&self_addr,
                                    &(p_ssa_pdb->p_line_data->self_addr),
                                    sizeof(icf_transport_address_st));
                    }
                    else
                    {
                        ret_val = ICF_FAILURE;
                    }
                }
                else
                {
                    icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                                    sizeof(icf_transport_address_st));
                }
                if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                               self_addr.addr.addr_type)
                {
                    icf_port_strcat(addr_val.str,self_addr.addr.addr.domain.str);
                }
                else/*Assumption that it will be IPV4*/
                {
                    if(ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                                          &(self_addr),self_ip))
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else
                    {
                        icf_port_strcat(addr_val.str,self_ip);
                    }
                }
                icf_port_strcat(addr_val.str, (icf_uint8_t *)">");
            }

            else
            {
                icf_port_strcpy( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
            }

    /* Klocwork warning removal.*/ 
    if (ICF_NULL != p_overlap_trans_info)
    {      
    if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
        p_ssa_pdb, 
        (icf_uint8_t*)"P-Preferred-Identity",
                        addr_val.str,
        p_overlap_trans_info->pSipMsg))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header (P-Preferred-Identity)"));
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "OPTIONS",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
        return ICF_FAILURE;
    }
    }
    else
    {
        return ICF_FAILURE;
    }  
    }
    /* Insert Header/Tag/Body if any given by the application */

    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count)
    {
        if (ICF_NULL == p_overlap_trans_info)
        {
           return ICF_FAILURE;
        }    	
        if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list),
            ICF_TRUE, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
    }
    
    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list.count)
    {
        if (ICF_NULL == p_overlap_trans_info)
        {
           return ICF_FAILURE;
        }    	
        if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list),
            ICF_TRUE, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
    }
#ifdef ICF_IPSEC_ENABLED
        /* if SA exists, send the Securiy-Verify Header in the outgoing MESSAGE */
        if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled) &&
                /* if SA exits */
                (ICF_NULL != p_ssa_pdb->p_sa_context))
        {
            /* insert security-verify header in the otg OPTIONS */
            if (ICF_FAILURE == icf_ssa_get_sec_verify_string (p_ssa_pdb,&p_value,
                        p_ssa_pdb->p_sa_context))
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_FAILURE ==     
                    icf_ssa_insert_unknown_hdr_in_sip_msg (
                        p_ssa_pdb,
                        (icf_uint8_t*)"Security-Verify",
                        p_value, 
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg))
            {
                ICF_PRINT(("\nFailed to insert unknown header \
                            (Security-Verify)"));
                ret_val = ICF_FAILURE;
            }
            if (ICF_NULL != p_value)
            {
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_value,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
            }
            if (ICF_SUCCESS == ret_val )
            {
                ICF_PRINT(("\nSecurity Verify Header inserted to \
                            outgoing MESSAGE "));
            }
        }
#endif
    
    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.count)
    {
        if (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
            p_ssa_pdb,&(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list) , 
            ICF_TRUE, &(p_overlap_trans_info->slMsgBodyList)))
        {
                sdf_ivk_uaClearTransaction(\
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                        p_overlap_trans_info,\
                        "OPTIONS",\
                        Sdf_en_uacTransaction);

                /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                            p_ssa_ctxt->p_call_obj));*/

                return ICF_FAILURE;

        }
            /*Message body header changes Start*/
            else if ( ICF_FAILURE == \
                    icf_ssa_SetAllMsgBody(\
                        Sdf_co_null,p_overlap_trans_info,\
                        (icf_int8_t *)p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        body_list.content_type.str,\
                        &sdf_error))
            {
                sdf_ivk_uaClearTransaction(\
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                        p_overlap_trans_info,\
                        "OPTIONS",\
                Sdf_en_uacTransaction);

                /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                            p_ssa_ctxt->p_call_obj));*/
        
                return ICF_FAILURE;
            }
            /*Message body header changes End*/
    }
        if (ICF_SUCCESS == ret_val)
    {
#ifdef ICF_LOAD_STAT
        p_ssa_pdb->p_glb_pdb->load_data.otg_options_attempts++;
#endif

            if ((ICF_NULL != (ICF_SSA_TCP_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask)) ||
                    (ICF_NULL != (ICF_SSA_TLS_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask)))
            {
                ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                        ICF_SSA_EXPLICIT_CONNECT_REQ);

    }
        if ( ICF_FAILURE == icf_ssa_send_to_peer(
            p_ssa_pdb,
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            p_overlap_trans_info->pSipMsg,
            &options,
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "OPTIONS",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == sdf_ivk_uaEndTransaction(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            Sdf_co_null,
            "OPTIONS",
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "OPTIONS",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
    }
        }
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;

} /* icf_ssa_send_options_req */

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_msg_body_frm_sip_message
 * DESCRIPTION:     This function gets the first unknnown message body
 * from the SIP message structure and sets it in the message body list struct
 ******************************************************************************/
icf_return_t    icf_ssa_get_msg_body_frm_sip_message(
        INOUT  icf_ssa_pdb_st         *p_ssa_pdb,
        INOUT    SipMessage             *p_sip_msg,
        /*INOUT    Sdf_st_callObject      *p_call_object,*/
        INOUT       en_SipMessageType dReqRespType,
        OUT   icf_msg_body_list_st   *p_body_list
        )
{
    icf_return_t      ret_val = ICF_SUCCESS, dummy_ret_val = ICF_SUCCESS;
    icf_msg_body_st   *p_msg_body = ICF_NULL;
    icf_uint8_t       *p_media_type = ICF_NULL;
    Sdf_ty_s8bit      *p_buffer = Sdf_co_null;
    Sdf_ty_u32bit     bufLength = 0;
    Sdf_ty_u32bit     dCount = 0;
    Sdf_st_error      sdf_error;
    SipError          sip_error;
    SipHeader         content_type_hdr;
    SipMsgBody        *p_sip_msg_body = Sdf_co_null;
    en_SipMsgBodyType body_type;
    icf_uint8_t    body_count = 0;
	/*Fix done for SPR-18722 : CSR-1-6068965*/
    icf_int8_t    *p_ContentTypeVal = ICF_NULL;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    p_body_list->count = 0;
    p_body_list->body = ICF_NULL;
    if (SipFail == sip_getMsgBodyCount(p_sip_msg, &dCount, &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to get MsgBodyCount from SipMessage"));
        ret_val = ICF_FAILURE;
    }
    else if ( ICF_NULL < dCount)
    {
        /* Get the top level content-type header from SIP message
     */
        if (SipFail == sip_getHeader(p_sip_msg, SipHdrTypeContentType,
                    &content_type_hdr, &sip_error))
        {
            ICF_PRINT(((icf_uint8_t *)"\nFailed to get Content-Type Header"));
            ret_val = ICF_FAILURE;
        return ret_val;
        }
        else if(ICF_FAILURE == icf_ssa_get_content_type_frm_msg(\
                /*p_call_object*/dReqRespType,p_ssa_pdb,&content_type_hdr,\
                &p_ContentTypeVal))
        {
            ICF_PRINT(((icf_uint8_t *)"Failed to get Content-Type Header from SIP"\
                   " message\n"));
            /* Free the local reference */
            sip_freeSipHeader(&content_type_hdr);
            ret_val = ICF_FAILURE;
        return ret_val;
        }
        else if(ICF_NULL == p_ContentTypeVal)
        {
            sip_freeSipHeader(&content_type_hdr);
            return ICF_FAILURE;
        }    

        for(body_count=0; body_count < dCount; body_count++)
        {
            
            /* Get the message body type in the SIP message.
            */
            if(SipFail == sip_getMsgBodyTypeAtIndex(p_sip_msg,\
                &body_type,body_count,\
                (SipError *)&sip_error))
            {
                ICF_PRINT(((icf_uint8_t *)"Failed to get the message body "
                    "type\n"));
                ret_val = ICF_FAILURE;
                break;
            }

            if(SipSdpBody == body_type)
            {
                /* Ignore the SDP body. SDP has already extracted from the message.*/
                continue;
            }
            
            /* Extract the message body from SIP message.
            */
            if(Sdf_co_success == sdf_ivk_uaGetUnknownBodyFromSipMessage(\
                p_sip_msg,body_count,&p_buffer,\
                &bufLength,&sdf_error))
            {
            /* allocate memory for a msg body list node and 
            * add to List
                */
                
                if(0 == p_body_list->count)
                {
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,\
                        ICF_PORT_SIZEOF(icf_msg_body_st),\
                        ICF_MEM_COMMON,p_msg_body,\
                        ICF_DONOT_RET_ON_FAILURE,p_ssa_pdb->p_ecode,\
                        ret_val)
                        
                }
                else if(ICF_NULL != p_msg_body)
                {
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,\
                        ICF_PORT_SIZEOF(icf_msg_body_st),\
                        ICF_MEM_COMMON,p_msg_body->next,\
                        ICF_DONOT_RET_ON_FAILURE,p_ssa_pdb->p_ecode,\
                        ret_val)
                }

                if ( ICF_FAILURE == ret_val)
                {
                    /* Free the local reference */
                    sip_freeSipHeader(&content_type_hdr);
                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,\
                        p_media_type,\
                        ICF_MEM_COMMON,\
                        p_ssa_pdb->p_ecode,\
                        dummy_ret_val)
                }
                else if(ICF_NULL != p_msg_body)
                    
                {
                    if(p_body_list->count)
                    {
                        p_msg_body=p_msg_body->next;
                    }
                    else
                        p_body_list->body = p_msg_body;

                    if (ICF_NULL != p_msg_body)
                    {
                        p_msg_body->next = ICF_NULL; 
                    }
                    p_body_list->count++;
                    
                    sip_listGetAt(&(p_sip_msg->slMessageBody),\
                        body_count,(SIP_Pvoid *)&p_sip_msg_body,\
                        &sip_error);
                }
            }
            /* Fill the mime headers for each body as per the 
            * message body type
            */
            switch(body_type)
            {
            case SipSdpBody :
            /* Application SDP has already extracted from SIP message
            * Thus ignore the message body.
                */
                break;
                
            case SipIsupBody :
            case SipAppSipBody :
            /* At present ICF does not support body
            *  headers extraction mechanism except
            *  MIME headers
                */
                ICF_ASSERT(p_ssa_pdb->p_glb_pdb,\
                    p_ssa_pdb->p_line_data)
                    
                    break;
            case SipUnknownBody :
            case SipMultipartMimeBody :
                if((p_sip_msg_body && \
                    (icf_port_strcmp(\
                    (icf_uint8_t *)((SipContentTypeHeader *) (content_type_hdr.pHeader))->pStr1,\
                    (icf_uint8_t *)"multipart/mixed") == 0)) || (p_sip_msg_body && \
                    (icf_port_strcmp(\
                    (icf_uint8_t *)((SipContentTypeHeader *) (content_type_hdr.pHeader))->pStr1,\
                    (icf_uint8_t *)"multipart/related")==0)))
                {
                    ret_val = icf_ssa_get_mime_hdrs_from_sip_msg(\
                                /*p_call_object*/dReqRespType,p_ssa_pdb,p_sip_msg_body,\
                                p_msg_body);
                }
                break;
                         case SipBodyAny :
                               /* Just to remove warnings */
                                break;
            }
            
            if ((ICF_SUCCESS == ret_val) && (ICF_NULL != p_msg_body))
            {
                p_msg_body->length= bufLength;

                                if (ICF_NULL == p_ContentTypeVal)
                                {
				    /* Free the local reference */
				    sip_freeSipHeader(&content_type_hdr);
					
				    ICF_MEMFREE(
						p_ssa_pdb->p_glb_pdb,
						p_msg_body,
						ICF_MEM_COMMON,
						p_ssa_pdb->p_ecode,
						dummy_ret_val)
							
				    ICF_MEMFREE(
						p_ssa_pdb->p_glb_pdb,
						p_media_type,
						ICF_MEM_COMMON,
						p_ssa_pdb->p_ecode,
						dummy_ret_val)

                                    return ICF_FAILURE;                               
                                }
                                                
                /* Set the top level content-type*/
                /*Fix done for SPR-18722 : CSR-1-6068965*/
                icf_port_strcpy(p_body_list->\
                    content_type.str,(icf_uint8_t *)p_ContentTypeVal);
                
                p_body_list->content_type.str_len = \
                    (icf_int16_t )icf_port_strlen(p_body_list->\
                    content_type.str);
                
                    /* Allocate memory for message body value and copy the recvd
                    * msg body
                */
                if (ICF_NULL != p_msg_body->length)
                {
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        bufLength,
                        ICF_MEM_COMMON,
                        p_msg_body->value,
                        ICF_DONOT_RET_ON_FAILURE,
                        p_ssa_pdb->p_ecode, ret_val)

                    if ( ICF_FAILURE == ret_val)
                    {
                        /* Free the local reference */
                        sip_freeSipHeader(&content_type_hdr);
                        
                        ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_msg_body,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            dummy_ret_val)
                            
                        ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_media_type,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            dummy_ret_val)
                            
                        ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_ContentTypeVal,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            dummy_ret_val)
                        break;                            
                    }
                    else
                    {   
                        icf_port_memcpy(p_msg_body->value,(icf_int8_t*)p_buffer,\
                                bufLength);
                    }
                }
                
            }
            else
            {
                ret_val = icf_cmn_free_msg_body_list(p_ssa_pdb->p_glb_pdb,
                    p_body_list,
                    p_ssa_pdb->p_ecode);
                break;
            }
            
         }/*End of For Loop for Message Bodies*/

         /* Free the local reference */
        sip_freeSipHeader(&content_type_hdr);

    }

    if(ICF_NULL != p_ContentTypeVal)
    {
        ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_ContentTypeVal,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
    }


    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
ICF_SIC_END

/*******************************************************************************
 * FUNCTION:        icf_print_pdu
 * DESCRIPTION:     This function is create an external message to send network 
 *                  PDUs to application with API-ICF_TRACE_NW_BUFF_IND
 ******************************************************************************/
/*Jason , syslog*/
#ifdef VOIP_SYSLOG
icf_return_t icf_print_pdu(icf_glb_pdb_st *p_glb_pdb,
                               icf_uint8_t* p_buf, 
                               icf_uint8_t* p_host, 
                               icf_uint32_t port, 
                               icf_uint32_t len,
                               icf_boolean_t direction
                               )
{

    icf_internal_msg_st              internal_msg;
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_return_t                     dummy_ret_val = ICF_SUCCESS;
    icf_msg_st                       *p_pa_msg = ICF_NULL;
    icf_uint32_t                      msg_len = 0;    
    icf_trace_nw_buff_ind_st         *p_nw_buff_ind = ICF_NULL;
    icf_error_t                      ecode;
    icf_config_data_st               *p_cfg_data = ICF_NULL;
    icf_uint32_t                     i;
	icf_uint8_t templog[128]="";
	icf_uint32_t templen=0;
	icf_uint8_t nextline=0;
	icf_uint8_t buf_phoneNum[250];
	icf_uint8_t devicePhoneNumber_local[250]; 

#if 0 //for debug print sip message  
    ICF_PRINT(((icf_uint8_t *)"\n-----------------------------------------------------\n"));
    ICF_PRINT(((icf_uint8_t *)"PRINTING SIP PDU OF LENGTH: %d----\n",len ));
    ICF_PRINT(((icf_uint8_t *)"-----------------------------------------------------\n"));
#endif	
    for(i = 0; i < len; i++)
    {
#if 0 //for debug print sip message       
        if ((p_buf[i] > ICF_MAX_NON_PRINTABLE_CHARACTER)
                ||( p_buf[i] == ICF_NEXT_LINE_CHARACTER))
            ICF_PRINT(((icf_uint8_t *)"%c", p_buf[i]));
#endif

		if(p_buf[i] == ICF_NEXT_LINE_CHARACTER){
			nextline=1;
		}
#if 1		
		if((nextline==0)){          
			templen=i;
		}
#endif		
		
    }
//	templog[i+1]='\n';
	
//    ICF_PRINT(((icf_uint8_t *)"\n----------------------------------------------------\n"));
	icf_port_strncpy(templog,(icf_uint8_t *)p_buf,    templen);

	
#if 0

	if(p_glb_pdb->p_call_ctx==ICF_NULL){
		printf("\r\n icf_print_pdu,p_glb_pdb->p_call_ctx is null\n");
	}else{
		printf("\r\n icf_print_pdu, callid %d\n",p_glb_pdb->p_call_ctx->call_id);
	}
#endif



#if 0
	if (p_glb_pdb->p_call_ctx != NULL){
		sprintf(buf_phoneNum, "%s", p_glb_pdb->p_call_ctx->remote_party_addr.addr_val.str);
		printf("buf_phoneNum=%s\r\n", buf_phoneNum);
		sprintf(devicePhoneNumber_local, "%s", strtok(buf_phoneNum, "@"));
		printf("devicePhoneNumber_remote=%s\r\n", devicePhoneNumber_local);
	}else{
		printf("p_ssa_pdb->p_glb_pdb->p_call_ctx->local_address.addr_val.str == NULL-handle_successful_decode"); 
	}

	//0 for send sip
	//1 for recevie sip
	printf("\r\n icf_print_pdu direction %d\n",direction);
#endif

	if(direction==1){
			icf_port_strcat(templog, " - SIP Message Send");
			templen=templen+19;
	}else{
			icf_port_strcat(templog, " - SIP Message received");
			templen=templen+23;


	}
	templog[templen+1]='\n';
	printf("len is %d templog is %s\n",templen,templog);

//eric.chung 


	len=templen;

    /*Create an external message and send message to ADM*/ 
    /* get cfg data for getting the max number of applications*/
    if(ICF_FAILURE == icf_dbm_get_module_glb_data(     
        p_glb_pdb ,
        (icf_int_module_id_t const) ICF_INT_MODULE_CFG,
        (icf_void_t *)&p_cfg_data,
        &ecode))
    {
        return ICF_FAILURE;
    }
    
    if (ICF_TRUE == p_cfg_data->nw_trace_enabled)
    {
        /*Calculate the message length*/
        msg_len = sizeof(icf_api_header_st) + sizeof(icf_trace_nw_buff_ind_st) + len;

        
        /*Allocate memory for API header strucure */
        ICF_MEMGET(p_glb_pdb, msg_len - len, ICF_MEM_COMMON, p_pa_msg,
            ICF_RET_ON_FAILURE, &ecode, ret_val)
            
        /* Fill the message header for ICF_TRACE_NW_BUFF_IND */        
        p_pa_msg->hdr.api_id = ICF_TRACE_NW_BUFF_IND;
        p_pa_msg->hdr.api_length = (icf_uint16_t)msg_len;
		if(p_glb_pdb->p_call_ctx==ICF_NULL){
	        p_pa_msg->hdr.call_id = ICF_INVALID_CALL_ID;
		}else{
			p_pa_msg->hdr.call_id =	p_glb_pdb->p_call_ctx->call_id;
		}
        p_pa_msg->hdr.app_id = ICF_GENERIC_APP_ID;
            
        /*Fill message payload*/
        p_nw_buff_ind = (icf_trace_nw_buff_ind_st*)&(p_pa_msg->payload[0]);
        
        p_nw_buff_ind->nw_address.addr.addr_type = ICF_TRANSPORT_ADDRESS_IPV4_ADDR;
        

        dummy_ret_val = icf_port_str_to_trans_addr(p_host, &(p_nw_buff_ind->nw_address.addr));

        
        p_nw_buff_ind->nw_address.port_num = (icf_uint16_t)port;    

        ICF_MEMGET(p_glb_pdb, len+2, ICF_MEM_COMMON, 
            p_nw_buff_ind->nw_buffer.p_buff,
            ICF_DONOT_RET_ON_FAILURE, &ecode, ret_val)
        if (ICF_FAILURE == ret_val || ICF_NULL == p_nw_buff_ind->nw_buffer.p_buff)
        {
           ICF_MEMFREE(p_glb_pdb, 
                       p_pa_msg, 
                       ICF_MEM_COMMON,
                       &ecode, 
                       ret_val ) 
           return ICF_FAILURE;
        } 

//        icf_port_memcpy(p_nw_buff_ind->nw_buffer.p_buff,p_buf,len);
//for syslog 
	    icf_port_memcpy(p_nw_buff_ind->nw_buffer.p_buff,templog,templen);

        p_nw_buff_ind->nw_buffer.p_buff[len]='\0';
        
        p_nw_buff_ind->nw_buffer.len = len;
        
        /*Fill header in internal message structure*/
        internal_msg.msg_hdr.msg_id = ICF_TRACE_NW_BUFF_IND;
        
        internal_msg.msg_hdr.p_glb_pdb = p_glb_pdb;
        
        internal_msg.msg_hdr.payload_length = (icf_uint16_t)msg_len;
        
        /*Assign p_pa_msg to p_pa_msg_data of icf_internal_msg_st*/
        internal_msg.p_msg_data = (icf_uint8_t*)p_pa_msg;    
        
        /*Call icf_adm_process_mesg(p_internal_msg)*/
        ret_val = icf_adm_process_mesg(&internal_msg);
        
        /*If process msg return fail*/
        if(ICF_FAILURE == ret_val)
        {        
            
        }  /* if(ICF_FAILURE == ret_val) */
        
        /*Deallocate API header structure*/
        ICF_MEMFREE(p_glb_pdb, p_nw_buff_ind->nw_buffer.p_buff, ICF_MEM_COMMON,
            &ecode, dummy_ret_val )

        ICF_MEMFREE(p_glb_pdb, p_pa_msg, ICF_MEM_COMMON,
            &ecode, dummy_ret_val )
    }
 
     return ret_val;

}
                               
#else
icf_return_t icf_print_pdu(icf_glb_pdb_st *p_glb_pdb,
                               icf_uint8_t* p_buf, 
                               icf_uint8_t* p_host, 
                               icf_uint32_t port, 
                               icf_uint32_t len)
{
#ifndef ICF_TRACE_ENABLE	/*ZyXEL Porting*/
	/*Because a lot of debug messages printed on the screen is not we like(extra loading). 	mark here to disable SIP packet trace messages don't printf on the screen.	*/
	return ICF_SUCCESS;
#else
    icf_internal_msg_st              internal_msg;
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_return_t                     dummy_ret_val = ICF_SUCCESS;
    icf_msg_st                       *p_pa_msg = ICF_NULL;
    icf_uint32_t                      msg_len = 0;    
    icf_trace_nw_buff_ind_st         *p_nw_buff_ind = ICF_NULL;
    icf_error_t                      ecode;
    icf_config_data_st               *p_cfg_data = ICF_NULL;
    icf_uint32_t                     i;

    ICF_PRINT(((icf_uint8_t *)"\n-----------------------------------------------------\n"));
    ICF_PRINT(((icf_uint8_t *)"PRINTING SIP PDU OF LENGTH: %d----\n",len ));
    ICF_PRINT(((icf_uint8_t *)"-----------------------------------------------------\n"));
    for(i = 0; i < len; i++)
    {
        if ((p_buf[i] > ICF_MAX_NON_PRINTABLE_CHARACTER)
                ||( p_buf[i] == ICF_NEXT_LINE_CHARACTER))
            ICF_PRINT(((icf_uint8_t *)"%c", p_buf[i]));
    }
    ICF_PRINT(((icf_uint8_t *)"\n----------------------------------------------------\n"));

    /*Create an external message and send message to ADM*/ 
    /* get cfg data for getting the max number of applications*/
    if(ICF_FAILURE == icf_dbm_get_module_glb_data(     
        p_glb_pdb ,
        (icf_int_module_id_t const) ICF_INT_MODULE_CFG,
        (icf_void_t *)&p_cfg_data,
        &ecode))
    {
        return ICF_FAILURE;
    }
    
    if (ICF_TRUE == p_cfg_data->nw_trace_enabled)
    {
        /*Calculate the message length*/
        msg_len = sizeof(icf_api_header_st) + sizeof(icf_trace_nw_buff_ind_st) + len;
        
        /*Allocate memory for API header strucure */
        ICF_MEMGET(p_glb_pdb, msg_len - len, ICF_MEM_COMMON, p_pa_msg,
            ICF_RET_ON_FAILURE, &ecode, ret_val)
            
        /* Fill the message header for ICF_TRACE_NW_BUFF_IND */        
        p_pa_msg->hdr.api_id = ICF_TRACE_NW_BUFF_IND;
        p_pa_msg->hdr.api_length = (icf_uint16_t)msg_len;
        p_pa_msg->hdr.call_id = ICF_INVALID_CALL_ID;
        p_pa_msg->hdr.app_id = ICF_GENERIC_APP_ID;
            
        /*Fill message payload*/
        p_nw_buff_ind = (icf_trace_nw_buff_ind_st*)&(p_pa_msg->payload[0]);
        
        p_nw_buff_ind->nw_address.addr.addr_type = ICF_TRANSPORT_ADDRESS_IPV4_ADDR;
        
#if 0
        /* sscanf is crashing on device */
        icf_port_sscanf(p_host, "%d.%d.%d.%d", 
            &p_nw_buff_ind->nw_address.addr.addr.ipv4_addr.octet_1,
            &p_nw_buff_ind->nw_address.addr.addr.ipv4_addr.octet_2,
            &p_nw_buff_ind->nw_address.addr.addr.ipv4_addr.octet_3,
            &p_nw_buff_ind->nw_address.addr.addr.ipv4_addr.octet_4);
#else
        dummy_ret_val = icf_port_str_to_trans_addr(p_host, &(p_nw_buff_ind->nw_address.addr));
#endif
        
        p_nw_buff_ind->nw_address.port_num = (icf_uint16_t)port;    

        ICF_MEMGET(p_glb_pdb, len+2, ICF_MEM_COMMON, 
            p_nw_buff_ind->nw_buffer.p_buff,
            ICF_DONOT_RET_ON_FAILURE, &ecode, ret_val)
        if (ICF_FAILURE == ret_val || ICF_NULL == p_nw_buff_ind->nw_buffer.p_buff)
        {
           ICF_MEMFREE(p_glb_pdb, 
                       p_pa_msg, 
                       ICF_MEM_COMMON,
                       &ecode, 
                       ret_val ) 
           return ICF_FAILURE;
        } 

        icf_port_memcpy(p_nw_buff_ind->nw_buffer.p_buff,p_buf,len);
        p_nw_buff_ind->nw_buffer.p_buff[len]='\0';
        
        p_nw_buff_ind->nw_buffer.len = len;
        
        /*Fill header in internal message structure*/
        internal_msg.msg_hdr.msg_id = ICF_TRACE_NW_BUFF_IND;
        
        internal_msg.msg_hdr.p_glb_pdb = p_glb_pdb;
        
        internal_msg.msg_hdr.payload_length = (icf_uint16_t)msg_len;
        
        /*Assign p_pa_msg to p_pa_msg_data of icf_internal_msg_st*/
        internal_msg.p_msg_data = (icf_uint8_t*)p_pa_msg;    
        
        /*Call icf_adm_process_mesg(p_internal_msg)*/
        ret_val = icf_adm_process_mesg(&internal_msg);
        
        /*If process msg return fail*/
        if(ICF_FAILURE == ret_val)
        {        
            
        }  /* if(ICF_FAILURE == ret_val) */
        
        /*Deallocate API header structure*/
        ICF_MEMFREE(p_glb_pdb, p_nw_buff_ind->nw_buffer.p_buff, ICF_MEM_COMMON,
            &ecode, dummy_ret_val )

        ICF_MEMFREE(p_glb_pdb, p_pa_msg, ICF_MEM_COMMON,
            &ecode, dummy_ret_val )
    }
 
     return ret_val;
#endif
}
#endif 

/*******************************************************************************
 * FUNCTION:        icf_ssa_add_ContactHeaderToSipMsg
 * DESCRIPTION:     This function adds a List of contacts to the SIP message
 ******************************************************************************/

icf_return_t icf_ssa_add_ContactHeaderToSipMsg
    (Sdf_st_callObject *pObject,
     Sdf_ty_slist *pslContactList,
     Sdf_st_overlapTransInfo *pOverlapTransInfo,
     Sdf_st_error *pErr)
{
    Sdf_ty_slist                 contact_addr_list;
    icf_boolean_t            contact_list_valid = ICF_TRUE;
    icf_return_t             ret_val=ICF_SUCCESS;
    Sdf_st_transaction *pTransaction = Sdf_co_null;
    Sdf_ty_u32bit i = 0, dSize = 0;
    Sdf_st_listIterator dListIterator;
    SipMessage            *pSipMsg = Sdf_co_null;

    if(Sdf_co_null == pslContactList)
    {
        /* Get the Contact list from InitData */
        if (Sdf_co_fail == sdf_listInit(
            &contact_addr_list,
            __sdf_fn_uaFreeCompleteHeader,
            Sdf_co_false,
            pErr))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            ret_val = ICF_FAILURE;
            contact_list_valid = ICF_FALSE;
        }
        else if (Sdf_co_fail == sdf_fn_uaCloneSipHeadersList(
            &contact_addr_list,
            &(pObject->pInitData->slContact),
            pErr))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            pslContactList = &contact_addr_list;
        }
    }
    else
    {
        contact_list_valid = ICF_FALSE;
    }

    if(ICF_SUCCESS == ret_val)
    {
        
        sdf_listSizeOf(pslContactList, &dSize, pErr);
        
        if (dSize > 0)
        {
            if( pOverlapTransInfo == Sdf_co_null )
            {
                if (sdf_ivk_uaGetTransactionFromCallObject(pObject, \
                    Sdf_en_uacTransaction, &pTransaction,pErr) == Sdf_co_fail)
                {
                    pErr->errCode=Sdf_en_callObjectAccessError;
                    return Sdf_co_fail;
                }
                pSipMsg = pTransaction->pSipMsg;
                
                sdf_ivk_uaFreeTransaction(pTransaction);
            }
            else
                pSipMsg = pOverlapTransInfo->pSipMsg;
            
            
            if(sip_deleteAllHeaderType(pSipMsg, SipHdrTypeContactAny, \
                (SipError *)&(pErr->stkErrCode)) == SipFail)
            {
                pErr->errCode=Sdf_en_headerManipulationError;
                ret_val = ICF_FAILURE;
            }
            else
            {
                sdf_listInitIterator(pslContactList, &dListIterator, pErr);
                
                while (dListIterator.pCurrentElement != Sdf_co_null)
                {
                    SipHeader *pContactHdr = Sdf_co_null;
                    
                    pContactHdr = (SipHeader*)\
                        (dListIterator.pCurrentElement->pData);
                    
                    if (pContactHdr == Sdf_co_null)
                    {
                        sdf_listNext(&dListIterator, pErr);
                        i++;
                        continue;
                    }
                    
                    if (SipFail == sip_insertHeaderAtIndex(pSipMsg, pContactHdr, \
                        (Sdf_ty_u32bit)i, (SipError *)&(pErr->stkErrCode)))
                    {
                        pErr->errCode=Sdf_en_headerManipulationError;
                        ret_val = ICF_FAILURE;
                        break;
                    }
                    sdf_listNext(&dListIterator, pErr);
                    i++;
                }
            }
        }
    }
    if(ICF_TRUE == contact_list_valid)
    {
        sdf_listDeleteAll(&contact_addr_list, pErr);
    }
    return ret_val;
}
/*******************************************************************************
 * FUNCTION:        icf_ssa_fetch_matching_overlap_txn
 *
 * DESCRIPTION:     This function fetches the matching overlap transaction
 *                  corresponding to the msg type and transaction state
 *                  state from the list of overlapped transactions in the
 *                  call object
 *
 ******************************************************************************/
icf_return_t icf_ssa_fetch_matching_overlap_txn(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT      Sdf_ty_messageType       msg_type,
        INOUT      Sdf_ty_state             trans_state,
        INOUT      Sdf_st_callObject        *p_call_obj,
        INOUT    Sdf_st_overlapTransInfo  **p_p_match_overlap_txn)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    Sdf_st_error                        sdf_error;
    icf_uint32_t                     list_size = 0, count = 0;

    Sdf_st_overlapTransInfo             *p_ovtxn = Sdf_co_null;

    
    if(ICF_NULL == p_ssa_pdb)
    {
        return ICF_FAILURE;
    }
    
    p_ssa_pdb=p_ssa_pdb; 
        
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /*
     * We iterate through the list of overlapped transactions and

     * fetch the overlap transaction with the requisite msg_type
     * and transaction state
     */

    if ( Sdf_co_fail ==
            sdf_listSizeOf(&(p_call_obj->slOverlapTransInfo),
                (Sdf_ty_u32bit*)(&list_size), &sdf_error))
    {
        /*Raise a Major error here - UATK_PROCESSING FAILURE*/
        ret_val = ICF_FAILURE;
    }
    else
    {
        for (count = 0; count < list_size; count++)
        {
            if( Sdf_co_fail == sdf_listGetAt(
                        &(p_call_obj->slOverlapTransInfo),
                        count,
                        (Sdf_ty_pvoid)&p_ovtxn,
                        &sdf_error))
            {
                /*Raise MajorError - UATK_PROCESSING FAILURE*/
                ret_val = ICF_FAILURE;
                break ;
            }
            else
            {

                /*
                 * Check for the message type and the transaction state
                 */
                if (( msg_type == p_ovtxn->dMsgType) &&
                        ((trans_state == p_ovtxn->dState) || 
                        (Sdf_en_transactionCancel == p_ovtxn->dState)))
                {
                    /*
                     * Found the matching transaction
                     */
                    *p_p_match_overlap_txn = p_ovtxn;
                    break;
                }
            }
        }
        if (count == list_size || ICF_FAILURE == ret_val)
        {
            /*Raise MajorError - NO TXN TO BE RESPONDED TO*/
            ret_val = ICF_FAILURE ;
        } /* if (count == list_size) */
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_set_RouteHeaderListToInitData
 *
 * DESCRIPTION:     This function makes the Route header from the
 *                  Service Route if presnent in the RGN block
 *                  Else set the default Outbound Proxt as
 *                  Preloaded Route,Currently It Does not handle
 *                  Record Route
 ******************************************************************************/
icf_return_t icf_ssa_set_RouteHeaderListToInitData(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT      icf_address_st        *p_local_address,
        INOUT      icf_line_id_t        line_id,
        INOUT    icf_error_t*         p_ecode)
{

#ifdef IMS_CLIENT
    icf_rgm_context_st       *p_rgn_blk_addr = Sdf_co_null;
    SipHeader                   *p_temp_hdr = Sdf_co_null;
    icf_boolean_t            is_serv_rte_present = ICF_FALSE;
    Sdf_ty_u32bit               size = 0, l_index = 0;
    SipHeader                   *p_header = Sdf_co_null;
    icf_uint8_t                  *p_port=ICF_NULL;    
    SipAddrSpec              *pSrvRteAddrSpec = Sdf_co_null;
    icf_uint8_t              *p_host_ip  = ICF_NULL,*p_proxy_ip=ICF_NULL;
#endif
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_line_data_st         *p_line_data = p_ssa_pdb->p_line_data;
    icf_transport_address_st *p_proxy_addr = ICF_NULL;
    icf_uint8_t              proxy_address[ICF_MAX_STR_LEN];    
    icf_boolean_t            port_matched = ICF_FALSE;
    Sdf_st_error                sdf_error;
    icf_boolean_t            is_proxy_cfg = ICF_FALSE, send_route = ICF_TRUE;
    icf_address_st            *p_rem_addr = ICF_NULL;

#ifdef ICF_SIGCOMP_SUPPORT
    icf_transport_address_st   *p_sigcomp_proxy_addr = ICF_NULL;
    icf_boolean_t              is_to_add_sigcomp_param_in_route = ICF_FALSE;
    icf_void_t           *p_sigsa_ctxt = ICF_NULL;
#endif

#ifdef NON_IMS_CLIENT
/* To remove warning */
p_local_address=p_local_address;
p_ecode=p_ecode;
#endif
    /* To remove warning */
    line_id=line_id;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, p_line_data)

    #ifdef NON_IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_FALSE)
    if (ICF_FALSE == ICF_IS_BIT_SET(p_ssa_pdb->p_glb_cfg_data->default_settings,
                            ICF_CFG_CC_CALL_THRU_SIP_PROXY))
    {
        return ICF_SUCCESS;
    }
ICF_CHECK_IMS_END
#endif

    if (ICF_SSA_USER_ADDR_FRM_SIC & p_ssa_pdb->common_bitmask)
    {
        p_rem_addr = &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->dest_addr);
    }
    else
    {
        p_rem_addr = &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr);
    }

#ifdef ICF_SIGCOMP_SUPPORT
#ifdef ICF_IPSEC_ENABLED
    if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
    {
        icf_rgm_glb_data_st         *p_rgm_glb_data  = ICF_NULL;

        if (ICF_FAILURE == \
                icf_dbm_get_module_glb_data(
                        p_ssa_pdb->p_glb_pdb,\
                        ICF_INT_MODULE_REGM, 
                        (icf_void_t **)(&p_rgm_glb_data),
                        p_ssa_pdb->p_ecode))
        {
            /*ICF_SIGSA_TRACE(("\nFailure while getting RGM Global Data in SIGSA\n"));    */
            return ICF_FAILURE;
        }
        p_sigsa_ctxt = p_rgm_glb_data->p_sigsa_ctxt;
        }
        else
        {
            p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
        }
#else
    p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
#endif
#endif


#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
    /* Get Registration Block as per the Local Address */
    if(ICF_FAILURE == icf_rgm_fetch_ctxt_for_uri(
        p_ssa_pdb->p_glb_pdb,p_local_address,&p_rgn_blk_addr,p_ecode))
    {
        ret_val = ICF_FAILURE;

        return ICF_FAILURE;
    }
ICF_CHECK_IMS_END
#endif
    if (ICF_SUCCESS == ret_val)
    {
        /* Set the Proxy address as stored in the line_data */
        p_proxy_addr = &(p_line_data->proxy_addr);
    }

#ifdef NON_IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_FALSE)
    is_proxy_cfg = (ICF_CFG_LINE_DATA_PROXY_RECD &
        p_line_data->line_data_received)?ICF_TRUE:ICF_FALSE; 

    if (ICF_FALSE == is_proxy_cfg)
    {
        return ICF_SUCCESS;
    }
ICF_CHECK_IMS_END
#endif
    
#ifdef ICF_SIGCOMP_SUPPORT
    /* For SigComp query Sigsa whether Any updated sigcomp address is
     * present or not */
    /* Currently It is assumed that if sigcomp support is on then 
     * Peer supports Sigcomp and ICF does not send OPTION method to
     * P-CSCF : So below code commented */
    if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->sigcomp_required)
    {
        is_to_add_sigcomp_param_in_route = ICF_TRUE;
    }
    /*
    if((IPPSTK_NULL != p_ssa_pdb->p_ssa_ctxt) &&
       (IPPSTK_NULL != p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt) &&
       (IPPSTK_SUCCESS == ippstk_sigsa_get_sigcomp_proxy_addrs_from_ctxt
                        (p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt,
                        &p_sigcomp_proxy_addr,
                        &is_to_add_sigcomp_param_in_route,p_ecode)))
    {
        if(IPPSTK_NULL != p_sigcomp_proxy_addr)
        {
            p_proxy_addr = p_sigcomp_proxy_addr;
        }
    }
    */    
#endif

    /* If Service Route is present then check whether first Route header
     * stored in service route points to the proxy which is configured
     * in our databse, If yes then we will not add it to the Route header
     */

#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
    if(ICF_NULL == p_rgn_blk_addr->p_srv_rte)
    {
        ICF_PRINT(("\n[SSA]:No header in Service route header list"));
    }
    else if(Sdf_co_fail == sdf_listSizeOf(
                ((Sdf_ty_slist*)p_rgn_blk_addr->p_srv_rte),
                &size, &sdf_error))
    {
        ICF_PRINT(("\n[SSA]: Failure in getting size of Service-Route\
                    header list from Registration Context"));
    }
    else if ( ICF_NULL == size)
    {
        ICF_PRINT(("\n[SSA]:No header in Service route header list"));
    }
    else
    {
        is_serv_rte_present = ICF_TRUE;
    }
ICF_CHECK_IMS_END
#endif

    if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
            p_proxy_addr->addr.addr_type)
    {
        icf_port_strcpy(proxy_address,p_proxy_addr->addr.addr.domain.str);
    }
    else
    {
        icf_ssa_convert_to_IP_addr(
           p_proxy_addr,proxy_address);

    }

#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
    if(ICF_TRUE == is_serv_rte_present)
    {
        SipError        SipErr;
        if(Sdf_co_fail == sdf_listGetAt(
                    (Sdf_ty_slist*)p_rgn_blk_addr->p_srv_rte, 
                    l_index,
                    (Sdf_ty_pvoid *)&p_header, &sdf_error))
        {
            ICF_PRINT(("\n[SSA]:Failure in hdr retrieval,going for \
                        next"));
        }

        else if(Sdf_co_fail == sip_getAddrSpecFromFromHdr(p_header, &pSrvRteAddrSpec,
                    &SipErr))
        {
            ret_val = ICF_FAILURE;
        }
        else if (SipAddrSipUri == pSrvRteAddrSpec->dType)

        {
            /* need to invk function getHostIp so that we make sure that
             * we are comparing the same Address types
             */
            if ( Sdf_co_success == sdf_fn_uaGetHostIp(
                                            proxy_address, 
                                            ((Sdf_ty_s8bit **)&p_proxy_ip),
                                            &sdf_error))
            {
                if ( Sdf_co_success == sdf_fn_uaGetHostIp(
                                        pSrvRteAddrSpec->u.pSipUrl->pHost, 
                                        (( Sdf_ty_s8bit **)&p_host_ip), 
                                        &sdf_error))
                {
                    /* now compare the two addresses */
                    if(0 == icf_port_strcmp(p_proxy_ip,
                                               p_host_ip))
                    {
#ifndef ICF_IPSEC_ENABLED
                        /*Compare the ports now*/
                        if(p_proxy_addr->port_num ==
                                *(pSrvRteAddrSpec->u.pSipUrl->dPort))
                        {
                            ICF_PRINT(("\n[SSA]:Proxy Address matched with Service-\
                                        Route's First entry"));
                            port_matched = ICF_TRUE;
                        }
#else
                        /* if IPsec is confgured and SA is established by now,
                         * we will use the proxy protected server port for sending
                         * this request
                         */
                        if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
                        {
                            /* if SA is established by now */
                            if (ICF_NULL != p_ssa_pdb->p_sa_context)
                            {
                                if(p_ssa_pdb->p_sa_context->
                                    p_proxy_security_params->port_s ==
                                    *(pSrvRteAddrSpec->u.pSipUrl->dPort))
                                {
                                    ICF_PRINT(("\n[SSA]:\
                                        Proxy Address matched with Service-\
                                        Route's First entry"));

                                    port_matched = ICF_TRUE;
                                }
                            }
                        }
#endif
                    } /* if addresses matched */
                    sdf_memfree(0, (Sdf_ty_pvoid *)&p_host_ip, &sdf_error);
                    sdf_memfree(0, (Sdf_ty_pvoid *)&p_proxy_ip, &sdf_error);
                }
                else
                {
                    sdf_memfree(0, (Sdf_ty_pvoid *)&p_proxy_ip, &sdf_error);

                }
                
            }
        }
        else if (SipAddrReqUri == pSrvRteAddrSpec->dType)
        {
            if(0 == Sdf_mc_strncmp(proxy_address,
                        pSrvRteAddrSpec->u.pUri, 
                        Sdf_mc_strlen(proxy_address)))
            {
                p_port = Sdf_mc_strstr(pSrvRteAddrSpec->u.pUri, ":");
                if (ICF_NULL != p_port)
                {
                    p_port++; /*Point next character to ":" */
                    /*Compare the ports now*/
                    if(p_proxy_addr->port_num == Sdf_mc_atoi(p_port))
                    {
                        ICF_PRINT(("\n[SSA]:Proxy Address matched with Service-\
                                Route's First entry"));
                        port_matched = ICF_TRUE;
                    }
                } /* if (ICF_NULL != p_port) */
            }
        }

        if(pSrvRteAddrSpec != Sdf_co_null)
            sip_freeSipAddrSpec(pSrvRteAddrSpec);
    }
ICF_CHECK_IMS_END
#endif

    /* Here we are assuming that if port match is true then the first
     * service should also contain comp=sigcomp param in the fisrt entry
     * if the outbound proxy supports sigcomp
     */
        
    if(ICF_FALSE == port_matched)
    { /*It shall be executed even IP is not matched*/
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
#ifdef ICF_SIGCOMP_SUPPORT
        if(ICF_TRUE == 
                is_to_add_sigcomp_param_in_route)
        {
            if ( Sdf_co_fail == 
                    sdf_ivk_uaAddDefaultPreLoadedRoute(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                        Sdf_co_null,
                        proxy_address,
                        p_proxy_addr->port_num,
                        "lr;comp=sigcomp",/*pParam*/
                        ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)?"sips":"sip"),
                        &sdf_error))
            {
                /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                ret_val = ICF_FAILURE;
            }

        }
        else
        {
            if ( Sdf_co_fail == 
                    sdf_ivk_uaAddDefaultPreLoadedRoute(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                        Sdf_co_null,
                        proxy_address,
                        p_proxy_addr->port_num,
                        "lr",/*pParam*/
                        ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)?"sips":"sip"),
                        &sdf_error))
            {
                /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                ret_val = ICF_FAILURE;
            }

        }

#else
        if(ICF_FAILURE == ret_val)
        {
            /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/

        }
        else if ( Sdf_co_fail == 
                sdf_ivk_uaAddDefaultPreLoadedRoute(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                    Sdf_co_null,
                    proxy_address,
                    p_proxy_addr->port_num,
                    "lr",/*pParam*/
                    "sip",
                    &sdf_error))
        {
            /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
#endif /*SIGCOMP check*/
ICF_CHECK_IMS_END
#endif
#ifdef NON_IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_FALSE)
        if(ICF_FAILURE == ret_val)
        {
            /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
        }
    else
    {
        if ((ICF_ADDRESS_PLAN_SIP_URI == p_rem_addr->addr_type ) ||
            (ICF_ADDRESS_PLAN_SIPS_URI == p_rem_addr->addr_type))
        {
            icf_uint8_t    *p_temp = ICF_NULL;
            icf_return_t    user_dom_is_ip = ICF_SUCCESS;
            icf_int8_t    *p_rem_port = ICF_NULL;
            icf_uint8_t     *p_rem_ip = ICF_NULL;
            p_temp = icf_port_strchr(p_rem_addr->addr_val.str,'@');
            /* Duplicate the string following the @ sign */ 

            if(ICF_NULL != p_temp)
            {        
                p_rem_ip = icf_port_strdup(p_temp + 1) ;
            }
            else
            {
                p_rem_ip = icf_port_strdup(p_rem_addr->addr_val.str);
            }
            
            if(ICF_NULL != p_rem_ip)
            {    
                icf_port_strtokr((icf_int8_t *)p_rem_ip,":",&p_rem_port);
                /*p_rem_port = icf_port_strtok(ICF_NULL,":");*/
                user_dom_is_ip = icf_port_check_if_ip(p_rem_ip);

            /* Compare the user's domain and proxy address in these scenarios
             *    1) If the user address is of type user@<IP> and proxy address
             *       is also an IP address 
             *    2) If the user address is of type user@<domain> and proxy 
             *    address is also a domain name
             *  If both happens to be same then compare the port numbers if they 
             *  are also same then dont send the route header  
             */ 
            if(((ICF_SUCCESS == user_dom_is_ip) && 
                        (ICF_TRANSPORT_ADDRESS_IPV4_ADDR == 
                        p_line_data->proxy_addr.addr.addr_type)) ||
                    ((ICF_FAILURE == user_dom_is_ip) && 
                    (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                    p_line_data->proxy_addr.addr.addr_type)))
            {
                if(!(icf_port_strcmp(p_rem_ip,proxy_address)))
                {
                    /* If IP are same then compare ports
                     * to be same . No port in address 
                     * would mean default port 5060 */
					/* Fix for CSR 1-7680323: SPR 19955 */
					/* Insert Route header if remote port is not specified and
					 * proxy port is 5060, or if both are 5060.
					 * This is required when proxy address is configured as 
				 	 * domain name so that SRV query is not made and directly A query
					 * is made since port is already known. Without this fix, we pass
					 * port number as 0 in SetTo() hence UATK attempts SRV first. So 
					 * insert Route header in the message with port 5060.
					 */
                    if((ICF_NULL == p_rem_port) && 
                            (5060 == p_line_data->proxy_addr.port_num))
                    {
                        send_route = ICF_TRUE;
                    }
                    else if ((ICF_NULL != p_rem_port) && 
                             (icf_port_atoi((const icf_int8_t *)p_rem_port) == 
                             	p_line_data->proxy_addr.port_num) &&
							 (5060 == p_line_data->proxy_addr.port_num))
                    {
                        send_route = ICF_TRUE;
                    }
                    else if(ICF_NULL != p_rem_port && 
                            icf_port_atoi((const icf_int8_t *)p_rem_port) == 
                            p_line_data->proxy_addr.port_num)
                    {
                        send_route = ICF_FALSE;
                    }
                }
            }
            }
            icf_port_strfree(p_rem_ip);
        }
        if(ICF_TRUE == send_route)
        {
            if ( Sdf_co_fail == 
                    sdf_ivk_uaAddDefaultPreLoadedRoute(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                        Sdf_co_null,
                        (icf_int8_t *)proxy_address,
                        p_proxy_addr->port_num,
                        "lr",/*pParam*/
                        ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)?"sips":"sip"),
                        &sdf_error))
            {
                /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                ret_val = ICF_FAILURE;
            }
        }/*if send route was true*/
    }
ICF_CHECK_IMS_END
#endif
    }

#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
    if(ICF_FAILURE == ret_val)
    {
        return ret_val;
    }
    else if(ICF_TRUE == is_serv_rte_present)
    {
        SipError        SipErr;
        for(;l_index < size ;l_index++)
        {
            if(Sdf_co_fail == sdf_listGetAt(
                        (Sdf_ty_slist*)p_rgn_blk_addr->p_srv_rte,
                        l_index,
                        (Sdf_ty_pvoid *)&p_header, &sdf_error))
            {
                ICF_PRINT(("\n[SSA]:Failure in hdr retrieval,going for \
                            next"));
            }
            else if (SipFail ==sip_initSipHeader(&p_temp_hdr,
                        SipHdrTypeRoute, &SipErr))
            {
                ret_val = ICF_FAILURE;
            }
            else if(SipFail == sip_cloneSipHeader(p_temp_hdr,
                        p_header, &SipErr))
            {
                ret_val = ICF_FAILURE;
            }
            if(ICF_SUCCESS == ret_val)
            {
            if (sdf_listAppend(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData->slPreLoadedRoute),
                        p_temp_hdr, &sdf_error) == Sdf_co_fail)
            {
                sip_freeSipHeader(p_temp_hdr);
                ICF_PRINT(("\n[SSA]:Failure to insert Route header"));
                ret_val = ICF_FAILURE;
                break;
            }
            }
        }
    }
ICF_CHECK_IMS_END
 #endif
    ICF_PRINT(((icf_uint8_t *)"\n[SSA]: icf_ssa_set_RouteHeaderListToInitData"));
    return ret_val;
}


#ifdef IMS_CLIENT 
/*******************************************************************************
 * FUNCTION:        icf_ssa_make_ims_auth_hdr
 *
 * DESCRIPTION:     This function makes the authorization header for
 *                  IMS scenario
 *
 ******************************************************************************/
 icf_return_t icf_ssa_make_ims_auth_hdr(
            INOUT    icf_ssa_pdb_st            *p_ssa_pdb,
            INOUT    SipMessage                    *p_sip_msg)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;
    
    SipHeader       *pHeader = ICF_NULL;
    Sdf_ty_s8bit    *pHdrName=ICF_NULL;
    Sdf_ty_s8bit    *pFixdBody=ICF_NULL, *p_body=ICF_NULL ;
    Sdf_ty_s32bit   HdrBodyLen=0, usr_name_sz;
    
    Sdf_ty_s32bit   realm_size = 0;
    Sdf_ty_s32bit   uri_size = 0;
    Sdf_ty_s8bit    *pRealm=ICF_NULL;
    Sdf_ty_s8bit    *pUri=ICF_NULL;
    Sdf_ty_s8bit    *pNonce=ICF_NULL;
    Sdf_ty_s8bit    *pResponse=ICF_NULL;
    SipError                            sip_err;
    
    icf_rgm_context_st        *p_rgm_context = ICF_NULL;
    
    
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        
        /* Copy the ssa ctxt pointer locally */
        p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))
        
        /* Copy the rgm_context pointer locally */
        p_rgm_context = (icf_rgm_context_st *)(p_ssa_ctxt->p_rgm_ctxt);
        
        ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_rgm_context))
        
        
        
        /*
        * Initialize a Header
        */
        if (SipFail == (sip_initSipHeader(&pHeader, SipHdrTypeUnknown,&sip_err)))
        {
            ICF_PRINT(("\nFailed to initialize Auth Header"));
            
            return ICF_FAILURE;
        }
        /* Inserting the Header name in the unknown Header */
        Sdf_mc_strdup(pHdrName,"Authorization");
        
        if ( ICF_NULL == pHdrName )
        {
            sip_freeSipHeader(pHeader);
            return ICF_FAILURE;
        }
        
        if (sip_setNameInUnknownHdr(pHeader,pHdrName,&sip_err) == SipFail)
        {
            ICF_PRINT(("\nFailed to Set name"));
            sip_freeSipHeader(pHeader);
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                pHdrName,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
                
                return ICF_FAILURE;
        }
        
        /* building the Header Body 
        pFixdBody = "Digest Username=";*/
        
        
        
        ICF_CRM_START
            /* For ICF */
            /* building the Header Body */
            
            pFixdBody = "Digest username=\"";
        
        pRealm = "\",realm=\"";
        pNonce = "\",nonce=\"";
        pUri = "\",uri=\"";
        pResponse = "\",response=\"\"";
        
        

            
            /*Calculating Name string length minus NULL char at the end*/
            
            usr_name_sz = Sdf_mc_strlen(p_ssa_pdb->p_line_data->\
            authentication_key.str);
        

            
            realm_size = Sdf_mc_strlen(p_rgm_context->auth_data_sent.realm.str);
        uri_size = Sdf_mc_strlen(p_rgm_context->auth_data_sent.uri.str);

            
            
            /* This is the old IMS_CLIENT */
            
            /*Calculating total body length including "double-quotes"
            HdrBodyLen = Sdf_mc_strlen(pFixdBody) + usr_name_sz + 2;*/
            
            /* For ICF Rel 3_0_0 */
            
            
            ICF_CRM_START
            
            /*Calculating total body length */
            HdrBodyLen = Sdf_mc_strlen(pFixdBody) + 
            Sdf_mc_strlen(pRealm) + 
            Sdf_mc_strlen(pNonce) + 
            Sdf_mc_strlen(pUri) + 
            Sdf_mc_strlen(pResponse) +
            usr_name_sz + realm_size + uri_size+1;
        
        ICF_CRM_END
            
            
            
            ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            HdrBodyLen+1,
            ICF_MEM_COMMON,
            p_body,
            ICF_DONOT_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val)
            if (ICF_FAILURE == ret_val)
            {
               sip_freeSipHeader(pHeader);   
               return ICF_FAILURE;
            }
            
            icf_port_strcpy(p_body, pFixdBody);
        
        
        /*icf_port_strcat(p_body, "\"");*/
        
        
        icf_port_strcat(p_body, p_ssa_pdb->p_line_data->\
            authentication_key.str);
        
        
        /*icf_port_strcat(p_body, "\"");*/
        
        
        
            /* New parameters being appended to the authorization header */
            
            /* Append Realm  */
            icf_port_strcat(p_body, pRealm);
        icf_port_strcat(p_body, p_rgm_context->auth_data_sent.realm.str);
            
        
        /* Append Nonce  */
        icf_port_strcat(p_body, pNonce);
        
        /* Append URI */
        icf_port_strcat(p_body, pUri);
        icf_port_strcat(p_body, p_rgm_context->auth_data_sent.uri.str);
            
        
        /* Append Response  */
        icf_port_strcat(p_body, pResponse);
        
        

            /* Preparing the Message Body */
            
            if (sip_setBodyInUnknownHdr(pHeader,p_body,&sip_err) == SipFail)
            {
                ICF_PRINT(("\nFailed to set body"));
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_body,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
                    sip_freeSipHeader(pHeader);
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,pHeader,\
                    ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
                    
                    ret_val = ICF_FAILURE;
            }
            
            else if (ICF_FAILURE == sip_insertHeaderAtIndex(
                p_sip_msg, pHeader,0, &sip_err))
            {
                
                sip_freeSipHeader(pHeader);
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,pHeader,\
                    ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)

                ret_val = ICF_FAILURE;
                    
                    
            }
            else
            {
                sip_freeSipHeader(pHeader);
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,pHeader,\
                    ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
            }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;

            
            
            
}/* function icf_ssa_make_ims_auth_hdr() ends here */
#endif


/*******************************************************************************
 * FUNCTION:        icf_ssa_add_rgm_app_data
 *
 * DESCRIPTION:     This function adds the app related data: hdr/ tag/ msg list
 *                  to the overlap transaction: In case of REGISTER message
 *
 ******************************************************************************/
 icf_return_t        icf_ssa_add_rgm_app_data(
     INOUT     icf_ssa_pdb_st                    *p_ssa_pdb,
     INOUT     Sdf_st_overlapTransInfo             *p_overlap_trans_info)
 {
     
     icf_return_t                     ret_val = ICF_SUCCESS;
     icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;

     icf_rgm_context_st        *p_rgm_context = ICF_NULL;
     icf_uint16_t                loop_app = ICF_NULL;
     icf_header_list_st        *p_hdr_list = ICF_NULL;
     icf_tag_list_st            *p_tag_list = ICF_NULL;
     icf_msg_body_list_st        *p_msg_list = ICF_NULL;
     
     
     
     ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
         
    /* Copy the ssa ctxt pointer locally */
     p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
     ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))
         
    /* Copy the rgm_context pointer locally */
    p_rgm_context = (icf_rgm_context_st *)(p_ssa_ctxt->p_rgm_ctxt);
         
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_rgm_context))

    /* here the tags from the mandatory headers will be removed */
    if (ICF_FAILURE == icf_ssa_rgm_remove_tags(p_ssa_pdb,
                                    p_overlap_trans_info->pSipMsg))
    {
        ret_val = ICF_FAILURE;
    }

         
    else

    {/* tag removal success: starts */
         
    /* To add the additional tags/headers/msg_body to REGISTER 
     * as received from the application data */
         
     /* Loop for all the applications in rgm_context 
     * for the entries with is_valid as TRUE */
         
         
     for (loop_app = 0; loop_app < p_ssa_pdb->p_glb_cfg_data->max_applications ;
                            loop_app++)
     {
         if (ICF_FALSE == p_rgm_context->p_app_data_list[
             loop_app].is_valid)
             continue;
         
         /* for loop_app begins */
         if (ICF_HDR_LIST_PRESENT & p_rgm_context->
             p_app_data_list[loop_app].bitmask)
             
         {
             /* Header list present: Insert: begin */
             p_hdr_list = &(p_rgm_context->p_app_data_list[
                 loop_app].header_list);
             if ((ICF_FAILURE == ret_val)||
                 (ICF_FAILURE ==
                 icf_ssa_insert_header_list_in_sip_msg(
                 p_ssa_pdb,p_hdr_list,
                 ICF_FALSE,
                 p_overlap_trans_info->pSipMsg)))
                 
             {
                 /* Error during addition of header list */
                 ret_val = ICF_FAILURE;
             }
             
         }/* Header list present: Insert: end */
         
         
         if (ICF_TAG_LIST_PRESENT & p_rgm_context->
             p_app_data_list[loop_app].bitmask)
         {
             /* Tag list present: Insert: begin */
             p_tag_list = &(p_rgm_context->p_app_data_list[
                 loop_app].tag_list);
             if ((ICF_FAILURE == ret_val)||
                 (ICF_FAILURE ==
                 icf_ssa_insert_tag_list_in_sip_msg(
                 p_ssa_pdb,p_tag_list,
                 ICF_FALSE,
                 p_overlap_trans_info->pSipMsg)))
             {
                 /* Error during addition of tag list */
                 ret_val = ICF_FAILURE;
             }
         }/* Tag list present: Insert: end */
         
         if (ICF_BODY_LIST_PRESENT & p_rgm_context->
             p_app_data_list[loop_app].bitmask)
         {
             Sdf_st_error   sdf_error;

             /* Msg_body list present: Insert: begin */
             p_msg_list = &(p_rgm_context->p_app_data_list[
                 loop_app].body_list);
             if ((ICF_FAILURE == ret_val)||
                 (ICF_FAILURE ==
                 icf_ssa_insert_body_list_in_sdf_list(
                 p_ssa_pdb,p_msg_list,
                 ICF_FALSE,
                 &(p_overlap_trans_info->slMsgBodyList))))
             {
                 /* Error during addition of msg_body list */
                 ret_val = ICF_FAILURE;
             }
            /*Message body header changes Start*/
            else if (ICF_FAILURE == icf_ssa_SetAllMsgBody(\
                Sdf_co_null, p_overlap_trans_info,\
                (icf_int8_t *)p_msg_list->content_type.str,&sdf_error))
            {
                
                ret_val = ICF_FAILURE;
            }
         }/* Msg_body list present: Insert: end */
         
         
     }/* for loop_app Ends */
    
    }/* tag removal success: ends */


     ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;

         
}/* icf_ssa_add_rgm_app_data() ends here */

/*******************************************************************************
 * FUNCTION:        icf_ssa_fill_uac_auth
 *
 * DESCRIPTION:     This function fills the UAC auth info member using
 *                  auth_sent member of rgm_context
 *
 ******************************************************************************/
 icf_return_t icf_ssa_fill_uac_auth(
            INOUT    icf_ssa_pdb_st                *p_ssa_pdb,
            INOUT     Sdf_st_uacAuthInfo              *p_uac_auth_info)
 {
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;
    icf_string_st                    temp_nc;
    icf_rgm_context_st               *p_rgm_context = ICF_NULL;
    Sdf_ty_u32bit                    new_cnonce_int = 0;
    icf_string_st			         authentication_key,
                                     authentication_password;   
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))

    /* Copy the rgm_context pointer locally */
    p_rgm_context = (icf_rgm_context_st *)(p_ssa_ctxt->p_rgm_ctxt);
         
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_rgm_context))
    /* Fixed for SPR 16051: Here we fetch the credentials 
	   from either the user_db coress to rgm_user_address 
	   or from line data depending on the opetion PA has
	   selected */
	if(ICF_FAILURE == icf_cmn_get_auth_params(
			        p_ssa_pdb->p_glb_pdb, 
				&p_rgm_context->rgm_user_address,
				p_ssa_pdb->p_line_data->line_id,
				&authentication_key,
				&authentication_password))
	{
		ret_val = ICF_FAILURE;
		return ret_val;
	}
     
     /* Set UserName  */
     Sdf_mc_strdup(
         p_uac_auth_info->pUserName, 
         authentication_key.str);

         if (ICF_IMS_AUTH_OPTION == p_ssa_pdb->p_glb_cfg_data->auth_type)
         {/* IMS option begins */

             /* QoP, Cnonce and NonceCount are kept as Sdf_co_null */
             p_uac_auth_info->pQop = Sdf_co_null;
             p_uac_auth_info->pCnonce = Sdf_co_null;
             p_uac_auth_info->pNonceCount = Sdf_co_null;


             if (ICF_AUTH_RES_PRESENT &
                 p_rgm_context->auth_data_sent.auth_data_present)
             {
                 /* Set the RES received into the UAC auth Info */
                 Sdf_mc_strdup(
                     p_uac_auth_info->pPassword,
                     p_rgm_context->auth_data_sent.res.str);
             }
             else
             {
                 /* Set the password as null into the UAC auth Info */
                 p_uac_auth_info->pPassword = Sdf_co_null;
                 
             }
             
         }/* IMS option ends */
         else
         {
             /* ICF_NONIMS_AUTH_OPTION */
             Sdf_mc_strdup(
                 p_uac_auth_info->pPassword,
                    authentication_password.str);
             
             /* Initializing the QoP, Cnonce and NonceCount as Sdf_co_null */
             p_uac_auth_info->pQop = Sdf_co_null;
             p_uac_auth_info->pCnonce = Sdf_co_null;
             p_uac_auth_info->pNonceCount = Sdf_co_null;
             
             if (ICF_AUTH_QOP_PRESENT &
                 p_rgm_context->auth_data_sent.auth_data_present)
             {
             /*********** QoP ****************/
             /* Qop was received in 401 and 
              * client_nonce has some non_null value:
              * cnonce is MUST to be sent when QoP received */
                 
                 Sdf_mc_strdup(
                     p_uac_auth_info->pQop,
                     p_rgm_context->auth_data_sent.qop.str);
             
                /*********** cnonce ****************/
                /* For every challenge, the value of cnonce will be generated 
                 * afresh and also saved in rgm_ctxt->auth_data_sent */
                if (ICF_REQ_AGAIN_AFTER_CHALLENGE & p_rgm_context->indicator)
                {
                    /* Clear the previous value from rgm_ctxt */
                    icf_port_memset(
                        &(p_rgm_context->auth_data_sent.cnonce),
                        0,
                        ICF_PORT_SIZEOF(icf_string_st));

                    /* Generate a fresh value */
                    if (Sdf_co_fail == 
                          sdf_fn_uaGetCurrentTimeInMicroSecs(&new_cnonce_int))
                    {
                        ret_val = ICF_FAILURE;
                        return ret_val;
                    }

                    /* Save the fresh value in rgm_ctxt */
                    icf_port_sprintf((icf_int8_t *)p_rgm_context->auth_data_sent.cnonce.str,
                    (icf_int8_t *)"%u", new_cnonce_int);
                    p_rgm_context->auth_data_sent.cnonce.str_len =
                     (icf_uint16_t)icf_port_strlen(p_rgm_context->auth_data_sent.cnonce.str);
                    p_rgm_context->auth_data_sent.auth_data_present |=
                     ICF_AUTH_CNONCE_PRESENT;

                    /* reset the indicator bit till next challenge */
                    ICF_RESET_BIT(p_rgm_context->indicator,
                        ICF_REQ_AGAIN_AFTER_CHALLENGE);
                }

             if (ICF_AUTH_CNONCE_PRESENT &
                 p_rgm_context->auth_data_sent.auth_data_present)
             {
                 
                 /* cNonce is picked from rgm_context */
                 Sdf_mc_strdup(
                     p_uac_auth_info->pCnonce,
                     p_rgm_context->auth_data_sent.cnonce.str);

                /* save this value for sending in Re-reg or De-reg */
                 icf_port_memcpy(
                        &p_rgm_context->client_nonce,
                        &p_rgm_context->auth_data_sent.cnonce,
                        ICF_PORT_SIZEOF(icf_string_st));
               }

                /*********** Nonce-count/nc ****************/
             if (ICF_AUTH_NC_PRESENT &
                 p_rgm_context->auth_data_sent.auth_data_present)
             {
                 temp_nc.str_len = 0;
                 /* Convert the nonce_count to string */
                 icf_ssa_compute_nc(p_ssa_pdb->p_glb_pdb,
                     p_ssa_ctxt, &temp_nc, 
                     p_rgm_context->auth_data_sent.nonce_count,
                     p_ssa_pdb->p_ecode);
                 
                 /* increment the value for sending in next request */
                 (p_rgm_context->auth_data_sent.nonce_count)++;
                      
                 if (temp_nc.str_len)
                 {
                     Sdf_mc_strdup(
                         p_uac_auth_info->pNonceCount,
                         temp_nc.str);
                 }
             }/* Nonce count present */

             }/* QoP received: ends */
             else
             {
                 /* No qop: nothing to do */
             }
             
         }/* non IMS*/ 
         
     ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;             
             
}/* Function icf_ssa_fill_uac_auth() ends here */

/*******************************************************************************
 * FUNCTION:        icf_ssa_chk_n_append_auts
 *
 * DESCRIPTION:     This function appends the AUTS parameter to Authorization header 
 *                    if it is present in the IMS scenario.
 *
 ******************************************************************************/
icf_return_t icf_ssa_chk_n_append_auts(
            INOUT    icf_ssa_pdb_st                    *p_ssa_pdb,
            INOUT     Sdf_st_overlapTransInfo             *p_overlap_trans_info)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;
    icf_rgm_context_st                *p_rgm_context = ICF_NULL;
    icf_string_st                    encoded_auts, auth_param;
   
    SipMessage*                            p_sip_msg;
    SipParam*                            p_sip_param = SIP_NULL;
    SipError                            sip_err;
    Sdf_ty_u32bit                        count=0;
    icf_int8_t*                        p_auts_value = ICF_NULL;
    
    SipHeader                            dHeader;
    
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))

    /* Copy the rgm_context pointer locally */
    p_rgm_context = (icf_rgm_context_st *)(p_ssa_ctxt->p_rgm_ctxt);

    /* Copy the Sip Message locally */
     p_sip_msg = p_overlap_trans_info->pSipMsg;
         
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_rgm_context))

    icf_port_memset((icf_void_t *)(&encoded_auts), 0,
                            ICF_PORT_SIZEOF(icf_string_st));

    icf_port_memset((icf_void_t *)(&auth_param), 0,
                            ICF_PORT_SIZEOF(icf_string_st));

    if (ICF_IMS_AUTH_OPTION == p_ssa_pdb->p_glb_cfg_data->auth_type)
    {
        if ((ICF_AUTH_RES_PRESENT & 
            p_rgm_context->auth_data_sent.auth_data_present) &&
            (ICF_AUTH_AUTS_PRESENT & 
            p_rgm_context->auth_data_sent.auth_data_present))
        {
            /* both the bits cannot be set: failure*/
            ret_val = ICF_FAILURE;
        }
        else if(ICF_AUTH_AUTS_PRESENT & 
            p_rgm_context->auth_data_sent.auth_data_present)
        {
            /* encode base 64: auth_data_sent.auts */

            encodeBase64((icf_int8_t *)p_rgm_context->auth_data_sent.auts.str,
                            (icf_int8_t *)encoded_auts.str);
            encoded_auts.str_len = (icf_uint16_t)icf_port_strlen((icf_uint8_t *)encoded_auts.str);
            icf_port_strcpy(auth_param.str, (icf_uint8_t *)"\"");
            icf_port_strcat(auth_param.str, encoded_auts.str);
            icf_port_strcat(auth_param.str, (icf_uint8_t *)"\"");
            
			/*Fix done for SPR-18722 : CSR-1-6068965*/
            Sdf_mc_strdup(p_auts_value,(icf_int8_t *) auth_param.str);

            if (SipFail == sip_initSipParam(&p_sip_param, &sip_err))
            {
                ret_val = ICF_FAILURE;
            }
            else if (SipFail == sip_listInit(&(p_sip_param->slValue),0,&sip_err))
            {
                ret_val = ICF_FAILURE;

            }
            else if (SipFail == sip_listInsertAt(&(p_sip_param->slValue), 0,
                        (icf_void_t *)(p_auts_value),&sip_err))
            {
                ret_val = ICF_FAILURE;
            }

            else 
            {                
                icf_port_strcpy(auth_param.str,(icf_uint8_t *)"auts");
                auth_param.str_len = (icf_uint16_t)icf_port_strlen((icf_uint8_t *)auth_param.str);

                ICF_MEMGET(
                    p_ssa_pdb->p_glb_pdb,
                    auth_param.str_len + 1,
                    ICF_MEM_COMMON,
                    p_sip_param->pName,
                    ICF_DONOT_RET_ON_FAILURE,
                    p_ssa_pdb->p_ecode,
                    ret_val)
                if (ICF_FAILURE == ret_val)
                {
                   ICF_MEMFREE(
                       p_ssa_pdb->p_glb_pdb,
                       p_sip_param,
                       ICF_MEM_COMMON,
                       p_ssa_pdb->p_ecode,
                       ret_val)
                    return ICF_FAILURE;
                }
                                
                icf_port_strcpy((icf_uint8_t *)p_sip_param->pName, (icf_uint8_t *)auth_param.str);

                if(SipFail == sip_getHeaderCount(p_sip_msg, SipHdrTypeAuthorization, &count, &sip_err))
                
                {
                ret_val = ICF_FAILURE ;
            }
            
            /* If multiple headers of same type is found, we choose the first header
            * index 0 and insert the tags to that header,*/
                else if(SipFail == sip_getHeaderAtIndex(p_sip_msg, 
                SipHdrTypeAuthorization, &dHeader, 0, &sip_err))
                {
                    ret_val = ICF_FAILURE;
                }
                else if (SipFail == sip_insertParamAtIndexInAuthorizationHdr(
                                        &dHeader,p_sip_param,0,&sip_err))  
                {
                    sip_freeSipHeader(&dHeader);
                    ret_val = ICF_FAILURE;

                }
                else
                {                
                    sip_freeSipHeader(&dHeader);
                }
            }                
        
                 
        }/* AUTS present: ends */
        else
        {
            /* Nothing to be done: RES already handled */
        }

    }/* IMS scenrio: ends */

     ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;             

}/* Function icf_ssa_chk_n_append_auts() ends here */

/*******************************************************************************
 * FUNCTION:        icf_ssa_make_contact_of_app_data
 *
 * DESCRIPTION:     This function creates a contact header using the app_data
 *
 * RETURNS            SUCCESS: Contact header created successfully
 *                    FAILURE:
 *
 ******************************************************************************/
icf_return_t     icf_ssa_make_contact_of_app_data(
            INOUT        icf_ssa_pdb_st       *p_ssa_pdb,
            INOUT         icf_rgm_app_ctxt_st    *p_app_data,
            INOUT         SipHeader               **p_p_contact_hdr,
            OUT            icf_error_t            *p_ecode)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    SipError            sip_err;
    SipContactHeader    *p_contact_hdr = ICF_NULL;
    Sdf_ty_s8bit        contact_addr[ICF_MAX_STR_LEN] = "\0";
#ifdef IMS_CLIENT
    Sdf_ty_s8bit        app[ICF_MAX_STR_LEN] = "\0";
#endif

#ifdef ICF_NAT_RPORT_SUPPORT
    icf_rport_config_data_st            *p_rport_config_data = ICF_NULL;
#endif
    icf_uint8_t        str_duration[ICF_MAX_STR_LEN] = "\0";
    icf_glb_pdb_st               *p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    icf_config_data_st           *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    Sdf_st_error                    Error;  
    icf_uint16_t                 port_num = 0;
    icf_uint32_t                    duration = ICF_NULL;
    icf_tag_st                    temp_tag;
    icf_address_st               *p_user_address = ICF_NULL;
        icf_transport_address_st     *p_contact_address = ICF_NULL;
    icf_uint8_t                    *p_temp = ICF_NULL;
        icf_transport_address_st    self_addr;
    
        /* To Remove Warnings */
        p_ecode=p_ecode;
        ICF_SSA_INIT_TRANS_ADDR(&self_addr)
    
     /*If per line self transport then copy address from line_data*/
       if (ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
       {
           icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                           sizeof(icf_transport_address_st));
#ifdef ICF_NAT_RPORT_SUPPORT
           p_rport_config_data = p_ssa_pdb->p_line_data->p_rport_config_data;
#endif
       }
       else
       {
           icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                           sizeof(icf_transport_address_st));
#ifdef ICF_NAT_RPORT_SUPPORT
            p_rport_config_data = &(p_glb_cfg_data->rport_config_data);
#endif
       }
    
#ifdef ICF_NAT_RPORT_SUPPORT
    if(ICF_TRUE == p_rport_config_data->is_rport_reqd)
    {
        p_contact_address = &(p_rport_config_data->contact_ip_addr);
    }
    else
    {
        p_contact_address = &(self_addr);
        
    }    
#else
    p_contact_address = &(self_addr);

#endif



    if(ICF_APP_ID_INVALID == p_app_data->app_id)
    {
        return ICF_FAILURE;
    }
    if (sip_initSipHeader(p_p_contact_hdr, SipHdrTypeContactNormal, \
                        &(sip_err)) == SipFail)
    {
        return ICF_FAILURE;
    }
    p_contact_hdr = (SipContactHeader *) ((*p_p_contact_hdr)->pHeader);

    /* Making of contact header For application */
    /*
          Username = app_appid;
          Addr_spec = sip uri;
          IP, Port from global data.*/
            
    /* Make the contact address */
    /* expires=value in each contact header */
    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt)
    {
    duration = (p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->rgm_duration/1000);
    
    /* To add expires tag in Contact header */
    icf_port_memset((icf_void_t *)(&temp_tag),
        0, ICF_PORT_SIZEOF(icf_tag_st));
    
    icf_port_strcpy(temp_tag.hdr_name.str,
        (icf_uint8_t *)"Contact");
    temp_tag.hdr_name.str_len = 
        (icf_uint16_t)icf_port_strlen(
        temp_tag.hdr_name.str);
    
    icf_port_strcpy(temp_tag.tag_value.str,
        (icf_uint8_t *)"expires=");
    icf_port_sprintf((icf_int8_t *)str_duration,"%d",duration);
    icf_port_strcat(temp_tag.tag_value.str,
        str_duration);
    icf_port_strcat(temp_tag.tag_value.str,
        (icf_uint8_t *)" ");
    
    temp_tag.tag_value.str_len = 
        (icf_uint16_t)icf_port_strlen(
        temp_tag.tag_value.str);
    
    temp_tag.next = ICF_NULL;
    }    
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_TRUE)
/* Start: Multiple Public Users ICF5.0*/

    /* the contact shall be in the format %s_%d@ip where %s is the 
     * user address and %d is the app_id*/

    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt)
    {
        /* The userId in Contact header should be the userid configured through 
         * set_line_params api. If this is not configured, then the userid part
         * of From header should be used.
         */
        p_user_address = &(p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->rgm_user_address);
        if (ICF_NULL != p_ssa_pdb->p_line_data->contact_user_info.str_len)
        {
            icf_port_strcpy(contact_addr, 
                p_ssa_pdb->p_line_data->contact_user_info.str);
        }
        else
        {
            icf_port_strcpy(contact_addr,p_user_address->addr_val.str);
        }

        if (( ICF_ADDRESS_PLAN_SIP_URI == p_user_address->addr_type) ||
                        (ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type))
        {
            p_temp = icf_port_strchr(contact_addr,'@');
            if(ICF_NULL != p_temp)
            {
                *p_temp = '\0';
            }
            icf_port_sprintf(app,"_%d@",p_app_data->app_id);
            icf_port_strcat(contact_addr,app);
        }
        /*
         * If the address type is SIP URI ,then we will
         * extract the userid from the SIP URI and then 
         * append the self IP address and port in order
         * to form the contact header
         */
        else if((ICF_ADDRESS_PLAN_TEL_URI == p_user_address->addr_type)||
            (ICF_ADDRESS_PLAN_E164 == p_user_address->addr_type))
        {
            icf_port_sprintf(app,"_%d@",p_app_data->app_id);
            icf_port_strcat(contact_addr,app);
        }
        else
        {
            contact_addr[0]='\0';
        }
    }
/* End: Multiple Public Users ICF5.0*/
ICF_CHECK_IMS_END
#endif
#ifdef NON_IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_FALSE)
    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt)
    {
        p_user_address = &(p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->rgm_user_address);
        icf_port_strcpy((icf_uint8_t *)contact_addr,(icf_uint8_t *)p_user_address->addr_val.str);

        if ( ICF_ADDRESS_PLAN_E164 ==
                p_user_address->addr_type)
        {
            icf_port_strcat((icf_uint8_t *)contact_addr,(icf_uint8_t *)"@");
        }
        /*
         * If the address type is SIP URI ,then we will
         * extract the userid from the SIP URI and then 
         * append the self IP address and port in order
         * to form the contact header
         */

        else if (( ICF_ADDRESS_PLAN_SIP_URI ==
                                p_user_address->addr_type )||
                         ( ICF_ADDRESS_PLAN_SIPS_URI ==
                                p_user_address->addr_type ))
        {
            p_temp = icf_port_strchr((icf_uint8_t *)contact_addr,(icf_uint8_t)'@');
            if(ICF_NULL != p_temp)
            {
             *p_temp = '\0';
            }
            icf_port_strcat((icf_uint8_t *)contact_addr,(icf_uint8_t *)"@");
        }
        else
        {
            contact_addr[0]='\0';
        }
    }
ICF_CHECK_IMS_END
#endif

    if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
        self_addr.addr.addr_type)
    {
        icf_port_strcat((icf_uint8_t *)contact_addr,
            (icf_uint8_t *)self_addr.addr.addr.domain.str);

    }
    else 
    {
#ifdef ICF_IPV6_ENABLED
        icf_uint8_t remote_ip[ICF_MAX_IPV6_ADDRESS_LENGTH] = {'\0'};
#else
        icf_uint8_t remote_ip[32] = {'\0'};
#endif
        
        if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
            p_contact_address,remote_ip))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            icf_port_strcat((icf_uint8_t *)contact_addr, (icf_uint8_t *)remote_ip);
        }
    }

    if(ICF_NULL == p_user_address)
        return ICF_FAILURE;
    
#ifdef ICF_IPSEC_ENABLED
    if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
    {
        icf_ipsec_sa_context_st              *p_sa_context = ICF_NULL;

        p_sa_context = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;

        /* check is SA exists */
        if (ICF_NULL != p_sa_context)
        {
            port_num = p_sa_context->p_ue_security_params->port_s;
        }
        else

        {
            port_num = p_contact_address->port_num;
        }
    }
    else
#endif
    {
        if (ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type)
        {
            port_num = p_glb_cfg_data->p_tls_init_data->tls_sip_serv_port_num;
        }
        else
        {
            port_num = p_contact_address->port_num;
        }   
     }
     if (sdf_ivk_uaMakeAddrSpecFromConstituents(&(p_contact_hdr->pAddrSpec), contact_addr,
                                port_num,
                                (ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type)?"sips":"sip",
                                &Error) == Sdf_co_fail)
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        /* Adding the expires=value tag in contact header*/
        Sdf_ty_slist        s_list;
        
        if (sdf_listInit(&s_list, __sdf_fn_uaFreeString, Sdf_co_false, &Error)             
            == Sdf_co_fail)
        {
            ret_val = ICF_FAILURE ;
        }
        else if (sdf_ivk_uaInsertHeaderParam(*p_p_contact_hdr, 
            (icf_int8_t *)temp_tag.tag_value.str,  
            &s_list, 0, &Error) == Sdf_co_fail)
        {
            ret_val = ICF_FAILURE ;
            sdf_listDeleteAll(&s_list, &Error);
        
        }
        sdf_listDeleteAll(&s_list, &Error);

        if (ICF_TRUE == 
            ICF_IS_BIT_SET(p_app_data->bitmask,ICF_TAG_LIST_PRESENT ) &&
            ICF_TRUE == 
             ICF_IS_BIT_SET(p_app_data->bitmask,ICF_TAGS_REFRESHED))
        {
            /* Insert Application specific Contact Header tags to contact header */
            
            icf_uint16_t list_count = (icf_uint16_t)p_app_data->tag_list.count;
            icf_tag_st   *p_tag = p_app_data->tag_list.tag;
            en_HeaderType   hdr_type = 0;
            /*
            Loop on the tag list of the application
            {
            if (hdr_name == contact) then 
            add value to the ParamaList of the contact Header.


            } Loop on tag list ends 
            */
            while (list_count > 0 && ICF_NULL != p_tag) 
            {
                /* Check whether tag is for Contact header or not*/
                SipError err;
                icf_ssa_get_hdr_type_from_name(p_tag->hdr_name.str, &hdr_type, &err);
                
                if((hdr_type == SipHdrTypeContactNormal)   ||
                   (hdr_type == SipHdrTypeContactWildCard) ||
                   (hdr_type == SipHdrTypeContactAny))
                {
                    if ( p_tag->tag_type & ICF_TAG_TYPE_SIP_URI_PARAM)
                    {
                        icf_ssa_append_sip_uri_param_in_sip_hdr(
                            p_ssa_pdb,p_tag->tag_value.str,*p_p_contact_hdr);
                        
                    }
                    else if ( p_tag->tag_type & ICF_TAG_TYPE_SIP_URI_HDR_PARAM)
                    {
                        icf_ssa_append_sip_uri_hdr_param_in_sip_hdr(
                            p_ssa_pdb,p_tag->tag_value.str,*p_p_contact_hdr);
                    }
                    else if ( p_tag->tag_type & ICF_TAG_TYPE_HDR_PARAM)
                    {
                        Sdf_ty_slist        sList;

                        if(sdf_listInit(&sList, __sdf_fn_uaFreeString, Sdf_co_false, &Error)             
                            == Sdf_co_fail)
                        {
                            ret_val = ICF_FAILURE ;
                        }
                        /* instead of sending a list of values
                        * corresponding to a tag in a list we send the entire tag=value portion
                        * as a string to InsertHeaderParam, thus the second argument.
                        */
                        
                        else if (sdf_ivk_uaInsertHeaderParam(*p_p_contact_hdr, 
                            (icf_int8_t *)p_tag->tag_value.str,  
                            &sList, 0, &Error) == Sdf_co_fail)
                        {
                            ret_val = ICF_FAILURE ;
                            sdf_listDeleteAll(&sList, &Error);
                            break;
                        }
                        sdf_listDeleteAll(&sList, &Error);
                    }
                    else
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Ignoring Invalid Tag Type\n"));
                    }
                }
                list_count = (icf_uint16_t)(list_count - 1);
                p_tag = p_tag->next;
            }
        }/* Tag list present: Insert: end */
    }

    if(ICF_SUCCESS == ret_val)
    {
        icf_address_st  temp_addr;

        if ( ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type)
        {
            temp_addr.addr_type = ICF_ADDRESS_PLAN_SIPS_URI;
        }
        else
        {
            temp_addr.addr_type = ICF_ADDRESS_PLAN_SIP_URI;
        }

        if('\0' != contact_addr[0])
        {
            icf_port_strcpy(temp_addr.addr_val.str,(icf_uint8_t *)contact_addr);
            temp_addr.addr_val.str_len = (icf_uint16_t)icf_port_strlen(temp_addr.addr_val.str);

            if(ICF_FAILURE == icf_dbm_append_uri_to_address_list(
                        p_ssa_pdb->p_glb_pdb,
                        &temp_addr,
                        &(p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->p_contact_uri_list),
                        p_ssa_pdb->p_ecode))
            {
                ret_val = ICF_FAILURE;
            }
        }
    }
    return ret_val;
}/* Function icf_ssa_make_contact_of_app_data() ends here */

/*******************************************************************************
 * FUNCTION:        icf_ssa_make_contact_list_for_reg
 *
 * DESCRIPTION:     This function makes contact list for Register request
 *                  
 ******************************************************************************/

icf_return_t icf_ssa_make_contact_list_for_reg(
     INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
     INOUT    Sdf_ty_slist              *p_contact_addr_list)
{
    icf_return_t                   ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st                *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    icf_rgm_context_st             *p_rgm_ctxt = p_ssa_ctxt->p_rgm_ctxt;
    icf_uint8_t                    loop_app=0;
    SipHeader                      *p_contact_hdr = ICF_NULL;
    Sdf_st_error                   SdfError;
    Sdf_st_error                   sdf_error;
    if (ICF_NULL != p_rgm_ctxt->p_contact_uri_list)
    {
        /* free the contact list */
        icf_dbm_delete_address_list(p_ssa_pdb->p_glb_pdb,
            &(p_rgm_ctxt->p_contact_uri_list),
            p_ssa_pdb->p_ecode);
        p_rgm_ctxt->p_contact_uri_list = ICF_NULL;
    }

    if (ICF_TRUE == p_rgm_ctxt->auto_reg_flag)
    {
        /* Make Dummy contact address for Auto Register */
        icf_rgm_app_ctxt_st         dummy_app_ctxt;
        icf_port_memset((icf_void_t*)&dummy_app_ctxt,0,sizeof(icf_rgm_app_ctxt_st));
        dummy_app_ctxt.app_id = ICF_DUMMY_APP_ID;
        if(ICF_FAILURE == icf_ssa_make_contact_of_app_data(p_ssa_pdb,
                                                           &dummy_app_ctxt,
                                                           &p_contact_hdr,
                                                           p_ssa_pdb->p_ecode))
        {
                ret_val = ICF_FAILURE;
        }
        else
        {
            /* Got a valid Contact Header, Append to the List */
            if (sdf_listAppend(p_contact_addr_list, p_contact_hdr, &SdfError) == Sdf_co_fail)
            {
                ret_val = ICF_FAILURE;
            }
        }
    }
    if(ICF_SUCCESS == ret_val)
    {
        
        for(;loop_app<p_ssa_pdb->p_glb_cfg_data->max_applications;loop_app++)
        {
            icf_rgm_app_ctxt_st    *p_app_data =
                (icf_rgm_app_ctxt_st*)
                &(p_rgm_ctxt->p_app_data_list[loop_app]);
            
            if (ICF_FALSE == p_app_data->is_valid)
                continue;

            if (ICF_RGM_APP_DEREG_ON_PROBATION &
                    p_app_data->app_indicator)
                continue;
            
            if(ICF_FAILURE == 
                (ret_val = icf_ssa_make_contact_of_app_data(p_ssa_pdb,
                p_app_data,
                &p_contact_hdr,
                p_ssa_pdb->p_ecode)))
            {
                break;
            }
            else if(ICF_NULL != icf_port_strlen(p_ssa_pdb->trans_param))
            {
                if (ICF_FAILURE ==
                        icf_ssa_insert_param_in_addr_spec(
                            p_ssa_pdb, 
                            ((SipContactHeader*)
                             (p_contact_hdr->pHeader))->pAddrSpec,
                            (icf_uint8_t *)"transport",p_ssa_pdb->trans_param, &sdf_error))
                {
                    ret_val = ICF_FAILURE;
                    break;
                }
                icf_port_strcpy(p_ssa_pdb->trans_param,(icf_uint8_t *)"\0");
            }
            /* Got a valid Contact Header, Append to the List */
            if (sdf_listAppend(p_contact_addr_list, p_contact_hdr, &SdfError) == Sdf_co_fail)
            {
                ret_val = ICF_FAILURE;
                break;
            }

            
        }

#ifdef ICF_SIGCOMP_SUPPORT
        /* Check The Config data whether we are supporting 
        * sigcomp or not,If Yes then add comp=sigcomp param
        * in the contact header
        */
        if(ICF_TRUE == 
            p_glb_cfg_data->sigcomp_required)
        {
            Sdf_st_error  sdf_error;
            if(ICF_FAILURE == 
                icf_ssa_AddParamToContactHdrList(
                p_contact_addr_list,
                "comp=sigcomp",
                &sdf_error))
            {
            /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                *major ERROR*/
                ret_val = ICF_FAILURE;
            }
            
        }
        
#endif
    }
    return ret_val;
}     

/* Manually merged code for filter related things */

/*******************************************************************************
 * FUNCTION:        icf_ssa_match_string
 *
 * DESCRIPTION:     This function matches two strings based on the match_type  
 *                  given. Returns ICF_SUCCESS if the strings satisfy the 
 *                  match criteria, otherwise ICF_FAILURE is returned.
 *
 ******************************************************************************/

icf_return_t icf_ssa_match_string(
                                        INOUT icf_uint8_t *p_target, 
                                        INOUT icf_uint8_t *p_match_str, 
                                        INOUT icf_match_type_t match_type,
                                        OUT icf_boolean_t *p_match_success)
{
    icf_return_t ret_val = ICF_SUCCESS;
    *p_match_success = ICF_FALSE;
    switch(match_type)
    {
    case ICF_EXACT_STRING_MATCH :
        {
            if(0 == icf_port_strcmp(p_target,p_match_str))
                *p_match_success = ICF_TRUE;
            break;
        
        }
    case ICF_SUB_STRING_MATCH :
        {
            if(ICF_NULL != icf_port_strstr((const icf_int8_t *)p_target,(const icf_int8_t *)p_match_str))
                *p_match_success = ICF_TRUE;
            break;
        }
    default : break;
    }
    return ret_val;
}


/*******************************************************************************
 * FUNCTION:        icf_ssa_match_header_filter
 *
 * DESCRIPTION:     This function matches a SIP message against filters  
 *                  on Header Name and Header Content
 *
 ******************************************************************************/
icf_return_t icf_ssa_match_header_filter(
                                           INOUT  SipMessage            *p_sip_msg, /* Sip message */
                                           INOUT  icf_int_filter_st    *p_int_filter, /* Filter to be matched */
                                           OUT icf_boolean_t        *p_match,
                                           OUT icf_error_t        *p_ecode)
{
    icf_uint8_t i;
    icf_string_node_st *p_curr_node=ICF_NULL;
    en_HeaderType dType;
    SipError sip_err;
    icf_uint8_t *p_temp_buff,*p_remainingbuff,*p_token,*p_header_name;

    icf_boolean_t match_success = ICF_FALSE;
    icf_uint32_t dCount,temp_strlen;
    icf_uint8_t index;
    icf_return_t ret_val=ICF_SUCCESS;

    /* To remove warnings */
    p_ecode=p_ecode;

    p_temp_buff=p_remainingbuff=p_token=p_header_name=ICF_NULL;

    if(ICF_FILTER_BY_HEADER_CONTENT == p_int_filter->filter_type)
    {
        p_header_name = p_int_filter->target_header.str;
    }
    
    for(i=0,p_curr_node=p_int_filter->filter_expr.p_match_str_list;
        i<p_int_filter->filter_expr.count;
        i++,p_curr_node = (icf_string_node_st *)p_curr_node->p_next)
    {
        match_success = ICF_FALSE;
        if(ICF_FILTER_BY_HEADER_NAME == p_int_filter->filter_type)
        {
            p_header_name = p_curr_node->p_str;
        }

        /* get header type */
        icf_ssa_get_hdr_type_from_name(p_header_name, &dType, &sip_err);
        
        /* There can be multiple hdrs for that type */
        /* Get Header Count */
        if (SipFail == sip_getHeaderCount(p_sip_msg, dType, &dCount, \
            &sip_err))
        {
            return ICF_FAILURE;
        }
        
        /* Iterate through the list to get all headers of type dType */
        for(index = 0; ((index < dCount) && (ICF_FALSE == match_success)); index++)
        {
            
            /* Construct Header from SipMessage */
            if(SipFail == sip_getHeaderAsStringAtIndex(p_sip_msg,dType,((SIP_S8bit **)&p_temp_buff),\
                            index, &sip_err))
                return ICF_FAILURE;
            temp_strlen = icf_port_strlen(p_temp_buff);
            /* Tokenize the : separated string into hdr name/value.*/
            p_token = icf_port_strchr(p_temp_buff,':');
        
            if (ICF_NULL == p_token)
            {                    
                fast_memfree(0, p_temp_buff, &sip_err);
                return ICF_FAILURE;
            }

            *p_token = '\0';
            p_token ++;
            /*p_token = icf_port_strtok(p_temp_buff,":",&p_remainingbuff); */
            
            if(ICF_FILTER_BY_HEADER_CONTENT == p_int_filter->filter_type)
            {
                if(0 != icf_port_strcmp(p_temp_buff,p_header_name))
                {
                    fast_memfree(0, p_temp_buff, &sip_err);
                    continue;
                }
                            /* Remove Leading Spaces from header content*/
                while(icf_port_isspace(*p_token))
                    p_token++;

            }
            else
            {
                p_token = p_temp_buff;
            }

            /* Compare the header with the match string
            * If matches, allocate memory and store in call ctxt,
            * else continue with next header from list.
            */
            icf_ssa_match_string(
                p_token, 
                p_curr_node->p_str,
                p_int_filter->match_type,
                &match_success);

            /* free the memory allocated for p_temp_buff */
            fast_memfree(0, p_temp_buff, &sip_err);
            p_temp_buff = p_remainingbuff = ICF_NULL;
        }

        /* break if match_all is true and match_success is false 
           or match_all is false and match_success is true */
        if(match_success != p_int_filter->filter_expr.match_all)
            break;
    }
    *p_match = match_success;
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_match_req_line_filter
 *
 * DESCRIPTION:     This function matches a SIP message against filters  
 *                  on Request Line 
 *
 ******************************************************************************/

icf_return_t icf_ssa_match_req_line_filter(
                                              INOUT  SipMessage            *p_sip_msg,
                                              INOUT  icf_int_filter_st    *p_int_filter,
                                              OUT icf_boolean_t        *p_match,
                                              OUT icf_error_t        *p_ecode)
{
    icf_string_node_st *p_curr_node=ICF_NULL;
    icf_string_st target_str;
    icf_uint8_t i;
    icf_boolean_t match_success=ICF_FALSE;
    icf_return_t ret_val = ICF_SUCCESS;
     /* To remove warning */
     p_ecode=p_ecode;

    if( ICF_FAILURE == icf_ssa_get_reqline_as_string(p_sip_msg,target_str.str))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        for(i=0,p_curr_node=p_int_filter->filter_expr.p_match_str_list;
        i<p_int_filter->filter_expr.count;
        i++,p_curr_node = (icf_string_node_st *)p_curr_node->p_next)
        {    
            match_success = ICF_FALSE;
            icf_ssa_match_string(
                target_str.str,
                p_curr_node->p_str,
                p_int_filter->match_type,
                &match_success);
            if(match_success != p_int_filter->filter_expr.match_all)
                break;
        }
    }
    *p_match = match_success;
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_map_req_to_app_filter
 *
 * DESCRIPTION:     This function matches a SIP message against the application  
 *                  filter criteria to find out which application is the correct
 *                  one for handling the message. 
 *                  * The app id of first matching filter criteria is filled in 
 *                    p_app_id. 
 *                  * If none of the filters match then the default
 *                    application id is filled in p_app_id. 
 *                  * If none of the filters match and no default application is 
 *                    configured, then ICF_INVALID_APP_ID is filled in p_app_id.
 *
 ******************************************************************************/
icf_return_t icf_ssa_map_req_to_app_filter (
                                                  INOUT  icf_ssa_pdb_st *p_ssa_pdb,
                                                  INOUT  SipMessage        *p_sip_msg,
                                                  OUT icf_app_id_t   *p_app_id,
                                                  OUT icf_error_t    *p_ecode)
{
    
    icf_dbm_data_st    *p_dbm_data = ICF_NULL;
    icf_config_data_st *p_cfg_data = ICF_NULL;
    icf_app_conf_st    *p_app_conf = ICF_NULL;
    icf_app_id_t       forward_app_id,default_app_id ;
    icf_uint8_t        app_index;
    icf_boolean_t      match_success = ICF_FALSE;
    icf_return_t       ret_val = ICF_SUCCESS;
    SipReqLine            *pReqLine=ICF_NULL;
    SipAddrSpec           *p_addr_spec = ICF_NULL;
    SipError              sip_err;
    icf_uint8_t *p_start,*p_end,*p_target_str;
    icf_int8_t app_num_str[ICF_MAX_STR_LEN] = "";

    p_start = p_end = p_target_str = ICF_NULL;

    

    /* get dbm data for getting application data */
    if(ICF_FAILURE == icf_dbm_get_module_glb_data(
        p_ssa_pdb->p_glb_pdb ,
        (icf_int_module_id_t const)ICF_INT_MODULE_DBM,
        (icf_void_t *)&p_dbm_data,
        p_ecode))
    {
        return ICF_FAILURE;
    }
    
    /* get cfg data for getting the max number of applications*/
    if(ICF_FAILURE == icf_dbm_get_module_glb_data(     
        p_ssa_pdb->p_glb_pdb ,
        (icf_int_module_id_t const) ICF_INT_MODULE_CFG,
        (icf_void_t *)&p_cfg_data,
        p_ecode))
    {
        return ICF_FAILURE;
    }

    
    p_app_conf = p_dbm_data->p_app_conf;
    forward_app_id = default_app_id = ICF_INVALID_APP_ID;

    /* First - check the request line and extract user name
       If username is in the format of APP_xx, match the 
       message only with app-id xx */

    /* Get the user name from the message */
    if (SipFail == sip_getReqLineFromSipReqMsg(p_sip_msg,
                &pReqLine,&sip_err))
    {
        return ICF_FAILURE;
    }

#ifdef ICF_WITH_MUATK_2_2
    p_addr_spec = pReqLine->pAddrSpec;
#else
    p_addr_spec = pReqLine->pRequestUri;
#endif
    

    /*********************************************************************
    
    The code below tries to extract the application id
    for requests coming on the application contact. 
    if the user name in the request uri ends with "_n" where n is a number
    we first try to match the filter of the application n.
    This will override the normal sequential filter matching mechanism
    where the filters are matched in the order in which the applications
    are added. 
    This code can fail in a scenario where the username is not a contact 
    address but has a similar format and more than 1 application has the
    same filter criteria.
    ************************************************************************/

    if(SipAddrReqUri == p_addr_spec->dType)
    {
        p_end = icf_port_strchr((icf_uint8_t *)p_addr_spec->u.pUri,(icf_uint8_t)'@');
        p_target_str = (icf_uint8_t *)p_addr_spec->u.pUri;
        
    }

    else if(ICF_NULL != p_addr_spec->u.pSipUrl->pUser)
    {
        p_end = (icf_uint8_t *)p_addr_spec->u.pSipUrl->pUser + icf_port_strlen((icf_uint8_t *)p_addr_spec->u.pSipUrl->pUser);
        p_target_str = (icf_uint8_t *)p_addr_spec->u.pSipUrl->pUser;
    }
    if(p_end != ICF_NULL)
    {
        for(p_start = p_end - 1;p_start > p_target_str;p_start--)
        {
            if((*p_start == '_') || (*p_start < '0') || (*p_start > '9'))
            {
                break;
            }
        }

        if((p_start > p_target_str) && (*p_start == '_'))
        {
            icf_uint8_t temp_char = *p_end;
            p_start++;
            *p_end = '\0';
            icf_port_strcpy((icf_uint8_t *)app_num_str,(icf_uint8_t *)p_start);
            *p_end = temp_char;
        }
    }
    sip_freeSipReqLine(pReqLine);

    
    if(0 != icf_port_strcmp((icf_uint8_t *)app_num_str,(icf_uint8_t *)""))
    {
        icf_app_id_t app_num;
        app_num = icf_port_atoi(app_num_str);
        if(0 < app_num )
        {
            /* app id valid */
            for( app_index = 0;
            app_index < p_cfg_data->max_applications; app_index ++)
            {
                if(ICF_FALSE == p_app_conf[app_index].is_valid) 
                    continue; /* this index is invalid, move to next */

                if(app_num == p_app_conf[app_index].app_id)
                {
                    if(ICF_FAILURE == icf_ssa_match_app_filter(p_ssa_pdb,p_sip_msg,
                        p_app_conf + app_index,
                        &match_success,p_ecode))
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else if(ICF_TRUE == match_success)
                    {
                        /* Filter matched */
                        *p_app_id = app_num;
                        return ICF_SUCCESS;
                    }
                    break;
                }
            }
        }
    }

 
    /*iterate on all applications*/
    for (app_index = 0;app_index<p_cfg_data->max_applications;
        app_index++)
    {
        match_success=ICF_FALSE;  /*filter not matched till now*/
        if(ICF_FALSE == p_app_conf[app_index].is_valid) 
            continue; /* this index is invalid, move to next */
        
        /* filter_list empty and no default application found till now */

        if (ICF_NULL == p_app_conf[app_index].p_filter_list)
        {
            if (default_app_id == ICF_INVALID_APP_ID )
            {
                /* match supported methods */
                if(ICF_FAILURE == icf_ssa_match_app_methods(p_ssa_pdb,p_sip_msg,
                    p_app_conf + app_index,
                    &match_success,p_ecode))
                {
                    ret_val = ICF_FAILURE;
                    break; /* break out of the for loop */
                }
                else if(ICF_TRUE == match_success)
                {
                    /* if supported methods match*/
                    default_app_id = p_app_conf[app_index].app_id;
                }
            }
            continue;
        }

        if(ICF_FAILURE == icf_ssa_match_app_filter(p_ssa_pdb,p_sip_msg,
            p_app_conf + app_index,
            &match_success,p_ecode))
        {
            ret_val = ICF_FAILURE;
            break;
        }


        if(ICF_TRUE == match_success) 
            /* if current application's filter criteria matched the message */
        {
            forward_app_id = p_app_conf[app_index].app_id;
            break;
        }
    }
    /* No application matched, assign the default application as the handler */
    if(ICF_SUCCESS == ret_val)
    {
        if(ICF_INVALID_APP_ID == forward_app_id) 
            forward_app_id = default_app_id; 
        *p_app_id = forward_app_id;
    }
    else
    {
        *p_app_id = ICF_INVALID_APP_ID;
    }
    
    return ret_val;
}

#ifdef ICF_SESSION_TIMER
/*******************************************************************************
 * FUNCTION:        icf_ssa_set_session_timer_details
 *
 * DESCRIPTION:     This function sets the session timer related headers 
 *                    to the default values
 *
 ******************************************************************************/

icf_return_t icf_ssa_set_session_timer_details(
    icf_ssa_pdb_st        *p_ssa_pdb,
    Sdf_st_callObject     *p_call_obj)
{
    Sdf_st_error dErr;
    icf_return_t ret_val = ICF_TRUE;
    icf_session_timer_data_st      *p_session_timer_data = ICF_NULL;

    if (ICF_NULL == p_ssa_pdb ||
        ICF_NULL == p_ssa_pdb->p_ssa_ctxt ||
        ICF_NULL == p_ssa_pdb->p_ssa_ctxt->p_call_ctxt)
    {
        ret_val = ICF_FAILURE;
    }
    else if (ICF_FALSE == p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->session_timer_enable)
    {
       ICF_PRINT(((icf_uint8_t *)"\nSession Timer is Disabled,this function should not get hit.\n"))
       ret_val = ICF_FAILURE;
    }
    else
    if ((ICF_NULL == p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_session_timer_data))
    {
        ICF_PRINT(((icf_uint8_t *)"\nSession Timer is Either Disabled or sesion timer data is unavailable.\n"))
        ret_val = ICF_FAILURE;
    }
    /* Fix for crash in outgoing call */
    if(ICF_FAILURE == ret_val)
    {
        /*do nothing*/
    }
    else
    {
        ICF_PRINT(((icf_uint8_t *)"\n [SSA] Entered icf_ssa_set_session_timer_details"));
        p_session_timer_data = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_session_timer_data;

        if ((ICF_TRUE == p_session_timer_data->session_refresher_reqd)&&
            ((sdf_ivk_uaSetRefresher(p_call_obj,p_session_timer_data->session_timer_refresher, &dErr)) == Sdf_co_fail))
        {
            ret_val = ICF_FAILURE;
        }
        else if((ICF_SESSION_REFRESHER_NONE != 
		     p_session_timer_data->session_timer_refresher))
        { 
            /* FIX for SPR 13210, SSA will set session timer 
             value from configuration data */

            if((sdf_ivk_uaSetSessionInterval(p_call_obj, 
                p_session_timer_data->session_timer, &dErr)) == Sdf_co_fail)
            {
                ret_val= ICF_FAILURE;
            }
            else
            if((sdf_ivk_uaSetMinSe (p_call_obj, 
                p_session_timer_data->min_se,  &dErr)) == Sdf_co_fail)
            {
                ret_val= ICF_FAILURE;
            }
            else
            {
                p_call_obj->pSessionTimer->dIsSupportedTimer = Sdf_co_true;
            }
        }
    }
    ICF_PRINT(((icf_uint8_t *)"\n [SSA] Exited icf_ssa_set_session_timer_details"));
    return ret_val; 
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_start_session_timer
 *
 * DESCRIPTION:     This function Starts the Session timer if it is not 
 *                    started by UATK
 *
 ******************************************************************************/
Sdf_ty_retVal icf_ssa_start_session_timer(
                                             Sdf_st_callObject **ppCallObj,
                                             icf_glb_pdb_st *p_glb_pdb,
#ifdef ICF_WITH_MUATK_2_2
                                             Sdf_st_eventContext *pEventContext,
#endif
                                             Sdf_st_error *pErr)
{
    Sdf_ty_bool dIsActiveTimer;
    Sdf_ty_u32bit SessionInterval = 0;
    Sdf_ty_retVal ret_val = Sdf_co_success;

    if(ICF_NULL == p_glb_pdb)
    {
       ICF_PRINT(((icf_uint8_t *)"p_glb_pdb is null"));
       return ICF_FAILURE;
    }

    p_glb_pdb=p_glb_pdb;

    ICF_FUNCTION_ENTER(p_glb_pdb);
    
    if ((sdf_ivk_uaIsActiveSessionTimer(*ppCallObj, &dIsActiveTimer, \
                    pErr)) == Sdf_co_fail)
    {
        ret_val = Sdf_co_fail;
    }
    /*dIsActiveTimer will be true when UATK starts session timer*/
    if(dIsActiveTimer==Sdf_co_false)
    {
        if(sdf_ivk_uaGetSessionInterval(*ppCallObj,&SessionInterval,pErr) == Sdf_co_fail)
        {
            ret_val = Sdf_co_fail;
        }
        if(SessionInterval !=0)
        {
            /*Starts the session timer*/
#ifdef ICF_WITH_MUATK_2_2
            if ((sdf_ivk_uaStartRefresh(*ppCallObj,pEventContext, pErr)) == Sdf_co_fail)
#else
            if ((sdf_ivk_uaStartRefresh(*ppCallObj,pErr)) == Sdf_co_fail)
#endif
            {
                 ret_val = Sdf_co_fail;
            }
            else{
                ICF_PRINT(((icf_uint8_t *)"\n [SSA] Session Timer started by SSA"));
            }
        }
    }
    else{
        ICF_PRINT(((icf_uint8_t *)"\n [SSA] Session Timer started by UATK"));
    }

    ICF_FUNCTION_EXIT(p_glb_pdb);
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_set_refresher_method
 *
 * DESCRIPTION:     This function sets the subsequest session refresh request
 *                    for session timer
 *                    
 *
 ******************************************************************************/
/* SPR 9591- Changed the function prototype to pass the SipMessage instead of the
 * transaction pointer as being done earlier
 */
Sdf_ty_retVal icf_ssa_set_refresher_method(SipMessage *p_message,
                                              icf_glb_pdb_st *p_glb_pdb,
                                              icf_ssa_ctxt_st **p_ssa_ctxt,
                                              Sdf_st_error *pErr)
{

    SipHeader dAllowHeader;
    SIP_S8bit *p_allow_value;
    Sdf_ty_u32bit no_of_allow_headers = 0;
    Sdf_ty_u32bit index =0;
    icf_boolean_t   allow_header_received = ICF_FALSE;
    icf_boolean_t   allow_header_received_with_update = ICF_FALSE;
    icf_session_timer_data_st      *p_session_timer_data = ICF_NULL;
    
#ifdef ICF_TRACE_ENABLE
        icf_return_t    ret_val = 0;
#endif


    if(ICF_NULL == p_glb_pdb)
    {
       ICF_PRINT(((icf_uint8_t *)"p_glb_pdb is null"));
       return ICF_FAILURE;
    }

    p_glb_pdb=p_glb_pdb;

    if (ICF_NULL == *p_ssa_ctxt)
    {
        ICF_PRINT(((icf_uint8_t *)"\nSSA Ctxt received is NULL.\n"))
        return ICF_FAILURE;
    }
    if (ICF_NULL == (*p_ssa_ctxt)->p_call_ctxt)
    {
        ICF_PRINT(((icf_uint8_t *)"\nUnable to Fetch Call Ctxt from SSA Ctxt.\n"))
        return ICF_FAILURE;
    }
    if ((ICF_TRUE == (*p_ssa_ctxt)->p_call_ctxt->session_timer_enable) &&
        (ICF_NULL == (*p_ssa_ctxt)->p_call_ctxt->p_session_timer_data))
    {
        ICF_PRINT(((icf_uint8_t *)"\nSession Timer is Either Disabled or sesion timer data is unavailable.\n"))
        return ICF_FAILURE;
    }
 
    ICF_FUNCTION_ENTER(p_glb_pdb);
  
    p_session_timer_data = (*p_ssa_ctxt)->p_call_ctxt->p_session_timer_data;
    
    /* Get the Allow headers count and find for UPDATE method in all headers. if 
     * UPDATE method is present in Allow Header then set subsequent session
     * refresh request as Sdf_en_refresherUpdate */
    if(sip_getHeader(p_message,
        SipHdrTypeAllow, &dAllowHeader,(SipError*)&(pErr->stkErrCode)) != SipFail){
    
        if(sip_getHeaderCount(p_message,SipHdrTypeAllow,
            &no_of_allow_headers,(SipError*)&(pErr->stkErrCode)) != SipFail){
            sip_freeSipHeader(&dAllowHeader);
            
            for(index = 0;index < no_of_allow_headers;index++)
            {
                if(sip_getHeaderAtIndex(p_message,
                    SipHdrTypeAllow, &dAllowHeader, 
                    index, (SipError*)&(pErr->stkErrCode)) != SipFail)
                    {
                      allow_header_received = ICF_TRUE;
                      if(sip_getMethodFromAllowHdr(&dAllowHeader,&p_allow_value,
                        (SipError*)&(pErr->stkErrCode)) != Sdf_co_fail){

                        if(strcmp(p_allow_value,"UPDATE") == 0)
                        {
                            allow_header_received_with_update = ICF_TRUE;
                        }
                    }
                    sip_freeSipHeader(&dAllowHeader);
                }
            }
        }
        else
        {
            sip_freeSipHeader(&dAllowHeader);
        }
    }

    /* In the begining refresher method in ssa ctxt is none,
     * Now if UPDATE received from remote in ALLOW header then check
     * whether applications supports it, if it support then UPDATE will
     * be the session refresher method. 
     * Once UPDATE is set as refresher method, IPTK will not reset it to
     * INVITE until and unless ALLOW header is received but without UPDATE.       
     */
    if(ICF_NULL !=  (*p_ssa_ctxt)->p_call_ctxt->p_session_timer_data)
    {

        if ((ICF_TRUE == allow_header_received_with_update) &&
        (ICF_CFG_CALL_MODIFY_METHOD_UPDATE == \
              p_session_timer_data->session_refresher_method))
        {
           if (ICF_CFG_CALL_MODIFY_METHOD_UPDATE == \
              p_session_timer_data->session_refresher_method)
           {
               ICF_SSA_SET_SESSION_REFRESH_REQ((*p_ssa_ctxt),Sdf_en_refresherUpdate);
           }
           else
           {
               ICF_SSA_SET_SESSION_REFRESH_REQ((*p_ssa_ctxt),Sdf_en_refresherInvite);
           }  
       }
       else if ((ICF_TRUE == allow_header_received) &&
             (ICF_FALSE == allow_header_received_with_update))
       {
           ICF_SSA_SET_SESSION_REFRESH_REQ((*p_ssa_ctxt),Sdf_en_refresherInvite);       
       }  
       else if ((ICF_FALSE == allow_header_received) &&
             (Sdf_en_refresherUpdate != (*p_ssa_ctxt)->refresher_method_type))
       {
           ICF_SSA_SET_SESSION_REFRESH_REQ((*p_ssa_ctxt),Sdf_en_refresherInvite);
       }
    }
 
    ICF_FUNCTION_EXIT(p_glb_pdb);
    return Sdf_co_success;
}
#endif /*Session Timer*/
#if 0
/*****************************************************************************
 * FUNCTION:        icf_ssa_is_update_present_in_allow_hdr
 *
 * DESCRIPTION:     This function checks that whether update
 *                  method is present in the ALLOW header of 
 *                  a received SIP message.
 *
 *****************************************************************************/
Sdf_ty_retVal icf_ssa_is_update_present_in_allow_hdr(SipMessage *p_message,
                                                     icf_glb_pdb_st *p_glb_pdb,
                                                     icf_ssa_ctxt_st **p_ssa_ctxt,
                                                     Sdf_st_error *pErr)
{

    SipHeader dAllowHeader;
    SIP_S8bit *p_allow_value;
    Sdf_ty_u32bit no_of_allow_headers = 0;
    Sdf_ty_u32bit index =0;

#ifdef ICF_TRACE_ENABLE
        icf_return_t    ret_val = 0;
#endif


    if(ICF_NULL == p_glb_pdb)
    {
       ICF_PRINT(("p_glb_pdb is null"));
       return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_glb_pdb);


    /* Get the Allow headers count and find for UPDATE method in all headers. if 
     * UPDATE method is present in Allow Header then set the flag allowed_value
     * in call context to ICF_UPDATE_ALLOWED_IN_200OK  */
      
    if(sip_getHeader(p_message,
        SipHdrTypeAllow, &dAllowHeader,(SipError*)&(pErr->stkErrCode)) != SipFail){

        if(sip_getHeaderCount(p_message,SipHdrTypeAllow,
            &no_of_allow_headers,(SipError*)&(pErr->stkErrCode)) != SipFail){
                        sip_freeSipHeader(&dAllowHeader);
            for(index = 0;index < no_of_allow_headers;index++){

                if(sip_getHeaderAtIndex(p_message,
                    SipHdrTypeAllow, &dAllowHeader,
                    index, (SipError*)&(pErr->stkErrCode)) != SipFail){

                    if(sip_getMethodFromAllowHdr(&dAllowHeader,&p_allow_value,
                        (SipError*)&(pErr->stkErrCode)) != Sdf_co_fail){

                        if(strcmp(p_allow_value,"UPDATE") == 0){
                                  
                            /* Setting value of allowed_value to ICF_UPDATE_ALLOWED_IN_200OK  */
                          (*p_ssa_ctxt)->p_call_ctxt->allowed_value = ICF_UPDATE_ALLOWED_IN_200OK ; 
                            
                        }
                    }
                                        sip_freeSipHeader(&dAllowHeader);
                }
            }
        }
                else
                {
                        sip_freeSipHeader(&dAllowHeader);
                }
    }

    ICF_FUNCTION_EXIT(p_glb_pdb);
    return Sdf_co_success;
}

#endif

/*****************************************************************************
 * FUNCTION:        icf_ssa_flush_alive_connections
 *
 * DESCRIPTION:     This function flushes all alive connections corresponding
 *                  to a call on TCP.This scenario occurs if we have 2 
 *                  TCP connections for the same dialog
 *
 *****************************************************************************/
icf_return_t icf_ssa_flush_alive_connections(
        icf_ssa_pdb_st        *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st          *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    icf_nw_interface_info_st nw_interface_info;
    icf_interface_info_st     interface_info;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if(ICF_NULL == p_ssa_ctxt)
    {
        return ICF_FAILURE;
    }
    else
    {
        p_ssa_ctxt->p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    }
    /* Changes for closing the connection fd if the connection 
       is non persistent
    */   
    if (p_ssa_ctxt->p_conn_table_req_entry != ICF_NULL)
    {
        if (ICF_TRUE == p_ssa_ctxt->p_conn_table_req_entry->is_persistent)
        {
            ICF_SSA_DEC_CONN_REF_COUNT(p_ssa_ctxt->p_conn_table_req_entry);
        }
        else
        {
             nw_interface_info.bitmap = ICF_INTF_INFO_PROTOCOL_TCP;
             nw_interface_info.receiver_fd = p_ssa_ctxt->p_conn_table_req_entry->conn_fd;

            interface_info.p_port_info = p_ssa_pdb->p_glb_pdb->p_glb_data->p_glb_port_info;
			interface_info.interface_type = ICF_INTF_TYPE_FIFO;
			interface_info.fd_id = nw_interface_info.receiver_fd;
			interface_info.interface_type = ICF_INTF_TYPE_TCP;
			ret_val = icf_port_tcp_non_blocking_peek(&interface_info,
			    (icf_void_t*)(((icf_global_port_info_st*)(p_ssa_pdb->
			    p_glb_pdb->p_glb_data->p_glb_port_info))->
			    ext_info.p_tcp_recv_buffer),
				p_ssa_pdb->p_ecode);
			if(ICF_FAILURE == ret_val)
			{
					/* Close the TCp socket on purge timer expiry if
					 * this is an incoming connection
					 */
					if(ICF_NULL == (ICF_TCP_DATA_SERVER_PORT & 
											p_ssa_pdb->p_ssa_glb_data->
                                    p_ssa_tcpm_conn_db->bitmap))
					{ 
							icf_es_close_tcp_conn(
											p_ssa_pdb->p_glb_pdb->p_glb_data->p_glb_port_info,
											&nw_interface_info, p_ssa_pdb->p_ecode);
							p_ssa_pdb->p_conn_table_entry = p_ssa_ctxt->p_conn_table_req_entry;
							icf_ssa_remove_conn_entry(p_ssa_pdb, p_ssa_ctxt->p_conn_table_req_entry->conn_fd);
							p_ssa_pdb->p_conn_table_entry = ICF_NULL;
							p_ssa_ctxt->p_conn_table_req_entry = ICF_NULL;
					}
			}
			else
			{
					ICF_PRINT(((icf_uint8_t *)"\n[SSA]:TCP Data pending on Socket %d.Socket Not Closed",interface_info.fd_id));
					ret_val = ICF_FAILURE;
			}
		}
		/* Changes for closing the connection fd if the connection 
       is non persistent
    */ 
   }  
    if ((ICF_NULL != p_ssa_ctxt->p_conn_table_resp_entry) &&(
            p_ssa_ctxt->p_conn_table_resp_entry != p_ssa_ctxt->p_conn_table_req_entry))
    {
        if (ICF_TRUE == p_ssa_ctxt->p_conn_table_resp_entry->is_persistent)
        {
            ICF_SSA_DEC_CONN_REF_COUNT(p_ssa_ctxt->p_conn_table_resp_entry);
        }
        else
        {
             nw_interface_info.bitmap = ICF_INTF_INFO_PROTOCOL_TCP;
             nw_interface_info.receiver_fd = p_ssa_ctxt->p_conn_table_resp_entry->conn_fd;
			 interface_info.p_port_info = p_ssa_pdb->p_glb_pdb->p_glb_data->p_glb_port_info;
			 interface_info.interface_type = ICF_INTF_TYPE_FIFO;
			interface_info.fd_id = nw_interface_info.receiver_fd;
			interface_info.interface_type = ICF_INTF_TYPE_TCP;
			ret_val = icf_port_tcp_non_blocking_peek(&interface_info,
			    (icf_void_t*)(((icf_global_port_info_st*)(p_ssa_pdb->
			    p_glb_pdb->p_glb_data->p_glb_port_info))->
			    ext_info.p_tcp_recv_buffer),
				p_ssa_pdb->p_ecode);
			if(ICF_FAILURE == ret_val)
			{
					/* Close the TCp socket on purge timer expiry if
					 * this is an incoming connection
					 */
					if(ICF_NULL == (ICF_TCP_DATA_SERVER_PORT & 
											p_ssa_pdb->p_ssa_glb_data->
                                    p_ssa_tcpm_conn_db->bitmap))
					{ 
							icf_es_close_tcp_conn(
											p_ssa_pdb->p_glb_pdb->p_glb_data->p_glb_port_info,
											&nw_interface_info, p_ssa_pdb->p_ecode);
							p_ssa_pdb->p_conn_table_entry = p_ssa_ctxt->p_conn_table_resp_entry;
							icf_ssa_remove_conn_entry(p_ssa_pdb, p_ssa_ctxt->p_conn_table_resp_entry->conn_fd);
							p_ssa_pdb->p_conn_table_entry = ICF_NULL;
							p_ssa_ctxt->p_conn_table_resp_entry = ICF_NULL;
					}
			}
			else
			{
					ICF_PRINT(((icf_uint8_t *)"\n[SSA]:TCP Data pending on Socket %d.Socket Not Closed",interface_info.fd_id));
					ret_val = ICF_FAILURE;
			}

        }
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


/****************************************************************************
 * FUNCTION:           icf_ssa_add_transport_param_in_contact_hdr
 *
 * DESCRIPTION:        This routine fetch contact headers from InitData
 *                     Check if transport is TCP or UDP then insert 
 *                     transport=tcp/udp paramater in contact header
 * 
 *****************************************************************************/
icf_return_t   icf_ssa_add_transport_param_in_contact_hdr(
        icf_ssa_pdb_st        *p_ssa_pdb,
        Sdf_st_initData          *p_init_data,
        Sdf_st_error             *p_error)
{
    icf_return_t       ret_val = ICF_SUCCESS;
    Sdf_ty_u32bit         dSize = 0;
    SipHeader             *p_contact_header = SIP_NULL;
    icf_uint32_t       iterator1 = 0;
    icf_int8_t        *p_param = ICF_NULL;
    icf_uint8_t        param[] = "udp";
    Sdf_st_error          sdf_error;
	icf_uint8_t         param_str[ICF_MAX_STR_LEN] = "\0";

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    
    if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_glb_cfg_data->self_mode)
    || (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_glb_cfg_data->self_mode))
    {
	    /*Fix done for SPR-18722 : CSR-1-6068965*/
        Sdf_mc_strdup(p_param, (icf_int8_t *)param);
        if (ICF_TRANSPORT_TYPE_UDP != p_ssa_pdb->p_ssa_ctxt->transport &&
            ICF_NULL != p_param)
        {
            icf_port_strcpy((icf_uint8_t *)p_param,(icf_uint8_t *)"tcp");
        }
    }
    else if (ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->p_glb_cfg_data->self_mode)
    {
        Sdf_mc_strdup(p_param, (icf_uint8_t *)param);
    }
    else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_glb_cfg_data->self_mode)
    {
        Sdf_mc_strdup(p_param,(icf_int8_t *)"tls");
    }
    else
    {
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ICF_SUCCESS;
    } /* else */

    if(ICF_NULL == p_param)
    {
        ret_val = ICF_FAILURE;
    }
    /*Get the Size of Conatact Header List*/
    else if(Sdf_co_fail == sdf_listSizeOf(&(p_init_data->slContact),&dSize,p_error))
    {
        ret_val = ICF_FAILURE;
    }
    /*If list contains elements*/
    else if(dSize !=0)
    {
        /*
        SipContactParam  contactParam;
        contactParam.dType = SipCParamExtension;
        contactParam.u.pExtensionAttr = param;
        */

        /*Fetch all the Contact headers from initdata*/
        for(iterator1=0; iterator1<dSize; iterator1++)
        {
            if(Sdf_co_fail == sdf_listGetAt(&(p_init_data->slContact),
                        iterator1, (Sdf_ty_pvoid *)&p_contact_header,p_error))
            {
                ret_val = ICF_FAILURE;
                break;
            }
			/* CSR 1-6720876: SPR 19246 */
			/* Before adding transport param in Contact header, check if the 
			 * parameter is already present.
			 */
			else if (ICF_SUCCESS == icf_ssa_check_for_param_in_sipurl(
						((SipContactHeader*)(p_contact_header->pHeader))\
									->pAddrSpec->u.pSipUrl,
						(icf_uint8_t *)"transport",
						param_str,
						p_ssa_pdb->p_ecode) &&
					('\0' != param_str[0]))
			{
				ICF_PRINT(("\n[SSA]: transport param exists in Contact hdr\n"));
				ret_val = ICF_SUCCESS;
				break;
			}
			/*Fix done for SPR-18722 : CSR-1-6068965*/
            else if (ICF_FAILURE ==
                    icf_ssa_insert_param_in_addr_spec(
                        p_ssa_pdb, 
                        ((SipContactHeader*)
                         (p_contact_header->pHeader))->pAddrSpec,
                        (icf_uint8_t *)"transport",(icf_uint8_t *)p_param, &sdf_error))
            {
                ret_val = ICF_FAILURE;
            }
            /*
               else if (Sdf_co_fail == 
               sip_insertContactParamAtIndexInContactHdr(p_contact_header,
                        &contactParam, 0, &sip_err))
            {
                ret_val = ICF_FAILURE;
                break;
            }*/
        } /* for(iterator1=0; iterator1<dSi... */

    } /* if(dSize !=0) */

    ICF_MEMFREE(
            p_ssa_pdb->p_glb_pdb,
            p_param,
            ICF_MEM_COMMON,
            p_ssa_pdb->p_ecode,
            ret_val)

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;
} /* icf_ssa_add_param_in_contact_hdr */



/*******************************************************************************
 * FUNCTION:        icf_ssa_insert_param_in_addr_spec
 *
 * DESCRIPTION:     This function inserts parametrs into the addr spec passed
 *                  to it as a paramter
 *                  1. The parmater name and value are also passed to this
 *                     function
 *
 ******************************************************************************/
icf_return_t icf_ssa_insert_param_in_addr_spec(
        icf_ssa_pdb_st   *p_ssa_pdb,
        SipAddrSpec    *p_addr_spec,
        icf_uint8_t *p_param,
        icf_uint8_t *p_value,
        Sdf_st_error *p_sdf_error)
{
    icf_uint8_t  param_list_string[20] = "\0";
    icf_return_t ret_val = ICF_SUCCESS;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    switch (p_addr_spec->dType)
    {
        case SipAddrReqUri:
            {
                SIP_S8bit *p_temp = SIP_NULL;
                icf_uint8_t    uri_size = ICF_NULL;

                /* In this case we have to make the string completely */
                icf_port_strcat(param_list_string,(icf_uint8_t *)";");
                icf_port_strcat(param_list_string,p_param);
                
                if (ICF_NULL == p_addr_spec->u.pUri)
                {
                   return ICF_FAILURE;
                }
                                
                if((Sdf_co_null != p_value) && 
                    (0 < icf_port_strlen((icf_uint8_t *)p_addr_spec->u.pUri)))
                {
                    icf_port_strcat(param_list_string,(icf_uint8_t *)"=");
                    icf_port_strcat(param_list_string,p_value);
                }

                /* 
                 * uri_size is the total size of the TEL URL
                 * Since memory is not allocated for the paramters,
                 * we shall allocate memory for a string which
                 * shall hold the TEL URL along with the parameters.
                 */
                uri_size = (icf_uint8_t)(icf_port_strlen((icf_uint8_t *)p_addr_spec->u.pUri) +
                    icf_port_strlen(param_list_string)+1 );

                /*Memory allocation for pUri in addr spec*/
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        uri_size,
                        ICF_MEM_COMMON,
                        p_temp,
                        ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode,
                        ret_val)


                /*
                 * Copy the contents of the existing TEL URL
                 * into the string p_temp ,the memory for which
                 * has been allocated in the previous step
                 * Concate the paramter(name-value) pair
                 */
                icf_port_strcpy((icf_uint8_t *)p_temp, (icf_uint8_t *)p_addr_spec->u.pUri);
                icf_port_strcat((icf_uint8_t *)p_temp, (icf_uint8_t *)param_list_string);

                /* Free the memory for the existing uri*/
                ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_addr_spec->u.pUri,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)

                /*
                 * Now assign the pointer to the newly formed TEL URL
                 * to the SIP address spec
                 */
                p_addr_spec->u.pUri = p_temp;
                break;
            }
        case SipAddrSipUri:
        case SipAddrSipSUri:
            {
                SipList *p_dest = &((p_addr_spec->u).pSipUrl->slParam);

                if(Sdf_co_fail == icf_ssa_append_par_to_sip_list(
                            p_ssa_pdb,p_dest,
                            p_param,p_value,p_sdf_error))
                {
                    ret_val = ICF_FAILURE;
                } /* "transport",tp,p_err)) */
            } /* case SipAddrSipSUri: */
            break;
        default:
            break;
    } /* switch (pSipAddrSpec->dType) */
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} /* icf_ssa_insert_param_in_addr_spec */


/*******************************************************************************
 * FUNCTION:        icf_ssa_append_par_to_sip_list
 *
 * DESCRIPTION:     This function appends a parameter to given SIP list
 *
 ******************************************************************************/
icf_return_t icf_ssa_append_par_to_sip_list(
        icf_ssa_pdb_st      *p_ssa_pdb,
        SipList                *p_dest,
        icf_uint8_t         *p_param_name,
        icf_uint8_t         *p_paramValue,
        Sdf_st_error           *p_err)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_return_t     dummy_ret_val = ICF_SUCCESS;
    SipParam            *p_temp_param = Sdf_co_null;
    Sdf_ty_s8bit        *p_dup_value = Sdf_co_null;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if(SipFail == sip_initSipParam(&p_temp_param,
                (SipError *)&(p_err->stkErrCode)))
    {
        ret_val = ICF_FAILURE;
    }
    else if(Sdf_co_null != p_temp_param)
    {
        p_temp_param->pName = (SIP_S8bit*)STRDUPACCESSOR((const icf_int8_t *)p_param_name);
        if(Sdf_co_null != p_paramValue)
        {
            p_dup_value = (SIP_S8bit*)STRDUPACCESSOR((const icf_int8_t *)p_paramValue);
            
            if (0 != icf_port_strlen((icf_uint8_t *)p_dup_value))
            {
                if (SipFail == sip_listAppend(
                    &(p_temp_param->slValue),
                    p_dup_value,
                    (SipError *)&(p_err->stkErrCode)))
                {
                    ret_val = ICF_FAILURE;
                }
            }
            else
            {
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_dup_value,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
            }
        }
    }
    if (ICF_FAILURE != ret_val)
    {
        if ( SipFail == sip_listAppend(
                    p_dest, p_temp_param,
                    (SipError *)&(p_err->stkErrCode)))
        {
            ret_val = ICF_FAILURE;
        }
    }

    if (ICF_FAILURE == ret_val)
    {
        if ( Sdf_co_null != p_dup_value)
        {
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_dup_value,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
        }

        if (Sdf_co_null != p_temp_param)
        {
             if(Sdf_co_null != p_temp_param->pName)
             {
               ICF_MEMFREE(
                       p_ssa_pdb->p_glb_pdb,
                       p_temp_param->pName,
                       ICF_MEM_COMMON,
                       p_ssa_pdb->p_ecode,
                       dummy_ret_val)
              } /* if(p_temp_param->pName != Sdf_co... */

            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_temp_param,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
        }
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val ;
} /* icf_ssa_append_par_to_sip_list */


/*****************************************************************************
 * FUNCTION:        icf_ssa_check_for_trans_param
 *
 * DESCRIPTION:     Function to derive transport mode based on proxy mode
 *                  and mode received in remote party address in create call
 * This function checks for combinations of trnasport param given in req UR
 * peer mode ( proxy/registrar) as configured with ICF to determine if
 * revert is possible and to store the decided transport in ssa ctxt
 * transport_mode - this should be given by calling fn, based on  whether it 
 * is registrar or for proxy
 * p_param_val - is the pointer to transport string given by App for the
 * request in processing as part of the request URI
 *****************************************************************************/
icf_return_t icf_ssa_check_for_trans_param(
        icf_ssa_pdb_st        *p_ssa_pdb,
        icf_transport_mode_et transport_mode,
        icf_uint8_t           *p_param_val,
        icf_boolean_t         is_outbound_defined)
{
    icf_return_t   ret_val = ICF_SUCCESS;
    icf_transport_mode_et remote_mode;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (ICF_NULL != p_param_val)
    {
        if (!icf_port_strcmp(p_param_val, (icf_uint8_t *)"tcp"))
            remote_mode = ICF_TRANSPORT_TYPE_TCP;
        else if (!icf_port_strcmp(p_param_val, (icf_uint8_t *)"tls"))
            remote_mode = ICF_TRANSPORT_TYPE_TLS;
        else
            remote_mode = ICF_TRANSPORT_TYPE_UDP;
    }
    else
        remote_mode = ICF_TRANSPORT_MODE_BOTH;

    /*If remote transport mode is present, then derive transport mode
     * on the basis of transport_mode and rem_mode in create_call*/
    if (ICF_NULL != p_param_val)
    {
        if (ICF_TRANSPORT_MODE_BOTH == transport_mode)
        {
            if (ICF_TRANSPORT_TYPE_TCP == remote_mode)
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else if (ICF_TRANSPORT_TYPE_UDP == remote_mode)
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else if (ICF_TRANSPORT_TYPE_TLS == remote_mode)
            {
               ret_val = ICF_FAILURE;
            }
            else
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_MODE_BOTH;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_TRUE;
            }
        }
        else if ((ICF_TRANSPORT_TYPE_TCP == transport_mode)) 
        {
            if (ICF_TRANSPORT_TYPE_TCP == remote_mode)
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else if (ICF_TRANSPORT_TYPE_UDP == remote_mode)
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_TRANSPORT_TYPE_TLS == remote_mode)
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_MODE_BOTH;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
        }
        else if (ICF_TRANSPORT_TYPE_UDP == transport_mode)
        {
            if (ICF_TRANSPORT_TYPE_TCP == remote_mode)
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_TRANSPORT_TYPE_TLS == remote_mode)
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_TRANSPORT_TYPE_UDP == remote_mode)
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_MODE_BOTH;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
        }
        else if (ICF_TRANSPORT_TYPE_TLS == transport_mode)
        {
            if (ICF_TRANSPORT_TYPE_TLS == remote_mode)
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TLS;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else if ((ICF_TRANSPORT_TYPE_UDP == remote_mode) && (ICF_FALSE == is_outbound_defined))
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else if ((ICF_TRANSPORT_TYPE_UDP == remote_mode) && (ICF_TRUE == is_outbound_defined))
            {
                ret_val = ICF_FAILURE;
            }
            else if ((ICF_TRANSPORT_TYPE_TCP == remote_mode) && (ICF_FALSE == is_outbound_defined))
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else if ((ICF_TRANSPORT_TYPE_TCP == remote_mode) && (ICF_TRUE == is_outbound_defined))
            {
                ret_val = ICF_FAILURE;
            }
        }
    } /* if (ICF_TRUE == remote_mode... */
    else
    {
        p_ssa_pdb->send_trans_param = ICF_FALSE;

        if ((ICF_TRANSPORT_TYPE_TCP == transport_mode) ||
                (ICF_TRANSPORT_MODE_BOTH == transport_mode))
        {
            p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
            p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
        } /* if (ICF_TRANSPORT_TYPE_TCP ... */
        else if (ICF_TRANSPORT_TYPE_UDP == transport_mode)
        {
            p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
            p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
        }
        else if (ICF_TRANSPORT_TYPE_TLS == transport_mode)
        {
            p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TLS;
            p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
        }
        else
        {
            p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_MODE_BOTH;
            p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_TRUE;
        }
    }
    if (ICF_TRANSPORT_MODE_BOTH == 
            p_ssa_pdb->p_ssa_ctxt->transport )
    {
        p_ssa_pdb->p_ssa_ctxt->transport = 
            p_ssa_pdb->p_glb_cfg_data->self_mode;
    }
    if ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport) && 
        (ICF_NULL == p_ssa_pdb->p_glb_cfg_data->p_tls_init_data))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Error : TLS data is not configured and derived transport mode is TLS "));
    ret_val = ICF_FAILURE;
    } 
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} /* icf_ssa_check_for_trans_param */

/*******************************************************************************
 * FUNCTION:        icf_ssa_check_for_new_conn
 *
 * DESCRIPTION:     This function checks if new connection received, then it
 *                  updates it in ssa context
 *
 ******************************************************************************/
icf_return_t   icf_ssa_check_for_new_conn(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT  icf_ssa_ctxt_st *p_ssa_ctxt,
        INOUT  Sdf_st_callObject *p_call_obj)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    /*Following is used to hold the ssa ctxt stored in 
    p_ssa_pdb, we need to invoke the TCPSM with ssa_pdb having the 
    original ssa ctxt.  we will use this variable to 
    store whateer value is in the ssa_pdb.p_ssa_ctxt and
    then restore it after we are done with processing*/
    icf_ssa_ctxt_st      *p_temp_ssa_ctxt = ICF_NULL;
    icf_ssa_tcpm_conn_data_st  **p_p_temp_conn = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    

    if (p_ssa_pdb->dMsgType == SipMessageRequest)
        p_p_temp_conn = &(p_ssa_ctxt->p_conn_table_resp_entry);
    else
        p_p_temp_conn = &(p_ssa_ctxt->p_conn_table_req_entry);

    if (ICF_NULL == *p_p_temp_conn)
    {
        *p_p_temp_conn = 
            p_ssa_pdb->p_conn_table_entry;
#ifdef ICF_SECURE_SUPPORT
        if (p_ssa_pdb->p_conn_table_entry->prot_conn_bitmask & ICF_TRANSPORT_TLS)
        {
            p_ssa_ctxt->p_conn_table_resp_entry = p_ssa_pdb->p_conn_table_entry;
            p_ssa_ctxt->p_conn_table_req_entry = p_ssa_pdb->p_conn_table_entry;
        }
#endif

    } /* if (ICF_MAX_NO_OF_PERSISTENT_CONNECTIONS == p_s... */
    else
    {
        p_temp_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;

        p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;
        /*Invoke TCP-SM to replace ssa_ctx connection
         * with ssa_pdb connection*/
        ICF_SSA_IVK_TCPSM_FRM_CTX(p_ssa_pdb, p_ssa_ctxt, \
            ICF_SSA_TCPM_REPLACE_CONN_FD, ret_val)
        p_ssa_pdb->p_ssa_ctxt = p_temp_ssa_ctxt;
        *p_p_temp_conn = 
            p_ssa_pdb->p_conn_table_entry;
#ifdef ICF_SECURE_SUPPORT
        if (p_ssa_pdb->p_conn_table_entry->prot_conn_bitmask & ICF_TRANSPORT_TLS)
        {
            p_ssa_ctxt->p_conn_table_resp_entry = p_ssa_pdb->p_conn_table_entry;
            p_ssa_ctxt->p_conn_table_req_entry = p_ssa_pdb->p_conn_table_entry;
        }
#endif

    } /* else */    

    if (ICF_SUCCESS == ret_val)
    {
        ret_val = icf_ssa_copy_conn_fd_to_callobj(
                p_ssa_pdb,
                p_call_obj,
                p_ssa_pdb->p_conn_table_entry->conn_fd);
    } /* if (ICF_SUCCESS == ret_val) */

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;
} /* INOUT  icf_ssa_pdb_st *p_ssa... */

/*******************************************************************************
 * FUNCTION:        icf_ssa_copy_conn_fd_to_callobj
 *
 * DESCRIPTION:     This function copies new connection FD to call object
 *
 ******************************************************************************/
icf_return_t   icf_ssa_copy_conn_fd_to_callobj(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT  Sdf_st_callObject *p_call_obj,
        INOUT    icf_int32_t    conn_fd)
{
        icf_return_t     ret_val = ICF_SUCCESS;
    Sdf_st_listIterator dListIterator;
    Sdf_st_error        sdf_error;
#ifdef ICF_SECURE_SUPPORT
    icf_ssa_ctxt_st     *p_ssa_ctxt = (icf_ssa_ctxt_st *)p_call_obj->pAppData->pData;
#endif
 

    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }  
    p_ssa_pdb=p_ssa_pdb;  
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if ( ICF_NULL != p_call_obj->pUasTransaction)
    {
        p_call_obj->pUasTransaction->dSocket.dSockfd = conn_fd;
#ifdef ICF_SECURE_SUPPORT                
        if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
        {
            p_call_obj->pUasTransaction->dSocket.dProtocol =
                Sdf_en_protoTls;
        }
        else
        {
#endif
            p_call_obj->pUasTransaction->dSocket.dProtocol =
                Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
        }
#endif
    }
    if ( ICF_NULL != p_call_obj->pUacTransaction)
    {
        p_call_obj->pUacTransaction->dSocket.dSockfd = conn_fd;
#ifdef ICF_SECURE_SUPPORT                
        if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
        {
            p_call_obj->pUacTransaction->dSocket.dProtocol =
                Sdf_en_protoTls;
        }
        else
        {
#endif
            p_call_obj->pUacTransaction->dSocket.dProtocol =
                Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
        }
#endif
    }
    sdf_listInitIterator(&(p_call_obj->slOverlapTransInfo), \
            &dListIterator, &sdf_error);

    while (dListIterator.pCurrentElement != Sdf_co_null)
    {
        Sdf_st_overlapTransInfo *p_overlap_trans_info;

        p_overlap_trans_info = (Sdf_st_overlapTransInfo *) \
            (dListIterator.pCurrentElement->pData);
        if ( Sdf_co_null != p_overlap_trans_info)
        {
            p_overlap_trans_info->dSocket.dSockfd = conn_fd;
#ifdef ICF_SECURE_SUPPORT                
            if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
            {
                 p_overlap_trans_info->dSocket.dProtocol =
                     Sdf_en_protoTls;
            }
            else
            {
#endif            
                 p_overlap_trans_info->dSocket.dProtocol =
                     Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
            }
#endif        
        }
        sdf_listNext(&dListIterator, &sdf_error);
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        
    return ret_val;
} /* INOUT    icf_uint16_t   conn_f... */

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_method_name
 *
 * DESCRIPTION:     This utility function will be invoked to populate the method
 *                     name in the string function argument. The function will 
 *                     check the bitmaks and accordingly get the function name.
 *                     The function is invoked from within the function 
 *                     icf_ssa_send_dialog_initiator_msg, when attempting to 
 *                     revert to UDP if the connection on TCP has failed.
 *
 ******************************************************************************/
icf_return_t    icf_ssa_get_method_name(
        INOUT   icf_uint32_t  bitmask,
        INOUT   icf_uint8_t    *pMethod
)
{
    if (ICF_SSA_REG_PENDING & bitmask)
    {
        icf_port_strcpy(pMethod, (icf_uint8_t *)"REGISTER");
    }
    else
       if (ICF_SSA_SUBS_PENDING & bitmask)
       {
           icf_port_strcpy(pMethod,(icf_uint8_t *)"SUBSCRIBE");
       }
    else
    if (ICF_SSA_REFER_PENDING & bitmask)
    {
        icf_port_strcpy(pMethod, (icf_uint8_t *)"REFER");
    }
    else
    if (ICF_SSA_PUBLISH_PENDING & bitmask)
    {
        icf_port_strcpy(pMethod, (icf_uint8_t *)"PUBLISH");
    }
    else
    if (ICF_SSA_OPTION_PENDING & bitmask)
    {
        icf_port_strcpy(pMethod, (icf_uint8_t *)"OPTIONS");
    }
    else
    if (ICF_SSA_MESSAGE_PENDING & bitmask)
    {
        icf_port_strcpy(pMethod, (icf_uint8_t *)"MESSAGE");
    }
    else
    {
        return ICF_FAILURE;
    }
    return ICF_SUCCESS;
}


/*******************************************************************************
 * FUNCTION:        icf_ssa_reset_fd_in_uaCallObj
 *
 * DESCRIPTION:     This function will invoke sdf_ivk_uaResetSockFd in a loop so 
 *                    that all the fd's are reset in the CallObj. 
 *
 ******************************************************************************/
void icf_ssa_reset_fd_in_uaCallObj(
    INOUT     Sdf_st_callObject        *pCallObject,
    INOUT         icf_uint16_t            sockFd)
{
    /* local variables */
    Sdf_ty_retVal    ret_val = Sdf_co_success;
    Sdf_st_error    sdf_error;

    do 
    {
        ret_val = sdf_ivk_uaResetSockFd(pCallObject,
                (Sdf_ty_socketId)sockFd, &sdf_error);
    } while (ret_val == Sdf_co_success);

    return;
}


#ifdef ICF_IPSEC_ENABLED
/*******************************************************************************
 * FUNCTION:        icf_ssa_get_sec_client_string
 *
 * DESCRIPTION:     This function will create the string (from the security 
 *                    param structure) that will be inserted in the Security 
 *                    Client Header in the outgoing Register Request
 *
 ******************************************************************************/
icf_return_t    icf_ssa_get_sec_client_string (
        INOUT         icf_ssa_pdb_st                  *p_ssa_pdb,
        INOUT         icf_uint8_t                     **p_p_str,
        INOUT            icf_ipsec_security_params_st   *p_sec_params
        )
{
    /* local variables */
    icf_error_t                      ecode = ICF_NULL;
    icf_return_t                     ret_val    = ICF_SUCCESS;
    icf_rgm_glb_data_st              *p_dbm_rgm_glb_data = ICF_NULL;
    icf_uint8_t                      tmpStr[50] = "\0";
    icf_uint8_t                      count =0;
    icf_uint8_t                      *p_str = ICF_NULL;

    /* get memory for the the p_str argument */
    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
         ICF_MAX_SEC_HDR_LEN,
         ICF_MEM_COMMON, 
         (icf_void_t*)(p_str),
         ICF_RET_ON_FAILURE, 
         &ecode, ret_val);

    /* make the string to be inserted in the Security Param header */
    icf_port_strcpy(p_str, "ipsec-3gpp; alg=");
    /* fetch the RGM glb data to get self algos */
    ret_val = icf_dbm_get_module_glb_data(
                 p_ssa_pdb->p_glb_pdb,
                 (icf_int_module_id_t)(ICF_INT_MODULE_REGM),
                 (icf_void_t **)(&p_dbm_rgm_glb_data),
                 &ecode);     
             
    ICF_ASSERT(
        p_ssa_pdb->p_glb_pdb,(ICF_NULL != p_dbm_rgm_glb_data))
    while (count < ICF_MAX_SUPP_I_ALGO)
    {
        icf_port_strcpy(
            tmpStr,
            p_dbm_rgm_glb_data->p_ue_algo_list->integrity_algo[count].str);
                
        icf_port_strcat(p_str, tmpStr);
        count += 1;
        if ((ICF_NULL != 
            p_dbm_rgm_glb_data->p_ue_algo_list->integrity_algo[count].str_len) &&
            (count < ICF_MAX_SUPP_I_ALGO))
        {
            icf_port_strcat(p_str, ",");
        }
        tmpStr[0] ='\0';
    }
    
    count =0;
    icf_port_strcat(p_str, "; ealg=");
    while (count < ICF_MAX_SUPP_E_ALGO)
    {
        icf_port_strcpy(
                tmpStr,
                p_dbm_rgm_glb_data->p_ue_algo_list->encryption_algo[count].str);
                
        icf_port_strcat(p_str, tmpStr);
        count += 1;
        if ((count < ICF_MAX_SUPP_E_ALGO) &&
            (ICF_NULL != 
            p_dbm_rgm_glb_data->p_ue_algo_list->encryption_algo[count].str_len))
            
        {
            icf_port_strcat(p_str, ",");
        }
        tmpStr[0] ='\0';
    }
    
    icf_ssa_get_sec_string(p_str, p_sec_params);

    *p_p_str = p_str;

    return ret_val;

}

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_sec_string
 *
 * DESCRIPTION:     This function will create the string (from the security 
 *                    param structure) that will be inserted in the Security 
 *                    Client/Verfiy Header in the outgoing Protected messages  
 *
 ******************************************************************************/
icf_void_t    icf_ssa_get_sec_string(
        INOUT     icf_uint8_t                        *pString,
        INOUT     icf_ipsec_security_params_st        *p_sec_params
)
{
    /* local variables */
    icf_uint8_t        tmpString[50];

    icf_port_strcat(pString, "; spi-c=");
    icf_port_sprintf( tmpString, "%d", p_sec_params->spi_c);
    icf_port_strcat(pString, tmpString);

    icf_port_strcat(pString, "; spi-s=");
    icf_port_sprintf( tmpString, "%d", p_sec_params->spi_s);
    icf_port_strcat(pString, tmpString);
    
    icf_port_strcat(pString, "; port-c=");
    icf_port_sprintf( tmpString, "%d", p_sec_params->port_c);
    icf_port_strcat(pString, tmpString);
        
    icf_port_strcat(pString, "; port-s=");
    icf_port_sprintf( tmpString, "%d", p_sec_params->port_s);
    icf_port_strcat(pString, tmpString);

    return;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_sec_verify_string
 *
 * DESCRIPTION:     This function will create the string (from the security 
 *                    param structure) that will be inserted in the Security 
 *                    Verify Header in the outgoing Protected Messages  
 *
 ******************************************************************************/
icf_return_t    icf_ssa_get_sec_verify_string (
        INOUT         icf_ssa_pdb_st            *p_ssa_pdb,
        INOUT         icf_uint8_t                **p_str,
        INOUT         icf_ipsec_sa_context_st    *p_sec_context
        )
{
    /* local variables */
    icf_error_t                ecode = ICF_NULL;
    icf_return_t                ret_val    = ICF_SUCCESS;
    icf_uint8_t                tmpStr[50];

    /* get memory for the the p_str argument */
    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
         ICF_MAX_SEC_HDR_LEN,
         ICF_MEM_COMMON, 
         (icf_void_t*)(*p_str),
         ICF_RET_ON_FAILURE, 
         &ecode, ret_val);

    /* make the string to be inserted in the Security Param header */
    icf_port_strcpy((*p_str), "ipsec-3gpp; q=");
    icf_port_sprintf(tmpStr, "%s", p_sec_context->p_q_value);
    icf_port_strcat((*p_str), tmpStr);

    icf_port_strcat((*p_str), "; alg=");
    icf_port_sprintf(tmpStr,"%s",p_sec_context->p_integrity_algo);    
    icf_port_strcat((*p_str), tmpStr);

    if (ICF_NULL != p_sec_context->p_encryption_algo)
    {
        icf_port_strcat((*p_str), "; ealg=");
        icf_port_sprintf(tmpStr,"%s",p_sec_context->p_encryption_algo);    
        icf_port_strcat((*p_str), tmpStr);
    }

    icf_ssa_get_sec_string((*p_str), 
        p_sec_context->p_proxy_security_params);            
    
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_fetch_sa_context
 *
 * DESCRIPTION:     This function will fetch a SA context for an incoming 
 *                    message from the network. The fetched SA context and the 
 *                    corresponding REGM context are save in the SSA PDB for 
 *                    future use in SSA processing of the message. 
 *
 ******************************************************************************/
icf_return_t    icf_ssa_fetch_sa_context(
        INOUT   icf_ssa_pdb_st  *p_ssa_pdb,
        INOUT   icf_nw_interface_info_st    *p_nw_info
)
{
    /* local variables */
    icf_boolean_t            sa_exists = ICF_FALSE;
    icf_uint8_t                node_count =0;
    icf_rgm_context_st        *p_rgm_context = ICF_NULL;
    icf_config_data_st        *p_dbm_cfg_data = ICF_NULL;
    icf_return_t                ret_val = ICF_SUCCESS;
    
    
    ret_val = icf_dbm_get_module_glb_data(
                 p_ssa_pdb->p_glb_pdb,
                 (icf_int_module_id_t)(ICF_INT_MODULE_CFG),
                 (icf_void_t **)(&p_dbm_cfg_data),
                 p_ssa_pdb->p_ecode);     
             
    ICF_ASSERT(
        p_ssa_pdb->p_glb_pdb,(ICF_NULL != p_dbm_cfg_data))

    for (node_count =0; 
        node_count < p_dbm_cfg_data->max_registration_req; 
        node_count ++) 
    {
        /* currently there will be only one RGM context */ 
        if (ICF_SUCCESS == icf_dbm_get_used_rgn_blk(
                p_ssa_pdb->p_glb_pdb,
                (icf_uint8_t)node_count,
                &p_rgm_context,
                p_ssa_pdb->p_ecode))
        {
            /* check if an SA exists in the REGM ctxt */
            if ((ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context) ||
                (ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context))
            {
                sa_exists = ICF_TRUE;
            }
            /* check if the message is recvd on a valid SA either old or new */
            if ((ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context) && 
                (p_nw_info->remote_port_num == 
                ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context->p_proxy_security_params->port_s))
            {
                /* message revd on old SA */
                p_ssa_pdb->p_sa_context = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context;
                p_ssa_pdb->p_rgm_context = p_rgm_context;
                break;
            }
            else  /* check for new SA context */
            if ((ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context) && 
                (p_nw_info->remote_port_num == 
                ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->p_proxy_security_params->port_s))
            {
                p_ssa_pdb->p_sa_context =  ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
                p_ssa_pdb->p_rgm_context = p_rgm_context;
                break;
            }
        }
        else
        {
            ret_val = ICF_FAILURE;
            break;
        }
    } /* for loop ends here */
    /* if a SA exists and the message is recvd on an invalid SA, we need to 
     * return failure
     */
    if ((ICF_FAILURE != ret_val) && (sa_exists == ICF_TRUE ) &&
        (ICF_NULL == p_ssa_pdb->p_sa_context))
    {
        /* error except for error responses */
        ret_val = ICF_FAILURE;
    }
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_set_sa_ctxt_for_otg_req
 *
 * DESCRIPTION:     Each new transaction will be sent on the network using the 
 *                    new SA if it is active by then. Incase the new SA is not 
 *                    active by then, the new transaction will be sent out on the 
 *                    old SA 
 *                    The function would be invoked each time a non-Register 
 *                    request is being sent out from ICF. For a register request 
 *                    the RGM context would be fetched from the SSA context 
 *                    itself.
 *                    The extracted SA context and the corresponding REG context
 *                    will be saved in the SSA PDB for future reference.
 *
 ******************************************************************************/
icf_return_t    icf_ssa_set_sa_ctxt_for_otg_req(
        INOUT   icf_ssa_pdb_st  *p_ssa_pdb,
        INOUT   icf_address_st  *p_address
)
{
    /* local variables */
    icf_rgm_context_st    *p_rgm_context = ICF_NULL;
    icf_return_t            ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st        *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;

    /* fetch the corresponding REGM context for this context */
    if (ICF_FAILURE == icf_rgm_fetch_ctxt_for_uri(
            p_ssa_pdb->p_glb_pdb,
            p_address,
            &p_rgm_context,
            p_ssa_pdb->p_ecode)) 
    {
        /* Error */
        ret_val = ICF_FAILURE;
    }

    /* each new outgoing transaction will first be attempted on the NEW SA. 
     * But if the SA is not yet active, the message will be sent on the 
     * old SA.This will happen only incase of parallel registration 
     */
    if ((ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context) && /* SA exists */
        (ICF_TRUE == ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->is_active))
    {
        /* save the SA context and the REGM context pointers in the
         * SSA PDB for future reference
         */
        p_ssa_pdb->p_sa_context = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
        p_ssa_pdb->p_rgm_context = p_rgm_context ;

        /* also set these pointers in the SSA ctxt. Required incase of 
         * transaction time-out scenarios */
        p_ssa_ctxt->ssa_sa_context.p_sa_context = 
            ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
        p_ssa_ctxt->ssa_sa_context.p_rgm_context = 
            p_rgm_context;
    }
    else if ((ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context) && 
        (ICF_TRUE == ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context->is_active))
    {
        /* save the SA context and the REGM context pointers in the
         * SSA PDB for future reference
         */
        p_ssa_pdb->p_sa_context = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context;
        p_ssa_pdb->p_rgm_context = p_rgm_context ;

        /* also set these pointers in the SSA ctxt. Required incase of 
         * transaction time-out scenarios */
        p_ssa_ctxt->ssa_sa_context.p_sa_context = 
            ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context;
        p_ssa_ctxt->ssa_sa_context.p_rgm_context = 
            p_rgm_context;
    }
    else /* if SA doens't exist */
    if (ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context) 
    {
        p_ssa_pdb->p_sa_context = ICF_NULL;
        p_ssa_pdb->p_rgm_context = p_rgm_context ;
    }
    
    return ret_val;
}


/*******************************************************************************
 * FUNCTION:        icf_ssa_rgm_delete_old_sa_ind
 *
 * DESCRIPTION:     This utility function will be invoked from within all 
 *                    UACCallbacks that handle responses from the network, like 
 *                    sdf_ivk_txnComplete. The function will check the count of 
 *                    the active transactions on a give SA. If the count is 0, 
 *                    SSA will send an indication to REGM to delete the SA 
 *                    
 *                    This indication will be sent to REGM incase of transaction 
 *                    completion of non-REGISTER transactions. For REGISTER 
 *                    transactions, the REGM internally takes care to delete the 
 *                    old SA when there no pending transactions are active on it.
 *                    
 *                    This indication is also sent to RGM after the 
 *                    send_call_to_peer() is successful for an outgoing response 
 *                    to the received non-Invite transaction or 200 OK for the 
 *                    Invite transaction that was originally initiated by ICF. 
 *
 ******************************************************************************/
icf_return_t    icf_ssa_rgm_delete_old_sa_ind(
        INOUT   icf_ssa_pdb_st  *p_ssa_pdb        
)
{
    /* local variables */
    icf_uint8_t        tmpString[256] = "\0";
    /*icf_ssa_ctxt_st  *p_ssa_ctxt = */
    /*    (icf_ssa_ctxt_st*)(p_call_obj->pAppData->pData);*/
    
    /* by now we have extracted the regm context the associated SA with
     * the transaction. These pointers are saved in the ssa_pdb. */
    
    if ((ICF_NULL != p_ssa_pdb->p_sa_context) &&
       (p_ssa_pdb->p_sa_context == ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context))
    {
      /* check if the SA is old SA */
      /* send an internal message to RGM */
        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = 
                                ICF_DELETE_OLD_SA;
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 
            ICF_PORT_SIZEOF(icf_rgm_context_st);

        /* Populate the internal message payload */
        p_ssa_pdb->p_internal_msg->p_msg_data = 
            (icf_uint8_t *)p_ssa_pdb->p_rgm_context;

        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CFG;
    
        icf_ssa_get_sec_string (tmpString, 
            p_ssa_pdb->p_sa_context->p_ue_security_params);

        ICF_PRINT(("\nDeleting old SA \n%s", tmpString));

        /*Send the message to original module*/
        icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);

    }
    /* if the saved SA context is the new context, then this trigger need not
     * be sent to REGM
     */
    return ICF_SUCCESS;
}


/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_parse_sec_serv_header
 ** DESCRIPTION:  This function parses the received Security-Server header 
 **               in the received 401 from the network. The header is parsed
 **               the received params are saved in the reg context.
 **
 ***************************************************************************/
icf_return_t icf_ssa_parse_sec_serv_header(
        INOUT  icf_ssa_pdb_st           *p_ssa_pdb,
        INOUT  icf_ipsec_sa_context_st  *p_sa_context,
        INOUT  Sdf_st_callObject             *p_call_obj,
        INOUT  SipHeader                     dHeader)

{
    /* local variables */
    icf_return_t         ret_val = ICF_SUCCESS;
    icf_int8_t          *pToken = ICF_NULL;
    SIP_S8bit                *pBuffer = SIP_NULL, *pTmpBuffer = ICF_NULL;
    SIP_S8bit                *pAllocBuff = ICF_NULL;

    icf_ipsec_security_params_st *p_proxy_security_params = ICF_NULL;
/* To remove warning */
     p_call_obj=p_call_obj;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
            
    
    pBuffer = (((SipUnknownHeader *)
#ifdef ICF_WITH_MUATK_2_2
        (dHeader.pHeader))->pStr2);
#else
        (dHeader.pHeader))->pBody);
#endif
        
    pTmpBuffer = icf_port_strdup(pBuffer);    
    /* check if q value is received in the incoming sec-server header */    
    pToken = icf_port_strtokr(pBuffer,"q", &pBuffer);
    if (ICF_NULL != pToken)
    {    
        /* get the value of q value */
        icf_ssa_get_sec_value(pBuffer, &pToken);
        p_sa_context->p_q_value = icf_port_strdup(pToken);
    }
    /* reassign the tmpBuf pointer to pBuff, since the order of these params 
     * is not fixed in the header */
    pBuffer = icf_port_strdup(pTmpBuffer);
    pAllocBuff = pBuffer;

    /* now get the algo from the received header */
    pToken = icf_port_strstr(pBuffer, "alg");
    pBuffer = pToken;

    if (ICF_NULL != pToken)
    {
        icf_uint8_t      *pTmpToken = ICF_NULL;

        icf_ssa_get_sec_value(pBuffer, &pToken);
        if (ICF_NULL != (pTmpToken = 
                icf_port_strtokr(pToken, ",", &pBuffer)))
        {
            p_sa_context->p_integrity_algo = icf_port_strdup(pTmpToken);
        }
        else
        {
            p_sa_context->p_integrity_algo = icf_port_strdup(pToken);
        }
    }
    else
    {
        ret_val = ICF_FAILURE ;
    }
    if (ICF_SUCCESS == ret_val)
    {
        /* reassign the tmpBuf pointer to pBuff, since the order of these 
         * params is not fixed in the header */
        
        icf_port_strfree(pAllocBuff);
        pAllocBuff = ICF_NULL;

        pBuffer = icf_port_strdup(pTmpBuffer);
        pAllocBuff = pBuffer;

        /* get the ealgo if present in the received header */
        pToken = icf_port_strstr(pBuffer,"ealg");
        pBuffer = pToken;
        if (ICF_NULL != pToken)
        {
            icf_uint8_t      *pTmpToken = ICF_NULL;
            icf_ssa_get_sec_value(pBuffer,
                        &pToken);
            p_sa_context->p_encryption_algo = icf_port_strdup(pToken);
            if (ICF_NULL != (pTmpToken = 
                icf_port_strtokr(pToken, ",",&pToken)))
            {
                p_sa_context->p_encryption_algo = icf_port_strdup(pTmpToken);
            }
            else
            {
                p_sa_context->p_encryption_algo = icf_port_strdup(pToken);
            }
        }
    }
    /* get the spi-c if present in the received header. This is mandatory, if 
     * not present parsing fails */
    if (ICF_SUCCESS == ret_val)
    {
        /* reassign the tmpBuf pointer to pBuff, since the order of these 
         * params is not fixed in the header */
        icf_port_strfree(pAllocBuff);
        pAllocBuff = ICF_NULL;

        pBuffer = icf_port_strdup(pTmpBuffer);
        pAllocBuff = pBuffer;
        
        pToken = icf_port_strstr(pBuffer,"spi-c");
        pBuffer = pToken;

        if (ICF_NULL != pToken)
        {
            icf_ssa_get_sec_value(pBuffer, &pToken);
            /* allocate memory to store the server security params */
            ICF_MEMGET(
                p_ssa_pdb->p_glb_pdb,
                ICF_PORT_SIZEOF(icf_ipsec_security_params_st),
                ICF_MEM_COMMON,
                p_proxy_security_params,
                ICF_RET_ON_FAILURE,
                p_ssa_pdb->p_ecode,
                ret_val);
            p_proxy_security_params->spi_c = icf_port_atoi(pToken);
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
    }
    /* get the spi-s if present in the received header. This is mandatory, if 
     * not present parsing fails  */
    if (ICF_SUCCESS == ret_val)
    {
        /* reassign the tmpBuf pointer to pBuff, since the order of these 
         * params is not fixed in the header */
        icf_port_strfree(pAllocBuff);
        pAllocBuff = ICF_NULL;

        pBuffer = icf_port_strdup(pTmpBuffer);
        pAllocBuff = pBuffer;

        pToken = icf_port_strstr(pBuffer,"spi-s");
        pBuffer = pToken;

        if (ICF_NULL != pToken)
        {
            icf_ssa_get_sec_value(pBuffer, &pToken);
            p_proxy_security_params->spi_s = icf_port_atoi(pToken);
        }
        else
        {
            /* delete the memory allocated for the security params */    
            ICF_MEMFREE(
                  p_ssa_pdb->p_glb_pdb,
                  p_proxy_security_params,
                  ICF_MEM_COMMON,
                  p_ssa_pdb->p_ecode,
                  ret_val);

            ret_val = ICF_FAILURE;
        }
    }
    /* get the port-c if present in the received header. This is mandatory, if 
     * not present parsing fails  */
    if (ICF_SUCCESS == ret_val)
    {
        /* reassign the tmpBuf pointer to pBuff, since the order of these 
         * params is not fixed in the header */
        icf_port_strfree(pAllocBuff);
        pAllocBuff = ICF_NULL;

        pBuffer = icf_port_strdup(pTmpBuffer);
        pAllocBuff = pBuffer;

        pToken = icf_port_strstr(pBuffer,"port-c");
        pBuffer = pToken ;

        if (ICF_NULL != pToken)
        {
            icf_ssa_get_sec_value(pBuffer, &pToken);
            p_proxy_security_params->port_c = icf_port_atoi(pToken);
        }
        else
        {
            /* delete the memory allocated for the security params */    
            ICF_MEMFREE(
                  p_ssa_pdb->p_glb_pdb,
                  p_proxy_security_params,
                  ICF_MEM_COMMON,
                  p_ssa_pdb->p_ecode,
                  ret_val);

            ret_val = ICF_FAILURE;
        }
    }
    /* get the port-s if present in the received header. This is mandatory, if 
     * not present parsing fails  */
    if (ICF_SUCCESS == ret_val)
    {
        /* reassign the tmpBuf pointer to pBuff, since the order of these 
         * params is not fixed in the header */
        icf_port_strfree(pAllocBuff);
        pAllocBuff = ICF_NULL;

        pBuffer = icf_port_strdup(pTmpBuffer);
        pAllocBuff = pBuffer;

        pToken = icf_port_strstr(pBuffer,"port-s");
        pBuffer = pToken;

        if (ICF_NULL != pToken)
        {
            icf_ssa_get_sec_value(pBuffer,
                        &pToken);
            p_proxy_security_params->port_s = icf_port_atoi(pToken);
        }
        else
        {
            /* delete the memory allocated for the security params */    
            ICF_MEMFREE(
                  p_ssa_pdb->p_glb_pdb,
                  p_proxy_security_params,
                  ICF_MEM_COMMON,
                  p_ssa_pdb->p_ecode,
                  ret_val);

            ret_val = ICF_FAILURE;
        }
    }

    if (ICF_SUCCESS == ret_val)
    {
        p_sa_context->p_proxy_security_params = p_proxy_security_params;
        p_proxy_security_params = ICF_NULL;
    }

    if (pTmpBuffer)
        icf_port_strfree(pTmpBuffer);
    if (pAllocBuff)
        icf_port_strfree(pAllocBuff);
    return ret_val;
}


/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_sec_value
 ** DESCRIPTION:  
 **
 ***************************************************************************/
icf_void_t icf_ssa_get_sec_value(
    INOUT     SIP_S8bit        *pBuffer,
    INOUT     icf_int8_t    **p_pToken)
{
    /* local variables */
    icf_uint8_t    seps[] = ";", *pToken = ICF_NULL;
    icf_uint8_t  count =0;


    /*count = icf_port_strlen(pToken);*/
    while(pBuffer[count] != '=')
    {
        count ++;
    }
    count += 1;
    while (pBuffer[count] == ' ')
    {
        count ++;
    }    
    
    pBuffer = pBuffer+count;

    pToken = icf_port_strtok(pBuffer, seps);
    *p_pToken = pToken;

    return ;
}

#if 0
/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_sa_conn_db
 ** DESCRIPTION: 
 **
 **************************************************************************/
icf_return_t    icf_ssa_get_sa_conn_db(
    INOUT     icf_ssa_glb_data_st    *p_ssa_glb_data,
    INOUT     icf_uint16_t            port_num,
    INOUT     icf_uint8_t            *pIndex)
{
    /* local variables */
    icf_return_t        ret_val = ICF_SUCCESS;
    icf_uint8_t        count =0;

    for (count =0; count <ICF_MAX_SA_CONNECTIONS; count++)
    {
        if (port_num == p_ssa_glb_data->sa_conn_db_node[count].prot_port_num)
        {
            *pIndex = count;
            break;
        }
    }

    if (ICF_MAX_SA_CONNECTIONS == count)
    {
        *pIndex = ICF_MAX_SA_CONNECTIONS;
        ret_val = ICF_FAILURE;
    }

    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_sa_tcp_conn_db
 ** DESCRIPTION: 
 **
 **************************************************************************/
icf_return_t    icf_ssa_get_sa_tcp_conn_db(
    INOUT     icf_ssa_glb_data_st    *p_ssa_glb_data,
    INOUT     icf_uint16_t            port_num,
    INOUT     icf_uint8_t            *pIndex)
{
    /* local variables */
    icf_return_t        ret_val = ICF_SUCCESS;
    icf_uint8_t        count =0;

    for (count =0; count <ICF_MAX_SA_CONNECTIONS; count++)
    {
        if (port_num == p_ssa_glb_data->sa_tcp_conn_db_node[count].
                            prot_port_num)
        {
            *pIndex = count;
            break;
        }
    }

    if (ICF_MAX_SA_CONNECTIONS == count)
    {
        *pIndex = ICF_MAX_SA_CONNECTIONS;
        ret_val = ICF_FAILURE;
    }

    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_sa_conn_db_node_index
 ** DESCRIPTION:  
 **
 ***************************************************************************/
icf_return_t icf_ssa_get_sa_conn_db_node_index (
    INOUT     icf_ssa_pdb_st    *p_ssa_pdb,
    INOUT     icf_uint8_t        *pIndex
    )
{
    /* local variables */
    icf_return_t        ret_val = ICF_FAILURE;
    icf_uint8_t        count =0;
    
    *pIndex = ICF_MAX_SA_CONNECTIONS;

    do
    {
        if (ICF_INVALID_FD == 
        p_ssa_pdb->p_ssa_glb_data->sa_conn_db_node[count].fd)
        {
            *pIndex = count;
            ret_val = ICF_SUCCESS;
            break;
        }
        count += 1;
    } while (count < ICF_MAX_SA_CONNECTIONS);
    
    return ret_val;
}


/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_sa_tcp_conn_db_node_index
 ** DESCRIPTION:  
 **
 ***************************************************************************/
icf_return_t icf_ssa_get_sa_tcp_conn_db_node_index (
    INOUT     icf_ssa_pdb_st    *p_ssa_pdb,
    INOUT     icf_uint8_t        *pIndex
    )
{
    /* local variables */
    icf_return_t        ret_val = ICF_FAILURE;
    icf_uint8_t        count =0;
    
    *pIndex = ICF_MAX_SA_CONNECTIONS;

    do
    {
        if (ICF_INVALID_FD == 
        p_ssa_pdb->p_ssa_glb_data->sa_tcp_conn_db_node[count].fd)
        {
            *pIndex = count;
            ret_val = ICF_SUCCESS;
            break;
        }
        count += 1;
    } while (count < ICF_MAX_SA_CONNECTIONS);
    
    return ret_val;
}
#endif

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_checkNdeleteRouteHdr
 ** DESCRIPTION:  The function is invoked to delete the existing Route Set 
 **               from the Message, Persistent Route Set and Pre-Loaded
 **               Route Set and then create a new Route Set for sending
 **               the Register on the SA and protected ports.
 **
 ***************************************************************************/
icf_result_t   icf_ssa_checkNdeleteRouteHdr(
          Sdf_st_callObject           *pCallObj)
{
    /* local variable */
    Sdf_st_error                SdfErr;
/*    Sdf_st_listIterator         dListIterator;*/
    Sdf_st_initData *pInitData = Sdf_co_null;


    /*sip_getHeaderCount(pCallObj->pUacTransaction->pSipMsg,SipHdrTypeRoute ,\*/
/*            &dCount,(SipError *)&(SdfErr.stkErrCode));*/

   /* if(dCount != 0)*/
    {
        /* Remove preloaded reoute info from Call Object profile (if any) */
        sip_deleteAllHeaderType (pCallObj->pUacTransaction->pSipMsg, \
                SipHdrTypeRoute,\
                (SipError *)&(SdfErr.stkErrCode));

        /* Also Delete the Preloaded Route Info from the Init Data so that
         * for other transaction like cancel It will not be filled and
         * the message wont be sent to the outbound proxy
         */
        if(((sdf_ivk_uaGetInitDataFromCallObject(pCallObj, &pInitData, \
                            &SdfErr)) == Sdf_co_success) && 
                (pInitData != Sdf_co_null))
        {
            sdf_listDeleteAll(&(pInitData->slPreLoadedRoute), &SdfErr);
            sdf_ivk_uaFreeInitData(pInitData);

        } /* pErr)) == Sdf_co_sucicf_ssa_copy_conn_fd_to_callobcess) */

        /* Delete the Route header information from the common info */
        sdf_listDeleteAll(&(pCallObj->pCommonInfo->slInvRoute),&SdfErr);
        if( pCallObj->pCommonInfo->dPreloadedSet == Sdf_co_true)
        {
            pCallObj->pCommonInfo->dPreloadedSet = Sdf_co_false;
        }

        /* Delete the Route header From Persistent Headers */
        sdf_ivk_uaDeleteHeaderListByCorrelation( \
                &(pCallObj->slPersistentHeaders), 
                "uat-routeset", 
                &SdfErr);
    }
    return ICF_SUCCESS;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_sa_set_ssa_ctxt_node
 ** DESCRIPTION:  The function will set the SSA context to the TCP conn DB
 **               when the same connection is shared by more than one SSA 
 **               contexts 
 **
 ***************************************************************************/
icf_void_t   icf_ssa_sa_set_ssa_ctxt_node(
        INOUT    icf_ssa_pdb_st   *p_ssa_pdb )
{
    /* local variables */
    icf_uint32_t      count =0;
    icf_ssa_ctxt_st      **pp_ssa_ctxt_local= ICF_NULL;
    
    while (count < ICF_MAX_NO_OF_PERSISTENT_CONNECTIONS) 
    {
        pp_ssa_ctxt_local = 
            &(p_ssa_pdb->p_ssa_glb_data->ssa_tcpm_conn_db[\
            p_ssa_pdb->ssa_conn_db_index].p_ssa_ctxt) + count;
        
        if(ICF_NULL != (*pp_ssa_ctxt_local))
        {
            count +=1;
        }
        else
        {
            *pp_ssa_ctxt_local= p_ssa_pdb->p_ssa_ctxt;
            break;
        }
    }
   
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_open_sa_server
 ** DESCRIPTION:  The function will be invoked on request from REGM (after SA
 **               creation the first time). Here we will open both TCP and
 **               UDP servers on the protected ports
 **
 ***************************************************************************/
icf_return_t icf_ssa_open_sa_server(
    INOUT    icf_ssa_pdb_st   *p_ssa_pdb)
{
    /* local variables */
    
    icf_uint8_t              trans_addr[ICF_MAX_STR_LEN] = "\0";
    icf_uint16_t             self_prot_port =0;
    icf_uint16_t             fd_id = ICF_INVALID_FD ;
    icf_glb_pdb_st           *p_glb_pdb = p_persistent_glb_pdb;
    icf_transport_address_st *p_transport_address = ICF_NULL;
    icf_return_t             ret_val = ICF_SUCCESS;

  
   ICF_PRINT(("\nEntered Function: icf_ssa_open_sa_server"));
        
    p_transport_address = &(p_ssa_pdb->p_glb_cfg_data->self_ip_address);
    if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
        p_transport_address->addr.addr_type)
    {
        icf_port_strcpy(trans_addr, 
            p_transport_address->addr.addr.domain.str);
    }
    else 
    {
        icf_ssa_convert_to_IP_addr(p_transport_address,
            trans_addr);
    }
    
    /* TCP server will be openned only if the transport mode is configured
     * to TCP or BOTH 
     */
    if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_glb_cfg_data->self_mode)||
       (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_glb_cfg_data->self_mode))
    {
         /* incase of TCP, we will bind the server port with self server port
          * and then later bind it to the self client port if SA exists */
        self_prot_port = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
            p_ue_security_params->port_s;

        /* we will open TCP and UDP server ports for protected self ports */
        /* open TCP servers fisrt */
        if ( ICF_FAILURE == icf_port_open_channel( 
            self_prot_port,
            ICF_TRANSPORT_TYPE_TCP, 
            ICF_TRUE, 
            trans_addr, 
            (icf_uint32_t*)&fd_id, 
            p_ssa_pdb->p_ecode))
        {
            ICF_PRINT(("[SSA]:Failure in TCP open server for PROT Port\n"));
            ret_val = ICF_FAILURE ;
        }
        
        /* save the FD in ssa_sa_tcp_conn_db node in ssa_pdb */
        p_ssa_pdb->p_ssa_glb_data->
            sa_conn_db_node[ICF_SSA_TCP_SA_CONNECTION].fd = fd_id;
        p_ssa_pdb->p_ssa_glb_data->
            sa_conn_db_node[ICF_SSA_TCP_SA_CONNECTION].prot_port_num = 
            self_prot_port;
        
        /* this fd needs to be set in the read fd set */
        icf_port_set_sa_fd(
            p_glb_pdb->p_glb_data->p_glb_port_info,
            ICF_TRANSPORT_TYPE_TCP,
            fd_id);
    }
    /* open UDP server if UDP is configured in the system */
    if ((ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->p_glb_cfg_data->self_mode) ||
       (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_glb_cfg_data->self_mode))
    {
        /* if SA exists */
        self_prot_port = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
            p_ue_security_params->port_s;

        /* open UDP server port */
        if ( ICF_FAILURE == icf_ssa_sa_open_udp_channel( 
            self_prot_port,
            ICF_TRANSPORT_TYPE_UDP, 
            trans_addr, 
            (icf_uint32_t*)&fd_id, 
            p_ssa_pdb->p_ecode))
        {
            ICF_PRINT(("[SSA]:Failure in UDP open server for PROT Port\n"));
            ret_val = ICF_FAILURE ;
        }
        
        ICF_PRINT(("\nSSA:UDP SERVER port for SA opened successfully "));
        /* save the FD in ssa_sa_tcp_conn_db node in ssa_pdb */
        p_ssa_pdb->p_ssa_glb_data->
            sa_conn_db_node[ICF_SSA_UDP_SA_CONNECTION].fd = fd_id;
        p_ssa_pdb->p_ssa_glb_data->
            sa_conn_db_node[ICF_SSA_UDP_SA_CONNECTION].prot_port_num = 
            self_prot_port;
        
        /* this fd needs to be set in the read fd set */
        icf_port_set_sa_fd(
            p_glb_pdb->p_glb_data->p_glb_port_info,
            ICF_TRANSPORT_TYPE_UDP,
            fd_id);
    }
    return ret_val;
}

icf_return_t icf_ssa_close_sa_server(
    INOUT    icf_ssa_pdb_st   *p_ssa_pdb)
{
    ICF_PRINT(("\n:SSA: Entered Function: icf_ssa_close_sa_server"));

    /* we need to close the servers that we have opened in out system
     * for SA ports
     */
    icf_es_port_close_sa_servers(
        p_ssa_pdb->p_glb_pdb->p_glb_data->p_glb_port_info);

    return ICF_SUCCESS;    
}
#endif /* ICF_IPSEC_ENABLED */

/*******************************************************************************
 * 
 * FUNCTION:        icf_ssa_send_authorized_req
 *
 * DESCRIPTION:     This function constructs and sends req with 
 *                  Authentication info on network. DIGEST and basic schemes are
 *                  supported.
 *                  1.Initialize the UAC auth info list 
 *                  2.Iterate through the authorization params list
 *                  stored in the SSA ctxt.This list was returned when
 *                  the PROXY/REGISTRAR/UAS challenged us with 401/407 response 
 *                  asking for authorization parameters.
 *                  3.If the scheme present in the elements of this list
 *                  is "Digest" or "Basic",populate the authorization parameters from
 *                  that configured on the line and append the same to the
 *                  UAC auth info list initialized earlier. 
 *                  4. Invoke sdf_ivk_uaFormRequestWithAuthorization with the
 *                  authorization paramters and send the request to peer.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_authorized_req(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_return_t               ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st            *p_ssa_ctxt = ICF_NULL;
    Sdf_st_overlapTransInfo       *p_overlap_trans_info = Sdf_co_null;
    Sdf_st_error                  sdf_error , *p_err = &sdf_error;
    Sdf_ty_slist                  uac_auth_info_list;
    Sdf_ty_u32bit                 index = 0;
    Sdf_ty_u32bit                  new_cnonce_int = 0;
    icf_uint8_t                      cnonce_str[ICF_MAX_STR_LEN] = "\0";    
    icf_address_st             *p_user_address = ICF_NULL;
    icf_string_st		 authentication_key,
                         authentication_password;  
    Sdf_st_headerList    *pHeaderList = Sdf_co_null;
    SipHeader            *p_event_hdr = Sdf_co_null, \
                         *p_sub_state_hdr = Sdf_co_null, \
                         *p_content_type_hdr = Sdf_co_null;
    Sdf_ty_slist          slHeaderList;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt;

    /* Fix For SPR:19788*/
    if (ICF_NULL == p_ssa_ctxt)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:SSA CTX is NULL in icf_ssa_send_authorized_req\n"));
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;        
    }

    /* Initialize the uac auth info list */
    if (Sdf_co_fail == sdf_listInit( &uac_auth_info_list,\
             __sdf_fn_uaFreeUacAuthInfo, Sdf_co_false, &sdf_error))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        /* Fixed for SPR 16051: Here we fetch the user db node 
           corresponding to the user in ssa_ctxt so that we can
           use the auth key and passwd from the user_db */
        if(p_ssa_ctxt->p_call_ctxt)
        {
            p_user_address = 
				&p_ssa_ctxt->p_call_ctxt->local_address;
		}
		else if(p_ssa_ctxt->p_rgm_ctxt)
		{
		    p_user_address = 
				&p_ssa_ctxt->p_rgm_ctxt->rgm_user_address;		
		}
		else if(p_ssa_ctxt->p_sic_ctxt)
		{
		    p_user_address = 
				p_ssa_ctxt->p_sic_ctxt->p_user_address;		
		}

	    /* Fixed for SPR 16051: Here we fetch the credentials 
		from either the user_db coress to rgm_user_address 
		or from line data depending on the opetion PA has
		selected */
	    if(ICF_NULL != p_user_address)
		{
			ret_val = icf_cmn_get_auth_params(
					p_ssa_pdb->p_glb_pdb, 
					p_user_address,
					p_ssa_pdb->p_line_data->line_id,
					&authentication_key,
					&authentication_password);
		}
		else
		{
			ret_val = ICF_FAILURE;
		}

		if(ICF_FAILURE == ret_val)
		{
			return ret_val;
		}

        /* Auth info list is intialized,  start processing  the auth param
         * list one by one*/
        for (index = 0; index < p_ssa_ctxt->auth_params_list_size; index++)
        {
            Sdf_st_authenticationParams     *p_auth_params = Sdf_co_null;
            Sdf_st_uacAuthInfo              *p_uac_auth_info = Sdf_co_null;
           
            /* Get the auth param list element from ssa context 
             * TBD: DOES it get incremented in case of multiple 401/407 */ 
            if (Sdf_co_fail == sdf_listGetAt( p_ssa_ctxt->p_auth_params_list,\
                  index, (Sdf_ty_pvoid *)&p_auth_params, &sdf_error))
            {
                sdf_listDeleteAll(&uac_auth_info_list,p_err);

                ret_val = ICF_FAILURE;
                break;
            }
            else if((0 == Sdf_mc_strcasecmp(p_auth_params->pScheme, "Digest"))||
                    (0 == Sdf_mc_strcasecmp(p_auth_params->pScheme, "Basic")))
            {
                /* initialize uac auth info list element */
                if (Sdf_co_fail == sdf_ivk_uaInitUacAuthInfo(\
                            &p_uac_auth_info,p_err))
                {
                    sdf_listDeleteAll(&uac_auth_info_list,p_err);
                    ret_val = ICF_FAILURE;
                    break;
                }

                /* Set UserName and Password */
                Sdf_mc_strdup( p_uac_auth_info->pUserName,\
                           authentication_key.str);

                Sdf_mc_strdup( p_uac_auth_info->pPassword,
                        authentication_password.str);

                /* process qop */
                if (p_auth_params->pQop != Sdf_co_null)
                {
                    icf_string_st           temp_nc;
                    icf_uint8_t             *p_temp = ICF_NULL;
                    icf_boolean_t           send_nonce = ICF_TRUE;
                    
                    p_temp = (icf_uint8_t *)p_auth_params->pQop;
                    
                    if (ICF_NULL != icf_port_strstr((const icf_int8_t *)p_temp, (const icf_int8_t *)"auth-int"))
                    {
                        Sdf_mc_strdup(p_uac_auth_info->pQop, "auth-int");
                    }
                    else if (ICF_NULL != icf_port_strstr((const icf_int8_t *)p_temp, (const icf_int8_t *)"auth"))
                    {
                        Sdf_mc_strdup(p_uac_auth_info->pQop, "auth");
                    }
                    else
                    {
                        Sdf_mc_strdup(p_uac_auth_info->pQop, "");
                        send_nonce = ICF_FALSE;
                    }                 
                    
                    if (ICF_TRUE == send_nonce)
                    {
                        /* cnonce */
                        /* This function is invoked when a request was
                         * challenged and ICF is sending the request again with
                         * Auth params. So every time this function is
                         * invoked, cnonce will be generated afresh.
                         */
                        if (Sdf_co_fail == 
                          sdf_fn_uaGetCurrentTimeInMicroSecs(&new_cnonce_int))
                        {
                            sdf_listDeleteAll(&uac_auth_info_list,p_err);
                            ret_val = ICF_FAILURE;
                            break;
                        }
                        icf_port_sprintf((icf_int8_t *)cnonce_str,"%u", new_cnonce_int);
                        Sdf_mc_strdup(p_uac_auth_info->pCnonce, cnonce_str);

                        /* nc OR nonce-count */
                        icf_port_memset((icf_void_t *)&temp_nc, 0, 
                            ICF_PORT_SIZEOF(icf_string_st));
                    
                        /* Convert the nc OR nonce_count to string */
                        (p_ssa_ctxt->nc)++;
                        icf_ssa_compute_nc(p_ssa_pdb->p_glb_pdb,
                            p_ssa_ctxt, &temp_nc, 
                            p_ssa_ctxt->nc,
                            p_ssa_pdb->p_ecode);
                    
                        if (temp_nc.str_len)
                        {
                            Sdf_mc_strdup(
                                p_uac_auth_info->pNonceCount,
                                temp_nc.str);
                        }
                    } /* if (send_nonce) */
                } /* if (p_auth_params->pQop) */
            
                /* add the uac info element to list */
                if (Sdf_co_fail == sdf_listAppend( &uac_auth_info_list,\
                            (Sdf_ty_pvoid)p_uac_auth_info, p_err))
                {
                    sdf_listDeleteAll(&uac_auth_info_list,p_err);

                    ret_val = ICF_FAILURE;
                    break;
                }
            } /* End if(p_auth_params->pScheme) */
            else
            {
                /* Authentication scheme not supported */
                sdf_listDeleteAll(&uac_auth_info_list,p_err);
                ret_val = ICF_FAILURE;
                break;

            } /* End else(p_auth_params->pScheme) */
        } /* End for(index) */

        /* TBD: Check for IPPSKT_FAILURE */ 
        /*
         * Now form a request with authorization. The list of
         * authentication params and uac auth info structures
         * are passed to this API
         */
        /* Set the transport mode in local variable */

        if(ICF_FAILURE == icf_ssa_process_before_sending_auth_req(
                  p_ssa_pdb,&p_ssa_ctxt->p_call_obj,&p_overlap_trans_info))
        {
            sdf_listDeleteAll(&uac_auth_info_list,p_err);
            ret_val = ICF_FAILURE;
        }
        else if(sdf_ivk_uaAddExtraHeaders(p_ssa_ctxt->p_call_obj,
                   p_overlap_trans_info, (icf_int8_t *)p_ssa_pdb->p_method, p_err) 
                            == Sdf_co_fail)
        {
            ret_val = ICF_FAILURE;
        }
        /*spr 16926 Avoiding copy of SDP if method is BYE*/
        if(ICF_NULL != icf_port_strcmp(p_ssa_pdb->p_method,(icf_uint8_t *)"BYE"))
        {   
            /*  Fix for CSR 1-7618644 : SPR 19989 */
            /*  If method is NOTIFY then copy the message body into 
             *  overlap transaction. */
            if (ICF_NULL != icf_port_strcmp(p_ssa_pdb->p_method,\
                        (icf_uint8_t *)"NOTIFY"))
            {
           if(Sdf_co_fail == sdf_ivk_uaCopyMsgBodyFromPersistent (
              &(p_ssa_ctxt->p_call_obj->slPersistentMsgBodyList),
              &(p_ssa_ctxt->p_call_obj->pUacTransaction->slMsgBodyList),
              (Sdf_ty_s8bit *)"persistent",p_err))
           {
              ret_val = ICF_FAILURE;
           }
        }
            else
            {
                if(Sdf_co_fail == sdf_ivk_uaCopyMsgBodyFromPersistent (
                            &(p_ssa_ctxt->p_call_obj->slPersistentMsgBodyList),
                            &(p_overlap_trans_info->slMsgBodyList),
                            (Sdf_ty_s8bit *)"persistent",p_err))
                {
                    ret_val = ICF_FAILURE;
                }
            }
        }
		
		/*Fix for CSR 1-7507275 SPR 19881*/
		if((ICF_FAILURE != ret_val) && 
           (ICF_NULL == icf_port_strcmp(p_ssa_pdb->p_method,(icf_uint8_t *)"PRACK")))
		{
		   p_overlap_trans_info->dRseq = p_ssa_ctxt->p_call_obj->pCommonInfo->dRemoteRseq.dRseq;
            /*  Set the state as Sdf_en_overlapTransactionSent because stack
             *  is not able to change the state from idle to
             *  Sdf_en_overlapTransactionSent so setting the
             *  state as Sdf_en_overlapTransactionSent.
             */

            p_overlap_trans_info->dState = Sdf_en_overlapTransactionSent;
		}

        if((ICF_FAILURE != ret_val) &&
             (ICF_NULL == icf_port_strcmp(p_ssa_pdb->p_method,(icf_uint8_t *)"REFER")))
        {
           /*Copy ReferTo and RefrdBy From Persistent to Processed*/
           if(sdf_ivk_uaCopyHeaderListByCorrelation(\
                      &(p_ssa_ctxt->p_call_obj->slPersistentHeaders),\
                      &(p_overlap_trans_info->slProcessedHeaders),\
                      (Sdf_ty_s8bit *)"uat-ReferTo",p_err)==Sdf_co_fail)
           {
               ICF_PRINT(("Failed to Add ReferTo Headers\n"));
               ret_val = ICF_FAILURE;
           }
           if(sdf_ivk_uaCopyHeaderListByCorrelation(\
                     &(p_ssa_ctxt->p_call_obj->slPersistentHeaders),\
                     &(p_overlap_trans_info->slProcessedHeaders),\
                     (Sdf_ty_s8bit *)"uat-ReferredBy",p_err)==Sdf_co_fail)
           {
               ICF_PRINT(("Failed to Add RefrdBy Headers\n"));
               return Sdf_co_fail;
           }
       }
        if((ICF_FAILURE != ret_val) &&
                (ICF_NULL == icf_port_strcmp(p_ssa_pdb->p_method,(icf_uint8_t *)"NOTIFY")))
        {

            /*Retrieve the Event, Subsription-State and Content Type header From 
              Persistent header list*/
            if(sdf_ivk_uaGetHeaderListByCorrelation(\
                        &(p_ssa_ctxt->p_call_obj->slPersistentHeaders),\
                        (Sdf_ty_s8bit *)"uat-Event",\
                        &slHeaderList,\
                        p_err)==Sdf_co_fail)
            {
                ICF_PRINT(("Failed to Add Event Header\n"));
                ret_val = ICF_FAILURE;
            }
            else if(sdf_listGetAt(&slHeaderList, 0, \
                    (Sdf_ty_pvoid *)&pHeaderList, p_err) == Sdf_co_fail)
            {
                sdf_listDeleteAll(&slHeaderList,p_err);
                ICF_PRINT(("Failed to Add Event Header\n"));
                ret_val = ICF_FAILURE;

            }

            else if(sdf_listGetAt(&(pHeaderList->slHeaders),0,\
                (Sdf_ty_pvoid *)&p_event_hdr,p_err)\
                == Sdf_co_fail )
            {
                sdf_listDeleteAll(&slHeaderList,p_err);
                (void)sdf_ivk_uaFreeHeaderList(pHeaderList);
                ICF_PRINT(("Failed to Add Event Header\n"));
                ret_val = ICF_FAILURE;
            }
            else
            {
                sdf_listDeleteAll(&slHeaderList,p_err);
            }
            if (ICF_FAILURE != ret_val)
            {
                if(sdf_ivk_uaGetHeaderListByCorrelation(\
                            &(p_ssa_ctxt->p_call_obj->slPersistentHeaders),\
                            (Sdf_ty_s8bit *)"uat-Subscriptionstate",\
                            &slHeaderList,\
                            p_err)==Sdf_co_fail)
                {
                    ICF_PRINT(("Failed to Add Subscription state Header\n"));
                    ret_val = ICF_FAILURE;
                }
                else if(sdf_listGetAt(&slHeaderList, 0, \
                            (Sdf_ty_pvoid *)&pHeaderList, p_err) == Sdf_co_fail)
                {
                    sdf_listDeleteAll(&slHeaderList,p_err);
                    ICF_PRINT(("Failed to Add subscription state Header\n"));
                    ret_val = ICF_FAILURE;

                }

                else if(sdf_listGetAt(&(pHeaderList->slHeaders),0,\
                            (Sdf_ty_pvoid *)&p_sub_state_hdr,p_err)\
                        == Sdf_co_fail )
                {
                    sdf_listDeleteAll(&slHeaderList,p_err);
                    ICF_PRINT(("Failed to Add subscription state Header\n"));
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    sdf_listDeleteAll(&slHeaderList,p_err);
                }
            }
            if (ICF_FAILURE != ret_val)
            {
                if(sdf_ivk_uaGetHeaderListByCorrelation(\
                            &(p_ssa_ctxt->p_call_obj->slPersistentHeaders),\
                            (Sdf_ty_s8bit *)"uat-contenttype",\
                            &slHeaderList,\
                            p_err)==Sdf_co_fail)
                {
                    ICF_PRINT(("Failed to Add Content Type Header\n"));
                    ret_val = ICF_FAILURE;
                }
                else if(sdf_listGetAt(&slHeaderList, 0, \
                            (Sdf_ty_pvoid *)&pHeaderList, p_err) == Sdf_co_fail)
                {
                    sdf_listDeleteAll(&slHeaderList,p_err);
                    ICF_PRINT(("Failed to Add Content Type Header\n"));
                    ret_val = ICF_FAILURE;

                }

                else if(sdf_listGetAt(&(pHeaderList->slHeaders),0,\
                            (Sdf_ty_pvoid *)&p_content_type_hdr,p_err)\
                        == Sdf_co_fail )
                {
                    sdf_listDeleteAll(&slHeaderList,p_err);
                    ICF_PRINT(("Failed to Add Content Type Header\n"));
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    sdf_listDeleteAll(&slHeaderList,p_err);
                }
            }
        }


        if(ICF_FAILURE != ret_val)
        {   
           if (Sdf_co_fail == sdf_ivk_uaFormRequestWithAuthorization(\
               p_ssa_ctxt->p_call_obj, p_overlap_trans_info, (icf_int8_t *)p_ssa_pdb->p_method,
               Sdf_co_true, p_ssa_ctxt->p_auth_params_list,\
               &uac_auth_info_list, p_err))
           {
              /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
              sdf_listDeleteAll(&uac_auth_info_list,p_err);

              sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
                      p_overlap_trans_info, (const icf_int8_t *)p_ssa_pdb->p_method, \
                      Sdf_en_uacTransaction);

              ret_val = ICF_FAILURE;
           }
           else
           {
               /* Fix for SPR: 19788
                * If the INVITE request is generated with Authentication info and
                * call connect is not done, check whether diversion header list is
                * present in call context or not. If present insert the Diversion
                * header in outgoing INVITE SIP request.
                */
               if((ICF_NULL == icf_port_strcmp(p_ssa_pdb->p_method,(icf_uint8_t *)"INVITE"))
                       && (ICF_NULL != p_ssa_ctxt->p_call_ctxt) &&
                       !(p_ssa_ctxt->p_call_ctxt->common_bitmask & ICF_CALL_CONNECT_DONE))
               {   
				   SipMessage *p_sip_msg = Sdf_co_null;

                   if ((ICF_NULL != p_ssa_ctxt->p_call_ctxt->p_diversion_header_list)
                           && (ICF_NULL != p_ssa_ctxt->p_call_ctxt->
                               p_diversion_header_list->no_of_diversion_data))
                   {            
                       if (ICF_FAILURE == 
                               icf_ssa_form_and_insert_div_hdr(
                                   p_ssa_pdb,
                                   p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg))
                       {
                           ret_val = ICF_FAILURE;
                       }       
                   }
					
				   /* Fix for CSR 1-7497733 SPR 19838 */
				   /* Insert the refer-by header only when call setup is not
					* completed.*/
				   /* This will take care of scenario when outgoing INVITE request
					* inititated after receiving refer from network is rejected
					* with 401 or 407 response.Here we are forming the new INVITE
					* request with Authorization header.This INVITE request must contain
					* the refer-by header as initial call setup is not
					* completed.However for the subsequent Re-Invite for session
					* refresh when call connect is done IPTK must not insert the
					* refer-by header in Re-INVITE request.*/	

				   /* Being a outgoing INVITE request fetch sip message from
					* UAC transaction*/
				   if (ICF_NULL != p_ssa_ctxt->p_call_obj->pUacTransaction)
				   {    
					   p_sip_msg = p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg;
				   }

				   /* Forms and inserts a referred by header in the SipMsg
					* passed */

				   if(ICF_NULL != p_ssa_ctxt->p_call_ctxt->p_referred_party_addr)
				   { 
					   if (ICF_FAILURE == icf_ssa_form_and_insert_ref_by_hdr(
												   p_ssa_pdb,p_sip_msg))
					   {
						   sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
												   p_overlap_trans_info,
												   (const icf_int8_t *)p_ssa_pdb->p_method,\
												   Sdf_en_uacTransaction);
						   ret_val = ICF_FAILURE;                        
					   }
				   }

				   if(ICF_NULL != p_ssa_ctxt->p_call_ctxt->p_replaces_header)
				   {
					   if (ICF_FAILURE == icf_ssa_form_and_insert_replaces_hdr(
												   p_ssa_pdb,p_sip_msg))
					   {
						   sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
												   p_overlap_trans_info,
												   (const icf_int8_t *)p_ssa_pdb->p_method,\
												   Sdf_en_uacTransaction);
						   ret_val = ICF_FAILURE;                        
					   }
				   }
               }
               /* Fix for CSR 1-7618644 : SPR 19989.
                *If method is NOTIFY then copy the Event, Subscription state
                * and Content-Type header into Sip message
                */
               else if(ICF_NULL == 
                   icf_port_strcmp(p_ssa_pdb->p_method,\
                   (icf_uint8_t *)"NOTIFY"))
               {
                   if(Sdf_co_null != p_event_hdr)
                   {
                       if (Sdf_co_null != p_overlap_trans_info &&
                           Sdf_co_null!= p_overlap_trans_info->pSipMsg)
                       {
                           if(sip_insertHeaderAtIndex(p_overlap_trans_info->pSipMsg,\
                              p_event_hdr, \
                              0, \
                              (SipError *)&(p_err->stkErrCode)) == Sdf_co_fail)
                           {
                               ret_val = ICF_FAILURE;
                           }
                       }
                   }
                   if(Sdf_co_null != p_sub_state_hdr)
                   {
                       if (Sdf_co_null != p_overlap_trans_info &&
                           Sdf_co_null!= p_overlap_trans_info->pSipMsg)
                       {
                           if(sip_insertHeaderAtIndex(p_overlap_trans_info->pSipMsg,\
                              p_sub_state_hdr, \
                              0, \
                              (SipError *)&(p_err->stkErrCode)) == Sdf_co_fail)
                           {
                               ret_val = ICF_FAILURE;
                           }
                       }
                   }
                   if(Sdf_co_null != p_content_type_hdr)
                   {
                       if (Sdf_co_null != p_overlap_trans_info &&
                               Sdf_co_null!= p_overlap_trans_info->pSipMsg)
                       {
                           sip_deleteHeaderAtIndex(p_overlap_trans_info->pSipMsg,\
                                    SipHdrTypeContentType, 0, \
                                    (SipError *)&(p_err->stkErrCode));

                           if(sip_insertHeaderAtIndex(p_overlap_trans_info->pSipMsg,\
                                       p_content_type_hdr, \
                                       0, \
                                       (SipError *)&(p_err->stkErrCode)) == Sdf_co_fail)
                           {
                               ret_val = ICF_FAILURE;
                           }
                       }
                   }

               }
           }
           if((ICF_FAILURE == ret_val) ||
                   ICF_FAILURE == icf_ssa_make_send_auth_req(p_ssa_pdb,
                    p_overlap_trans_info,p_err))
           {
              ret_val = ICF_FAILURE;
           }
        }   
  
        /* TBD : Would we require auth para list in future */
        sdf_listDeleteAll(p_ssa_ctxt->p_auth_params_list, p_err);
        sdf_listDeleteAll(&uac_auth_info_list,p_err);
    } /* End else */

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} /* End of icf_ssa_send_register_req_with_auth() */
/*******************************************************************************
 * 
 * FUNCTION:        icf_ssa_process_before_sending_auth_req
 *
 * DESCRIPTION:     This function perform misc function before sending auth req
 *                  for REGISTER and INVITE METHOD
 *
 ******************************************************************************/
icf_return_t icf_ssa_process_before_sending_auth_req(
        icf_ssa_pdb_st         *p_ssa_pdb,
        Sdf_st_callObject         **p_p_call_obj,
        Sdf_st_overlapTransInfo   **p_p_overlap_trans_info)
{
    icf_return_t  ret_val = ICF_SUCCESS;
    Sdf_st_error     sdf_error ;
    icf_ssa_ctxt_st  *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    Sdf_ty_s8bit     proto[ICF_MAX_SIZE_INT_USAGE_STR];
    Sdf_st_callObject              *p_call_obj = ICF_NULL;
    Sdf_st_overlapTransInfo   *p_overlap_trans_info = ICF_NULL;
    
    /* To remove warning */
    p_p_call_obj=p_p_call_obj;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

   if(ICF_NULL == p_ssa_ctxt)
    return ICF_FAILURE;
   /*Fix done for SPR-18722 : CSR-1-6068965*/ 
   if (Sdf_mc_strcasecmp((icf_int8_t *)p_ssa_pdb->p_method,(icf_int8_t *)"REGISTER")==0) 
   {
        /*
         * Now form a request with authorization. The list of
         * authentication params and uac auth info structures
         * are passed to this API
         */
        /* Set the transport mode in local variable */
        if (((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_line_data->reg_mode)||
             (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_line_data->reg_mode))&&
              (ICF_NULL == (p_ssa_ctxt->bitmask & 
                     ICF_SSA_RGM_PREV_TRANS_TYPE_UDP)))
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
        }
#ifdef ICF_P_CSCF_DISCOVERY_ENABLED
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
/* We will net the transport mode to none for P-CSCF Discovery */
    icf_port_strcpy(proto,"");
ICF_CHECK_IMS_END
#endif
#endif


        if (Sdf_co_fail == sdf_ivk_uaStartTransaction( p_ssa_ctxt->p_call_obj,\
                 &p_overlap_trans_info, (const icf_int8_t *)p_ssa_pdb->p_method, &sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_ivk_uaSetTransportSchemeInTransaction(\
            p_ssa_ctxt->p_call_obj->pUacTransaction, p_overlap_trans_info,\
               proto, &sdf_error))
        {

            sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
                    p_overlap_trans_info, (const icf_int8_t *)p_ssa_pdb->p_method,\
                    Sdf_en_uacTransaction);

            ret_val = ICF_FAILURE;
        }
   }
   /*Fix done for SPR-18722 : CSR-1-6068965*/
   else if (Sdf_mc_strcasecmp((icf_int8_t *)p_ssa_pdb->p_method,(icf_int8_t *)"INVITE")==0) 
   {
        if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                                   p_ssa_ctxt->p_call_obj,
                                   &p_overlap_trans_info,
                                   "INVITE",
                                   &sdf_error))
        {
            /*Raise a Major error here - UATK_PROCESSING FAILURE*/
            sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                                   p_overlap_trans_info, "INVITE",
                                   Sdf_en_uacTransaction);

            p_call_obj = p_ssa_ctxt->p_call_obj;
            sdf_ivk_uaFreeCallObject(&p_call_obj);
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt, \
                       ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
            ret_val = ICF_FAILURE;
        }
   }
   /*Fix done for SPR-18722 : CSR-1-6068965*/
   else if (Sdf_mc_strcasecmp((icf_int8_t *)p_ssa_pdb->p_method,(icf_int8_t *)"SUBSCRIBE")==0) 
   {
       if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                   p_ssa_ctxt->p_call_obj,
                   &p_overlap_trans_info,
                   "SUBSCRIBE",
                   &sdf_error))
       {
           /*Raise a Major error here - UATK_PROCESSING FAILURE*/
           sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                   p_overlap_trans_info, "SUBSCRIBE",
                   Sdf_en_uacTransaction);
           p_call_obj = p_ssa_ctxt->p_call_obj;
           sdf_ivk_uaFreeCallObject(&p_call_obj);
           ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt, \
                   ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
               ret_val = ICF_FAILURE;
       }
   }
   /*Fix done for SPR-18722 : CSR-1-6068965*/
   else if (Sdf_mc_strcasecmp((icf_int8_t *)p_ssa_pdb->p_method,(icf_int8_t *)"OPTIONS")==0) 
   {
       if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                   p_ssa_ctxt->p_call_obj,
                   &p_overlap_trans_info,
                   "OPTIONS",
                   &sdf_error))
       {
           /*Raise a Major error here - UATK_PROCESSING FAILURE*/
           sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                   p_overlap_trans_info, "OPTIONS",
                   Sdf_en_uacTransaction);
           p_call_obj = p_ssa_ctxt->p_call_obj;
           sdf_ivk_uaFreeCallObject(&p_call_obj);
           ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt, \
                   ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
               ret_val = ICF_FAILURE;
       }
   } 
   else 
   {
       if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                   p_ssa_ctxt->p_call_obj,
                   &p_overlap_trans_info,
                   p_ssa_pdb->p_method,
                   &sdf_error))
       {
           /*Raise a Major error here - UATK_PROCESSING FAILURE*/
           sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                   p_overlap_trans_info, p_ssa_pdb->p_method,
                   Sdf_en_uacTransaction);
           p_call_obj = p_ssa_ctxt->p_call_obj;
           sdf_ivk_uaFreeCallObject(&p_call_obj);
           ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt, \
                   ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
               ret_val = ICF_FAILURE;
       }
   }
 
    *p_p_overlap_trans_info = p_overlap_trans_info;
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * 
 * FUNCTION:        icf_ssa_make_send_auth_req
 *
 * DESCRIPTION:     This function makes and send Authorized Req
 *
 ******************************************************************************/
icf_return_t icf_ssa_make_send_auth_req(
        icf_ssa_pdb_st         *p_ssa_pdb,
        Sdf_st_overlapTransInfo   *p_overlap_trans_info,
        Sdf_st_error               *p_err)
{
    icf_return_t ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st            *p_ssa_ctxt = ICF_NULL;
    icf_glb_pdb_st             *p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    SipMessage                 *p_sip_msg = Sdf_co_null;
    SipOptions                 sip_options;
    SipAddrSpec                *p_addr_spec = Sdf_co_null;
    Sdf_ty_u32bit              index = 0;
    Sdf_st_callObject          *p_call_obj = Sdf_co_null;
    icf_header_list_st         *p_hdr_list = ICF_NULL;
    icf_return_t               dummy_ret_val = ICF_SUCCESS;    
    
    if(ICF_NULL == p_glb_pdb)
    {
         ICF_PRINT(((icf_uint8_t *)"\nP_glb_pdb is null"));
         return ICF_FAILURE;          
    }
    ICF_FUNCTION_ENTER(p_glb_pdb)

    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt;
    if (ICF_NULL == p_ssa_ctxt)
    {
        return ICF_FAILURE;
    }
    p_call_obj = p_ssa_ctxt->p_call_obj;
   
    p_ssa_pdb->authorised_req=ICF_TRUE;

    /*Fix done for SPR-18722 : CSR-1-6068965*/
    if (Sdf_mc_strcasecmp((icf_int8_t *)p_ssa_pdb->p_method,(icf_int8_t *)"REGISTER")==0)
    {
        /*Changes to send contact header with the request*/
        while (index < p_ssa_ctxt->p_call_obj->pInitData->slContact.size)
        {
            SipHeader *pContactHdr = Sdf_co_null;

            sdf_listGetAt(&(p_ssa_ctxt->p_call_obj->pInitData->slContact),
                    index, (Sdf_ty_pvoid *)&pContactHdr, p_err);

            sip_insertHeaderAtIndex(p_overlap_trans_info->pSipMsg, \
                    pContactHdr,(Sdf_ty_u32bit)index, \
                    (SipError *)&(p_err->stkErrCode));
            index++;
        }

        if (ICF_SUCCESS == ret_val &&
                ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_line_data->reg_mode)
        {
            p_addr_spec = p_overlap_trans_info->pSipMsg->u.pRequest->pRequestLine->pAddrSpec;

            ret_val = icf_ssa_insert_param_in_addr_spec( p_ssa_pdb, 
                    p_addr_spec, (icf_uint8_t *)"transport", (icf_uint8_t *)"tcp",p_err);
        } /* else if (ICF_TRANSPORT_TYPE... */
        else if (ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->p_line_data->reg_mode)
        {
            p_addr_spec = p_overlap_trans_info->pSipMsg->u.pRequest->pRequestLine->pAddrSpec;
            
            ret_val = icf_ssa_insert_param_in_addr_spec(
                p_ssa_pdb, p_addr_spec,
                (icf_uint8_t *)"transport", (icf_uint8_t *)"udp",p_err);
        }
        }/* if (Sdf_mc_strcasecmp(p_method,"REGISTER")==0) */

       if(ICF_NULL == p_overlap_trans_info)
       {
           p_sip_msg = p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg;
       }
       else
       {
           p_sip_msg = p_overlap_trans_info->pSipMsg;
       }

        /*
         * The list of pAuthenticationParams and pUacAuthInfo are no longer
         * required and can be freed at this stage.
         */

        sip_options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

     /*Fix done for SPR-18722 : CSR-1-6068965*/
     if (Sdf_mc_strcasecmp((icf_int8_t *)p_ssa_pdb->p_method,(icf_int8_t *)"SUBSCRIBE")==0)
        {
         /* The SUBSCRIBE request with credentials was carrying the 
             * headers specified in icf_subscribe_req->header_list twice
             * So remove it from here
             */
            p_hdr_list = ICF_NULL;
             /* &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->persistent_header_list);*/

    }
        else
        {
           if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx)
           {
              p_hdr_list = 
                &(p_ssa_pdb->p_glb_pdb->p_call_ctx->persistent_header_list);
           }
        }
 /* Following things need to be done when sending SUBSCRIBE with 
        * authentication parameters:
        * - Send the Expires header as was sent in initial SUBSCRIBE
        * - Send the Event header as was sent in initial SUBSCRIBE
        * - Send the Tag list as was sent in initial SUBSCRIBE
        */
    /*Fix done for SPR-18722 : CSR-1-6068965*/ 
	if (0 == Sdf_mc_strcasecmp((icf_int8_t *)p_ssa_pdb->p_method,(icf_int8_t *)"SUBSCRIBE"))
    {
        SipHeader                    *p_exp_hdr = SIP_NULL;
        SipHeader                    *p_event_hdr = SIP_NULL;
        SipError                     sip_err;

/* Fix for CSR 1-8400252: SPR 20336 */
	/* Expires header should be sent for UnSubscribe irrespective
	 * of App setting. For other SUBS messages, check whether Expires
	 * header needs to be sent or not.
	 */
       if ((!(ICF_SIC_EXPIRES_HDR_NOT_TO_BE_SEND & p_ssa_ctxt->p_sic_ctxt->bitmask)) ||
       	 (ICF_NULL == p_ssa_ctxt->p_sic_ctxt->app_requested_duration))

        {
        /*Insert Expire header*/
        if (ICF_FAILURE == sip_initSipHeader(
                    &p_exp_hdr, SipHdrTypeExpiresSec, &sip_err))
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE == sip_setSecondsInExpiresHdr(
                    p_exp_hdr, p_ssa_ctxt->p_sic_ctxt->duration, &sip_err))
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE == sip_setHeader(
                    p_overlap_trans_info->pSipMsg, 
                    p_exp_hdr, &sip_err))
        {
            ret_val = ICF_FAILURE;
        }
        }

	if (ICF_FAILURE == ret_val)
	     {
	       ret_val = ICF_FAILURE;
	       ICF_PRINT(("\n[SSA]: Failed to set Expires header in SUBSCRIBE\n"));
       	     }

        /* Insert Event header as SipHdrTypeEvent instead of SipHdrTypeUnknown */
        else if (ICF_FAILURE == sip_initSipHeader(
                    &p_event_hdr, SipHdrTypeEvent, &sip_err))
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_NULL == p_event_hdr)
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE == sip_setEventTypeInEventHdr(
                    p_event_hdr,
                    Sdf_mc_strdupCT((const icf_int8_t *)p_ssa_ctxt->p_sic_ctxt->event_package.str),
                    &sip_err))
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE == sip_setHeader(
                    p_overlap_trans_info->pSipMsg, p_event_hdr, &sip_err))
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_NULL < p_ssa_ctxt->p_sic_ctxt->tag_list.count)
        {
            ret_val = icf_ssa_insert_tag_list_in_sip_msg(
                    p_ssa_pdb, &(p_ssa_ctxt->p_sic_ctxt->tag_list),
                    ICF_FALSE, p_overlap_trans_info->pSipMsg);
        }

        if (ICF_FAILURE == ret_val)
        {
            /*Raise a Major error here - UATK_PROCESSING FAILURE*/
            sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info, "SUBSCRIBE",
                    Sdf_en_uacTransaction);
            p_call_obj = p_ssa_ctxt->p_call_obj;
            sdf_ivk_uaFreeCallObject(&p_call_obj);
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt, \
                    ICF_MEM_COMMON, p_ssa_pdb->p_ecode, dummy_ret_val)
        }
        if (ICF_NULL != p_event_hdr)
        {
            sip_freeSipEventHeader((SipEventHeader*)p_event_hdr->pHeader);
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_event_hdr,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
        }
            sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_exp_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
    }

    /* Insert the User-Agent header */
    if((ICF_FAILURE == ret_val)|| (ICF_FAILURE == dummy_ret_val))
    {
        /* do nothing */
    }
    else if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
                p_ssa_pdb,
                p_hdr_list,
                ICF_FALSE,
                p_sip_msg))
    {
        /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
        sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info, (const icf_int8_t *)p_ssa_pdb->p_method, 
                Sdf_en_uacTransaction);
        ret_val = ICF_FAILURE;
    }
    /* Send request to peer */
    else if (ICF_FAILURE == icf_ssa_send_to_peer( p_ssa_pdb,\
                p_ssa_ctxt->p_call_obj, p_sip_msg,\
                &sip_options, p_err))
    {
        /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
        sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,\
                p_overlap_trans_info, (const icf_int8_t *)p_ssa_pdb->p_method, Sdf_en_uacTransaction);
        ret_val = ICF_FAILURE;
    }
    else if (Sdf_co_fail == sdf_ivk_uaEndTransaction(\
                    p_ssa_ctxt->p_call_obj, Sdf_co_null, (const icf_int8_t *)p_ssa_pdb->p_method, p_err))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info, (const icf_int8_t *)p_ssa_pdb->p_method, Sdf_en_uacTransaction);
            ret_val = ICF_FAILURE;
        }


        ICF_FUNCTION_EXIT(p_glb_pdb)
        return ret_val;
}


/*******************************************************************************
 * 
 * FUNCTION:        icf_ssa_fetch_auth_param_list
 *
 * DESCRIPTION:     This function extracts auth param received in 401/407
 *
 ******************************************************************************/
icf_return_t icf_ssa_fetch_auth_param_list(
        icf_ssa_pdb_st         *p_ssa_pdb,
        Sdf_st_callObject         **p_p_call_obj,
        Sdf_st_overlapTransInfo   *pOverlapTransInfo
        )
{

    icf_return_t ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st            *p_ssa_ctxt = ICF_NULL;
    Sdf_st_error         err;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)


    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt;

 
    /* Re-initialize the list in ssa ctxt */
    if (ICF_NULL != p_ssa_ctxt->p_auth_params_list)
    {
        sdf_listDeleteAll(
                p_ssa_ctxt->p_auth_params_list,
                &err);
    }
    else
    {
        ICF_MEMGET(
                p_ssa_pdb->p_glb_pdb,
                ICF_PORT_SIZEOF(Sdf_ty_slist),
                ICF_MEM_COMMON,
                p_ssa_ctxt->p_auth_params_list,
                ICF_RET_ON_FAILURE,
                p_ssa_pdb->p_ecode,
                ret_val)
    }

    if (Sdf_co_fail == sdf_listInit(
                p_ssa_ctxt->p_auth_params_list,
                __sdf_fn_uaFreeAuthenticationParams,
                Sdf_co_false,
                &err))
    {
        ret_val = Sdf_co_fail;
    }
    else if (Sdf_co_fail == sdf_ivk_uaGetAuthParams(
                *p_p_call_obj,
                pOverlapTransInfo,
                p_ssa_ctxt->p_auth_params_list,
                &err))
    {
        ret_val = Sdf_co_fail;
    }
    else
    {
        sdf_listSizeOf(
                p_ssa_ctxt->p_auth_params_list,
                &(p_ssa_ctxt->auth_params_list_size),
                &err);

        /* 
         * If no auth params are recd from PEER, then 
         * free thee list
         */
        if (ICF_NULL == p_ssa_ctxt->auth_params_list_size)
        {
            sdf_listDeleteAll(
                    p_ssa_ctxt->p_auth_params_list,
                    &err);
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_ssa_ctxt->p_auth_params_list,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
        }

    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_make_request_digest
 *
 * DESCRIPTION:     This creates request digest for digest authentication
 *                  
 * RETURNS:         ICF_SUCCESS in case of success and ICF_FAILURE in
 *                  case of failure.
 *
 ******************************************************************************/
icf_return_t icf_ssa_make_request_digest(
        INOUT    icf_glb_pdb_st *p_glb_pdb,
        IN      icf_www_authenticate_param_st *p_authenticate_params,
        INOUT    icf_authorisation_param_st   *p_authorization_params,
        IN         icf_uint32_t   msg_body_length, 
        IN         icf_uint8_t   *p_msg_body,
        OUT     icf_error_t    *p_ecode)
{
    icf_return_t                         ret_val = ICF_SUCCESS;
    HASHHEX                                    HA1, HEntity;
    /* To remove warnings */
    p_glb_pdb=p_glb_pdb;
    p_ecode=p_ecode;

        /* 
         * Calculate the H(A1)
         */
        DigestCalcHA1((icf_int8_t *)p_authenticate_params->p_algorithm, 
            (icf_int8_t *)p_authorization_params->p_username, (icf_int8_t *)p_authenticate_params->p_realm, 
            (icf_int8_t *)p_authorization_params->p_passwd, 
            (icf_int8_t *)p_authenticate_params->p_challenge, (icf_int8_t *)p_authorization_params->p_cnonce, HA1);

        /* 
         * Calculate the H(Entity)
         */
        DigestCalcHEntity((icf_int8_t *)p_msg_body,msg_body_length,HEntity);

        /* 
         * Calculate the response digest
         */
        DigestCalcResponse(HA1, (icf_int8_t *)p_authenticate_params->p_challenge, 
            (icf_int8_t *)p_authorization_params->p_nonce_count,
            (icf_int8_t *)p_authorization_params->p_cnonce, 
            (icf_int8_t *)p_authenticate_params->p_qop, (icf_int8_t *)p_authorization_params->p_method, 
            (icf_int8_t *)p_authorization_params->p_uri, HEntity,
            (icf_int8_t *)p_authorization_params->p_response);

    return(ret_val);
}


/*******************************************************************************
 * FUNCTION:        icf_ssa_rgm_remove_tags
 *
 * DESCRIPTION:     This function removes the parameters from the mandatory headers
 *                  To/ From/  for REGISTER message. 
 *                    
 ******************************************************************************/
 icf_return_t        icf_ssa_rgm_remove_tags(
     INOUT     icf_ssa_pdb_st                    *p_ssa_pdb,
     INOUT     SipMessage                           *p_sip_msg)
{
     icf_return_t                     ret_val = ICF_SUCCESS;
     SipError                             sip_error;
     en_HeaderType                     hdr_type = ICF_NULL;
     
     
     ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
         
    
     ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_sip_msg))

     icf_ssa_get_hdr_type_from_name((icf_uint8_t *)"From", &hdr_type, &sip_error);
     if (ICF_FAILURE == icf_ssa_clear_tags_for_hdr(
                            p_ssa_pdb, p_sip_msg,hdr_type))
     {
         ret_val = ICF_FAILURE;

     }
     else
     {
         icf_ssa_get_hdr_type_from_name((icf_uint8_t *)"To", &hdr_type, &sip_error);
         if (ICF_FAILURE == icf_ssa_clear_tags_for_hdr(
                            p_ssa_pdb, p_sip_msg,hdr_type))
         {
             ret_val = ICF_FAILURE;
         }

     }
     

     ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;



}/* Function icf_ssa_rgm_remove_tags() ends */

 
 /*****************************************************************************
 * FUNCTION:        icf_ssa_clear_tags_for_hdr
 *
 * DESCRIPTION:     This function removes the parameters from the header type
 *                  passed in the parameter list. Only the "tag" parameter in
 *                    To/From headaer is left intatct.
 *                    
 *****************************************************************************/
icf_return_t        icf_ssa_clear_tags_for_hdr(
     INOUT     icf_ssa_pdb_st                    *p_ssa_pdb,
     INOUT     SipMessage                           *p_sip_msg,
     INOUT           icf_uint32_t                        hdr_type)     
{
     icf_return_t                     ret_val = ICF_SUCCESS;
     icf_uint32_t                     loop_param = ICF_NULL;
     icf_uint32_t                     index_param = ICF_NULL;
     icf_uint32_t                     loop_hdr = ICF_NULL;
     icf_uint32_t                     param_count = ICF_NULL;
     icf_uint32_t                     hdr_count = ICF_NULL;
     SipError                             sip_error;
     SipHeader                             temp_hdr;
     SipParam                             *p_sip_param = ICF_NULL;
     
     
     

    if(ICF_NULL == p_ssa_pdb)
    {
        return ICF_FAILURE;
    }
	p_ssa_pdb=p_ssa_pdb;       
	
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
         
    
     ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_sip_msg))


     if (SipFail == sip_getHeaderCount(p_sip_msg,
            hdr_type, &hdr_count, &sip_error))
     {
         ret_val = ICF_FAILURE;

     }
     else 
     {
         for (loop_hdr = 0; (loop_hdr < hdr_count) && 
                            (ICF_SUCCESS == ret_val); loop_hdr++)
         {
             if (SipFail == sip_getHeaderAtIndex(p_sip_msg,
                        hdr_type, &temp_hdr, loop_hdr,&sip_error))
            {
                ret_val = ICF_FAILURE;
                break;
            }

            if (SipFail == sip_getParamCountFromCommonHdr(&temp_hdr,&param_count,
                                            &sip_error))
            {
                ret_val = ICF_FAILURE;
                /* free header */
                sip_freeSipHeader(&temp_hdr);
                break;
            }
            
            loop_param = 0;
            index_param = 0;
            while (loop_param != param_count)
            {
                if (SipFail == sip_getParamAtIndexFromCommonHdr(&temp_hdr, &p_sip_param,
                        index_param, &sip_error))
                {
                    ret_val = ICF_FAILURE;
                    
                    break;
                }
                 
                /* For the headers To and From: the parameter with name "tag"
                 * is generated by UATK, hence we are not removing it. */

                if ((SipHdrTypeTo == hdr_type || SipHdrTypeFrom == hdr_type)&&
                        (!icf_port_strcmp((icf_uint8_t *)p_sip_param->pName, (icf_uint8_t *)"tag")))
                {
                    loop_param++;
                    index_param++;
                    sip_freeSipParam(p_sip_param);
                    continue;
                }
                sip_freeSipParam(p_sip_param);

                if (SipFail ==  sip_deleteParamAtIndexInCommonHdr(&temp_hdr, index_param,
                                        &sip_error))
                {
                    ret_val = ICF_FAILURE;
                    break;
                }
                loop_param++;
             }/* while loop ends on param list */

            /* free header */
            sip_freeSipHeader(&temp_hdr);

         }/* for loop on hdr list: ends */
     }/* hdr count found: success */

     ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;

 }/* Function icf_ssa_clear_tags_for_hdr() ends */



 /*****************************************************************************
 * FUNCTION:        icf_ssa_get_reqline_as_string
 *
 * DESCRIPTION:     This function gets the request line from the SIP Message
 *                  and fills it as a string in the parameter p_target_str
 *                    
 *****************************************************************************/
icf_return_t icf_ssa_get_reqline_as_string(SipMessage *p_sip_msg, 
                                                 icf_uint8_t *p_target_str)
{
    SipReqLine *pReqLine=ICF_NULL;
    SipAddrSpec    *p_addr_spec = SIP_NULL;
    SipError sip_err;
    icf_string_st param_str;
    icf_return_t ret_val = ICF_SUCCESS;

    icf_port_strcpy(param_str.str,(icf_uint8_t *)"");

    if(SipMessageRequest != p_sip_msg->dType)
    {
        return ICF_SUCCESS;
    }
    if (SipFail == sip_getReqLineFromSipReqMsg(p_sip_msg,
                &pReqLine,&sip_err))
    {
        return ICF_FAILURE;
    }

#ifdef ICF_WITH_MUATK_2_2
    p_addr_spec = pReqLine->pAddrSpec;
#else
    p_addr_spec = pReqLine->pRequestUri;
#endif

    if(SipAddrReqUri == p_addr_spec->dType)
    {
        icf_port_strcpy(p_target_str,(icf_uint8_t *)p_addr_spec->u.pUri);
    }
    else if(SipFail == sip_formSipParamList(
        (icf_int8_t *)param_str.str,
        &(p_addr_spec->u.pSipUrl->slParam),
        (SIP_S8bit *)";",
        1,
        &sip_err))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        icf_port_strcpy(p_target_str,(icf_uint8_t *)"");

        if(ICF_NULL != p_addr_spec->u.pSipUrl->pUser)
        {
            icf_port_strcat(p_target_str,(icf_uint8_t *)"sip:");
            icf_port_strcat(p_target_str,(icf_uint8_t *)p_addr_spec->u.pSipUrl->pUser);
        }
        if(ICF_NULL != p_addr_spec->u.pSipUrl->pPassword)
        {
            icf_port_strcat(p_target_str,(icf_uint8_t *)":");
            icf_port_strcat(p_target_str,(icf_uint8_t *)p_addr_spec->u.pSipUrl->pPassword);
           
        }
        if(ICF_NULL != p_addr_spec->u.pSipUrl->pHost)
        {
            icf_port_strcat(p_target_str,(icf_uint8_t *)"@");
            icf_port_strcat(p_target_str,(icf_uint8_t *)p_addr_spec->u.pSipUrl->pHost);
        }

        if(ICF_NULL != p_addr_spec->u.pSipUrl->dPort)
        {
            icf_string_st port_str;
            icf_port_itoa(*(p_addr_spec->u.pSipUrl->dPort),port_str.str);
            icf_port_strcat(p_target_str,(icf_uint8_t *)":");
            icf_port_strcat(p_target_str, port_str.str);
        }
        
        /* Param List */
        icf_port_strcat(p_target_str,param_str.str);
        
        if(ICF_NULL != p_addr_spec->u.pSipUrl->pHeader)
            icf_port_strcat(p_target_str,(icf_uint8_t *)p_addr_spec->u.pSipUrl->pHeader);

    }

    sip_freeSipReqLine(pReqLine);
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_add_string_list_in_default_header
 **
 ** DESCRIPTION:        This function adds a headrer with the name p_hdr_name
 **                     and populates it with the values specified in the 
 **                     string list p_hdr_content
 **
 *****************************************************************************/
icf_return_t icf_ssa_add_string_list_in_default_header(Sdf_st_initData *p_profile,
                                              icf_uint8_t *p_name,
                                              icf_string_list_st *p_hdr_content,
                                              Sdf_ty_bool dAddAlways,
                                              icf_error_t *p_ecode)
{
    icf_string_list_node_st *p_cur_node;
    Sdf_st_error   sdf_error;
    icf_return_t ret_val = ICF_SUCCESS;
    icf_uint32_t i;
    /*To remove warnings */
    p_ecode=p_ecode;
    if(ICF_NULL == p_hdr_content)
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        for(i = p_hdr_content->count,p_cur_node = p_hdr_content->p_list;
        i--; 
        p_cur_node = p_cur_node->p_next)
        {
            if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,
                (icf_int8_t *)p_name,
                (icf_int8_t *)p_cur_node->str.str,
                dAddAlways,
                &sdf_error))
            {
                ret_val = ICF_FAILURE;
                break;
            }
        }
    }
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_make_app_profile
 **
 ** DESCRIPTION:        This function makes a SIP profile for an ICF application
 **
 *****************************************************************************/
icf_return_t icf_ssa_make_app_profile(Sdf_st_initData *p_profile,
                                            icf_ssa_pdb_st *p_ssa_pdb)
{
    icf_return_t ret_val = ICF_SUCCESS;
    icf_app_conf_st *p_app_conf = p_ssa_pdb->p_app_conf;

    /* Clone from default profile */
    if ( ICF_FAILURE == icf_ssa_clone_profile_data(p_ssa_pdb->p_glb_pdb,
        p_profile, p_ssa_pdb->p_ssa_glb_data->p_default_profile,p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    else if(ICF_NULL == p_app_conf)
    {
        /* Do nothing */
    }
    /* Supported Methods */
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
        p_profile,
        (icf_uint8_t *)"Allow", 
        &(p_app_conf->app_profile.supported_methods),
        Sdf_co_true,
        p_ssa_pdb->p_ecode)
        )
    {
        ret_val = ICF_FAILURE;
    }
    /* Supported Events */
    /*
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
        p_profile,
        "Supported", 
        &(p_app_conf->app_profile.supported_events),
        Sdf_co_true,
        p_ssa_pdb->p_ecode)
        )
    {
        ret_val = ICF_FAILURE;
    }*/
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
        p_profile,
        (icf_uint8_t *)"Accept", 
        &(p_app_conf->app_profile.supported_content_types),
        Sdf_co_false,
        p_ssa_pdb->p_ecode)
        )
    {
        ret_val = ICF_FAILURE;
    }
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
        p_profile,
        (icf_uint8_t *)"Accept-Encoding", 
        &(p_app_conf->app_profile.supported_encodings),
        Sdf_co_true,
        p_ssa_pdb->p_ecode)
        )
    {
        ret_val = ICF_FAILURE;
    }
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
        p_profile,
        (icf_uint8_t *)"Accept-Language", 
        &(p_app_conf->app_profile.supported_languages),
        Sdf_co_true,
        p_ssa_pdb->p_ecode)
        )
    {
        ret_val = ICF_FAILURE;
    }
#if 0 /* This ICF release does not handle PRACK */
    /* Hardcoding 100 rel in supported header */
    else if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Supported","100rel",Sdf_co_true,&sdf_error))
    {
        ret_val = ICF_FAILURE;
    }
#endif
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_make_profile_for_reg
 **
 ** DESCRIPTION:        This function makes a SIP profile for a registration
 **                     message
 **
 *****************************************************************************/

icf_return_t icf_ssa_make_profile_for_reg(Sdf_st_initData *p_profile,icf_ssa_pdb_st *p_ssa_pdb)
{
    icf_return_t                 ret_val = ICF_SUCCESS;
    Sdf_st_error                    sdf_error;
    icf_app_conf_st              *p_app_conf;
    icf_uint32_t                 count;
    icf_error_t                  *p_ecode;
    
    p_ecode = p_ssa_pdb->p_ecode;

    /* Remove all Extra Headers */
    if(Sdf_co_fail == sdf_listDeleteAll(&(p_profile->slExtraHeadersList), &sdf_error))
    {
        ret_val = ICF_FAILURE;
    }

    /* Clone from default profile */
    else if ( ICF_FAILURE == icf_ssa_clone_profile_data(p_ssa_pdb->p_glb_pdb,
        p_profile, p_ssa_pdb->p_ssa_glb_data->p_default_profile,p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        icf_uint8_t *p_hdr_name[ICF_NUM_APP_PROFILE_HDRS-1]={(icf_uint8_t *)"Allow", 
            (icf_uint8_t *)"Accept", 
            (icf_uint8_t *)"Accept-Encoding",
            (icf_uint8_t *)"Accept-Language"
        };
        /* Hardcoding 100 rel in supported header */
        /* 6_3_enhancement merge */
#if 0
        if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,p_hdr_name[1],"100rel",Sdf_co_true,&sdf_error))
        {
            /* clean up*/
            ret_val = ICF_FAILURE;
        }
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)

        /* Hardcoding path in supported header for IMS mode */
        if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,p_hdr_name[1],"path",Sdf_co_true,&sdf_error))
        {
            /* clean up*/
            ret_val = ICF_FAILURE;
        }

ICF_CHECK_IMS_END
#endif
        else 
#endif
        {
            icf_uint32_t counter;
            icf_rgm_app_ctxt_st    *p_app_data;

            for(count = 0;count<p_ssa_pdb->p_glb_cfg_data->max_applications;count++)
            {
                p_app_data =(icf_rgm_app_ctxt_st*)
                    &(p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->p_app_data_list[count]);

                counter = 0;
                
                
                if (ICF_FALSE == p_app_data->is_valid)
                    continue;
                
                if(ICF_FAILURE == icf_cfg_fetch_app_conf(
                    p_ssa_pdb->p_glb_pdb,
                    p_app_data->app_id,
                    &p_app_conf,
                    p_ecode))
                {
                    /* Free Memory */
                    ret_val = ICF_FAILURE;
                }     
                 else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(p_profile,p_hdr_name[counter++],&(p_app_conf->app_profile.supported_methods),Sdf_co_true,p_ecode))

                {
                    ret_val = ICF_FAILURE;
                }
#if 0
                else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(p_profile,p_hdr_name[counter++],&(p_app_conf->app_profile.supported_events),p_ecode))
                {
                    ret_val = ICF_FAILURE;
                }
#endif
                else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(p_profile,p_hdr_name[counter++],&(p_app_conf->app_profile.supported_content_types),Sdf_co_true,p_ecode))

                {
                    ret_val = ICF_FAILURE;
                }
                else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(p_profile,p_hdr_name[counter++],&(p_app_conf->app_profile.supported_encodings),Sdf_co_true,p_ecode))

                {
                    ret_val = ICF_FAILURE;
                }
                else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(p_profile,p_hdr_name[counter++],&(p_app_conf->app_profile.supported_languages),Sdf_co_true,p_ecode))
                {
                    ret_val = ICF_FAILURE;
                }				
                if(ICF_FAILURE == ret_val)
                    break;
            }
        }
    }
  
    return ret_val;
}


/*****************************************************************************
 ** FUNCTION:           icf_ssa_make_profile_for_internal_subscribe
 **
 ** DESCRIPTION:        This function makes a SIP profile for ICF initated 
 **                     SUBSCRIBE
 **
 *****************************************************************************/
icf_return_t icf_ssa_make_profile_for_internal_subscribe(Sdf_st_initData *p_profile,
                                                               icf_ssa_pdb_st *p_ssa_pdb)
{
    icf_return_t                 ret_val = ICF_SUCCESS;
    Sdf_st_error                    sdf_error;
    icf_error_t                  *p_ecode;
    
    p_ecode = p_ssa_pdb->p_ecode;

    /* Clone from default profile */
    if ( ICF_FAILURE == icf_ssa_clone_profile_data(p_ssa_pdb->p_glb_pdb,
        p_profile, p_ssa_pdb->p_ssa_glb_data->p_default_profile,p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    /* Hardcoding reg event package in the request */
    else if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Supported","reg",Sdf_co_true,&sdf_error))
    {
        /* clean up*/
        ret_val = ICF_FAILURE;
    }
    /* Hardcoding reg event package in the request */
    else if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Allow","NOTIFY",Sdf_co_true,&sdf_error))
    {
        /* clean up*/
        ret_val = ICF_FAILURE;
    }  
    /* Hardcoding reg event package: content-type accepted in the NOTIFY */

    /* Fix for SPR 10936
     */
    else if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Accept",
            "application/reginfo+xml",Sdf_co_true,&sdf_error))
    {
        /* clean up*/
        ret_val = ICF_FAILURE;
    }
    else if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Accept",
            "multipart/mixed",Sdf_co_true,&sdf_error))
    {
        /* clean up*/
        ret_val = ICF_FAILURE;
    }
    else if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Accept",
            "multipart/related",Sdf_co_true,&sdf_error))
    {
        /* clean up*/
        ret_val = ICF_FAILURE;
    }



    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_validate_basic_method
 **
 ** DESCRIPTION:        This function checks if the method in sip message is 
 **                     supported by the application. This fn checks only the 
 **                     basic methods (INVITE,ACK,CANCEL,OPTIONS,BYE)
 **                     p_invalid is set to true if method recieved one of the 
 **                     basic methods and the application supports basic
 **                     methods. Otherwise it is set to false
 **
 *****************************************************************************/
icf_return_t icf_ssa_validate_basic_method(
                                                 icf_ssa_pdb_st *p_ssa_pdb,
                                                 SipMessage *p_sip_msg, 
                                                 icf_boolean_t *p_invalid)
{
    icf_uint8_t *p_method;
    Sdf_ty_messageType dMethodType = Sdf_en_unknownRequest;
    Sdf_st_error sdf_err;
    icf_return_t ret_val = ICF_SUCCESS;
    icf_boolean_t match_found = ICF_FALSE;
    *p_invalid = ICF_FALSE;

    if(sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg, \
        ((Sdf_ty_s8bit ** )&p_method),  &sdf_err) == Sdf_co_fail)
    {
        ret_val = ICF_FAILURE;
    }
    else if(Sdf_co_fail == sdf_fn_uaGetMethodNameAsEnum((const icf_int8_t *)p_method, &dMethodType, &sdf_err))
    {
        ret_val = ICF_FAILURE;
    }
    else if(ICF_NULL == p_ssa_pdb->p_app_conf)
    {
        *p_invalid = ICF_TRUE;
    }
    else if ( ( (dMethodType == Sdf_en_invite)||     
        (dMethodType == Sdf_en_ack)    ||     \
        (dMethodType == Sdf_en_cancel) ||     \
        (dMethodType == Sdf_en_update) || \
        (dMethodType == Sdf_en_bye)    ||     \
        (dMethodType == Sdf_en_options) ) &&
        (ICF_FALSE == p_ssa_pdb->p_app_conf->app_profile.basic_method_support))
    {
        *p_invalid = ICF_TRUE;
    }
    else
    {
        icf_string_list_st *p_supp_methods =
            &(p_ssa_pdb->p_app_conf->app_profile.supported_methods);

        if(ICF_NULL == p_supp_methods)
        {
            *p_invalid = ICF_TRUE;
        }
        else
        {
            icf_string_list_node_st *p_cur_node = ICF_NULL;
            icf_uint8_t i = 0;

            for(i = (icf_uint8_t)p_supp_methods->count,p_cur_node = p_supp_methods->p_list;
                    i--; 
                    p_cur_node = p_cur_node->p_next)
            {
                if(0 == icf_port_strcasecmp((const icf_int8_t *)p_method,(const icf_int8_t *)p_cur_node->str.str))
                {
                    match_found = ICF_TRUE;
                    break;
                }
                else if (((Sdf_en_invite == dMethodType) || 
                            (Sdf_en_cancel == dMethodType) ||
                            (Sdf_en_ack == dMethodType) ||
                            (Sdf_en_bye == dMethodType) ||
                            (Sdf_en_options == dMethodType) ||
                            (Sdf_en_update == dMethodType)
                         ) &&
                        (0 == 
                         icf_port_strcasecmp((const icf_int8_t *)p_cur_node->str.str,(const icf_int8_t *)"INVITE"))
                        )
                { 
                    match_found = ICF_TRUE;
                    break;
                }
            }
        }
    }

    if((ICF_TRUE == *p_invalid) || (ICF_FALSE == match_found))  
    {
        *p_invalid = ICF_TRUE;
        if(Sdf_en_unknownRequest == dMethodType)
        {
            p_ssa_pdb->p_ssa_ctxt->failure_bitmask |=
                ICF_SSA_FAILURE_RESP_CODE_501;
        }
        else
        {
            p_ssa_pdb->p_ssa_ctxt->failure_bitmask |=
                ICF_SSA_FAILURE_RESP_CODE_405;
        }
    }

    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_make_allow_hdr_from_app_profile
 **
 ** DESCRIPTION:        This function makes an allow header from the methods 
 **                     specified in the supported methods list of an application
 *****************************************************************************/

icf_return_t icf_ssa_make_allow_hdr_from_app_profile(icf_ssa_pdb_st *p_ssa_pdb,
                                                           SipHeader **p_p_allow_hdr)
{
    SipError sip_err;
    icf_return_t ret_val=ICF_SUCCESS;
    icf_string_st allow_string;
    icf_uint32_t count;
    icf_string_list_node_st *p_cur_node;
    icf_app_id_t     app_id = ICF_APP_ID_INVALID;

    if(ICF_NULL == p_ssa_pdb->p_app_conf)
    {
        p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= ICF_SSA_FAILURE_RESP_CODE_405;
        /* The most obvious reason for sending 405 is that none of 
         * the configured applications supports the received method.
         * But the 405 response must contain Allow header. So we 
         * will form the Allow header from the profile of 1st app.
         * ICF always assigns app_id=1 to the 1st app.
         */
        app_id = 1;
        ret_val = icf_cfg_fetch_app_conf(
                   p_ssa_pdb->p_glb_pdb, app_id,
                   &(p_ssa_pdb->p_app_conf),p_ssa_pdb->p_ecode);

    }

    if(ICF_NULL == p_ssa_pdb->p_app_conf)
    {
        *p_p_allow_hdr = ICF_NULL;
        return ICF_FAILURE;
    }

    if(SipFail == sip_initSipHeader(p_p_allow_hdr, SipHdrTypeAllow,&sip_err))
        return ICF_FAILURE;

    icf_port_strcpy(allow_string.str,(icf_uint8_t *)"");

    if(ICF_TRUE == p_ssa_pdb->p_app_conf->app_profile.basic_method_support)
    {
        /* add the basic methods */
        icf_port_strcat(allow_string.str,(icf_uint8_t *)"INVITE,ACK,CANCEL,BYE,UPDATE,OPTIONS");
    }

    for(count = p_ssa_pdb->p_app_conf->app_profile.supported_methods.count,
        p_cur_node = p_ssa_pdb->p_app_conf->app_profile.supported_methods.p_list;
    count--;
    p_cur_node = p_cur_node->p_next)
    {
        /* add to allow header */
        if(ICF_NULL == icf_port_strstr((const icf_int8_t *)allow_string.str,(const icf_int8_t *) p_cur_node->str.str))
        {
            if(0 < icf_port_strlen(allow_string.str))
            {
                icf_port_strcat(allow_string.str,(icf_uint8_t *)",");
            }
            icf_port_strcat(allow_string.str,p_cur_node->str.str);
        }
    }
    if(0 < icf_port_strlen(allow_string.str))
    {
        if(SipFail == sip_setMethodInAllowHdr(*p_p_allow_hdr,Sdf_mc_strdupSdp((const icf_int8_t *)allow_string.str), &sip_err))
        {
            ret_val = ICF_FAILURE;
        }
    }
    else
    {
        sip_freeSipHeader(*p_p_allow_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                *p_p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        *p_p_allow_hdr = ICF_NULL;
    }
    
    if(ICF_FAILURE == ret_val)
    {
        sip_freeSipHeader(*p_p_allow_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                *p_p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        *p_p_allow_hdr = ICF_NULL;
    }
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_make_allow_hdr_for_reg
 **
 ** DESCRIPTION:        This function makes an allow header for REGISTER
 *****************************************************************************/

icf_return_t icf_ssa_make_allow_hdr_for_reg(icf_ssa_pdb_st *p_ssa_pdb,
                                                           SipHeader **p_p_allow_hdr)
{
    SipError sip_err;
    icf_return_t ret_val=ICF_SUCCESS;
    icf_string_list_node_st *p_cur_node;
    icf_string_st allow_string;
    icf_uint8_t count1,count2;
    icf_rgm_app_ctxt_st    *p_app_data;
    icf_app_conf_st *p_app_conf;
    icf_error_t ecode;
    icf_boolean_t basic_methods = ICF_FALSE;


  

    if(SipFail == sip_initSipHeader(p_p_allow_hdr, SipHdrTypeAllow,&sip_err))
        return ICF_FAILURE;

    icf_port_strcpy(allow_string.str,(icf_uint8_t *)"");
    
    /* Iterate on every application */
    for(count1 = 0;count1<p_ssa_pdb->p_glb_cfg_data->max_applications;count1++)
    {
        p_app_data =(icf_rgm_app_ctxt_st*)
            &(p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->p_app_data_list[count1]);
        
        if (ICF_FALSE == p_app_data->is_valid)
            continue;
        
        if(ICF_FAILURE == icf_cfg_fetch_app_conf(
            p_ssa_pdb->p_glb_pdb,
            p_app_data->app_id,
            &p_app_conf,
            &ecode))
        {
            /* Free Memory */
            ret_val = ICF_FAILURE;
            break;
        }
        if ((ICF_FALSE == basic_methods)&&
            (ICF_TRUE == p_app_conf->app_profile.basic_method_support))
        {
            basic_methods = ICF_TRUE;
            if(0 < icf_port_strlen(allow_string.str))
            {
                icf_port_strcat(allow_string.str,(icf_uint8_t *)",");
            }
            /* add the basic methods */
            icf_port_strcat(allow_string.str,(icf_uint8_t *)"INVITE,ACK,CANCEL,BYE,OPTIONS");
        }

        /* Iterate on all methods */
        for(count2 = (icf_uint8_t)p_app_conf->app_profile.supported_methods.count,
            p_cur_node = p_app_conf->app_profile.supported_methods.p_list;
        count2--;
        p_cur_node = p_cur_node->p_next)
        {
            if(ICF_NULL == icf_port_strstr((const icf_int8_t *)allow_string.str,
                                          (const icf_int8_t *)p_cur_node->str.str))
            {
                /* add to allow header */
                if(0 < icf_port_strlen(allow_string.str))
                {
                    icf_port_strcat(allow_string.str,(icf_uint8_t *)",");
                }
                icf_port_strcat(allow_string.str,p_cur_node->str.str);
            }
        }
    }
    if(ICF_SUCCESS == ret_val)
    {
        if(0 < icf_port_strlen(allow_string.str))
        {
            if(SipFail == sip_setMethodInAllowHdr(*p_p_allow_hdr,
                Sdf_mc_strdupSdp((const icf_int8_t *)allow_string.str), &sip_err))
            {
                ret_val = ICF_FAILURE;
            }
        }
        else
        {
            sip_freeSipHeader(*p_p_allow_hdr);
            
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                *p_p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
            *p_p_allow_hdr = ICF_NULL;
                
        }

    }

    if(ICF_FAILURE == ret_val)
    {
        sip_freeSipHeader(*p_p_allow_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                *p_p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        *p_p_allow_hdr = ICF_NULL;
    }
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_make_allow_hdr_for_int_subscribe
 **
 ** DESCRIPTION:        This function makes an allow header for SUBSCRIBE
 *****************************************************************************/
icf_return_t icf_ssa_make_allow_hdr_for_int_subscribe(icf_ssa_pdb_st *p_ssa_pdb,
                                                           SipHeader **p_p_allow_hdr)
{
    SipError sip_err;
    icf_return_t ret_val=ICF_SUCCESS;

    if(SipFail == sip_initSipHeader(p_p_allow_hdr, SipHdrTypeAllow,&sip_err))
        return ICF_FAILURE;
    
    if(SipFail == sip_setMethodInAllowHdr(*p_p_allow_hdr,Sdf_mc_strdupSdp("NOTIFY"), &sip_err))
    {
        ret_val = ICF_FAILURE;
        sip_freeSipHeader(*p_p_allow_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                *p_p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        *p_p_allow_hdr = ICF_NULL;
        
    }

    return ret_val;
}


/*****************************************************************************
** FUNCTION: icf_ssa_addDefaultHeader
**
** DESCRIPTION: Adds Header information to the call profile.
**
******************************************************************************/
icf_return_t icf_ssa_addDefaultHeader
    (Sdf_st_initData *pInitData,
    icf_int8_t *pName,
    icf_int8_t *pValue,
    Sdf_ty_bool dAddAlways,
    Sdf_st_error *pErr)
{
    Sdf_ty_s8bit *current_name = Sdf_co_null;
    Sdf_ty_s8bit *pTmpValue = Sdf_co_null;
    Sdf_ty_u32bit valueCount,match_found=0;
    Sdf_ty_u32bit index=0;
    Sdf_st_configExtraHeaders *pConfHdr = Sdf_co_null;
    Sdf_st_listIterator dListIterator;
    Sdf_ty_bool duplicate_value = Sdf_co_false;

    /* Error checks in the input parameters */
    sdf_listInitIterator(&(pInitData->slExtraHeadersList), \
        &dListIterator, pErr);
#ifdef ICF_STRICT_TEST
    if(ICF_NULL == pValue)
    {
        pErr->errCode=Sdf_en_invalidParamError;
        ICF_ALARM(((icf_uint8_t *)" :[SSA]: Invalid Value in default header\n"));
        return Sdf_co_fail;
    }
    else if(ICF_NULL == *pValue)
    {
        pErr->errCode=Sdf_en_invalidParamError;
        ICF_ALARM(((icf_uint8_t *)" :[SSA]: Invalid Value in default header\n"));
                return Sdf_co_fail;
    }
#endif

    while (dListIterator.pCurrentElement != Sdf_co_null)
    {
        pConfHdr =(Sdf_st_configExtraHeaders *) \
                    (dListIterator.pCurrentElement->pData);


        if(pConfHdr->pParam == Sdf_co_null)
        {    
            pErr->errCode=Sdf_en_invalidParamError;
            return Sdf_co_fail;
        }

        if(sip_getNameFromSipParam(pConfHdr->pParam,&current_name,\
                (SipError*)&(pErr->stkErrCode)) == SipFail)
        {
            pErr->errCode=Sdf_en_headerManipulationError;
            return Sdf_co_fail;
        }
        if(Sdf_mc_strcasecmp(current_name,pName) ==0)
        {
            Sdf_ty_s8bit *p_val= Sdf_co_null;
            if( sip_getValueCountFromSipParam(pConfHdr->pParam,&valueCount,\
                (SipError*)&(pErr->stkErrCode)) == SipFail)
            {
                pErr->errCode=Sdf_en_headerManipulationError;
                return Sdf_co_fail;
            }
               for (index =0;index<valueCount;index++ )
            {
               if(SipFail == sip_getValueAtIndexFromSipParam(
                   pConfHdr->pParam,
                   &p_val, 
                   index, 
                   (SipError*)&(pErr->stkErrCode)))
               {
                   return Sdf_co_fail;
               }
               if(0 == Sdf_mc_strcasecmp(p_val,pValue))
               {
                   /* Do not add this value as it is already present*/
                   duplicate_value = Sdf_co_true;
                   break;
               }
            }
            if(Sdf_co_false == duplicate_value)        
            {
                pTmpValue = Sdf_mc_strdupCallHandler(pValue);
                if(sip_insertValueAtIndexInSipParam(pConfHdr->pParam, pTmpValue, \
                    valueCount, (SipError*)&(pErr->stkErrCode)) == SipFail)
                {
                    pErr->errCode=Sdf_en_headerManipulationError;
                    return Sdf_co_fail;
                }
            }
            match_found =1;
        }
        sdf_listNext(&dListIterator, pErr);
    }

    if(!match_found)
    {
        if(sdf_ivk_uaInitConfigExtraHeaders(&pConfHdr,pErr) == Sdf_co_fail)
        {
            pErr->errCode=Sdf_en_noMemoryError;
            return Sdf_co_fail;
        }

        pTmpValue = Sdf_co_null;

        pTmpValue = Sdf_mc_strdupCallHandler(pName);

        if (sip_setNameInSipParam(pConfHdr->pParam, pTmpValue, \
            (SipError*)&(pErr->stkErrCode)) == SipFail)
        {
            pErr->errCode=Sdf_en_headerManipulationError;
            return Sdf_co_fail;
        }

        pTmpValue = Sdf_co_null;

        pTmpValue = Sdf_mc_strdupCallHandler(pValue);


        if(sip_insertValueAtIndexInSipParam(pConfHdr->pParam, pTmpValue, 0, \
            (SipError*)&(pErr->stkErrCode)) == SipFail)
        {
            pErr->errCode=Sdf_en_headerManipulationError;
            return Sdf_co_fail;
        }
        
        /* ---- CSR 1-4986136 ---- */	
        /* For an incoming call, the headers in subsequent messages in that
         * dialog are inserted by sdf_ivk_uaAddExtraHeaders( ) from 
         * slExtraHeadersList formed here. Now we need 
         * that the Supported and Accept headers should not be inserted from 
         * app-profile. Rather, they should be inserted in the SIP msg only if 
         * sent by app in that request's header list.
         * This expected behavior is same as for an outgoing call where the 
         * call object specific profile contains Supported and Accept from header 
         * list and not from app-profile formed during app_add_req.
         * Therefore, insert these headers in ExtraHeadersList for processing but 
         * do not send in each message.
         */


        /* ---- CSR 1-4986136 ---- */	
	/* For an incoming call, the headers in subsequent messages in that
	 * dialog are inserted by sdf_ivk_uaAddExtraHeaders( ) from 
	 * slExtraHeadersList formed here. Now we need 
         * that the Supported and Accept headers should not be inserted from 
         * app-profile. Rather, they should be inserted in the SIP msg only if 
         * sent by app in that request's header list.
         * This expected behavior is same as for an outgoing call where the 
         * call object specific profile contains Supported and Accept from header 
         * list and not from app-profile formed during app_add_req.
	 * Therefore, insert these headers in ExtraHeadersList for processing but 
	 * do not send in each message.
         */
	/*LOAD FIX 
	if ((0 == icf_port_strcasecmp("Supported", pName)) ||
		(0 == icf_port_strcasecmp("Accept", pName)))
	{
		dAddAlways = Sdf_co_false;
	}
	*/
        if (dAddAlways == Sdf_co_true)
        {
            pConfHdr->pData = Sdf_mc_strdupConfig("yes");
        }

        if(sdf_listAppend(&(pInitData->slExtraHeadersList),\
            (Sdf_ty_pvoid)pConfHdr,pErr) ==Sdf_co_fail)
        {
            pErr->errCode=Sdf_en_headerManipulationError;
            return Sdf_co_fail;
        }    
    }

    pErr->errCode = Sdf_en_noUaError;
    return Sdf_co_success;
}
/*****************************************************************************
** FUNCTION: icf_ssa_match_app_filter
**
** DESCRIPTION: Match application Filter
**
******************************************************************************/

icf_return_t icf_ssa_match_app_filter(icf_ssa_pdb_st *p_ssa_pdb,
                                        SipMessage *p_sip_msg,
                                        icf_app_conf_st *p_app_conf,
                                        icf_boolean_t *p_match_success,
                                        icf_error_t *p_ecode)
{
    icf_int_filter_st  *p_list_ptr = ICF_NULL;
    icf_uint8_t        *p_method=ICF_NULL;
    Sdf_st_error          sdf_err;

    if(ICF_NULL == p_app_conf->p_filter_list)
    {
        *p_match_success = ICF_TRUE;  
        return ICF_SUCCESS;
    }


    /*  match_filter */
    for (p_list_ptr = (p_app_conf->p_filter_list)->p_filter_list;  
    ICF_NULL != p_list_ptr;
    p_list_ptr = (icf_int_filter_st *)p_list_ptr->p_next)
    {
        *p_match_success = ICF_FALSE;  
        switch(p_list_ptr->filter_type) 
        {
        case ICF_FILTER_BY_HEADER_NAME :
            {
                /* check if header present */
                if(ICF_FAILURE == icf_ssa_match_header_filter(
                    p_sip_msg,
                    p_list_ptr,
                    p_match_success,
                    p_ecode))
                {
                    return ICF_FAILURE;
                }
                break;
            }
        case ICF_FILTER_BY_HEADER_CONTENT :
            {
                if(ICF_FAILURE == icf_ssa_match_header_filter(
                    p_sip_msg,
                    p_list_ptr,
                    p_match_success,
                    p_ecode))
                {
                    return ICF_FAILURE;
                }
                
                break;
            }
        case ICF_FILTER_BY_METHOD_NAME :
            {
                /*get method name*/
                if(Sdf_co_fail == sdf_ivk_uaGetMethodFromSipMessage(
                    p_sip_msg,
                    (( Sdf_ty_s8bit **)&p_method),
                    &sdf_err))
                {
                    return ICF_FAILURE;
                }
                icf_ssa_match_string(
                    p_method,
                    (p_list_ptr->filter_expr).p_match_str_list->p_str,
                    p_list_ptr->match_type,
                    p_match_success);
                break;
            }
        case ICF_FILTER_BY_REQ_URI_HDR_PARAM :
            {
                /* extract & match request uri */
                if(ICF_FAILURE == icf_ssa_match_req_line_filter(
                    p_sip_msg,
                    p_list_ptr,
                    p_match_success,
                    p_ecode))
                {
                    return ICF_FAILURE;
                }
                
                break;
            }
        default : break;
        }
        if(*p_match_success != (p_app_conf->p_filter_list)->match_all)
        {
            break;
        }
    }

    if(ICF_TRUE == *p_match_success)
    {
        /* Filter Matched, now match the supported methods */
        if(ICF_FAILURE == icf_ssa_match_app_methods(p_ssa_pdb,p_sip_msg,
                p_app_conf,
                p_match_success,p_ecode))
        {
            return ICF_FAILURE;
        }
    }
    return ICF_SUCCESS;
}


/*****************************************************************************
** FUNCTION: icf_ssa_match_app_methods
**
** DESCRIPTION: Match application's Supported Methods 
**
******************************************************************************/

icf_return_t icf_ssa_match_app_methods(icf_ssa_pdb_st *p_ssa_pdb,
                                        SipMessage *p_sip_msg,
                                        icf_app_conf_st *p_app_conf,
                                        icf_boolean_t *p_match_success,
                                        icf_error_t *p_ecode)
{
    
    icf_uint8_t        *p_method=ICF_NULL;
    Sdf_st_error       sdf_err;
    icf_string_list_st *p_supp_methods =
        &(p_app_conf->app_profile.supported_methods);

   /* To remove warnings */
    p_ssa_pdb=p_ssa_pdb;
    p_ecode=p_ecode; 
    *p_match_success = ICF_FALSE;
    if(ICF_NULL == p_supp_methods)
    {
        *p_match_success = ICF_TRUE;
    }
           
    if(ICF_NULL != p_supp_methods)
    {
        icf_string_list_node_st *p_cur_node = ICF_NULL;
        icf_uint32_t i = 0;
        
        /*See whether the Method matches with the suppoted
        *methods of the application or not
        */
        if(Sdf_co_fail == sdf_ivk_uaGetMethodFromSipMessage(
            p_sip_msg,
            (( Sdf_ty_s8bit **)&p_method),
            &sdf_err))
        {
            return ICF_FAILURE;
        }
        else
        {
            Sdf_ty_messageType  msg_type;
            sdf_fn_uaGetMethodNameAsEnum((const icf_int8_t *)p_method, &msg_type, &sdf_err);
            for(i = p_supp_methods->count,p_cur_node = p_supp_methods->p_list;
            i--; 
            p_cur_node = p_cur_node->p_next)
            {
                if(0 == icf_port_strcasecmp((const icf_int8_t *)p_method,(const icf_int8_t *)p_cur_node->str.str))
                {
                    *p_match_success = ICF_TRUE;
                    break;
                }
                else if (((Sdf_en_invite == msg_type) || 
                    (Sdf_en_cancel == msg_type) ||
                    (Sdf_en_ack == msg_type) ||
                    (Sdf_en_bye == msg_type) ||
                    (Sdf_en_prack == msg_type) ||
                    (Sdf_en_options == msg_type) ||
                    (Sdf_en_update == msg_type)
                    ) &&
                    (0 == 
                    icf_port_strcasecmp((const icf_int8_t *)p_cur_node->str.str,(const icf_int8_t *)"INVITE"))
                    )
                { 
                    *p_match_success = ICF_TRUE;
                    break;
                }
            }
        }/* Get Method Succeded*/
    }/*(ICF_NULL != p_hdr_content)*/
    return ICF_SUCCESS;
}

/*Message body header changes start*/
/*****************************************************************************
** FUNCTION: icf_ssa_get_media_type_from_content_type
**
** DESCRIPTION: The function extracts the media_type from the content-type 
**              header provided by the application to be present in the SIP 
**              message header or in the message body part.
**
******************************************************************************/

icf_return_t icf_ssa_get_media_type_from_content_type(
        INOUT  icf_uint8_t      *p_content_type,
        OUT Sdf_ty_s8bit        **p_p_media_type
        )
{
    char               delim[10] = {'\0'};
    Sdf_ty_s8bit       *p_ctype = "\0";
        
    /* Parse the content-type string to extract the media_type value
     */
    strcpy(delim,";\r\n");

    if(ICF_NULL != p_content_type)
    {
        Sdf_mc_strdup(p_ctype,p_content_type);
        p_ctype = strtok(p_ctype,delim);
        Sdf_mc_strdup(*p_p_media_type,p_ctype);
        sdf_memfree(Sdf_mc_callHandlerMemId, \
            (Sdf_ty_pvoid *)&p_ctype, Sdf_co_null);
    }
    else
    {
        return ICF_FAILURE;
    }

    return ICF_SUCCESS;
    
}/*End of icf_ssa_get_media_type_from_content_type.*/


/*****************************************************************************
** FUNCTION: icf_ssa_get_content_type_from_msg
**
** DESCRIPTION: The function extracts the content_type from incoming
**              SIP message or message body. This will extract the Media
**              Type and parameters from the Content-Type, if any are 
**              present in the content-type header. This function will
**              invoke SIP APIS directly to get the content-type header 
**              values.
**
******************************************************************************/

icf_return_t icf_ssa_get_content_type_frm_msg(
         /*INOUT   Sdf_st_callObject  *pObj, */
        INOUT   en_SipMessageType  dReqRespType,
        INOUT   icf_ssa_pdb_st     *p_ssa_pdb,
        INOUT   SipHeader          *pHeader,
        OUT  icf_int8_t        **p_p_content_type
        )
{
    icf_uint8_t    count = 0;
    icf_uint8_t    index = 0;
    Sdf_ty_s8bit   *pMediaType = ICF_NULL;
    SipError        error;
    SipParam        *p_param_list = ICF_NULL;
    SipError        pErr;
    Sdf_st_error    sdf_error;
    Sdf_ty_s8bit    temp_buff[300];
    Sdf_st_initData *pInitData;
    icf_return_t    ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb);

    /* Get Media-Type from Content-Type header
     */
    pInitData = p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData ;
    if (sip_getMediaTypeFromContentTypeHdr(pHeader, &pMediaType,\
                &error) == SipFail)
        {
          ICF_PRINT(((icf_uint8_t *)"\nFailed to get media-type from Content-Type "\
                  "Header"));
          sip_freeSipHeader(pHeader);
          return ICF_FAILURE;
        }
    /* Fix for content-type validation in Body Part
     */
    /* Validate the Content-Type Header in the Incoming SIP
     * Message body part
     */
    /* Check if the message body list is supported
     */
    if(ICF_FAILURE == icf_ssa_IsSupportedMediaTypeInMsgBody(\
                        /*pObj*/dReqRespType,pInitData,pMediaType,&sdf_error))
    {
        /* Media-Type in Content-Type of message body part is not supported
         */
        /* Generate 415 response
         */
        ICF_PRINT(((icf_uint8_t *)"[SSA:] Validation of Content-Type failed\n"));
        /* SPR 11096 Changes Start : Set the bitmask in ssa-ctxt to 
         * to indicate that 415 response is to be sent.
         */
         /*
        SipOptions        dOptions;
        SipMessage        *pMessage = Sdf_co_null;
        Sdf_st_transaction    *pTransaction = Sdf_co_null;
        Sdf_st_overlapTransInfo    *pOverlapTransaction = Sdf_co_null;
        dOptions.dOption= SIP_OPT_CLEN | SIP_OPT_FULLFORM;
        if(ICF_NULL != pObj->pUasTransaction->pSipMsg)
            pMessage = pObj->pUasTransaction->pSipMsg;
        else
            pMessage = pObj->pUacTransaction->pSipMsg;
            */
            /* 
         * Bad Content received in Content-type header. 415 unsupported
         * formed by UATK. Send the SipMsg by using .
         * sdf_ivk_uaGetTransactionForSipMsg
          */
        /*
        if (sdf_ivk_uaRejectRequest(pObj,\
                pInitData,415, &pOverlapTransaction, &sdf_error) == Sdf_co_fail)
        {
            ICF_PRINT(("\n[SSA]:Failed to form 415 response "));
            return ICF_FAILURE;
        }
            
        pMessage = pOverlapTransaction->pSipMsg;

        ICF_PRINT(("[SSA:] Validation of Content-Type failed\n"));
            
        if (ICF_FAILURE == icf_ssa_send_to_peer(p_ssa_pdb,
                    (pObj), pMessage, &dOptions,&sdf_error))
        {
            ret_val = ICF_FAILURE;
        }

        sdf_ivk_uaFreeOverlapTransInfo(pOverlapTransaction);

        
        if(sdf_ivk_uaGetTransactionForSipMsg(\
                (pObj), pMessage, &pTransaction, \
            &pOverlapTransaction, &sdf_error) == Sdf_co_success)
        {
            if(pOverlapTransaction == Sdf_co_null)
            {
                pMessage = pTransaction->pSipMsg;
                sdf_ivk_uaFreeTransaction(pTransaction);
            }
            else
            {
                pMessage = pOverlapTransaction->pSipMsg;
                sdf_ivk_uaFreeOverlapTransInfo(pOverlapTransaction);
            }

                        
            ICF_PRINT(("[SSA:] Validation of Content-Type failed\n"));
            if (ICF_FAILURE == icf_ssa_send_to_peer(p_ssa_pdb,
                    (pObj), pMessage, &dOptions,&sdf_error))
            {
                ret_val = ICF_FAILURE;
            }

        }*/
        p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
                    ICF_SSA_FAILURE_RESP_CODE_415;
        ret_val = ICF_FAILURE;
    }
       /*End of generating 415 response
        */
    else
    {
        Sdf_mc_strcpy(temp_buff,pMediaType);

        /* Get Parameter Count from the Content - Type header
         */
#if 0    
        if(sip_getParamCountFromContentTypeHdr(pHeader,(unsigned int *)\
                           &count, &pErr)!=SipFail)
#endif
        /* fix taken from Presence testing team while testing on device */
        if (!pHeader || !pHeader->pHeader)
        {
        }
        else
        {
            SipCommonHeader    *pCommonHdr = ICF_NULL;
            
            pCommonHdr = (SipCommonHeader*)(pHeader->pHeader);
            count = (icf_uint8_t) pCommonHdr->slParam.size;
            /* For each parameter get the parameter name and value
             *  and append to the content-type as string to be 
             *  passed to the application.
             */
            for(index = 0; index < count ; index++)
            {
                if(SipFail != sip_getParamAtIndexFromContentTypeHdr(
                            pHeader,&p_param_list,index,&pErr))
                {

                    if(ICF_NULL != p_param_list)
                    {
                        sdf_fn_uaSprintf(temp_buff+Sdf_mc_strlen(temp_buff),\
                            ";%s=%s",p_param_list->pName,
                            p_param_list->slValue.head->pData);

                        sip_freeSipParam(p_param_list);
                    }
                    
                }
                else
                    break;
                    
            }/*end of For Loop*/

            Sdf_mc_strdup(*p_p_content_type,temp_buff);
            
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
    return ret_val;

}

/************************************************************************
** FUNCTION: icf_ssa_set_unknown_hdr_in_MimeHdr
**
** DESCRIPTION: This function populates the unknown header in the SIP 
**              message body. These headers will be provided by the 
**              application. This function will invoke the SIP APIs 
**              directly to set the header.
**
************************************************************************/

icf_return_t icf_ssa_set_unknown_hdr_in_MimeHdr(
        INOUT    icf_header_st     *p_msg_hdr,
        INOUT  SipMimeHeader     *pMimeHdr
        )
{
    SipHeader     *pHeader = Sdf_co_null;
    Sdf_ty_s8bit  *pUnknownHdr = Sdf_co_null;
    Sdf_ty_s8bit  *pUnknownHdrName = Sdf_co_null;
    SipError      sip_error;
    
    if(SipFail == sip_initSipHeader(&pHeader,SipHdrTypeUnknown,\
                (SipError *)&sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\nCould not insert Message Body header"\
                    " in the SIP message\n"));
        return ICF_FAILURE;
    }

    Sdf_mc_strdup(pUnknownHdr,p_msg_hdr->hdr_value.str);
    Sdf_mc_strdup(pUnknownHdrName,p_msg_hdr->hdr_name.str);
    if(SipFail == sip_setNameInUnknownHdr(pHeader,pUnknownHdrName,\
        &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"Unable to set Message body header Name\n"));
        sip_freeSipHeader(pHeader);
        return ICF_FAILURE; 
    }
    else if(SipFail == sip_setBodyInUnknownHdr(pHeader,pUnknownHdr,\
                &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"Unable to set Message body header Value\n"));
        sip_freeSipHeader(pHeader);
        return ICF_FAILURE; 
    }
    /* Set the SIP header as MIME header in the message body.
     */
    else if(SipFail == sip_bcpt_insertAdditionalMimeHdrAtIndexInMimeHdr(\
                pMimeHdr,pHeader, 0 , &sip_error))
    {
        /* Free any local reference*/
        ICF_PRINT(((icf_uint8_t *)"Unable to set MIME Header in the message body\n"));
        sip_freeSipHeader(pHeader);
        return ICF_FAILURE; 
        
    }

    sip_freeSipHeader(pHeader);

    /* Free any local reference*/
    return ICF_SUCCESS; 
}

/************************************************************************
** FUNCTION: icf_ssa_form_and_insert_content_disp_hdr_in_msg
**
** DESCRIPTION: This function form and insert the content disposition 
**              header in the SIP message body headers in the outgoing 
**              request.
**
*************************************************************************/
icf_return_t icf_ssa_form_and_insert_content_disp_hdr_in_msg(
        INOUT    icf_header_st          *p_msg_hdr,
        INOUT  SipMimeHeader          *pMimeHdr
        )
{
    SipHeader        *pHeader = Sdf_co_null;
    Sdf_ty_s8bit     *pContentDisp = Sdf_co_null;
    SipError         sip_err;    
    icf_error_t  ecode = ICF_ERROR_NONE;
    icf_return_t     ret_val = ICF_SUCCESS;

    if(SipFail == sip_initSipHeader(&pHeader,\
                SipHdrTypeContentDisposition,\
                (SipError*)&sip_err))
    {
        ICF_PRINT(((icf_uint8_t *)"Failed to initialize Content Disposition "
                    "Header\n"));
        return ICF_FAILURE;

    }
    
    Sdf_mc_strdup(pContentDisp,p_msg_hdr->hdr_value.str);

    /* Set Content Disposition Type in the Content-Disposition header
     */
    if(SipFail == sip_setDispTypeInContentDispositionHdr(pHeader,\
                pContentDisp,(SipError *)&sip_err))
    {
        ICF_PRINT(((icf_uint8_t *)"Failed to insert Content Disposition Type"\
                " in Content- Disposition Header\n"));
        sip_freeSipHeader(pHeader);
        return ICF_FAILURE;
    }

    /* Set the Content - Disposition Header in the MIME Header
     */
    if(SipFail == sip_bcpt_setContentDispositionInMimeHdr(pMimeHdr,
                  pHeader,&sip_err))
    {
        ICF_PRINT(((icf_uint8_t *)"Failed to insert the Content Disposition"\
                " Header in the SIP message body.\n"));
        sip_freeSipHeader(pHeader);
        return ICF_FAILURE;
    }
    /*Free any local reference
     */
    sip_freeSipHeader(pHeader);
    ICF_MEMFREE(
                 p_persistent_glb_pdb,
                 pHeader,
                 ICF_MEM_COMMON,
                 &ecode,
                 ret_val)

    return ICF_SUCCESS;
}

/************************************************************************
** FUNCTION: icf_ssa_fill_msg_body_hdrs
**
** DESCRIPTION: This function insert the message body headers in the 
**              outgoing Sip Message.
**
************************************************************************/
icf_return_t icf_ssa_fill_msg_body_hdrs(
        INOUT    icf_ssa_pdb_st        *p_ssa_pdb,
        INOUT    icf_header_list_st    *p_hdr_list,
            INOUT  SipMsgBody               *pMsgBody
        )
{
    en_HeaderType       dType = SipHdrTypeAny;    
    SipError            SipErr;
    icf_header_st    *p_hdr = ICF_NULL;
    icf_uint16_t     hdr_count = 0;
    icf_return_t     ret_val = ICF_SUCCESS;
        /* To remove warnings */
        p_ssa_pdb=p_ssa_pdb;

    if(ICF_NULL != p_hdr_list->hdr)
    {
        p_hdr = p_hdr_list->hdr;
    }
    else
        return ICF_SUCCESS;
    hdr_count = (icf_uint16_t)p_hdr_list->count;

   if(ICF_NULL == pMsgBody->pMimeHeader)
   {
       /* Allocate Memory for mime header */
        if(SipFail == sip_bcpt_initSipMimeHeader(&pMsgBody->pMimeHeader,
            (SipError*)&SipErr))
        {
        /* Failed to initialize SIP Mime Header */
            ret_val = ICF_FAILURE;
        }
   }

    while(ICF_NULL != p_hdr && 0 < hdr_count)
    {
        /* Get Header Type from Name*/
        icf_ssa_get_hdr_type_from_name(p_hdr->hdr_name.str,\
                &dType,&SipErr);
        if(SipHdrTypeContentDisposition == dType)
        {
            /* Invoke the function for filling content 
             * disposition header in the Message body
             */
            if(ICF_FAILURE == 
               icf_ssa_form_and_insert_content_disp_hdr_in_msg(\
                    p_hdr,pMsgBody->pMimeHeader))
            {
                 ret_val = ICF_FAILURE;
                 break;
            }
        }
        else if(ICF_FAILURE == icf_ssa_set_unknown_hdr_in_MimeHdr(\
            p_hdr,pMsgBody->pMimeHeader))
        {
            ret_val = ICF_FAILURE;
            break;
        }
        hdr_count-- ;
        p_hdr = p_hdr->next;
    }
   return ret_val;
}

/************************************************************************
** FUNCTION: icf_ssa_get_mime_hdrs_from_sip_msg
**
** DESCRIPTION: This function retrieves the MIME headers from the SIP 
**              message. This function will invoke the SIP API's directly
**              to get these headers.
**
************************************************************************/
icf_return_t icf_ssa_get_mime_hdrs_from_sip_msg(
        /*INOUT       Sdf_st_callObject *pObj, */
        INOUT          en_SipMessageType dReqRespType,
        INOUT       icf_ssa_pdb_st    *p_ssa_pdb,
        INOUT       SipMsgBody        *pMsgBody,
        INOUT     icf_msg_body_st   *p_msg_body
        )
{
    SipMimeHeader         *pMime = Sdf_co_null;
    SipHeader             *pContentDisp = Sdf_co_null;
    icf_header_list_st    *p_hdr_list = ICF_NULL;
    icf_header_st         *p_hdr = ICF_NULL;
    icf_header_st         *p_temp_hdr = ICF_NULL;
    icf_uint8_t           *p_disp_type;
	/*Fix done for SPR-18722 : CSR-1-6068965*/
    icf_int8_t           *p_content_type=ICF_NULL;
    icf_uint8_t           *p_cid = ICF_NULL;
    SIP_S8bit              *p_cdesc=ICF_NULL;
    Sdf_ty_s8bit          *p_encoding=ICF_NULL;
    SipError              sip_err;
    Sdf_st_error          sdf_err;
    icf_return_t          ret_val = ICF_SUCCESS;
    SipBool                  sip_ret_val ;
    
    if (ICF_NULL == p_msg_body)
        return ICF_FAILURE;
        
    /* Get Mime Headers list from Message Body
     */
    if(SipFail != sip_bcpt_getMimeHeaderFromMsgBody(pMsgBody,&pMime,
                &sip_err))
    {
        /* Get Content-Type Header from Message Body
         */
                   
        ret_val = icf_ssa_get_content_type_from_mime_body(
                    /*pObj*/dReqRespType,p_ssa_pdb,\
                   pMsgBody,pMime,&p_content_type);

        if(ICF_SUCCESS == ret_val)
        {
            
            /*Fix done for SPR-18722 : CSR-1-6068965*/ 
            icf_port_memcpy(p_msg_body->content_type.str, p_content_type,\
                icf_port_strlen((icf_uint8_t *)p_content_type));
            p_msg_body->content_type.str_len = (icf_uint16_t)icf_port_strlen(\
                (icf_uint8_t *)p_content_type);
            
            sdf_memfree(Sdf_mc_callHandlerMemId, \
                (Sdf_ty_pvoid *)&p_content_type,\
                Sdf_co_null);
            p_hdr_list = &(p_msg_body->msg_body_hdr_list);
            if(ICF_NULL != p_hdr_list->hdr)    
            {
                ret_val = ICF_FAILURE;
            }
            /* Get Content - Disposition Header from MIME Body
            */
            else if (sip_initSipHeader(&pContentDisp, SipHdrTypeAny, \
                (SipError*)&(sdf_err.stkErrCode)) == SipFail)
            {
                ret_val = ICF_FAILURE;
            }
            
            else if(SipFail != sip_bcpt_getContentDispositionFromMimeHdr(\
                pMime,((SipHeader ** )&pContentDisp), &sip_err))
            {
            /* Get the Content Disposition Type from MIME
            *  Body
                */
                if(SipFail == sip_getDispTypeFromContentDispositionHdr(\
                    pContentDisp,(( SIP_S8bit ** )&p_disp_type),&sip_err))
                {
                    sip_freeSipHeader(pContentDisp);
                    sdf_memfree(Sdf_mc_callHandlerMemId, \
                        (Sdf_ty_pvoid *)&pContentDisp,Sdf_co_null);

                    ret_val = ICF_FAILURE;
                }
                /* Allocate memory for the Content Disposition 
                * Header
                */
                /*if(ICF_SUCCESS == ret_val)*/
                else
                {
                    p_hdr = (icf_header_st *)
                        sdf_memget(0,sizeof(icf_header_st),\
                        &sdf_err);
                    if(Sdf_co_null != p_hdr)
                    {
                        p_hdr_list->count ++;
                        Sdf_mc_strcpy(p_hdr->hdr_name.\
                            str,(Sdf_ty_s8bit *)\
                            "Content-Disposition");
                        
                        p_hdr->hdr_name.str_len = \
                            
                            (icf_uint16_t) icf_port_strlen(p_hdr->\
                            hdr_name.str);
                        Sdf_mc_strcpy(p_hdr->hdr_value.\
                            str,p_disp_type);
                        p_hdr->hdr_value.str_len = \
                            (icf_uint16_t) icf_port_strlen(p_hdr->\
                            hdr_value.str);
                        p_hdr->next = ICF_NULL;
                        
                        if(ICF_NULL == p_hdr_list->hdr)
                        {
                            p_hdr_list->hdr = p_hdr;
                            p_temp_hdr = p_hdr_list->hdr;
                        }
                    }
                }
                
            }/*End of if block for Content Disposition Header*/
            
            if (ICF_FAILURE  != ret_val)
            {
                sip_freeSipHeader(pContentDisp);
                sdf_memfree(Sdf_mc_callHandlerMemId, \
                    (Sdf_ty_pvoid *)&pContentDisp,Sdf_co_null);
            }
             /* Get Content-Id from MIME Body
            */

            if((ICF_SUCCESS == ret_val) &&
                                (SipFail != sip_bcpt_getContentIdFromMimeHdr(pMime, 
                &p_cid, &(sip_err))))
            {
            /* Allocate memory for the Content Id Header
                */
                p_hdr = (icf_header_st *)
                    sdf_memget(0,sizeof(icf_header_st),
                    &sdf_err);
                if(Sdf_co_null != p_hdr)
                {
                    p_msg_body->msg_body_hdr_list.count ++;
                    Sdf_mc_strcpy(p_hdr->hdr_name.str,\
                        (icf_uint8_t *)"Content-Id");
                    p_hdr->hdr_name.str_len = \
                       (icf_uint16_t) icf_port_strlen(p_hdr->\
                        hdr_name.str);
                    Sdf_mc_strcpy(p_hdr->hdr_value.str,\
                        (icf_uint8_t *)p_cid);
                    p_hdr->hdr_value.str_len = \
                        (icf_uint16_t) icf_port_strlen(p_hdr->hdr_value.str);
                    
                    p_hdr->next = ICF_NULL;
                    
                    if(ICF_NULL == p_hdr_list->hdr)
                    {
                        p_hdr_list->hdr = p_temp_hdr = p_hdr;                         
                    }
                    else if (ICF_NULL != p_temp_hdr)
                    {
                        p_temp_hdr->next = p_hdr;
                        p_temp_hdr = p_temp_hdr->next;
                    }
                                        else
                                        {
                                            ret_val = ICF_FAILURE;
                                        }
                }
                
            }/*End of if block for Content ID Header*/
            
            
            sip_ret_val=sip_bcpt_getContentDescFromMimeHdr(pMime,\
                &p_cdesc,&sip_err);
            
            if(SipFail != sip_ret_val)
            {
                
            /* Allocate memory for the Content Description 
            * Header
                */
                p_hdr = (icf_header_st *)
                    sdf_memget(0,sizeof(icf_header_st),
                    &sdf_err);
                if(Sdf_co_null != p_hdr)
                {
                    p_msg_body->msg_body_hdr_list.count ++;
                    Sdf_mc_strcpy(p_hdr->hdr_name.str,\
                        (icf_uint8_t *)"Content-Desc");
                    p_hdr->hdr_name.str_len = \
                        (icf_uint16_t) icf_port_strlen(p_hdr->hdr_name.str);
                    
                    Sdf_mc_strcpy(p_hdr->hdr_value.str,\
                        p_cdesc);
                    p_hdr->hdr_value.str_len = \
                        (icf_uint16_t) icf_port_strlen(p_hdr->hdr_value.str);
                    
                    p_hdr->next = ICF_NULL;
                    
                    if(ICF_NULL == p_hdr_list->hdr)
                    {
                        p_hdr_list->hdr = p_temp_hdr = p_hdr;                         
                    }
                    else if(ICF_NULL != p_temp_hdr)
                    {
                        p_temp_hdr->next = p_hdr;
                        p_temp_hdr = p_temp_hdr->next;
                        
                    }
                }
                
            }/*End of if block for Content Description Header*/
            
            
             /* Get Content-Transfer encoding Header from MIME Body
            */
            if(SipFail != sip_bcpt_getContentTransEncodingFromMimeHdr(
                pMime, &p_encoding,&sip_err))
            {
            /* Allocate memory for the Content transfer 
            * Encoding Header
                */
                p_hdr = (icf_header_st *)
                    sdf_memget(0,sizeof(icf_header_st),
                    &sdf_err);
                if(Sdf_co_null != p_hdr)
                {
                    p_msg_body->msg_body_hdr_list.count ++;
                    Sdf_mc_strcpy(p_hdr->hdr_name.str,\
                        (icf_uint8_t *)"Content-Encoding");
                    p_hdr->hdr_name.str_len = \
                        (icf_uint16_t)icf_port_strlen(p_hdr->hdr_name.str);
                    
                    Sdf_mc_strcpy( p_hdr->hdr_value.str,\
                        p_encoding);
                    p_hdr->hdr_value.str_len = \
                        (icf_uint16_t) icf_port_strlen(p_hdr->hdr_value.str);
                    
                    p_hdr->next = ICF_NULL;
                    if(ICF_NULL == p_hdr_list->hdr)
                    {
                        p_hdr_list->hdr = p_temp_hdr = p_hdr;                         
                    }
                    else
                    {
                        p_temp_hdr->next = p_hdr;
                        p_temp_hdr = p_temp_hdr->next;
                        
                    }
                }
                
            }/*End of if block for Content Transfer Encoding Header*/
        }

        sip_bcpt_freeSipMimeHeader(pMime);
       
    }
return ret_val;
}



/************************************************************************
** FUNCTION: icf_ssa_get_content_type_from_mime_body
**
** DESCRIPTION: The function extracts the content-tpe for an individual
**              Msg Body
**
************************************************************************/
icf_return_t icf_ssa_get_content_type_from_mime_body(
    /*INOUT  Sdf_st_callObject   *pObj,*/
    INOUT   en_SipMessageType dReqRespType,
    INOUT  icf_ssa_pdb_st      *p_ssa_pdb,
    INOUT  SipMsgBody        *pMsgBody,
    INOUT  SipMimeHeader       *pMime,
    OUT icf_int8_t    **p_p_content_type)
{

    SipHeader     *pContentType = Sdf_co_null;
    Sdf_st_error     sdf_error;
    icf_return_t  ret_val = ICF_SUCCESS;
    /* To Remove warning */
    pMsgBody=pMsgBody;


    if (sip_initSipHeader(&pContentType, SipHdrTypeAny, \
        (SipError*)&(sdf_error.stkErrCode)) == SipFail)
    {
        return ICF_FAILURE;
    }
    
    if (sip_bcpt_getContentTypeFromMimeHdr(pMime, \
        &pContentType, (SipError*)&(sdf_error.stkErrCode)) \
        != SipFail)
    {    
        /* Extract the content - type header values from the
         * Sip message body.
         */
        if(ICF_FAILURE == icf_ssa_get_content_type_frm_msg(\
                    /*pObj*/dReqRespType,p_ssa_pdb,pContentType,\
                           p_p_content_type))
        {    
            sip_freeSipHeader(pContentType);
            sdf_memfree(Sdf_mc_callHandlerMemId,
                (Sdf_ty_pvoid *)&pContentType,Sdf_co_null);
            ret_val = ICF_FAILURE;

        }
        
        else
        {
            sip_freeSipHeader(pContentType);
              sdf_memfree(Sdf_mc_callHandlerMemId,
                (Sdf_ty_pvoid *)&pContentType, Sdf_co_null);
            ret_val = ICF_SUCCESS;
        }

    }    
    return ret_val;
}
/*Message body header changes ends*/

/*******************************************************************************
 ** FUNCTION:           icf_ssa_make_otg_app_profile
 **
 ** DESCRIPTION:        This function makes a SIP profile for an ICF application
 **                     for an outgoing message. The Supported and Accept 
 **                     headers are formed from the header list in request API 
 **                     instead of the stored app profile.
 **
 ******************************************************************************/
icf_return_t icf_ssa_make_otg_app_profile(
                Sdf_st_initData         *p_profile,
                icf_ssa_pdb_st       *p_ssa_pdb)
{
#if 0
    Sdf_st_error                        sdf_error;
#endif
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_app_conf_st                  *p_app_conf = p_ssa_pdb->p_app_conf;
    icf_string_list_st               *p_supported_types = ICF_NULL;
    icf_header_list_st               *p_hdr_list = ICF_NULL;
    icf_header_list_st               temp_hdr_list={0,0};
/* Dump */
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* ---------------------------------------------------------------------- */
    /* In case of outgoing INVITE request, the Supported headers will be picked 
     * from the header_list in call_ctx.
     * In case of outgoing SUBSCRIBE/MESSAGE/PUBLISH/REFER/out-of-dialog-REFER 
     * request, Supported and Accept headers will be picked from the header_list
     * in sic_ctx.
     * This function will not be invoked for any other outgoing request
     */
    if (ICF_NW_OTG_CALL_SETUP == p_ssa_pdb->p_internal_msg->msg_hdr.msg_id)
    {
        /* For INVITE */
        p_hdr_list = &(p_ssa_pdb->p_glb_pdb->p_call_ctx->header_list);
    }
    else
    {
        /* For SUBSCRIBE/MESSAGE/PUBLISH/REFER/out-of-dialog-REFER */
         if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count)
        {
           p_hdr_list = &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list);
        }
        else
        {
           if (ICF_FAILURE == icf_cmn_clone_header_list(p_ssa_pdb->p_glb_pdb,
                                   &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
					   persistent_header_list),
                                   &temp_hdr_list, p_ssa_pdb->p_ecode))
           {
               return ICF_FAILURE;
           }
           else
           {
              p_hdr_list = &temp_hdr_list;
           }
        }
    }
    /* 6_3_enhancement merge */
#if 0

    /* ---------------------------------------------------------------------- */
    /* ******* Handling for Supported header <<-->> supported_events  ******* */
    /* copy the supported events from header list into p_supported_events */
    if (ICF_FAILURE == icf_cmn_get_strlist_from_hdrlist(
                                p_ssa_pdb->p_glb_pdb,
                                p_hdr_list,
                                "Supported",
                                &p_supported_events))
    {
        ret_val = ICF_FAILURE;
    }
#endif
    /* ---------------------------------------------------------------------- */
    /* ****** Handling for Accept header <<-->> supported_content_types ***** */
    /* copy supported content-types from header list into p_supported_types */
    if (ICF_FAILURE == icf_cmn_get_strlist_from_hdrlist(
                                p_ssa_pdb->p_glb_pdb,
                                p_hdr_list,
                                (icf_uint8_t *)"Accept",
                                &p_supported_types))
    {
        ret_val = ICF_FAILURE;
    }
    /* ---------------------------------------------------------------------- */
    /* Clone from default profile */
    else if (ICF_FAILURE == icf_ssa_clone_profile_data(
                                p_ssa_pdb->p_glb_pdb,
                                p_profile,
                                p_ssa_pdb->p_ssa_glb_data->p_default_profile,
                                p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    else if(ICF_NULL == p_app_conf)
    {
        /* Do nothing */
    }
    /* Supported Methods */
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
                                p_profile,
                                (icf_uint8_t *)"Allow", 
                                &(p_app_conf->app_profile.supported_methods),
                                Sdf_co_true,
                                p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    /* Supported Content-Encoding */
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
                                p_profile,
                                (icf_uint8_t *)"Accept-Encoding", 
                                &(p_app_conf->app_profile.supported_encodings),
                                Sdf_co_true,
                                p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    /* Supported Content-Language */
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
                                p_profile,
                                (icf_uint8_t *)"Accept-Language", 
                                &(p_app_conf->app_profile.supported_languages),
                                Sdf_co_true,
                                p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    /* Supported Content-Type - to be picked from request API header list */
    if ((ICF_SUCCESS == ret_val) && 
             (ICF_NULL != p_supported_types))
    {
        if (ICF_NULL != p_supported_types->count)
        {
            ret_val = icf_ssa_add_string_list_in_default_header(
                                p_profile,
                                (icf_uint8_t *)"Accept", 
                                p_supported_types,
                                Sdf_co_true,
                                p_ssa_pdb->p_ecode);

            /* free the memory allocated to p_supported_types */
            icf_cmn_free_string_list(
                p_ssa_pdb->p_glb_pdb,
                p_supported_types,
                p_ssa_pdb->p_ecode);
                
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb, 
                p_supported_types,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode, 
                ret_val)
        }
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;

} /* End function icf_ssa_make_otg_app_profile() */
/****************************************************************************
 * FUNCTION:           icf_ssa_get_last_node_of_timer_list
 *
 * DESCRIPTION:        This routine fetches last node of timer list
 * 
 *****************************************************************************/
icf_ssa_timer_list_st** icf_ssa_get_last_node_of_timer_list(
        icf_ssa_timer_list_st **p_timer_list)
{
    icf_ssa_timer_list_st **p_temp, *p_list = *p_timer_list;

    if (ICF_NULL == p_list)
    {
        p_temp = p_timer_list;
    }
    else
    {
        while(ICF_NULL != p_list->p_next)
        {
            p_list = p_list->p_next;
        }
        p_temp = &(p_list->p_next);
    } /* else */
    return p_temp;
} /* icf_ssa_timer_list_st *p_timer... */


/****************************************************************************
 * FUNCTION:           icf_ssa_insert_timer_in_list
 *
 * DESCRIPTION:        This routine inserts a timer in list
 * 
 *****************************************************************************/
icf_return_t icf_ssa_insert_timer_in_list(
        icf_glb_pdb_st        *p_glb_pdb,
        icf_ssa_timer_list_st **p_timer_list,
        icf_timer_id_t        timer_id,
        icf_void_t            *p_timer_data)
{
    icf_return_t           ret_val = ICF_SUCCESS;
    icf_ssa_timer_list_st  **p_temp;
    icf_error_t            ecode;

    p_temp = icf_ssa_get_last_node_of_timer_list(p_timer_list);

   
    ICF_MEMGET(p_glb_pdb,
            ICF_PORT_SIZEOF(icf_ssa_timer_list_st),
            ICF_MEM_COMMON,
            (*p_temp),
            ICF_RET_ON_FAILURE,
            &ecode,
            ret_val)

    (*p_temp)->timer_id = timer_id;
    (*p_temp)->p_timer_data = p_timer_data;
    (*p_temp)->p_next = ICF_NULL;

    return ret_val;
}


/****************************************************************************
 * FUNCTION:           icf_ssa_delete_timer_frm_list
 *
 * DESCRIPTION:        This routine deletes a timer from list of which timer
 *                     ID is passed
 * 
 *****************************************************************************/
icf_void_t icf_ssa_delete_timer_frm_list(
        icf_ssa_pdb_st   *p_ssa_pdb,
        icf_ssa_ctxt_st  *p_ssa_ctxt,
        icf_timer_id_t   tim_id)
{
    icf_return_t           ret_val = ICF_SUCCESS;
    icf_ssa_timer_list_st  *p_list = p_ssa_ctxt->p_timer_list;
    icf_ssa_timer_list_st  *p_temp = p_ssa_ctxt->p_timer_list;

    while(ICF_NULL != p_list)
    {
        if(tim_id == p_list->timer_id)
        {
            if (p_temp == p_list)
            {
                p_ssa_ctxt->p_timer_list = p_list->p_next;
            } /* if (p_temp == p_list) */
            else
            {
                p_temp->p_next = p_list->p_next;
            }
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_list,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            p_ssa_ctxt->timer_count--;
            break;
        } /* if(tim_id == p_list->timer_id) */
        p_temp = p_list;
        p_list = p_list->p_next;
    } /* while(ICF_NULL != p_list->n... */
}


/****************************************************************************
 * FUNCTION:           icf_ssa_check_if_any_timers_exist
 *
 * DESCRIPTION:        THis fucntion checks whether any timer is running for 
 *                     the given p_ssa_ctxt or not, it can be checked if the 
 *                     timer list is NULL or not 
 *
 *****************************************************************************/
icf_boolean_t   icf_ssa_check_if_any_timers_exist(
       icf_ssa_ctxt_st  *p_ssa_ctxt)
{
    icf_boolean_t  is_timer_exist = ICF_FALSE;
   
    if (ICF_NULL < p_ssa_ctxt->timer_count)
    {
        is_timer_exist = ICF_TRUE;
    }

    return is_timer_exist;
}

/*****************************************************************************
 * FUNCTION:         icf_ssa_form_and_insert_unknown_hdr
 *
 * DESCRIPTION:        This function forms and inserts an unknown 
 *                  header into the SIP message passed  to it
 *                  The name of the header and the contents are
 *                  passed to this function.
 * 
 *****************************************************************************/
 icf_return_t icf_ssa_form_and_insert_unknown_hdr (
         icf_ssa_pdb_st  *p_ssa_pdb,
         icf_uint8_t     *p_hdr_name,
         icf_uint8_t     *p_hdr_contents,
         SipMessage         *p_sip_msg)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_return_t     dummy_ret_val = ICF_SUCCESS;
    SipHeader            *p_sip_header = SIP_NULL;
    SipError            sip_error;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* 
     * If the p_hdr_contents is a blank string,do not 
     * insert the unknown header,just return SUCCESS
     */
    if (ICF_NULL == icf_port_strlen(p_hdr_contents))
    {
        ICF_SSA_DEBUG(("\[SSA]:User Agent is not configured,ret success\n"));
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }
    /* Init the unknown hdr */
    if (SipFail == sip_initSipHeader(
                &p_sip_header,SipHdrTypeUnknown,&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Set the name into the unknown hdr */
	/*Fix done for SPR-18722 : CSR-1-6068965*/
    else if (SipFail == sip_setNameInUnknownHdr(
                p_sip_header,(icf_int8_t *)icf_port_strdup(p_hdr_name),&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Set the contents into the unknown hdr */
	/*Fix done for SPR-18722 : CSR-1-6068965*/
    else if (SipFail == sip_setBodyInUnknownHdr(
            p_sip_header,(icf_int8_t *)icf_port_strdup(p_hdr_contents),&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Insert the unknown hdr into the SIP message */
    else if (SipFail == sip_insertHeaderAtIndex(
            p_sip_msg, p_sip_header,0,&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Free the header memoryr  */
    if (SIP_NULL != p_sip_header)
    {
        sip_freeSipHeader(p_sip_header);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_sip_header,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*****************************************************************************
 * FUNCTION:        icf_ssa_clear_options_context
 *
 * DESCRIPTION:     This function in invoked when call termination is
 *                  initiated and OPTIONS is ongoing.This function sends the 
 *                  failure resp (487 Request Terminated)for the OPTIONS request
 *                  1. Stop the OPTIONS timer and flush entry from the map
 *                  2. Send failure resp to peer
 *
 *****************************************************************************/
icf_return_t icf_ssa_clear_options_context(
        icf_ssa_pdb_st *p_ssa_pdb)
{
    icf_return_t                 ret_val = ICF_SUCCESS;
    Sdf_st_overlapTransInfo         *p_ovtxn = Sdf_co_null;
    Sdf_st_error                    sdf_error;
    SipOptions                      options;

    icf_ssa_ctxt_st              *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    icf_uint16_t                 sdf_resp_code = 487;

    /* ICF_6_1_OPTIONS_SUPPORT start */
    icf_internal_msg_st                 internal_msg;
    icf_sic_clear_options_ctx_st *p_clear_opt_ctx = ICF_NULL;
    icf_return_t                 dummy_ret_val = ICF_SUCCESS;
    /* ICF_6_1_OPTIONS_SUPPORT end */


    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

        /* ICF_6_1_OPTIONS_SUPPORT start */

        /* Options timer will be handled by SIC */

        /* ICF_6_1_OPTIONS_SUPPORT end */

    /*
     * Reset the mapping in the map maintained
     * in the SSA global data.Also reset the bit OPTIONS_ONGOING
     */
    icf_ssa_flush_entry_frm_map(p_ssa_pdb,p_ssa_ctxt);

        /* ICF_6_1_OPTIONS_SUPPORT start */
        internal_msg.msg_hdr.msg_id =
                ICF_SIC_CLEAR_OPTIONS_CTX;
        internal_msg.msg_hdr.payload_length =
                sizeof(icf_sic_clear_options_ctx_st);
        internal_msg.msg_hdr.p_glb_pdb = p_ssa_pdb->p_glb_pdb;
#ifdef ICF_ERROR_ENABLE
        internal_msg.msg_hdr.ecode = ICF_ERROR_TYPE_UNDEFINED;
#endif
        internal_msg.msg_hdr.status = ICF_STATUS_CONTINUE;
        internal_msg.p_msg_data = ICF_NULL;
        ICF_MEMGET(
                p_ssa_pdb->p_glb_pdb,
                internal_msg.msg_hdr.payload_length,
                ICF_MEM_COMMON,
                internal_msg.p_msg_data,
                ICF_RET_ON_FAILURE,
                p_ssa_pdb->p_ecode,
                ret_val
                );
        p_clear_opt_ctx =
                (icf_sic_clear_options_ctx_st*)(internal_msg.p_msg_data);

        p_clear_opt_ctx->p_sic_ctx = p_ssa_ctxt->p_sic_ctxt;

        icf_sic_process_mesg(&internal_msg);

        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                internal_msg.p_msg_data,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,dummy_ret_val)

        /* ICF_6_1_OPTIONS_SUPPORT end */

    /*
     * Fetch the overlapped transaction pOverlapTransInfo
     * stored in the call object corresponding to OPTIONS
    * request received
     */

    if( ICF_FAILURE == icf_ssa_fetch_matching_overlap_txn(
                p_ssa_pdb,Sdf_en_options,Sdf_en_transactionReceived,
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,&p_ovtxn))
    {
        /*Raise/Set an error here - UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
    else if (Sdf_co_fail == sdf_ivk_uaFormResponse(sdf_resp_code, "OPTIONS",
                p_ssa_ctxt->p_call_obj,
                p_ovtxn,
                Sdf_co_false,
                &sdf_error))
    {
        /*Raise/Set Error here:UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
    else
    {
        /* Specify the stack options */
        options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;
       if (ICF_FAILURE == icf_ssa_send_to_peer(p_ssa_pdb,
                    p_ssa_ctxt->p_call_obj,
                    p_ovtxn->pSipMsg,
                    &options,&sdf_error))
        {
            /*Raise/Set Error here:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;

}
/*****************************************************************************
 * FUNCTION:           icf_ssa_update_contact_in_profile
 *
 * DESCRIPTION:        This  routine:
 *                     1. Adds the contact header into the profile of call 
 *                     object
 *****************************************************************************/
icf_return_t icf_ssa_update_contact_in_profile(
        INOUT   icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_return_t                 ret_val = ICF_SUCCESS;
    icf_glb_pdb_st               *p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    icf_config_data_st           *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    icf_address_st               *p_user_address = ICF_NULL;
    Sdf_st_initData                 *p_callobj_spec_profile = 
                                    p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData;
    Sdf_st_error                    sdf_error;
    Sdf_ty_s8bit                    self_ip[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                    from_user_addr[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                    display_name[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                    contact_addr[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t                  *p_temp = ICF_NULL;
    icf_transport_address_st      *p_contact_address = ICF_NULL;
    icf_transport_address_st        self_addr;
    
#ifdef ICF_NAT_RPORT_SUPPORT
    icf_rport_config_data_st            *p_rport_config_data = ICF_NULL;
#endif

    ICF_FUNCTION_ENTER(p_glb_pdb)
    ICF_SSA_INIT_TRANS_ADDR(&self_addr)

    p_user_address = &(p_glb_pdb->p_call_ctx->local_address);

    /*If per line self transport then copy address from line_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
    {
        if (ICF_NULL != p_ssa_pdb->p_line_data)
        {
            icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                        sizeof(icf_transport_address_st));
#ifdef ICF_NAT_RPORT_SUPPORT
            p_rport_config_data = p_ssa_pdb->p_line_data->p_rport_config_data;
#endif
        }
        else
        {
             return ret_val;
        }
    }
    else
    {
        icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                        sizeof(icf_transport_address_st));
#ifdef ICF_NAT_RPORT_SUPPORT
            p_rport_config_data = &(p_glb_cfg_data->rport_config_data);
#endif
    }
    
    

#ifdef ICF_NAT_RPORT_SUPPORT
   
    if(ICF_TRUE == p_rport_config_data->is_rport_reqd)
    {
        p_contact_address = &(p_rport_config_data->contact_ip_addr);
    }
    else
    {
        p_contact_address = &self_addr;            
    }        
#else
    p_contact_address = &self_addr;

#endif

    if ( ICF_LOCAL_NAME_PRESENT &
            p_glb_pdb->p_call_ctx->common_bitmask)
    {
        icf_port_strcpy((icf_uint8_t *)display_name, 
                (icf_uint8_t *)p_glb_pdb->p_call_ctx->local_name.str);
    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)display_name, (icf_uint8_t *)"");
    }

    /*
     * We copy the complete user address string from the local
     * address and then check if it is a E164, if it is then 
     * we append the self user address from global config data
     * to the string to get complete userid@hostname string
     */
    icf_port_strcpy((icf_uint8_t *)from_user_addr,
            (icf_uint8_t *)p_user_address->addr_val.str);
    
    if ( ICF_ADDRESS_PLAN_E164 ==
            p_user_address->addr_type)
    {
        icf_port_strcat((icf_uint8_t *)from_user_addr,(icf_uint8_t *)"@");

        if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                self_addr.addr.addr_type)
        {
            icf_port_strcat((icf_uint8_t *)from_user_addr,
                    (icf_uint8_t *)self_addr.\
                    addr.addr.domain.str);
            icf_port_strcpy((icf_uint8_t *)contact_addr,(icf_uint8_t *)from_user_addr);

        }
        else/*Assumption that it will be IPV4*/
        {
            icf_uint8_t remote_ip[16];
            icf_uint8_t contact_ip[16];

            if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                        &(self_addr), remote_ip))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                icf_port_strcpy((icf_uint8_t *)contact_addr,(icf_uint8_t *)from_user_addr);
                icf_port_strcat((icf_uint8_t *)from_user_addr, (icf_uint8_t *)remote_ip);
                if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                            p_contact_address, contact_ip))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    icf_port_strcat((icf_uint8_t *)contact_addr, (icf_uint8_t *)contact_ip);
                }
            }
        }
    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)contact_addr,(icf_uint8_t *)from_user_addr);
    }

    /*
     * If the address type is SIP URI ,then we will
     * extract the userid from the SIP URI and then 
     * append the contact IP address and port in order
     * to form the contact header
     */

   if ((ICF_ADDRESS_PLAN_SIP_URI ==
            p_user_address->addr_type) ||
    (ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type))
    {
        p_temp = icf_port_strchr((icf_uint8_t *)contact_addr,(icf_uint8_t)'@');
        if (ICF_NULL != p_temp)
        {
             *p_temp = '\0';
        }
        icf_port_strcat((icf_uint8_t *)contact_addr,(icf_uint8_t *)"@");

        if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                 p_contact_address->addr.addr_type)
        {
            icf_port_strcat((icf_uint8_t *)contact_addr,(icf_uint8_t *)p_contact_address->addr.addr.domain\
                    .str);
        }
        else/*Assumption that it will be IPV4*/
        {
            icf_uint8_t remote_ip[16];

            if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                        p_contact_address,remote_ip))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                icf_port_strcat((icf_uint8_t *)contact_addr,(icf_uint8_t *)remote_ip);
            }
        }
    }
    /* 
     * In case of TEL URL,we just send the contact IP and port in the
     * contact addr
     */
    else if ( ICF_ADDRESS_PLAN_TEL_URI ==
            p_user_address->addr_type)
    {
        if(ICF_FAILURE == 
                icf_ssa_get_hostname_str_frm_trans_addr(
                    p_ssa_pdb,
                    p_contact_address,
                    (icf_uint8_t *)self_ip))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)contact_addr,(icf_uint8_t *)self_ip);
        }
    }
    if ( ICF_SUCCESS == ret_val)
    {
                    if (ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type)
            {
                if (Sdf_co_fail == sdf_ivk_uaAddDefaultContact(
                            p_callobj_spec_profile,
                            display_name,
                            contact_addr,
                            p_glb_cfg_data->p_tls_init_data->tls_sip_serv_port_num,
                            "sips",
                            &sdf_error))
                {
                    /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                     * major ERROR*/
                    sdf_ivk_uaFreeInitData(p_callobj_spec_profile);
                    ret_val = ICF_FAILURE;
                }
            }
            else
            {
                if (Sdf_co_fail == sdf_ivk_uaAddDefaultContact(
                            p_callobj_spec_profile,
                            display_name,
                            contact_addr,
                            p_contact_address->port_num,
                            "sip",
                            &sdf_error))
                {
                    /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                     * major ERROR*/
                    sdf_ivk_uaFreeInitData(p_callobj_spec_profile);
                    ret_val = ICF_FAILURE;
                }
            }    
            if ((ICF_FAILURE != ret_val))
            {
                if (ICF_FAILURE ==
                        icf_ssa_add_transport_param_in_contact_hdr(
                            p_ssa_pdb,
                            p_callobj_spec_profile,
                            &sdf_error))
                {
                    ret_val = ICF_FAILURE;
                }
         }
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_replaces_header
 * DESCRIPTION:  1.Fetch the Replaces header 
 *               2.Extract n/w call id and map it to ipphone internal call id. 
 *               3.If not matched then send failure response to n/w.
 *
 ***************************************************************************/
icf_return_t icf_ssa_parse_replaces_header(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  Sdf_st_error		  *p_err)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_ty_slist            slMatchedHeadersList;
    Sdf_ty_u32bit           size = 0;
    SipError                err;
    Sdf_ty_s8bit            *p_replaces_call_id = Sdf_co_null;
    Sdf_ty_s8bit            *p_from_tag = Sdf_co_null;
    Sdf_ty_s8bit            *p_to_tag = Sdf_co_null;

    icf_error_t          *p_ecode = p_ssa_pdb->p_ecode;
    icf_ssa_ctxt_st      *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    icf_ssa_ctxt_list_st      *p_ssa_list = ICF_NULL;
    icf_ssa_ctxt_list_st      *p_ssa_temp = ICF_NULL;
    icf_ssa_ctxt_st      *p_mapped_ssa_ctxt = ICF_NULL;
    Sdf_st_callObject       *p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    icf_nw_inc_call_setup_st *p_internal_msg = 
        (icf_nw_inc_call_setup_st *)p_ssa_pdb->p_internal_msg->p_msg_data;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        /*    ICF_SSA_TRACE(p_ssa_pdb,ICF_TRACE_REPLACES_HDR_PRESENT)*/

        /* Extract Replaces Header */
        if(Sdf_co_fail == sdf_ivk_uaGetHeaderListByType(p_call_obj->
                    pUasTransaction->slUnprocessedHeaders, SipHdrTypeReplaces,
                    &slMatchedHeadersList,p_err))
        {
            /* 
             * Remove all elements from the list and free 
             * the node data of each node
             */
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            ret_val = ICF_FAILURE;
        } /* if(Sdf_co_success == sdf_ivk_u... */
    /* Extract the size of the matched header list */
        else if(Sdf_co_fail == sdf_listSizeOf (&slMatchedHeadersList,
                    &size, p_err))
        {
            /* 
             * Remove all elements from the list and free 
             * the node data of each node
             */
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            ret_val = ICF_FAILURE;
        } /* if(Sdf_co_fail == sdf_listSize... */

    /* Replaces Header present */
        else if(size > 0)
        {
            SipHeader *p_replaces_hdr;
            Sdf_st_headerList *p_replaces_hdr_list = Sdf_co_null;
            /* Get HeaderList at index 0*/
            if( Sdf_co_fail == sdf_listGetAt(
                        &slMatchedHeadersList,0
                        ,(Sdf_ty_pvoid)&p_replaces_hdr_list,p_err))
            {
                /* 
                 * Remove all elements from the list and free 
                 * the node data of each node
                 */
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                ret_val = ICF_FAILURE;
            } /* if( Sdf_co_fail == sdf_listGet... */
            /* Extarct the first Replaces header */
            else if(Sdf_co_fail == sdf_listGetAt(
                        &(p_replaces_hdr_list)->slHeaders,0,
                        (Sdf_ty_pvoid *)&p_replaces_hdr,
                        p_err))
            {
                /* 
                 * Remove all elements from the list and free 
                 * the node data of each node
                 */
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                ret_val = ICF_FAILURE;
            } /* if(Sdf_co_fail == sdf_listSize... */

            /* Extract the Replaces Call ID from the Replaces Header */
            else if(SipFail == sip_getCallidFromReplacesHdr(
                        p_replaces_hdr,
                        &p_replaces_call_id,
                        &err))
            {
                /* 
                 * Remove all elements from the list and free 
                 * the node data of each node
                 */
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                ret_val = ICF_FAILURE;
            }
            else if (SipFail == sip_getFromTagFromReplacesHdr(
                        p_replaces_hdr,
                        &p_from_tag,
                        &err))
            {
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                ret_val = ICF_FAILURE;
            }
            else if (SipFail == sip_getToTagFromReplacesHdr(
                        p_replaces_hdr,
                        &p_to_tag,
                        &err))
            {
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                ret_val = ICF_FAILURE;
            }
            if (ICF_FAILURE != ret_val)
            {
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                /* 
                 * Search for a matching SSA context corresponding to the 
                 * Replaces call ID in the global map between
                 * the SSA contexts and network call ID's
                 */
                ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(
                        p_ssa_pdb->p_glb_pdb,(icf_uint8_t *)p_replaces_call_id,
                        (icf_void_t **)&p_ssa_list,p_ecode);
                if (ICF_SUCCESS == ret_val)
                {
#ifdef ICF_LOOPBACK_SUPPORT
                    for (p_ssa_temp = p_ssa_list;p_ssa_temp != ICF_NULL; p_ssa_temp = p_ssa_temp->p_next)
                    {
                        if (ICF_SUCCESS == icf_ssa_cmp_replaces_tags(p_ssa_pdb, 
                                    p_ssa_temp->p_ssa_ctxt->p_call_obj, 
                                    (icf_uint8_t *)p_from_tag, 
                                    (icf_uint8_t *)p_to_tag, 
                                    p_err))
                        {
                            p_mapped_ssa_ctxt = p_ssa_temp->p_ssa_ctxt;
                            ret_val =  ICF_SUCCESS;
                            break;
                        }
                    }
                    if (ICF_NULL == p_ssa_temp)
                    {
                        ret_val = ICF_FAILURE;
                    }
#else
                    p_mapped_ssa_ctxt = p_ssa_list->p_ssa_ctxt;
#endif
                }
                if ((ICF_FAILURE == ret_val) ||
                        (ICF_NULL == p_mapped_ssa_ctxt))
                {
					/* Fix for CSR 1-6727350: SPR 19316 */
					sdf_memfree(Sdf_mc_callHandlerMemId, 
                                     (Sdf_ty_pvoid*)&(p_from_tag),p_err);
                    sdf_memfree(Sdf_mc_callHandlerMemId, 
                                       (Sdf_ty_pvoid*)&(p_to_tag),p_err);

                    /* 
                     * Replaces header has a call ID which is not 
                     * corresponding to any call on our end
                     * Set the failure bitmask which will send 
                     * 481 on the network
                     */
                    p_ssa_ctxt->failure_bitmask |= 
                        ICF_SSA_FAILURE_RESP_CODE_481;
                    ret_val = ICF_FAILURE;
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                        return ret_val;
                }

                /* 
                 * An SSA context corresponding to the 
                 * Replaces call ID is found.
                 * Copy this Replaces call ID to the setup
                 * request and set the corresponding bit in
                 * the bitmask of the setup request
                 */
                p_internal_msg->replace_call_id = 
                    p_mapped_ssa_ctxt->p_call_ctxt->call_id ;
                ICF_SSA_SET_COMMON_BITMASK(
                        p_internal_msg->bitmask, 
                        ICF_NW_INC_SETUP_RELACE_CALL_ID)
            }
        } /* else if(size > 0) */
					
	/* Fix for CSR 1-6727350: SPR 19316 */
	sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_from_tag),p_err);
	sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_to_tag),p_err);

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}

/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_ref_by_header
 * DESCRIPTION:  1.Fetch the Referred By header 
 *               2.Extract referred by address and display name and
 *               populate it in call context.
 *
 ***************************************************************************/
icf_return_t icf_ssa_parse_ref_by_header(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  Sdf_st_error          *p_err)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_ty_slist            slMatchedHeadersList;
    Sdf_ty_u32bit           size = 0;
    SipError                err;

    Sdf_st_callObject       *p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    icf_call_ctx_st      *p_call_ctx = p_ssa_pdb->p_glb_pdb->p_call_ctx;
    icf_error_t          *p_ecode = p_ssa_pdb->p_ecode;
    icf_nw_inc_call_setup_st *p_internal_msg = 
        (icf_nw_inc_call_setup_st *)p_ssa_pdb->p_internal_msg->p_msg_data;


    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
/*    ICF_SSA_TRACE(p_ssa_pdb,ICF_TRACE_REF_BY_HDR_PRESENT)*/

    if(Sdf_co_fail == sdf_ivk_uaGetHeaderListByType(
                p_call_obj->pUasTransaction->slUnprocessedHeaders,
                SipHdrTypeReferredBy
                ,&slMatchedHeadersList,p_err))
    {
        sdf_listDeleteAll(&slMatchedHeadersList,p_err);
        ret_val = ICF_FAILURE ;
    } /* if(Sdf_co_success == sdf_ivk_u... */
    else if(Sdf_co_fail == sdf_listSizeOf (&slMatchedHeadersList,
                &size, p_err))
    {
        sdf_listDeleteAll(&slMatchedHeadersList,p_err);
        ret_val= ICF_FAILURE;
    } /* if(Sdf_co_fail == sdf_listSize... */
    /* Referred-by Header present */
    else if(size >0)
    {
        SipHeader   *p_ref_by_hdr = SIP_NULL;
        SipAddrSpec *p_referrer = SIP_NULL;
        SIP_S8bit   *p_refer_disp_name = SIP_NULL;
        Sdf_st_headerList *p_ref_by_hdr_list = Sdf_co_null;
        /* Get HeaderList at index 0*/
        if( Sdf_co_fail ==
                sdf_listGetAt(&slMatchedHeadersList,0
                    ,(Sdf_ty_pvoid)&p_ref_by_hdr_list,p_err))
        {
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            ret_val = ICF_FAILURE;
        } /* if( Sdf_co_fail == sdf_listGet... */
        else if(Sdf_co_fail == sdf_listGetAt(&(p_ref_by_hdr_list)->
                    slHeaders,0,(Sdf_ty_pvoid *)&p_ref_by_hdr,
                    p_err))
        {
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            ret_val = ICF_FAILURE;
        } /* if(Sdf_co_fail == sdf_listSize... */

        else if(SipFail == sip_getReferrerFromReferredByHdr
                (p_ref_by_hdr, (SipAddrSpec **)&p_referrer,
                 &err))
        {
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            ret_val = ICF_FAILURE;
        }
        /*
         * We are not checking the return value of 
         * sip_getDispNameFromReferredByHdr as it 
         * is not mandatory to get the display name
         * Assumption : sip_getDispNameFromReferredByHdr
         * returns FAILURE if no display name is present
         */
        else if (SipSuccess == sip_getDispNameFromReferredByHdr(
                    p_ref_by_hdr,&p_refer_disp_name,&err) && 
                (SIP_NULL != p_refer_disp_name))
        {
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                    ICF_PORT_SIZEOF(icf_name_st),
                    ICF_MEM_COMMON, 
                    p_call_ctx->p_referred_party_name,
                    ICF_RET_ON_FAILURE, p_ecode, ret_val)
            icf_cmn_init_string((icf_string_st *)
                    (p_call_ctx->p_referred_party_name));
            icf_port_strcpy(
                        p_call_ctx->p_referred_party_name->str,
                        (icf_uint8_t *)p_refer_disp_name);
            p_call_ctx->p_referred_party_name->str_len = 
                (icf_uint16_t)icf_port_strlen(
                        (icf_uint8_t *)p_call_ctx->p_referred_party_name->str);

        }

        if (ICF_FAILURE != ret_val )
        {
            /*
             * Populate the p_referred_party_addr member of
             * the call ctx and set the bitmask in the internal message 
             * indicating the same
             */
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                    ICF_PORT_SIZEOF(icf_address_st),
                    ICF_MEM_COMMON, 
                    p_call_ctx->p_referred_party_addr,
                    ICF_RET_ON_FAILURE, p_ecode, ret_val)

            icf_cmn_init_address(p_call_ctx->p_referred_party_addr);
            if (ICF_FAILURE == 
                    icf_ssa_populate_address_from_sip_addr_spec(
                        p_ssa_pdb,p_referrer,
                        p_call_ctx->p_referred_party_addr))
            {
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_call_ctx->p_referred_party_name,
                        ICF_MEM_COMMON, p_ecode, ret_val)
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_call_ctx->p_referred_party_addr,
                        ICF_MEM_COMMON, p_ecode, ret_val)
                ret_val = ICF_FAILURE;
            }
            if (ICF_FAILURE != ret_val )
            {
                ICF_SSA_SET_COMMON_BITMASK(
                        p_internal_msg->bitmask,
                        ICF_NW_INC_SETUP_REF_BY) 
            }
			sdf_listDeleteAll(&slMatchedHeadersList,p_err);
        }
		/* Fix for CSR 1-6727350: SPR 19316 */
		/* Free the addr spec here */
		sip_freeSipAddrSpec(p_referrer);
        sip_freeSipHeader(p_ref_by_hdr);
    } /* if(size >0) */
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_n_validate_requri
 * DESCRIPTION:  This function does the folowing :
 *               1.Populates the local name of cal context on the 
 *                 basis of the dispaly name in the To header
 *               2.Extracts the Request URI and does validations on the
 *                 same.In case of failure ,sets failure bitmask accordingly
 *               3.Populates local address of call context on the 
 *                 basis of the ReqURI
 *               4.Invokes the utility function to update the Contact
 *                 header into the profile of the call object
 *
 ***************************************************************************/
icf_return_t icf_ssa_parse_n_validate_requri(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  Sdf_st_error          *p_err)
{
    icf_return_t         ret_val = ICF_SUCCESS;

    Sdf_st_callObject       *p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    icf_call_ctx_st      *p_call_ctx = p_ssa_pdb->p_glb_pdb->p_call_ctx;
    icf_ssa_ctxt_st      *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    SipToHeader             *p_to = ((SipToHeader *)
            p_call_obj->pCommonInfo->pTo->pHeader);
    SipReqLine              *p_req_line = SIP_NULL ; 
    SipAddrSpec             *p_req_uri = SIP_NULL;
    Sdf_ty_u16bit           resp_code = 0;
    Sdf_ty_messageValidity  msg_val = Sdf_en_valid;
    SipError                err;
#ifdef ICF_REQ_URI_CALLED_PARTY_ADDR_PARSING
    icf_uint8_t             temp[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t             temp_old_addr[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t             temp_new_addr[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t             *p_user_part_full = ICF_NULL;
    icf_uint8_t             *p_user_part_pre = ICF_NULL;
    icf_uint8_t             *p_user_part_post = ICF_NULL;
    icf_uint8_t             *p_temp_old_addr = ICF_NULL;
    icf_uint8_t             *p_dial_string = ICF_NULL;
#endif /* #ifdef ICF_REQ_URI_CALLED_PARTY_ADDR_PARSING */

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /*
     * Extract the local address from the To header
     * and remote address from the From/p-asserted header 
     * and populate it in the call context
     * If the called/calling party addr is a SIP URI,then 
     * user@hostname is copied into the call context,
     * otherwise the entire URL is copied into the call
     * context
     */
    /* Copy the display name if present in the To header */
#ifdef ICF_WITH_MUATK_2_2
    if (SIP_NULL != p_to->pStr1)
    {
            icf_port_strcpy(p_call_ctx->local_name.str,
                (icf_uint8_t *)p_to->pStr1);
#else
    if (SIP_NULL != p_to->pDispName)
    {
            icf_port_strcpy(p_call_ctx->local_name.str,
                p_to->pDispName);
#endif    
        p_call_ctx->local_name.str_len =
            (icf_uint16_t )icf_port_strlen(p_call_ctx->local_name.str);
        /* 
         * Set the bit in common bitmask of call ctx
         * indicationg the presence of display name
         */
        p_call_ctx->common_bitmask |= 
            ICF_LOCAL_NAME_PRESENT;
    }
    /*
     * Now fetch the request URI from the SIP message
     */
    msg_val = sdf_ivk_uaValidateUri(
            p_call_obj,p_call_obj->pInitData,
            &resp_code,p_err);
    /*
     * The following are the resp codes returned by 
     * the above function.As users are not configured in
     * the profile,we will not fail our processing
     * if 404 (user not found ) resp code is returned
     * 400 resp code : invalid transport type
     * 416           : unsupported URI
     * 505           : invalid version
     * 400           : user not found
     */
    if ((Sdf_en_failed == msg_val) ||
            ((Sdf_en_invalid == msg_val) && (400 == resp_code)) ||
            ((Sdf_en_invalid == msg_val) && (416 == resp_code)) ||
            ((Sdf_en_invalid == msg_val) && (505 == resp_code))) 
    {
/*        ICF_SSA_TRACE(p_ssa_pdb,ICF_TRACE_VALIDATION_OF_REQ_URI_FAILURE)*/
        /*
         * Send appropiate error resp to nw.
         * Set SSA failure bitmask for the same
         */
        if (resp_code == 400)
        {
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_400;
        }
        else if (resp_code == 416)
        {
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_416;
        }
        else if (resp_code == 505)
        {
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_505;
        }
        else
        {
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_500;
        }
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == sip_getReqLineFromSipReqMsg(
                p_call_obj->pUasTransaction->pSipMsg,
                &p_req_line,&err))
    {
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == sip_getAddrSpecFromReqLine(
                p_req_line, &p_req_uri,&err))
    {
        ret_val = ICF_FAILURE;
    }
    /*
     * Now populate the local address on the basis
     * of the rquest URI
     */
    else if (ICF_FAILURE == 
            icf_ssa_populate_address_from_sip_addr_spec(
                p_ssa_pdb,p_req_uri,
                &(p_call_ctx->local_address)))
    {
        ret_val = ICF_FAILURE;
    }
   /*Check if sip:user@ip:port is present, remove port*/
    else if (ICF_FAILURE == icf_ssa_remove_port_from_address(
                            p_ssa_pdb, 
                            ((icf_uint8_t *)(p_call_ctx->local_address.addr_val.str))))
    {
        ret_val = ICF_FAILURE;
    }

#ifdef ICF_REQ_URI_CALLED_PARTY_ADDR_PARSING
    /*---------------------------------------------------------------------*/
    /*
     *      ++++ USER MATCHING FOR E.164 CONFIGURED NUMBER ++++
     * If the application has configured E.164 num 14083659220, then req-uri
     *      sip:+14083659220@20.20.20.20;user=phone                 -> matches
     *      sip:14083659220@20.20.20.20;user=phone                  -> No match
     *      sip:3659220;phone-context=+1408@20.20.20.20;user=phone  -> matches
     *      sip:3659220;phone-context=1408@20.20.20.20;user=phone   -> No match
     */
    /*---------------------------------------------------------------------*/
    /* In case the req-uri is of the form
     *      sip:3659220;phone-context=+1408@20.20.20.20;user=phone, or
     *      sip:+14083659220@20.20.20.20;user=phone
     * user search in local database should be done for both
     * (a) '3659220' - user part of address, and
     * (b) '14083659220' - phone-context dial string prefixed to user part
     *
     * For comparison (a) which will happen as per the original design, the
     * address will be stored in p_call_ctx->local_address.
     *
     * For comparison (b), the user address will be reconstructed and stored
     * in p_call_ctx->alternate_local_address.
     *
     * CC will check if any of these addresses are configured on any line.
     *
     * At this point, we have p_call_ctx->local_address. Now let's check if
     * phone-context param or '+' sign is present in req-uri and form the new
     * p_call_ctx->alternate_local_address
     */

    else if (((ICF_ADDRESS_PLAN_SIP_URI ==
                    p_call_ctx->local_address.addr_type) ||
             (ICF_ADDRESS_PLAN_SIPS_URI ==
                    p_call_ctx->local_address.addr_type)) &&
             (ICF_NULL != icf_port_strstr(
                                p_call_ctx->local_address.addr_val.str,
                                "user=phone")))
    {

        /*  ++++++++++++++++++ FIRST THE TOKENIZATION ++++++++++++++++++++++++++ */

        /* Get temp_old_addr =
         * '3659220;phone-context=+1408@20.20.20.20;user=phone'
         */
        icf_port_strcpy(temp, p_call_ctx->local_address.addr_val.str);
        icf_port_strcpy(temp_old_addr, p_call_ctx->local_address.addr_val.str);
        p_temp_old_addr = &temp_old_addr[0];

        /* Get p_user_part_full = '3659220;phone-context=+1408' */
        /* Get p_temp_old_addr = '@20.20.20.20;user=phone' */
        ICF_PRINT(("\n[SSA]: p_temp_old_addr before strtok = %s\n", \
                    p_temp_old_addr));
        p_user_part_full = icf_port_strtok(temp, "@");
        if(ICF_NULL != p_user_part_full)
        {
            p_temp_old_addr = p_temp_old_addr + icf_port_strlen(p_user_part_full);
        }
        ICF_PRINT(("\n[SSA]: p_temp_old_addr after strtok = %s\n", \
                    p_temp_old_addr));

        /* Get p_user_part_full = '3659220;phone-context=+1408' */
        /* Get p_user_part_pre = '3659220' */
        ICF_PRINT(("\n[SSA]: p_user_part_full before strtok = %s\n", \
                    p_user_part_full));
        icf_port_strcpy(temp, p_user_part_full);
        p_user_part_pre = icf_port_strtok(temp, ";");
        ICF_PRINT(("\n[SSA]: p_user_part_full after strtok = %s\n", \
                    p_user_part_full));
        ICF_PRINT(("\n[SSA]: p_user_part_pre = %s\n", p_user_part_pre));

        /* Get p_user_part_post = 'phone-context' */
        /* Get p_dial_string = '+1408' */
        p_user_part_post = &p_user_part_full[0];
        p_user_part_post = p_user_part_post + icf_port_strlen(p_user_part_pre) + 1;
        ICF_PRINT(("\n[SSA]: p_user_part_post before strtok = %s\n", \
                    p_user_part_post));
        p_dial_string = p_user_part_post + icf_port_strlen("phone-context") + 1;
        p_user_part_post = icf_port_strtok(p_user_part_post, "=");
        ICF_PRINT(("\n[SSA]: p_user_part_post after strtok = %s\n", \
                    p_user_part_post));

        /*  ++++++++++++++++++ THEN THE COMPARISON ++++++++++++++++++++++++++ */

        /* If phone-context param is present, prefix it to the userid
         *      3659220;phone-context=+1408@20.20.20.20;user=phone
         *          should match
         *      alternate_local_address = E164 number 14083659220
         */
        if ((ICF_NULL != p_user_part_pre) &&
                (ICF_NULL != p_user_part_post) &&
                (ICF_NULL == icf_port_strcmp(
                                             p_user_part_post, "phone-context")) &&
                ('+' == *p_dial_string))
        {
            ICF_PRINT(("\n[SSA]: Received req-uri contains phone-context param\n"));
            ICF_PRINT(("\n[SSA]: p_dial_string = %s\n", p_dial_string));

            /* Get temp_new_addr = '1408' */
            icf_port_strcpy(temp_new_addr, (p_dial_string + 1));
            /* Get temp_new_addr = '14083659220' */
            icf_port_strcat(temp_new_addr, p_user_part_pre);
#if 0
            /* Get temp_new_addr = '+14083659220@20.20.20.20;user=phone' */
            icf_port_strcat(temp_new_addr, p_temp_old_addr);
#endif

            /* Update the alternate local address in call ctxt */
            p_call_ctx->common_bitmask |= ICF_ALTERNATE_ADDR_FORMAT_POSSIBLE;
            p_call_ctx->alternate_local_address.addr_type = ICF_ADDRESS_PLAN_E164;
            icf_port_strcpy(
                    p_call_ctx->alternate_local_address.addr_val.str,
                    temp_new_addr);
            /* Update the string length of local address in call ctxt */
            p_call_ctx->alternate_local_address.addr_val.str_len =
                icf_port_strlen(p_call_ctx->alternate_local_address.addr_val.str);
        }
        /* If userid starts with '+', ignore it for comparison
         *      +14083659220@20.20.20.20;user=phone
         *          should match
         *      alternate_local_address = E164 number 14083659220
         */
        else if ((ICF_NULL != p_user_part_pre) && ('+' == *p_user_part_pre))
        {
            ICF_PRINT(("\n[SSA]: Received req-uri starts with + sign\n"));

            /* Update the alternate local address in call ctxt */
            p_call_ctx->common_bitmask |= ICF_ALTERNATE_ADDR_FORMAT_POSSIBLE;
            p_call_ctx->alternate_local_address.addr_type = ICF_ADDRESS_PLAN_E164;
            icf_port_strcpy(
                    p_call_ctx->alternate_local_address.addr_val.str,
                    (p_user_part_pre + 1));
            /* Update the string length of local address in call ctxt */
            p_call_ctx->alternate_local_address.addr_val.str_len =
                icf_port_strlen(p_call_ctx->alternate_local_address.addr_val.str);
        }
    else
    {
        ICF_PRINT(("\n[SSA]: No alternate address derived from req-uri\n"));
    }

    ICF_PRINT(("\n[SSA]: Received called party address = %s\n", \
            p_call_ctx->local_address.addr_val.str));

    ICF_PRINT(("\n[SSA]: Alternate called party address = %s\n", \
            p_call_ctx->alternate_local_address.addr_val.str));

    } /* if (p_call_ctx->local_address.addr_type) */
    /*---------------------------------------------------------------------*/

    if (ICF_FAILURE == ret_val)
    {
        /* do nothing */
        ret_val = ICF_FAILURE;
    }
#endif /* #ifdef ICF_REQ_URI_CALLED_PARTY_ADDR_PARSING */

    else if (ICF_FAILURE == 
            icf_ssa_update_contact_in_profile(
                p_ssa_pdb))
    {
        ret_val = ICF_FAILURE;
    }

    /* Free the acquired memory */
    if (SIP_NULL != p_req_uri)
    {
        sip_freeSipAddrSpec(p_req_uri);
    }
    if (SIP_NULL != p_req_line)
    {
        sip_freeSipReqLine(p_req_line);
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_supp_header
 * DESCRIPTION:  1.Invoke the SDF API which returns the list
 *                 of entries present in the Supported header.
 *               2.Iterate through the list and check for the presence
 *                 of 100 rel.If present ,set the bit 
 *                 ICF_REL_PROV_RESP_SUPP_BY_PEER in common bitmask
 *                 of the call context
 *
 ***************************************************************************/
icf_return_t icf_ssa_parse_supp_header(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT    SipMessage          *p_sip_msg,
        INOUT  Sdf_st_error          *p_err)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_ty_slist            slSupportedList;
    Sdf_ty_u32bit           size = 0,iterator = 0;

    icf_call_ctx_st      *p_call_ctx = p_ssa_pdb->p_glb_pdb->p_call_ctx;
    icf_uint8_t          *p_list_element = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (Sdf_co_fail == sdf_ivk_uaReturnSupportedList (
                p_sip_msg,&slSupportedList,p_err))
    {
        ret_val = ICF_FAILURE;
    }
    /* Fetch the size of the list */
    else if (Sdf_co_fail == sdf_listSizeOf(
                &slSupportedList,&size,p_err))
    {
        ret_val = ICF_FAILURE;
    }
    /*If list contains elements*/
    else if(size !=0)
    {
        /*Fetch all the entries from the Supported header */
        for(iterator = 0; iterator < size; iterator++)
        {
            if(Sdf_co_fail == sdf_listGetAt(&slSupportedList,
                        iterator, (Sdf_ty_pvoid *)&p_list_element,p_err))
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_NULL == icf_port_strcmp(
                        p_list_element,(icf_uint8_t *)"100rel"))
            {
                /* 
                 * Set the bit in common bitmask
                 * of the call context indicating support
                 * for reliable provisional responses
                 */  
                p_call_ctx->common_bitmask |=
                    ICF_REL_PROV_RESP_SUPP_BY_PEER;
/*                ICF_SSA_TRACE(p_ssa_pdb,*/
/*                        ICF_TRACE_SUPPORTED_100_REL_PRESENT)*/
                /* 
                 * We are not breaking out of the loop
                 * here as the same function can be used for 
                 * generic parsing of the Supported header
                 */
            }
        }
    }
    sdf_listDeleteAll(&slSupportedList,p_err);
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 *
 * FUNCTION:     icf_ssa_insert_params_frm_address_st
 * DESCRIPTION:  1.This functions checks the presence flag
 *                 present in the p_address paramter and on the
 *                 basis of this inserts paramters into the
 *                 p_addr_spec paramter passed to it
 *
 ***************************************************************************/
icf_return_t icf_ssa_insert_params_frm_address_st(
        icf_ssa_pdb_st *p_ssa_pdb,
        SipAddrSpec       *p_addr_spec,
        icf_address_st *p_address)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_st_error            sdf_error;    
    icf_uint8_t          index = ICF_NULL;
    icf_boolean_t        more_param = ICF_FALSE;
    icf_uint8_t          param_name[20] = "\0";
    icf_uint8_t          param_val[20] = "\0";
    icf_string_st        temp_addr;
    icf_int8_t          *p_param_list = ICF_NULL;
    icf_uint8_t          *p_param_addr = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    
    icf_port_strcpy(temp_addr.str, p_address->addr_val.str);

    p_param_addr = (icf_uint8_t *)icf_port_strtokr((icf_int8_t *)temp_addr.str,";", &p_param_list);

    if (ICF_NULL != p_param_list)
    {
        do
        {
            icf_port_strcpy(param_name, (icf_uint8_t *)"");
            icf_port_strcpy(param_val, (icf_uint8_t *)"");
            /*This function parses the unknown parameter string, here
            * index parameter always point to the next parameter or
            * pointed to NULL
            */
            more_param = icf_ssa_parse_unknown_param(p_ssa_pdb,
                (icf_uint8_t *)p_param_list, param_name, param_val,
                &index);
            
            if (icf_port_strcmp(param_name,(icf_uint8_t *)"transport"))
            {
                if (ICF_FAILURE == 
                    icf_ssa_insert_param_in_addr_spec(
                    p_ssa_pdb,p_addr_spec,
                    param_name, param_val, &sdf_error))
                {
                    ret_val = ICF_FAILURE;
                    break;
                }
            }
            if (ICF_FALSE == more_param)
            {
                break;
            }
        }while (1);
    }
    


    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_unknown_param
 * DESCRIPTION:  Function is used to parse unknown parameters and return
 *               them as name value(if present) pair
 ***************************************************************************/
icf_boolean_t icf_ssa_parse_unknown_param(
        icf_ssa_pdb_st   *p_ssa_pdb,
        icf_uint8_t      *p_unk_str,
        icf_uint8_t      *p_param_name,
        icf_uint8_t      *p_param_val,
        icf_uint8_t      *p_index)
{
    icf_uint8_t    index = *p_index;
    p_ssa_pdb=p_ssa_pdb;
    
   if(ICF_NULL == p_ssa_pdb)
   {
       return ICF_FAILURE;
   }
    
   ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    p_unk_str = p_unk_str + index;

    while ((*p_unk_str != '=') && (*p_unk_str != ';') &&
            (*p_unk_str != ICF_NULL))
    {
        *p_param_name = *p_unk_str;
        index++;
        p_param_name++;
        p_unk_str++;
    }

    index++;
    *p_param_name = ICF_NULL;
    
    if (*p_unk_str == '=')
    {
        p_unk_str++;
        while ((*p_unk_str != ';') && (*p_unk_str != ICF_NULL))
        {
            *p_param_val = *p_unk_str;
            index++;
            p_param_val++;
            p_unk_str++;
        }
        *p_param_val = ICF_NULL;
        index++;
    }

    *p_index = index;
    
    if (*p_unk_str != ICF_NULL)
        return ICF_TRUE;
    else
        return ICF_FALSE;

}


/***************************************************************************
 *
 * FUNCTION:     icf_ssa_init_pdb
 * DESCRIPTION:  1.This functions initialises the PDB
 *
 ***************************************************************************/
icf_return_t  icf_ssa_init_pdb(icf_ssa_pdb_st *p_ssa_pdb,
        icf_glb_pdb_st  *p_glb_pdb)
{
    
    icf_uint16_t   count = ICF_NULL;
    icf_return_t   ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_glb_pdb)
        
    icf_port_memset(p_ssa_pdb,0,sizeof(icf_ssa_pdb_st));

    p_ssa_pdb->p_glb_pdb = p_glb_pdb;
    /*
     * Now we init the void pointer which will be used to store the
     * list of memory chunks that will be allocated in callbacks and
     * will be freed on return path (after invocation of destination 
     * module-CM, CFG etc.)
     */
    for ( count = 0; count < ICF_SSA_MAX_MMRY_CHUNK_LST;
            count++)
    {
        p_ssa_pdb->allocated_memory[count].p_mem_chunk = ICF_NULL;
        p_ssa_pdb->allocated_memory[count].ssa_mem_type = 0;
    }
#ifdef ICF_IPSEC_ENABLED
    p_ssa_pdb->p_rgm_context = ICF_NULL;
    p_ssa_pdb->p_sa_context = ICF_NULL;
#endif
    p_ssa_pdb->p_app_conf = ICF_NULL;
#ifdef ICF_DNS_LOOKUP_ENABLED
    p_ssa_pdb->p_event_ctxt = Sdf_co_null;
#endif
    p_ssa_pdb->line_recvd = ICF_NULL;    
    p_ssa_pdb->p_ssa_ctxt = Sdf_co_null;
    p_ssa_pdb->hash_index = 0;

#ifdef ICF_TRACE_ENABLE
   p_ssa_pdb->dialog_status = 0;
   p_ssa_pdb->sdp_present = ICF_FALSE;
   p_ssa_pdb->replace_header_present = ICF_FALSE;
   p_ssa_pdb->p_buf = ICF_NULL;
   p_ssa_pdb->len = 0;

#endif
   p_ssa_pdb->p_conn_table_entry = ICF_NULL;
   p_ssa_pdb->conference_uri.addr_val.str_len = 0;
   p_ssa_pdb->conference_uri.addr_type = 0;
    p_ssa_pdb->warning_header_code = ICF_NULL;
    icf_port_memset(&(p_ssa_pdb->warning_text),'\0',sizeof(icf_string_st));
    p_ssa_pdb->authorised_req = ICF_FALSE;
    p_ssa_pdb->notify_tag_mismatch = ICF_FALSE;
    p_ssa_pdb->p_line_data= ICF_NULL;
    p_ssa_pdb->dest_module_id = ICF_INT_MODULE_INVALID;
 
    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_populate_contact_addr
 * DESCRIPTION:  1.This functions populates the icf_address_st
 *                 on the basis of the Contact header (if any)
 *                 present in the SIP message passed to it
 *
 ***************************************************************************/
icf_return_t icf_ssa_populate_contact_addr(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT    SipMessage        *p_sip_msg,
        INOUT  icf_address_st **p_p_contact_addr,
        INOUT  Sdf_st_error      *p_err)  
{
    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_ty_u32bit           size;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        
    if (SipFail == sip_getHeaderCount(
                p_sip_msg, SipHdrTypeContactAny,
                &size,(SipError *)&(p_err->stkErrCode)))
    {
        ret_val = ICF_FAILURE; 
    }
    else if (size != 0)
    {
        /*
         * If multiple contacts are returned by peer,
         * currently we are picking only the fisrt
         */
        SipHeader dest_hdr;

        if (SipFail == sip_getHeaderAtIndex(
                    p_sip_msg, SipHdrTypeContactAny,&dest_hdr, 0,
                    (SipError *)&(p_err->stkErrCode)))
        {
            ret_val = ICF_FAILURE; 
        }
        else
        {
            /* Allocate memory for the contact addr */
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                    ICF_PORT_SIZEOF(icf_address_st),
                    ICF_MEM_COMMON, 
                    *p_p_contact_addr,
                    ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)

            /* Initialize the address strucute */
           icf_cmn_init_address(*p_p_contact_addr);
            /*
             * The ret_val is not captured here as the
             * following function returns failure only if the
             * user portion of the SIP URI is null.
             * Though this is not acceptable in 
             * the request URI of an incoming INVITE,
             * it is acceptable in the From and Contact header
             */
            icf_ssa_populate_address_from_sip_addr_spec(
                    p_ssa_pdb,
                    (SipAddrSpec *)
                    ((SipContactHeader *)(dest_hdr.pHeader))->pAddrSpec,
                    *p_p_contact_addr);
        }
        sip_freeSipHeader(&dest_hdr);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

#ifdef ICF_SSA_UT_NR_CODE

/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_phone_context_frm_sip_uri
 * 
 * DESCRIPTION:  1.This function parses the SIP URI to extract the
 *                 user part and phone-context parameter and updates
 *                 the icf_address_st structure accordingly
 *
 ***************************************************************************/
icf_return_t icf_ssa_parse_phone_context_frm_sip_uri(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT    SipAddrSpec       *p_sip_addr_spec,
        INOUT  icf_address_st *p_addr)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    icf_uint8_t          seps[] = ";=";
    icf_uint8_t          *p_token = ICF_NULL;
    Sdf_ty_s8bit            *p_rem = ICF_NULL;
    icf_uint8_t          temp[15]="\0";
    icf_string_st        temp1;
    p_ssa_pdb=p_ssa_pdb;

    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    icf_cmn_init_string(&temp1);
    /* Copy the user portion of SIP URI into a temporary string */
    icf_port_strcpy(temp1.str,p_sip_addr_spec->u.pSipUrl->pUser);
    /* 
     * NOTE : This is a temporary fix to
     * incorporate the wrong patch delivered 
     * by UATK team 
     */
    if (SIP_NULL != p_sip_addr_spec->u.pSipUrl->pHost)
    {
        icf_port_strcat(temp1.str,"@");
        icf_port_strcat(temp1.str,p_sip_addr_spec->u.pSipUrl->pHost);
    }
    /* First extract the user part from SIP URI */
    p_token = icf_port_strtokr(temp1.str,seps,&p_rem);

    if(ICF_NULL != p_token)
    {
    /* Copy the token into the addr_val of the address_st */
    icf_port_strcpy(p_addr->addr_val.str,p_token);
    }

    /* Now extract the phone-context parameter */
    while( ICF_NULL != p_token)
    {
        if(0 == icf_port_strcmp(temp,"phone-context"))
        {
/*            ICF_SSA_TRACE(p_ssa_pdb,ICF_TRACE_PHONE_CTXT_RECVD)*/
            icf_port_strcat(p_addr->addr_val.str, "phone-context");
            icf_port_strcat(p_addr->addr_val.str, "=");
            icf_port_strcat(p_addr->addr_val.str, (icf_uint8_t *)p_token);
            icf_port_strcat(p_addr->addr_val.str, ";");
            p_addr->addr_val.str_len = 
                icf_port_strlen(p_addr->addr_val.str);            
        }
        icf_port_strcpy(temp,p_token);
        /* Get next token: */
        if (ICF_NULL != p_rem)
        {
            p_token = icf_port_strtokr(p_rem,seps,&p_rem); 
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
#endif

#ifdef ICF_SSA_UT_NR_CODE
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_tel_url
 * 
 * DESCRIPTION:  1.This function parses the TEL URL and
 *               populates the icf_address_st structure with
 *               the required information(along with any paramters received)
 *               
 *
 ***************************************************************************/
icf_return_t icf_ssa_parse_tel_url(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT    SipAddrSpec       *p_sip_addr_spec,
        INOUT  icf_address_st *p_addr)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    SipError                err;
    SipList                 *p_sip_param_list = SIP_NULL;
    TelUrl                  *p_tel = SIP_NULL;
    p_ssa_pdb=p_ssa_pdb;


    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }   
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (SipFail == sip_getTelUrlFromAddrSpec (
                p_sip_addr_spec,&p_tel,&err))
    {
        ret_val = ICF_FAILURE;
    } /* p_sip_addr_spec,&p_tel,&sip_er... */
    else
    {
        if (SIP_NULL != p_tel->pGlobal)
        {
            icf_port_strcpy(p_addr->addr_val.str,
                    p_tel->pGlobal->pBaseNo);
            p_addr->addr_val.str_len = icf_port_strlen(p_addr->addr_val.str);
            p_addr->addr_type = ICF_ADDRESS_PLAN_TEL_URI;

            p_sip_param_list = &(p_tel->pGlobal->slParams);
        } /* if (SIP_NULL != p_tel->pGlobal... */
        else if (SIP_NULL != p_tel->pLocal)
        {
            icf_port_strcpy(p_addr->addr_val.str,
                    p_tel->pLocal->pLocalPhoneDigit);
            p_addr->addr_val.str_len = icf_port_strlen(p_addr->addr_val.str);
            p_addr->addr_type = ICF_ADDRESS_PLAN_TEL_URI;                    
            p_sip_param_list = &(p_tel->pLocal->slParams);
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
    }

    if( ICF_FAILURE != ret_val)
    {
        /*
         * Extract the phone - context and user parameters from
         * address spec
         */
        if(SipFail == sip_formSipParamList(p_addr->addr_val.str,
            p_sip_param_list,
            (SIP_S8bit *)";",1,&err))
        {
            ret_val = ICF_FAILURE;
        }
        p_addr->addr_val.str_len = 
            icf_port_strlen(p_addr->addr_val.str);
    }

    if (SIP_NULL != p_tel)
    {
        sip_freeTelUrl(p_tel);
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
#endif

/*****************************************************************************
 * FUNCTION:        icf_ssa_check_for_reg_subs_trans_param
 *
 * DESCRIPTION:     Function to derive transport mode based on proxy mode
 *                  and mode received in remote party address in create call
 *
 *****************************************************************************/
icf_return_t icf_ssa_check_for_reg_subs_trans_param(
        icf_ssa_pdb_st        *p_ssa_pdb,
        icf_transport_mode_et reg_mode,
        icf_transport_mode_et self_mode)
{
    icf_return_t   ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if ((ICF_TRANSPORT_MODE_BOTH == reg_mode) &&
            (ICF_TRANSPORT_MODE_BOTH == self_mode))
    {
        p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_MODE_BOTH;
        p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_TRUE;
    }
    else if ((ICF_TRANSPORT_MODE_BOTH == reg_mode) &&
            (ICF_TRANSPORT_TYPE_TCP == self_mode))
    {
        p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
        p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
    }
    else if ((ICF_TRANSPORT_MODE_BOTH == reg_mode) &&
            (ICF_TRANSPORT_TYPE_UDP == self_mode))
    {
        p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
        p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
    }
    else if ((ICF_TRANSPORT_TYPE_TCP == reg_mode) &&
            (ICF_TRANSPORT_TYPE_UDP != self_mode))
    {
        p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
        p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
    }
    else if ((ICF_TRANSPORT_TYPE_UDP == reg_mode) &&
            (ICF_TRANSPORT_TYPE_TCP != self_mode))
    {
        p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
        p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;
} /* icf_ssa_check_for_reg_subs_trans_param */
/*****************************************************************************
 * FUNCTION:        icf_ssa_flush_entry_frm_map
 *
 * DESCRIPTION:     This function flushes the entry in the map
 *                  between the context identifier and the SSA ctxt
 *                  and resets the bit ICF_SSA_OPTIONS_ONGOING
 *                  in the SSA ctxt
 * 
 *****************************************************************************/
icf_void_t icf_ssa_flush_entry_frm_map(
        icf_ssa_pdb_st  *p_ssa_pdb,
        icf_ssa_ctxt_st *p_ssa_ctxt)
{
    icf_ssa_glb_data_st  *p_ssa_glb_data = (icf_ssa_glb_data_st*)
        p_ssa_pdb->p_ssa_glb_data;
    icf_uint8_t          index = (icf_uint8_t) p_ssa_ctxt->options_map_index;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /*
     * Flush the entry in the map between the context identifier 
     * and the SSA ctxt
     */
    p_ssa_glb_data->options_map[index].p_ssa_ctxt = ICF_NULL;
    p_ssa_glb_data->options_map[index].context_identifier = ICF_NULL;

    /*
     * Reset the options index and the bit
     * indiacting that OPTIONS is ongoing
     */
    p_ssa_ctxt->options_map_index = ICF_SSA_MAX_OPTIONS_CALL_OBJ;
    p_ssa_ctxt->context_identifier = ICF_NULL;
    p_ssa_ctxt->options_timer_id = ICF_TIMER_ID_INVALID;
    p_ssa_ctxt->bitmask &= ~ICF_SSA_OPTIONS_ONGOING;
    /* This has been commented for SPR 17158*/
/*    p_ssa_ctxt->bitmask &= ~ICF_SSA_OPTIONS_RECVD_OUT_OF_DIALOG;*/
}

/*Message body header changes Start*/
/************************************************************************
 * FUNCTION:        icf_ssa_SetAllMsgBody
 * DESCRIPTION:     This function is used to Set the Message Body in SIP
 *                  Message.
 ***********************************************************************/
icf_return_t icf_ssa_SetAllMsgBody
    (Sdf_st_transaction     *pTransaction,
    Sdf_st_overlapTransInfo *pOverlapTransInfo,
    Sdf_ty_s8bit            *p_content_type,
    Sdf_st_error            *pError)
{
    Sdf_ty_slist *pSrcList = Sdf_co_null;
    SipMessage   *pSipMsg = Sdf_co_null;
#ifdef SDF_IM
    Sdf_st_msgInfo    dMessageInfo;
#endif

    if (pError == ICF_NULL)
    return ICF_FAILURE;
    /* Choose the MsgBodyList inside the call object if
     * overlapTransactionInfo is NULL
     */
    if (Sdf_co_null == pOverlapTransInfo)
    {
        pSrcList = &(pTransaction->slMsgBodyList);
        pSipMsg = pTransaction->pSipMsg;
    }
    else
    {
        pSrcList = &(pOverlapTransInfo->slMsgBodyList);
        pSipMsg = pOverlapTransInfo->pSipMsg;
    }
#ifdef SDF_IM
    sdf_fn_uaGetMessageInfo(pSipMsg,  &dMessageInfo, pError);

    if( (dMessageInfo.dReqRespType == SipMessageResponse) && \
        (dMessageInfo.dMsgType == Sdf_en_message))
    {
        pError->errCode = Sdf_en_messageBodyNotAllowed;
        return ICF_FAILURE;
    }
#endif

    /* SipMessage now
     */
    if (icf_ssa_SetMsgBodyListInSipMessage(pSrcList, \
        pSipMsg, p_content_type,pError) == ICF_FAILURE)
    {
        pError->errCode=Sdf_en_sdpError;
        return ICF_FAILURE;
    }    

    pError->errCode = Sdf_en_noUaError;

    return ICF_SUCCESS;
}    

/************************************************************************
 ** FUNCTION:     icf_ssa_SetMsgBodyListInSipMessage
 **
 ** DESCRIPTION: This function sets the message bodies from the given 
 **         list into the outgoing SIP message.
 **         It first removes any previously present MsgBodies in
**               the SIP message, and then adds the new list.
 **
 ***********************************************************************/
static icf_return_t icf_ssa_SetMsgBodyListInSipMessage
    (Sdf_ty_slist *pMsgBodyList,
    SipMessage *pMsg,
    Sdf_ty_s8bit  *p_content_type,
    Sdf_st_error *pError)
{
    /* 
     * Parameter checks
     */
    if (pError == Sdf_co_null)
        return ICF_FAILURE;
    if (pMsg == Sdf_co_null)
    {
        pError->errCode=Sdf_en_sdpError;
        return ICF_FAILURE;
    }

    /* 
     * First delete the MsgBodys in the SIP message, then start 
     * appending new list.
     */
    if (sip_listDeleteAll(&(pMsg->slMessageBody),(SipError*)\
                &(pError->stkErrCode)) == SipFail)
    {
        pError->errCode=Sdf_en_sdpError;
        return ICF_FAILURE;
    }
    
    /* 
     * Now append the new MsgBodyList to this Sip Message
     */
    if (icf_ssa_AppendMsgBodyListToSipMessage(pMsgBodyList, pMsg,\
                p_content_type, pError) == Sdf_co_fail)
    {
        pError->errCode=Sdf_en_sdpError;
        return ICF_FAILURE;
    }
    pError->errCode = Sdf_en_noUaError;
    return ICF_SUCCESS;
}


/************************************************************************
 ** FUNCTION:      icf_ssa_AppendMsgBodyListToSipMessage
 **
 ** DESCRIPTION: This function appends the message bodies from the given 
 **         list into the SIP message. The MsgBodies already present
 **          in the SipMessage are left untouched.
 **
 ***********************************************************************/
static icf_return_t icf_ssa_AppendMsgBodyListToSipMessage
    (Sdf_ty_slist *pMsgBodyList,
    SipMessage    *pMsg,
    Sdf_ty_s8bit  *p_content_type,
    Sdf_st_error  *pError)
{
    Sdf_ty_u32bit    dSize=0;
    Sdf_ty_u32bit   index=0, dCount=0;
    SipHeader     *pMimeVersionHdr = Sdf_co_null;
    Sdf_ty_s8bit    *pTmpVal = Sdf_co_null;
    Sdf_ty_bool    dAddContentTypeHeader = Sdf_co_false;
    Sdf_ty_bool    dAddMimeHeader = Sdf_co_false;
    Sdf_ty_bool    dAddMimeVersionHeader = Sdf_co_false;
    icf_uint8_t  temp_buff[ICF_MAX_STR_LEN]="";
    icf_return_t ret_val = ICF_SUCCESS;
    icf_error_t  ecode = ICF_ERROR_NONE;
    
    sdf_listSizeOf(pMsgBodyList, &dSize, pError);
    
    if (dSize > 1)
    {
        Sdf_st_listIterator dListIterator;
        sdf_listInitIterator(pMsgBodyList, &dListIterator,pError);
        while (dListIterator.pCurrentElement != Sdf_co_null)
        {
            SipMsgBody       *pMsgBody = Sdf_co_null;
            SipMimeHeader *pMimeHdr = Sdf_co_null;
            Sdf_ty_s8bit  *pContentType = Sdf_co_null;
            SipHeader          *pHeader= SIP_NULL;
            pMsgBody = (SipMsgBody*)\
                (dListIterator.pCurrentElement->pData);
            
            /* Extract the message body type
            * IF message body type is application SDP then set the
            * content-type as application/sdp
            */
            if(SipSdpBody == pMsgBody->dType)
            {
                Sdf_mc_strdup(pContentType,"application/sdp");
                if(SipFail == sip_bcpt_initSipMimeHeader(&pMimeHdr,\
                    (SipError*)&(pError->stkErrCode)))
                {
                /* Failed to initialize SIP Mime Header
                    */
                    ret_val = ICF_FAILURE;
                } 
                
                /* Fill Content-Type header in MIME Header
                */
                else if(sip_initSipHeader(&pHeader,SipHdrTypeContentType,\
                    (SipError*)&(pError->stkErrCode))==SipFail)
                {
                    sip_bcpt_freeSipMimeHeader(pMimeHdr);
                    pError->errCode=Sdf_en_msgBodyError;
                    ret_val = ICF_FAILURE;
                }
                
                else if(sip_setMediaTypeInContentTypeHdr(pHeader, pContentType,\
                    (SipError*)&(pError->stkErrCode))==SipFail)
                {
                    sip_freeSipHeader(pHeader);
                    sip_bcpt_freeSipMimeHeader(pMimeHdr);
                    pError->errCode=Sdf_en_msgBodyError;
                    ret_val = ICF_FAILURE;
                }
                else if(sip_bcpt_setContentTypeInMimeHdr(pMimeHdr,pHeader,\
                    (SipError*)&(pError->stkErrCode))==SipFail)
                {
                    sip_bcpt_freeSipMimeHeader(pMimeHdr);
                    sip_freeSipHeader(pHeader);
                    pError->errCode=Sdf_en_msgBodyError;
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    pMsgBody->pMimeHeader = pMimeHdr;
                }

                if(ICF_FAILURE == ret_val)
                {
                    sdf_memfree(Sdf_mc_callHandlerMemId,
                        (Sdf_ty_pvoid *)pContentType,Sdf_co_null);
                    break;
                }

            }
            
            if (sip_insertMsgBodyAtIndex(pMsg, pMsgBody,\
                index, (SipError *)\
                &(pError->stkErrCode))\
                == SipFail)
            {
                sip_bcpt_freeSipMimeHeader(pMimeHdr);
                sip_freeSipHeader(pHeader);
                pError->errCode=Sdf_en_sdpError;
                ret_val = ICF_FAILURE;
                break;
            }
            sdf_listNext(&dListIterator, pError);
            dAddMimeHeader = Sdf_co_true;
            index++;
            dCount++;

             sip_freeSipHeader(pHeader);
             ICF_MEMFREE(
                    p_persistent_glb_pdb,
                    pHeader,
                    ICF_MEM_COMMON,
                    &ecode,
                    ret_val)

        } /* End of loop inserting message bodies in the SIP
              *  message
        */
        dAddMimeVersionHeader = Sdf_co_true;
        dAddContentTypeHeader = Sdf_co_true;

    }
    else if(dSize == 1)
    {
        SipMsgBody *pMsgBody = Sdf_co_null;
        dAddContentTypeHeader = Sdf_co_true;
        
        if (sdf_listGetAt(pMsgBodyList, 0, (Sdf_ty_pvoid *)\
            &pMsgBody, pError) == Sdf_co_fail)
        {
            pError->errCode=Sdf_en_sdpError;
            ret_val = ICF_FAILURE;
        }
        else if(Sdf_co_null != pMsgBody->pMimeHeader)
        {
            
            /* If the user has added the content_type header in MIME 
            * Header, it can be removed at this stage, as it is not
            * required for a single message body.
            */

            if(ICF_NULL != pMsgBody->pMimeHeader->pContentType)
            {
                /* Only single message body received and we have
                 * filled the mime content type in the add_body_list
                 * So this contenttype should go on the SIP message
                 */
                SipHeader *pMimeContentTypeHdr = ICF_NULL;

                /* Spr 16408: Here SipHdrTypeContentType is replaced by 
                   SipHdrTypeAny in sip_initSipHeader function call to avoid
                   memory leak because we do not want any memory allocation
                   for pHeader because we assign pointer 
                 in sip_bcpt_getContentTypeFromMimeHdr pMimeHdr->pContentType*/

                if (SipFail == sip_initSipHeader(
                    &pMimeContentTypeHdr,SipHdrTypeAny,
                    ((SipError *)&(pError->stkErrCode))))
                {
                    ret_val = ICF_FAILURE;
                }
                else if(SipFail == 
                    sip_bcpt_getContentTypeFromMimeHdr(pMsgBody->pMimeHeader,
                    &pMimeContentTypeHdr,(SipError *)&(pError->stkErrCode)))
                {
                    ret_val = ICF_FAILURE;
                }
                else if(SipFail == sip_setHeader(pMsg,pMimeContentTypeHdr,
                    (SipError *)&(pError->stkErrCode)))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    sip_freeSipContentTypeHeader(pMsgBody->pMimeHeader->pContentType);
                    pMsgBody->pMimeHeader->pContentType = Sdf_co_null;
                    dAddContentTypeHeader = Sdf_co_false;
                }

                if(ICF_NULL != pMimeContentTypeHdr)
                {
                    sip_freeSipHeader(pMimeContentTypeHdr);
                    sdf_memfree(Sdf_mc_callHandlerMemId,
                        (Sdf_ty_pvoid *)&pMimeContentTypeHdr,Sdf_co_null);
                }
                
            }
            if(ICF_FAILURE == ret_val)
            {
                
            }
            else if((ICF_NULL == pMsgBody->pMimeHeader->pContentDescription) &&
               (ICF_NULL == pMsgBody->pMimeHeader->pContentId) &&
               (ICF_NULL == pMsgBody->pMimeHeader->pContentTransEncoding) &&
               (ICF_NULL == pMsgBody->pMimeHeader->pContentDisposition) &&
               ( 0 == pMsgBody->pMimeHeader->slAdditionalMimeHeaders.size))
            {
                /* Free the Mime header and set to NULL*/
                sip_bcpt_freeSipMimeHeader(pMsgBody->pMimeHeader);
                pMsgBody->pMimeHeader = Sdf_co_null;
            }
            else
            {
                /* Some mime header is present so we will AddMimeVersionHeader*/
                dAddMimeVersionHeader = Sdf_co_true;
            }
        }
        if(ICF_FAILURE == ret_val)
        {
            
        }
        else if (sip_insertMsgBodyAtIndex(pMsg, pMsgBody, 0, \
            (SipError *)&(pError->stkErrCode)) == SipFail)
        {
            pError->errCode=Sdf_en_sdpError;
            ret_val = ICF_FAILURE;
        }
    }
    if(ICF_FAILURE == ret_val)
    {

    }
    if(Sdf_co_true == dAddContentTypeHeader)
    {
        /* Insert Content-Type header in the header list in case
        * of multiple message bodies
        */
        if(0 != icf_port_strcmp((icf_uint8_t *)"",(icf_uint8_t *)p_content_type))
        {
            sdf_fn_uaSprintf((icf_int8_t *)temp_buff,"Content-Type:%s ",p_content_type);
        }
        else
        {
            Sdf_mc_strcpy(temp_buff,\
                (icf_uint8_t *)"Content-Type:multipart/mixed; boundary=ICFMsgBodyBoundary");
            dAddMimeVersionHeader = Sdf_co_true;
        }

        if(SipFail == sip_setHeaderFromStringAtIndex(pMsg,
            SipHdrTypeContentType,(Sdf_ty_s8bit *)
            &temp_buff,0, (SipError *)
            &(pError->stkErrCode)))
        {
            ICF_PRINT(((icf_uint8_t *)"Failed to insert "\
                "Content-Type header to Sip Msg\n"));
             ret_val = ICF_FAILURE;
        }
    }
    if(ICF_FAILURE == ret_val)
    {

    }
    /* Add a MIME-version and Content-Type header now */
    else if(Sdf_co_true == dAddMimeVersionHeader)
    {
        pTmpVal = Sdf_mc_strdupCallHandler("1.0");
        if (sip_initSipHeader(&pMimeVersionHdr,\
            SipHdrTypeMimeVersion, \
            (SipError *)&(pError->stkErrCode))\
            == SipFail)
        {
            ret_val = ICF_FAILURE;
        }
        
        else if (sip_bcpt_setVersionInMimeVersionHdr(pMimeVersionHdr,\
            pTmpVal, (SipError *)&(pError->\
            stkErrCode)) == SipFail)
        {
            ret_val = ICF_FAILURE;
        }
        else if (sip_setHeader(pMsg, pMimeVersionHdr, \
            (SipError *)&(pError->stkErrCode)) == SipFail)
        {
            ret_val = ICF_FAILURE;
        }
        
        /* Free local variable */
        if(ICF_NULL != pMimeVersionHdr)
        {
            sip_freeSipHeader(pMimeVersionHdr);
            sdf_memfree(Sdf_mc_callHandlerMemId, \
                (Sdf_ty_pvoid *)&pMimeVersionHdr, pError);
        }
        if(ICF_FAILURE == ret_val)
        {
            sdf_memfree(Sdf_mc_callHandlerMemId,
                        (Sdf_ty_pvoid *)pTmpVal,Sdf_co_null);
        }

        
    }
   return ret_val;
}

/************************************************************************
 ** FUNCTION:      icf_get_content_type_from_msg_body
 **
 ** DESCRIPTION: This function extracts the Content type from message
 ** body list
 **
 ***********************************************************************/
static icf_void_t icf_get_content_type_from_msg_body(
        INOUT  icf_ssa_pdb_st  *p_ssa_pdb,
        OUT icf_int8_t     **p_p_content_type)
{
    icf_ssa_ctxt_st           *p_ssa_ctxt = ICF_NULL;

    icf_rgm_context_st        *p_rgm_context = ICF_NULL;
    icf_uint16_t              loop_app = ICF_NULL;
    icf_return_t              ret_val = 0;
     
     /* Copy the ssa ctxt pointer locally */
     p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->\
          p_call_obj->pAppData->pData;
     ret_val = ret_val;
     /*ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt)) */
     if (ICF_NULL == p_ssa_ctxt )
     {
         return;
     }
         
    /* Copy the rgm_context pointer locally */
    p_rgm_context = (icf_rgm_context_st *)(p_ssa_ctxt->p_rgm_ctxt);
         
    /*ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_rgm_context))*/
    if (ICF_NULL == p_rgm_context)
    {
        return;
    }        
    for (loop_app = 0; loop_app < p_ssa_pdb->p_glb_cfg_data->\
            max_applications ; loop_app++)
     {
       
         if (ICF_FALSE == p_rgm_context->p_app_data_list[
             loop_app].is_valid)
             continue;
    
     if (ICF_BODY_LIST_PRESENT & p_rgm_context->
             p_app_data_list[loop_app].bitmask)
         {
         if(ICF_NULL != p_rgm_context->p_app_data_list[loop_app].\
                 body_list.content_type.str)
         {
             Sdf_mc_strdup(*p_p_content_type,(icf_uint8_t *)p_rgm_context->\
                 p_app_data_list[loop_app].body_list.\
                 content_type.str);
                   break;
         }
     
            else 
        {
            Sdf_mc_strdup(*p_p_content_type,(icf_uint8_t *)"multipart/mixed;boundary=ICFMsgBodyBoundary");
            break;
        }
     }
         
     }/* for loop_app Ends */
    
}/* End of function*/

/*****************************************************************************
** FUNCTION: icf_ssa_IsSupportedMediaTypeInMsgBody
**
** DESCRIPTION: This function checks the following header in the receieved
**        message
**        1.      Checks the Media type present in the Content-Type
**            header against the List of Accepted Media present in the
**            Accept attribute of the user profile. 
**            If no match found with the Accepted Media then
**            it rejects with 415. 
**
******************************************************************************/
static icf_return_t icf_ssa_IsSupportedMediaTypeInMsgBody
(
        /*INOUT    Sdf_st_callObject *pObj,*/
        INOUT    en_SipMessageType dReqRespType,
        INOUT    Sdf_st_initData   *pInitData,
        INOUT    Sdf_ty_s8bit      *pMediaType,
        OUT   Sdf_st_error      *pErr)
{
    Sdf_st_configExtraHeaders     *pTemp =Sdf_co_null;
    Sdf_st_configExtraHeaders    *pAccept=Sdf_co_null;
    icf_uint32_t                    size2=0;
    icf_uint32_t                    IndicateAccept=0; 
    Sdf_st_listIterator             dListIterator;
    /*
    if (pObj == Sdf_co_null)
    {
             ICF_PRINT(("\n[SSA]:pObj param is Invalid "));    
        pErr->errCode=Sdf_en_invalidParamError;
        return ICF_FAILURE;
    }*/

    if (pInitData == Sdf_co_null)
    {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:pInitData param is Invalid "));
        pErr->errCode=Sdf_en_invalidParamError;
        return ICF_FAILURE;
    }

    /*
     * If a response has come in, avoid processing and return
     * ICF_SUCCESS
     */
     /*
    if (pObj->pUasTransaction->pSipMsg == Sdf_co_null && \
        pObj->pUacTransaction->pSipMsg != Sdf_co_null)
    {
        pErr->errCode = Sdf_en_noUaError;
        ICF_PRINT(("\n[SSA]:Exiting IsSupportedMediaType "));
        return ICF_SUCCESS;
    }
    */

    if(SipMessageResponse == dReqRespType)
    {
        pErr->errCode = Sdf_en_noUaError;
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Exiting IsSupportedMediaType "));
        return ICF_SUCCESS;
    }
    
    /*
     * Check if ACCEPT attribute 
     * had been set in the user profile and take those headers from the profile.
     */

    sdf_listSizeOf(&(pInitData->slExtraHeadersList), &size2, pErr);

    sdf_listInitIterator(&(pInitData->slExtraHeadersList),&dListIterator, pErr);

    while (dListIterator.pCurrentElement != Sdf_co_null)
    {
        pTemp = (Sdf_st_configExtraHeaders*)\
            (dListIterator.pCurrentElement->pData);

        if(pTemp->pParam->pName==Sdf_co_null)
        {
            sdf_listNext(&dListIterator, pErr);
            continue;
        }

        if(Sdf_mc_strcasecmp("ACCEPT",pTemp->pParam->pName)==0)
        {
            pAccept=pTemp;
            IndicateAccept = 1;
            break;
        }
        sdf_listNext(&dListIterator, pErr);
    }
    
    if(ICF_NULL != pMediaType)
    {
        icf_boolean_t dFound=ICF_FALSE;

        /* If ACCEPT attribute not present in the profile the check for default
         * media-types.
         */
        
        if((Sdf_mc_strcasecmp(pMediaType,"application/sdp")==0)
#ifdef SDF_REFER
            || (Sdf_mc_strcasecmp(pMediaType,"message/sipfrag")==0)
#endif
#ifdef SDF_IM
            || (Sdf_mc_strcasecmp(pMediaType,"text/plain")==0)
#endif
          )
        {
            dFound=ICF_TRUE;
        }
        else if(IndicateAccept != 0)
        {
            icf_uint32_t sizeval=0,ctr;

            if(sip_listSizeOf(&(pAccept->pParam->slValue),&sizeval, \
               (SipError*)&(pErr->stkErrCode)) ==SipFail)
            {
                                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failed to get the size of "\
                        "accepted media-type."));
                pErr->errCode=Sdf_en_initDataAccessError;
                return ICF_FAILURE;
            }
            for(ctr=0;ctr<sizeval;ctr++)
            {
                Sdf_ty_s8bit *pTempVal;

                if(sip_listGetAt(&(pAccept->pParam->slValue),  \
                    (Sdf_ty_u32bit) ctr,(Sdf_ty_pvoid *)&pTempVal,  \
                    (SipError*)&(pErr->stkErrCode)) == SipFail)
                {
                                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failed to get the Accept Parameter Value "));
                    pErr->errCode=Sdf_en_initDataAccessError;
                    return ICF_FAILURE;
                }
                if(Sdf_mc_strcasecmp(pMediaType,pTempVal)==0)
                {
                    dFound=ICF_TRUE;
                    break;
                }
            }
        }

        /* If no match found then form 415 response */
        if(ICF_TRUE != dFound)
        {/*
            if (sdf_ivk_uaRejectRequest(pObj,\
                    pInitData,415, &pOverlapTxn, pErr) == Sdf_co_fail)
            {
                                ICF_PRINT(("\n[SSA]:Failed to form 415 response "));
                return ICF_FAILURE;
            }
            if (pOverlapTxn != Sdf_co_null)
            {        

                if(pOverlapTxn != Sdf_co_null)
                {
                    if( pObj->pUasTransaction->pSipMsg != Sdf_co_null )
                        sip_freeSipMessage(pObj->pUasTransaction->pSipMsg);
                    pObj->pUasTransaction->pSipMsg=pOverlapTxn->pSipMsg;
                    HSS_LOCKEDINCREF(pObj->pUasTransaction->pSipMsg->dRefCount);
                }
            }    */
            return ICF_FAILURE;
        }
    }
    pErr->errCode = Sdf_en_noUaError;
    return ICF_SUCCESS;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_status_frm_notify_from_mime_body
 * DESCRIPTION:     This function checks the given SipMessage for Fragmented
 *                  Sip body and then checks it for the response code
 *                  It returns TRUE if a 200 OK is found, FALSE if any non 2xx
 *                  is found or no message body is found at all
 ******************************************************************************/
static icf_return_t icf_ssa_get_status_frm_notify_from_mime_body(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT      SipMsgBody           *p_sip_msg_body,
        OUT     icf_boolean_t        *p_status)
{
    icf_return_t         ret_val = ICF_SUCCESS;

    Sdf_st_error            sdf_error;
    SipMessage      *p_sip_frag_message = SIP_NULL;
    Sdf_ty_u16bit   frag_resp_code;
    SipBool            sip_ret_val=SipSuccess;

    p_ssa_pdb=p_ssa_pdb;
    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /*
     * Here I am setting the status as success, in the code below i will
     * check for presence of a non 2xx response in the sip message body.
     * if it is there then this status is changed to false.
     * In allother cases, that is when there is no sip message body ( there
     * could be otehr bodies), or the sip message body is there with 200 OK
     * we do not modify the status
     */
    *p_status = ICF_TRUE;
  
        /*
         * If message body is absent,SSA sets the status as FALSE
         */
        if (ICF_NULL == p_sip_msg_body)
        {
            *p_status = ICF_FALSE;
        }
   
        /*Now get the SipMessage Fragment from the SipMessageBody*/
        
        /* Changes start for SPR 10934
         */
        else
        {
            sip_ret_val=sip_getSipMessageFromMsgBody(p_sip_msg_body,
                            &p_sip_frag_message,
                            (SipError*)&(sdf_error.errCode));

            if (SipFail == sip_ret_val)
            {
                sip_freeSipMsgBody(p_sip_msg_body);
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sip_getSipMessageFromMsgBody"));
                 ret_val = ICF_FAILURE;
                *p_status = ICF_FALSE;
               
            }
            else
            {
                /* Set the message type for Sip Fragmented Body
                */
                p_sip_frag_message->dType = SipMessageResponse;
            }

            if(SipSuccess==sip_ret_val)
            {
                /*Now get the response code from SipMessage Fragment*/
                if (Sdf_co_fail == sdf_ivk_uaGetRespCodeFromSipMessage(
                         p_sip_frag_message,&frag_resp_code,&sdf_error))
                {
                    sip_freeSipMessage(p_sip_msg_body->u.pAppSipMessage);
                    sip_freeSipMsgBody(p_sip_msg_body);
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sdf_ivk_uaGetRespCodeFromSipMessage"));
                    ret_val = ICF_FAILURE;
                    *p_status = ICF_FALSE;
              
                }
                else
                {
                    sip_freeSipMessage(p_sip_msg_body->u.pAppSipMessage);
                    sip_freeSipMsgBody(p_sip_msg_body);

                    if (( 200 > frag_resp_code)||(299 < frag_resp_code))
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Non200 response code in SipMessageFragment"));
                        *p_status = ICF_FALSE;
              
                    }
                }
            }
            /*Changes ends for SPR 10934*/
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*Message body header changes Ends*/

/*******************************************************************************
 * FUNCTION:        icf_ssa_check_for_param_in_sipurl
 * DESCRIPTION:     This function gets the parameters present in the referred-to
                    address.
 ******************************************************************************/

icf_return_t icf_ssa_check_for_param_in_sipurl( 
                INOUT               SipUrl        *pUrl, 
                INOUT            icf_uint8_t    *p_param_name, 
                INOUT           icf_uint8_t    *p_out_param_string, 
                INOUT           icf_error_t    *p_ecode)
{
    Sdf_st_error    SipErr;
    Sdf_ty_u32bit    dUrlParamCount = 0;
    icf_uint16_t        tot_len = 0;

    p_ecode=p_ecode;    
    *p_out_param_string = ICF_NULL;

    if (sip_getUrlParamCountFromUrl(pUrl, &dUrlParamCount, \
        (SipError*)&SipErr) == SipFail)
    {
        return ICF_FAILURE;
    }
    if (dUrlParamCount > 0)
    {
        Sdf_ty_u32bit dIndex;
        for (dIndex = 0; dIndex < dUrlParamCount; dIndex++)
        {
            SipParam *pUrlParam;
            Sdf_ty_s8bit *pName;
            
            if (sip_getUrlParamAtIndexFromUrl(pUrl, &pUrlParam,\
                dIndex, (SipError*)&(SipErr)) == SipFail)
            {
                return ICF_FAILURE;
            }
            
            if (sip_getNameFromSipParam(pUrlParam, &pName, \
                (SipError*)&(SipErr)) == SipFail)
            {
                return ICF_FAILURE;
            }
            
            if (Sdf_mc_strcmp((const icf_int8_t *)pName, (const icf_int8_t *)p_param_name) == 0)
            {
                Sdf_ty_s8bit *pTempCompType = Sdf_co_null;
                
                if (sip_getValueAtIndexFromSipParam(pUrlParam, \
                    &pTempCompType, 0, (SipError*) \
                    &(SipErr)) == SipFail)
                {
                    return ICF_FAILURE;
                }

                tot_len = (icf_uint8_t)(icf_port_strlen((icf_uint8_t *)p_param_name) + icf_port_strlen((icf_uint8_t *)pTempCompType) + 1);

                if (ICF_MAX_STR_LEN <= tot_len)
                {
                    return ICF_FAILURE;
                }
                else
                {
                    icf_port_strcpy(p_out_param_string, p_param_name);
                    icf_port_strcat(p_out_param_string, (icf_uint8_t *)"=");
                    icf_port_strcat(p_out_param_string, (icf_uint8_t *)pTempCompType);
                    sip_freeSipParam(pUrlParam);
                    break;
                }
            
            }
        }
    }
    return ICF_SUCCESS;
}



/*NOTIFY_OUT_OF_DIALOG_START*/
/*******************************************************************************
 * FUNCTION:        icf_ssa_handle_notify_out_of_dialog
 *
 * DESCRIPTION:     This function parses NOTIFY req received out of dialog
 *
 ******************************************************************************/

icf_return_t   icf_ssa_handle_notify_out_of_dialog(
        icf_ssa_pdb_st              *p_ssa_pdb,
        icf_nw_inc_notify_ind_st    *p_notify_ind,
        Sdf_st_overlapTransInfo        *pOverlapTransInfo,
        SipMessage                     *pSipMsg)
{
    icf_return_t    ret_val = ICF_SUCCESS;

#ifdef NON_IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_FALSE)

    SipHeader          subs_header;
    Sdf_st_error       sdf_error;
    SIP_S8bit          *p_subs_state = ICF_NULL;
    SIP_U32bit         param_count = 0;
    SipError           error;
    SipParam           *p_param_list = ICF_NULL;
    SIP_U32bit         count = 0;
    icf_uint8_t     reason_code[15]="\0", *p_param_val;
    icf_uint16_t    retry_after = 0;
    icf_uint16_t    expires = 0;
       
    /*Fetch Subscription-State header*/
    if (SipFail != sip_getHeader(pSipMsg, 
                SipHdrTypeSubscriptionState,&subs_header, 
                (SipError*)&(sdf_error.stkErrCode)))
    {
    if (SipFail == 
            sip_impp_getSubStateFromSubscriptionStateHdr(
                &subs_header,&p_subs_state,
                (SipError*)&(sdf_error.stkErrCode)))
    {
        sip_freeSipHeader(&subs_header);
        return ICF_FAILURE;
    }
    else
    {
        /*Get Parameters in Subscription Header*/
        param_count = 
                
#ifdef ICF_WITH_MUATK_2_2
            ((SipSubscriptionStateHeader*)(subs_header.pHeader))->slParam.size;
#else
            ((SipSubscriptionStateHeader*)(subs_header.pHeader))->slParams.size;
#endif                
               
        while (count < param_count)
        {
            if (SipSuccess == 
                    sip_impp_getParamAtIndexFromSubscriptionStateHdr(
                        &subs_header, &p_param_list, count, &error))
            {
                sip_listGetAt(&(p_param_list->slValue), 0, 
                        (SIP_Pvoid *)&p_param_val, &error);
                
                if ( 0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"reason"))
                {
                    icf_port_strcpy(reason_code, p_param_val);
                }
                else if (0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"retry-after"))
                {
                    retry_after = (icf_uint8_t)icf_port_atoi((const icf_int8_t *)p_param_val);
                }
                else  if (0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"expires"))
                {
                    expires = (icf_uint8_t)icf_port_atoi((const icf_int8_t *)p_param_val);
                }
                sip_freeSipParam(p_param_list);
            }

            count++;
        } /* while (count < param_count) */
    } /* else */
    } /* If success of get sub state */


    if(ICF_NULL == p_subs_state)
    {
        /*If subscription-state is not present, take default as Active */
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureIn getting Subscription state frm MESSAGE"));
        p_notify_ind->subs_state = ICF_SUBS_STATE_ACTIVE;
        p_notify_ind->reason_code = ICF_NW_INC_SUBS_RESP_NO_RETRY;

    }
    else if ((0 == icf_port_strcmp((icf_uint8_t *)p_subs_state, (icf_uint8_t *)"active")) ||
            (0 == icf_port_strcmp((icf_uint8_t *)p_subs_state, (icf_uint8_t *)"pending")))
    {
        /*If subscription-state is active or pending then mark subs_state
         * = ICF_SUBS_STATE_ACTIVE*/
        p_notify_ind->subs_state = ICF_SUBS_STATE_ACTIVE;

        /*If expires parameter is present then copy to duration and mark
         * bitmask as duration_present*/
        if (0 != expires)
        {
            p_notify_ind->duration = expires * 1000;

            p_notify_ind->bitmask |= ICF_NW_INC_SUBS_DURATION_PRESENT;
        }
    } /* (0 == icf_port_strcmp(p_sub... */
    else
    {
        /*Otherwise mark subs_state = ICF_SUBS_STATE_TERMINATED*/
        p_notify_ind->subs_state = ICF_SUBS_STATE_TERMINATED;

        if ((0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"rejected")) ||
                (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"noresource")))
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_SUBS_RESP_NO_RETRY;
        }
        else if (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"giveup"))
        {
            if (0 != retry_after)
            {
                p_notify_ind->duration = retry_after;

                p_notify_ind->bitmask |= ICF_NW_INC_SUBS_DURATION_PRESENT;

                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_AFTER;
            }
            else
            {
                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_IMM;
            }
        } /* else if (0 == icf_port_strc... */
        else if ((0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"deactivated")) ||
                (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"timeout")))
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_NOTIFY_RETRY_IMM;
        }
        else if (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"probation"))
        {
            if (0 != retry_after)
            {
                p_notify_ind->duration = retry_after;

                p_notify_ind->bitmask |= ICF_NW_INC_SUBS_DURATION_PRESENT;
            }

            p_notify_ind->reason_code = 
                ICF_NW_INC_NOTIFY_RETRY_AFTER;
        }
        else  
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_SUBS_RESP_NO_RETRY;
        }
    } /* else */


    /* Free the local reference */
    if((ICF_SUCCESS == ret_val) && (ICF_NULL != p_subs_state))
    {
        /* We should free local refrence only if ret_val was success */
        sip_freeSipHeader(&subs_header);
    }
                
    p_notify_ind->bitmask |= ICF_NW_INC_NOTIFY_OUT_OF_DIALOG;

    /*Fetch Content-Type header from SIP message*/
    /*If Content-Type is application/simple-message-summary then
     * fetch message body*/
    if ((ICF_SUCCESS == ret_val && ICF_NULL != p_notify_ind->p_sic_ctx)|| 
          (ICF_NULL == p_subs_state))
    {
        p_notify_ind->p_sic_ctx->body_list.count=0;

        if (ICF_FAILURE == icf_ssa_get_msg_body_frm_sip_message(p_ssa_pdb, \
                    pOverlapTransInfo->pSipMsg,\
                    /**ppCallObj*/SipMessageRequest,
                    &(p_notify_ind->p_sic_ctx->body_list)))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInMsgBody retreival from MESSAGE"));
            p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_415;
            ret_val = ICF_FAILURE;
        }  
    }

ICF_SIC_END
    if (ICF_FAILURE != ret_val)
    {
        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = 
            ICF_NW_INC_NOTIFY_IND;
        
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length =
            ICF_PORT_SIZEOF(icf_nw_inc_notify_ind_st);
        
        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_SIC;
    }    

ICF_CHECK_IMS_END
#endif /* NON_IMS_CLIENT*/
    return ret_val;
}

icf_return_t icf_ssa_get_replaces_header_from_referto(
     SipReferToHeader *pReferToHdr,
     SipReplacesHeader **ppReplacesHdr,
     Sdf_st_error *pErr)
{
    SipHeader         dSipHeaderReferTo;
    SipHeader         *pSipHeaderReplaces = Sdf_co_null;
    Sdf_ty_retVal     dRetVal = ICF_FAILURE;
    icf_uint32_t    param_count=0, i, j;
    icf_string_st     ReplacesStr;    
    SipList         *pList = SIP_NULL;

    /* DO not remove this as ={0}; causes warnings */
        
    dSipHeaderReferTo.dType=0;
    dSipHeaderReferTo.pHeader=SIP_NULL;
    ReplacesStr.str[0]='\0';
    ReplacesStr.str_len=0;

    if(pErr == Sdf_co_null)
    {
        return ICF_FAILURE;
    }
    if ((Sdf_co_null == pReferToHdr) || (Sdf_co_null == ppReplacesHdr))
    {
        pErr->errCode=Sdf_en_invalidParamError;
        return ICF_FAILURE;
    }
    
    *ppReplacesHdr = Sdf_co_null;
    dSipHeaderReferTo.dType = SipHdrTypeReferTo;
    dSipHeaderReferTo.pHeader = pReferToHdr;
    icf_port_strcpy(ReplacesStr.str,(icf_uint8_t *)"Replaces:");

    if((pReferToHdr->pAddrSpec->dType !=SipAddrSipUri) &&
        (pReferToHdr->pAddrSpec->dType !=SipAddrSipSUri))
    {
        icf_uint8_t *p_loc = ICF_NULL;
        /* For uris other then sip and sips */
        if ((ICF_NULL != pReferToHdr->pAddrSpec->u.pUri) &&
            (ICF_NULL != (p_loc = (icf_uint8_t *)icf_port_strstr(
            pReferToHdr->pAddrSpec->u.pUri, 
            (const icf_int8_t *)"Replaces="))))
        {
            icf_port_strcat(ReplacesStr.str, 
                p_loc+strlen("Replaces="));
            dRetVal = ICF_SUCCESS;
        }
    }
    /* Check whether Repleace cams as a header param */
    else if (ICF_NULL != pReferToHdr->pAddrSpec->u.pSipUrl)
    {
        icf_uint8_t *p_loc = ICF_NULL;
        if ((ICF_NULL != pReferToHdr->pAddrSpec->u.pSipUrl->pHeader) &&
            (ICF_NULL != (p_loc = (icf_uint8_t *)icf_port_strstr(
            (const icf_int8_t *)pReferToHdr->pAddrSpec->u.pSipUrl->pHeader, 
            (const icf_int8_t *)"Replaces="))))
        {
            icf_port_strcat(ReplacesStr.str, 
                p_loc+strlen("Replaces="));
            dRetVal = ICF_SUCCESS;
        }
        else
        {
            pList = &(pReferToHdr->pAddrSpec->u.pSipUrl->slParam);
            param_count = pList->size;
            if(0 == param_count)
            {
                /* Check for the slParam of the heder */
                pList = &(pReferToHdr->slParam);
                param_count = pList->size;
                
            }
        }
    }

    
    for (i=0; i<param_count; i++)
    {
        SipParam *pParam=Sdf_co_null;
        
        if (sip_listGetAt(pList, i, ((SIP_Pvoid *)&pParam), \
        (SipError *)&pErr->stkErrCode) == SipFail)
        return SipFail;        
        
        if (Sdf_co_null != pParam)
        {
            if (0 == Sdf_mc_strcasecmp(pParam->pName, "Replaces"))
            {
                Sdf_ty_s8bit *pParamStr = Sdf_co_null;
                Sdf_ty_u32bit dParamValueCount;
                
                sip_getValueCountFromSipParam(pParam, &dParamValueCount, 
                        (SipError *)&pErr->stkErrCode);
                if (dParamValueCount>=1)
                {
                    dRetVal = ICF_SUCCESS;
                    Sdf_mc_strcpy(ReplacesStr.str, "Replaces:");
                }
                for (j=0; j<dParamValueCount; j++)
                {
                    sip_getValueAtIndexFromSipParam(pParam, &pParamStr, j, 
                            (SipError *)&pErr->stkErrCode);
                    /* If there are any Header Params in "Replaces" header,
                     * append them to the header separated by semicolon (;) */
                    /* KLOCSWORK*/
                    if (j>0)
                    {
                        if (icf_port_strlen(ReplacesStr.str) < ICF_MAX_STR_LEN - 2)
                        {
                            Sdf_mc_strcat(ReplacesStr.str, ";");
                        }
                    }
                    if (icf_port_strlen(ReplacesStr.str) < ICF_MAX_STR_LEN - 2)
                    {
                        Sdf_mc_strcat(ReplacesStr.str, pParamStr);
                    }
                }
                sip_freeSipParam(pParam);
                break;
            }
            sip_freeSipParam(pParam);
        }
    }

    /* 
     * If "Replaces" param was found in "Refer-To" header, then 
     * 1. convert the String to SipReplacesHeader 
     * 2. Initialise a SipHeader
     * 3. Convert string to SipHeader (of type SipReplacesHeader)
     */
    if (ICF_SUCCESS == dRetVal)
    {
        
        sdf_fn_uaUnescapeCharacters((icf_int8_t *)ReplacesStr.str, pErr);
        if (SipFail == sip_initSipHeader(&pSipHeaderReplaces, SipHdrTypeAny, \
                (SipError *)&pErr->stkErrCode))
        {
            pErr->errCode = pErr->stkErrCode;
            return ICF_FAILURE;
        }
        if (SipFail == sip_parseSingleHeader((icf_int8_t *)ReplacesStr.str, SipHdrTypeReplaces,
                pSipHeaderReplaces, (SipError *)&pErr->stkErrCode))
        {
            sdf_memfree(Sdf_mc_callHandlerMemId,(Sdf_ty_pvoid*)&pSipHeaderReplaces, \
                pErr);
            return ICF_FAILURE;
        }
        /* Store the "Replaces" Header in the return value */
        *ppReplacesHdr = (SipReplacesHeader *)pSipHeaderReplaces->pHeader;
        sdf_memfree(Sdf_mc_callHandlerMemId,(Sdf_ty_pvoid*)&pSipHeaderReplaces, \
                pErr);
    }
    return (icf_uint8_t)dRetVal;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_validate_mode_n_addr_type
 *
 * DESCRIPTION:     
 *
 ******************************************************************************/

icf_return_t   icf_ssa_validate_mode_n_addr_type(
        icf_ssa_pdb_st              *p_ssa_pdb)
{
    icf_return_t    ret_val = ICF_SUCCESS;
    /* 
     * If the transport mode stored in the ssa ctxt is TLS and the 
     * call is being initiated to a non-SIP URI, we fail, the call.
     */

    if ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport) &&
        (ICF_ADDRESS_PLAN_SIPS_URI != 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_type))
    {
        ret_val = ICF_FAILURE;
    }
    else if (((ICF_ADDRESS_PLAN_SIPS_URI == 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_type) &&
        (ICF_ADDRESS_PLAN_SIPS_URI != 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_type)) ||
        ((ICF_ADDRESS_PLAN_SIPS_URI == 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_type) &&
         (ICF_ADDRESS_PLAN_SIPS_URI != 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_type)))
    {
        ret_val = ICF_FAILURE;
    }
    else if ((ICF_NULL != (ICF_CFG_CC_CALL_THRU_SIP_PROXY &
             p_ssa_pdb->p_glb_cfg_data->default_settings)) &&
          ((ICF_ADDRESS_PLAN_SIPS_URI == 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_type) &&
            (ICF_TRANSPORT_TYPE_TLS != p_ssa_pdb->p_line_data->transport_mode)))
    {
        ret_val = ICF_FAILURE;
    }
    else if ((ICF_NULL == (ICF_CFG_CC_CALL_THRU_SIP_PROXY &
             p_ssa_pdb->p_glb_cfg_data->default_settings)) &&
          ((ICF_ADDRESS_PLAN_SIPS_URI == 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_type) &&
            (ICF_TRANSPORT_TYPE_TLS != p_ssa_pdb->p_glb_cfg_data->self_mode)))
    {
        ret_val = ICF_FAILURE;
    }
    return ret_val;
}


/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_set_pending_in_ctxt
 * DESCRIPTION:  
 *         This function is written to be a generic function which
 * can be called from multiple places in SSA. It sets the bitmask to indicate
 *  what kind of method is pending on successful TCP COnnect completion
 *  so that approriate action could be taken when asynch response for TCP 
 *  connect is received
***************************************************************************/
icf_return_t    icf_ssa_set_pending_in_ctxt(icf_ssa_pdb_st    *p_ssa_pdb,
                Sdf_ty_s8bit    *p_method,
                icf_ssa_ctxt_st        *p_ssa_ctxt)
{
    icf_return_t    ret_val = ICF_SUCCESS;
    p_ssa_pdb=p_ssa_pdb;
    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"INVITE"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_INVITE_PENDING;
        }
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *) "REGISTER"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_REG_PENDING;
        }
#ifdef SIP_IMPP
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"SUBSCRIBE"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_SUBS_PENDING;
        }
#endif
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"PUBLISH"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_PUBLISH_PENDING;
        }
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"MESSAGE"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_MESSAGE_PENDING;
        }
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"REFER"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_REFER_PENDING;
        }
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *) "OPTIONS"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_OPTION_PENDING;
        }
        else
        {
            ret_val = ICF_FAILURE;
        }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_attempt_out_of_uatk_connect
 * DESCRIPTION:  
 *         This function is written to be a generic function which
 * can be called from multiple places in SSA. Two kinds of usage scenarios
 *     1. DNS_LOOKUP_DISABLED: In this case, the message formation routine
 * invokes ssa_send_to_peer which checks ( just before invoking 
 * icf_ssa_initiate_dispatch_sequence) if a TCP/TLS connect is required. If
 * so, this function is invoked.
 *    2. DNS_LOOKUP_ENABLED: In this case, ssa_send_to_peer invokes UATK
 * API HandleLookup which launches asynch DNS query. On reception of response to 
 * that, SSA checks in the SSA CTXT if a bitmask is set indicating OUT_OF_UATK_
 * CONNECT_REQ ( this was set before invoking ssa_send_to_peer).If so, this is
 * done else initiate dispatch is invoked.

 * Returns: SUCCESS/FAILURE and flag that indicates whether msg can be sent
 *     or not ( i.e to invoke dispatch sequences or not..
 *    SUCCESS + TRUE = invoke dispatch routine
 *    SUCCESS + FALSE = do not invoke dispatch routine, (asynch conn. pending)
 *    FAILURE + - = do not invoke dispatch routine, return failure
 *
 * Things which should be present in  contexts:
 * 1. peer address and port number: if DNS off, then message forming routine will
 * do this, else the DNS resp handler callback will get it from dest info in 
 * transaction data - to be filled in SSA PDB
 * 2. pointer to transaction or to message formed
 * 3, TRANSPOT_MODE bitmask in ssa context
 * 5. NON ALOCATION of ssa conn DB node
 * 6. p_ssa_ctxt->transport should be set correctly in the calling routine

 * Things done by this routine
 * 1. allocates a conn db node and populates it
 * 2. attempts TCP connect,
 *         if a synch failure, resp pending. should store all the info and return with 
 *         indication to not send the message
 *         if synch failure, checks if reversion can be done ( based on transport mode
 *         in line data and optionally also on INITIAL_REQ bitmask) if so, returns
 *         indication to send the message
 *         if synch success, stores data and returns indication to send the message
 ***************************************************************************/
icf_return_t icf_ssa_attempt_out_of_uatk_connect(
        icf_ssa_pdb_st            *p_ssa_pdb,
        Sdf_st_callObject        *p_call_obj,
        Sdf_st_transaction        *p_txn,
        Sdf_st_overlapTransInfo        *p_overlap_txn,
    icf_boolean_t            *p_ready_to_send)
{
    icf_return_t         ret_val = ICF_SUCCESS, sm_ret_val = ICF_FAILURE;
    icf_ssa_ctxt_st        *p_ssa_ctxt = (icf_ssa_ctxt_st*)
        (p_call_obj->pAppData->pData);
#ifdef ICF_DNS_LOOKUP_ENABLED
    icf_boolean_t            to_loop = ICF_TRUE;
    Sdf_st_transportInfo    *pDestInfo      = Sdf_co_null; 
    Sdf_st_error             Err;
#endif

    SipMessage        *p_sip_msg = SIP_NULL;
    Sdf_st_error        sdf_error;
    Sdf_ty_s8bit        *p_method = Sdf_co_null;
    Sdf_st_socket        *p_socket = Sdf_co_null;
    en_SipMessageType    dMsgType; 
    icf_ssa_tcpm_conn_data_st  **p_p_temp_conn = ICF_NULL;
    icf_ssa_tcpm_conn_data_st  *p_conn = ICF_NULL;
    

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt; /*Just in case*/
    *p_ready_to_send = ICF_TRUE;

    /*Get the message pointer*/
    if ( Sdf_co_null == p_overlap_txn)
    {
        p_sip_msg = p_txn->pSipMsg;
        p_socket = &(p_txn->dSocket);
        p_ssa_ctxt->p_pending_txn = (icf_void_t*)p_txn;
    }
    else if ( Sdf_co_null == p_txn)
    {
        p_sip_msg = p_overlap_txn->pSipMsg;
        p_socket = &(p_overlap_txn->dSocket);
        p_ssa_ctxt->p_pending_txn = (icf_void_t*)p_overlap_txn;
    }
    else
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:NullTxnPointer,returning Failure"));
        ICF_SSA_RESET_COMMON_BITMASK(p_ssa_ctxt->bitmask, 
                ICF_SSA_EXPLICIT_CONNECT_REQ)
        return ICF_FAILURE;
    }

    dMsgType = icf_ssa_get_msg_type(p_ssa_pdb, p_call_obj);

#ifdef ICF_DNS_LOOKUP_ENABLED
    /* code added here to support the DNS retries */
   /* In case of TCP the destination IP address is was not picked from the p_dest_info of the stack
    * SO  Will pick the  value from the stack here and fill it from p_dest_info*/
    if (sdf_ivk_uaGetDestInfoFromTransaction(p_txn,\
                p_overlap_txn,&pDestInfo, &Err) == Sdf_co_success)

    {
        if(ICF_NULL != pDestInfo->pIp)
        {
            icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->dest_ip, (icf_uint8_t *)pDestInfo->pIp);
        }

        if(pDestInfo->dPort != 0) 
        {
            p_ssa_pdb->dest_port = (icf_uint16_t)pDestInfo->dPort;
        }
        
        if(ICF_NULL != p_txn)
        {
            (void)sdf_ivk_uaFreeTransportInfo(p_txn->pDestInfo);
        }
        else if(ICF_NULL != p_overlap_txn )
        {
            (void)sdf_ivk_uaFreeTransportInfo(p_overlap_txn->pDestInfo);
        }


    }
#else
    {
        /*Since node was not allocated earlier, we need to 
          populate the peer address into it. This is set in PDB by the callinig  fn.*/
        icf_return_t    dummy_retval = ICF_SUCCESS;
        icf_uint8_t    *p_ip_addr = ICF_NULL;
        /*get the destination IP address and port from
         * proxy configuration*/
        if ( ICF_FAILURE == icf_port_get_host_ip(
                    (icf_int8_t *)p_ssa_pdb->dest_ip,
                    (icf_int8_t **)&p_ip_addr))
        {
            ICF_PRINT(("[SSA]:FailureInProxyAddrResolution"));
            ret_val = ICF_FAILURE;
        }
        else if(ICF_NULL != p_ip_addr)
        {
            icf_port_strcpy(p_ssa_pdb->dest_ip, p_ip_addr);

            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_ip_addr,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_retval)
        }
    }

#endif

    if (dMsgType == SipMessageRequest)
    {
        p_p_temp_conn = &(p_ssa_ctxt->p_conn_table_req_entry);
        p_ssa_pdb->conn_type = ICF_CONN_TYPE_REQUEST;
    } 
    else
    {
        p_p_temp_conn = &(p_ssa_ctxt->p_conn_table_resp_entry);
        p_ssa_pdb->conn_type = ICF_CONN_TYPE_RESPONSE;
    } 

    if (p_ssa_pdb->p_conn_table_entry !=  ICF_NULL)
    {
        ICF_PRINT(((icf_uint8_t *)"PDB is containing the connection information. So reusint it\n"));
        *p_p_temp_conn = p_ssa_pdb->p_conn_table_entry;
        return ICF_SUCCESS;
    }
    /*then allocate a conn db node is not allocated already*/
#if 0
    if ( ICF_NULL == *p_p_temp_conn)
    {
#endif
#ifdef ICF_SECURE_SUPPORT
        if (p_ssa_ctxt->transport == ICF_TRANSPORT_TYPE_TLS)
        {
            p_ssa_pdb->protocol = ICF_TRANSPORT_TLS;
            p_ssa_pdb->conn_type = ICF_CONN_TYPE_BOTH;
        }
        else
#endif
        {
            p_ssa_pdb->protocol = ICF_TRANSPORT_TCP;
        }
        if(0 != ICF_MAX_PURGE_TIMER_DURATION)
        { 
            if (ICF_NULL != (p_conn = icf_ssa_get_conn_db_by_ip(p_ssa_pdb,
                       p_ssa_pdb->p_ssa_glb_data->p_ssa_tcpm_conn_db )))
            {
                ICF_PRINT(((icf_uint8_t *)"Connection already exists. Reusing it\n")); 
                if (dMsgType == SipMessageRequest)
                {
                    ICF_SSA_INC_CONN_REF_COUNT(p_conn);
                    p_ssa_ctxt->p_conn_table_req_entry = p_conn;
#ifdef ICF_SECURE_SUPPORT
                    if (p_ssa_ctxt->transport == ICF_TRANSPORT_TYPE_TLS)
                        p_ssa_ctxt->p_conn_table_resp_entry = p_conn;
#endif
                }
                else
                {
                    p_ssa_ctxt->p_conn_table_resp_entry = p_conn;
#ifdef ICF_SECURE_SUPPORT
                    if (p_ssa_ctxt->transport == ICF_TRANSPORT_TYPE_TLS)
                        p_ssa_ctxt->p_conn_table_req_entry = p_conn;
#endif
                }
                ICF_PRINT(((icf_uint8_t *)"Total %d calls are on this connection\n", p_conn->ref_count));
                *p_ready_to_send = ICF_TRUE;
                ICF_SSA_RESET_COMMON_BITMASK(p_ssa_ctxt->bitmask, 
                        ICF_SSA_EXPLICIT_CONNECT_REQ)
                    return ICF_SUCCESS;
            }
        }
        p_conn = icf_ssa_add_conn_entry(p_ssa_pdb->p_ssa_glb_data->p_ssa_tcpm_conn_db);

        if (ICF_NULL== p_conn)
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInConnDbNode Allocation,returning Failure"));
            ret_val =  ICF_FAILURE;
        }
    if ( ICF_FAILURE == ret_val)
    {
        ICF_SSA_RESET_COMMON_BITMASK(p_ssa_ctxt->bitmask, 
                ICF_SSA_EXPLICIT_CONNECT_REQ)
        *p_ready_to_send = ICF_FALSE;
        return ICF_FAILURE;
    }

    /*Get the method*/
    if ( Sdf_co_fail == sdf_ivk_uaGetMethodFromSipMessage(
                p_sip_msg,&p_method,&sdf_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInGettingMethodFromSipMessage"));
        ret_val = ICF_FAILURE;
    }
    else
    {/*Invoking TCP SM*/

#ifdef ICF_DNS_LOOKUP_ENABLED
        do
        {
#endif
            /* the following action on conn db node are 
             being done here as we may loop if 
            sm returns failure and there are more DNS records
            (assuming DNS_LOOKUP enabled). then we need to 
            fill up the conn db node etc. again as SM failure
            leg would have reset it all*/
           
            /* In case of TCP the destination IP address is not picked from the p_dest_info of the stack
             * which was filled by dns buffer so we are again filling the same here */
            if (dMsgType == SipMessageRequest)
            {
                ICF_SSA_INC_CONN_REF_COUNT(p_conn);
                p_ssa_ctxt->p_conn_table_req_entry = p_conn;
#ifdef ICF_SECURE_SUPPORT
                if (p_ssa_ctxt->transport == ICF_TRANSPORT_TYPE_TLS)
                    p_ssa_ctxt->p_conn_table_resp_entry = p_conn;
#endif
            }
            else
            {
                ICF_SSA_INC_CONN_REF_COUNT(p_conn);
                p_ssa_ctxt->p_conn_table_resp_entry = p_conn;
#ifdef ICF_SECURE_SUPPORT
                if (p_ssa_ctxt->transport == ICF_TRANSPORT_TYPE_TLS)
                    p_ssa_ctxt->p_conn_table_req_entry = p_conn;
#endif
            }
            p_ssa_pdb->p_conn_table_entry = p_conn;
            icf_port_strcpy(p_ssa_pdb->p_conn_table_entry->peer_ip,(icf_uint8_t *)p_ssa_pdb->dest_ip);
            p_ssa_pdb->p_conn_table_entry->peer_port_num = p_ssa_pdb->dest_port;
            /*p_ssa_pdb->p_conn_table_entry->p_ssa_ctxt =
             * p_ssa_pdb->p_ssa_ctxt;*/
            p_ssa_pdb->p_conn_table_entry->conn_fd = ICF_INVALID_SOCKFD;
            p_ssa_pdb->p_conn_table_entry->tcpm_sm_state = ICF_SSA_TCPM_IDLE;
            p_ssa_pdb->p_conn_table_entry->ref_count = 1;
            p_ssa_pdb->p_conn_table_entry->timer_count = 0;
            p_ssa_pdb->p_conn_table_entry->prot_conn_bitmask = (icf_uint8_t)(p_ssa_pdb->conn_type |
                p_ssa_pdb->protocol);
            ICF_SSA_PRINT_CONN_DB(p_ssa_pdb->p_conn_table_entry)
            if (0 != ICF_PURGE_TIMER_DURATION)
                            p_ssa_pdb->p_conn_table_entry->is_persistent = ICF_TRUE;

            ICF_SSA_IVK_TCPSM(p_ssa_pdb, 
                    ICF_SSA_TCPM_OPEN_CONN_REQ, sm_ret_val)

            if ( ICF_SUCCESS == sm_ret_val)
            {
                if (ICF_SSA_TCPM_AWT_CON_RESP ==
                        p_ssa_pdb->p_conn_table_entry->tcpm_sm_state)
                {
                    if ( ICF_FAILURE == icf_ssa_set_pending_in_ctxt(
                                p_ssa_pdb, p_method,p_ssa_ctxt))
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:UnKnownMethodType!!"));
                        ret_val = ICF_FAILURE;
                    }
                    /* this is used to judge for revert in case
                       of failure in asynch connect*/
                    p_ssa_ctxt->bitmask |= ICF_SSA_TCP_TRANSPORT;
                    *p_ready_to_send = ICF_FALSE;
                }
                if ( ICF_SUCCESS == ret_val)
                {
                    p_socket->dSockfd = 
                        p_ssa_pdb->p_conn_table_entry->conn_fd;
#ifdef ICF_SECURE_SUPPORT
                    if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
                    {
                        p_socket->dProtocol = Sdf_en_protoTls;
                    }
                    else
                    {
#endif
                        p_socket->dProtocol = Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT
                    }
#endif
                }
#ifdef ICF_DNS_LOOKUP_ENABLED
                to_loop = ICF_FALSE;
                /*No loop required now as SM has returned success*/
#endif
            }/*StateMachine success leg end*/
#ifdef ICF_DNS_LOOKUP_ENABLED
            else
            {
                ICF_SSA_SET_TXN_DNS_STATE(p_txn, p_overlap_txn, Sdf_en_dnsIpUsed)

                /*Connect has failed to the current IP, so we attempt to move to the next IP*/

                if ( ICF_FAILURE ==  icf_ssa_get_next_dest_from_list(
                            p_ssa_pdb, p_call_obj, p_txn, p_overlap_txn))
                {
                    to_loop = ICF_FALSE;
                    /*sm_ret_val is ICF_FAILURE;*/
                }
            }
        }while(ICF_TRUE == to_loop);/*End of DO*/
#endif 
        if ( ICF_FAILURE == sm_ret_val)
        {
            /*Failure from SM, now we check if reversion is possible/
              allowed. C riteria: TRANSPORT mode should be BOTH*/
            if ((ICF_TRUE == p_ssa_ctxt->revert_mode) ||
                (ICF_TRANSPORT_MODE_BOTH == p_ssa_ctxt->transport))
            {
                if ( ICF_FAILURE == icf_ssa_revert_to_udp(
                            p_ssa_pdb, p_call_obj, &p_overlap_txn,
                            (icf_uint8_t *)p_method, &sdf_error))
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInRevertingToUdp\n"));
                    *p_ready_to_send = ICF_FALSE;
                    ret_val = ICF_FAILURE;
                }
                /* this is to tell that for subsequent requests
                 * we will not change the transport mode 
                 */
                else
                {
#ifdef ICF_DNS_LOOKUP_ENABLED
                    /*Code to be added to launch a new DNS query
                      for UDP, prior to that remove the DNS records from 
                      transaction structure*/

                    ICF_SSA_SET_TXN_DNS_STATE(p_txn, p_overlap_txn, Sdf_en_Idle)

                        if ( Sdf_co_fail == sdf_ivk_uaHandleLookup(p_call_obj,
                                    p_overlap_txn, p_sip_msg,
                                    p_ssa_pdb->p_event_ctxt,&sdf_error))
                        {
                            if ( Sdf_en_dnsInvState != sdf_error.errCode)
                            {
                                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureIn HandleLookUp API"));
                                ret_val = ICF_FAILURE;
                            }
                            else
                            {
                                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Sdf_en_dnsInvState, Continuing"));
                            }
                        }
                        else if (Sdf_co_false != sdf_ivk_uaIsDnsQueryState(p_call_obj,
                                    p_overlap_txn, &sdf_error))
                        {
                            *p_ready_to_send = ICF_FALSE;/*ret_val is Success*/
                        }
#endif
                    ICF_SSA_RESET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask, \
                            ICF_SSA_TCP_TRANSPORT);
                    ICF_SSA_RESET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask, \
                            ICF_SSA_TLS_TRANSPORT);
                    p_ssa_pdb->p_ssa_ctxt->trans_mode_reverted = ICF_TRUE;
                }
            }
            else
            {
                ret_val = ICF_FAILURE;
            }
        }/*StateMachine failure leg end*/
    }

    if ( ICF_FAILURE == ret_val)
    {
        p_ssa_ctxt->p_pending_txn = ICF_NULL;
        *p_ready_to_send = ICF_FALSE;
    }

    /*resetting the bitmask. this bitmask was set only to indicate to the calling
    function that the invocation is for a dialog-estbalishing request processing.
    so anb out of dialog connect is required 
    Further, when we move to asynchronous, this should be reset whenever we 
    receive a final response for the tcp connect - in TCPSM funcs*/
        ICF_SSA_RESET_COMMON_BITMASK(p_ssa_ctxt->bitmask, 
                ICF_SSA_EXPLICIT_CONNECT_REQ)

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}



/*******************************************************************************
 * FUNCTION:        icf_ssa_modify_callobj_profile_after_call_accept
 * DESCRIPTION:     This function updates the call object profile for the supported
 *                  and require headers.
 *                  Also this function will add unsupported header in the call
 *                  object profile.
 ******************************************************************************/

icf_return_t icf_ssa_modify_callobj_profile_after_call_accept
(
 INOUT   icf_ssa_pdb_st       *p_ssa_pdb,
 INOUT   Sdf_st_initData      *pInitData,
 OUT     Sdf_st_error         *p_error)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    Sdf_st_listIterator dListIterator;
    Sdf_st_error        Err;
    /*To remove warning*/
    p_error=p_error;
     
    p_ssa_pdb=p_ssa_pdb;
    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        
        sdf_listInitIterator(&(pInitData->slExtraHeadersList),\
        &dListIterator, &Err);
    
    while (dListIterator.pCurrentElement != Sdf_co_null)
    {
        Sdf_st_configExtraHeaders *pTemp = Sdf_co_null;
        en_HeaderType pType;
        Sdf_ty_s8bit dTempType[Sdf_co_characterBufferSize]="";
        
        pTemp = (Sdf_st_configExtraHeaders*)\
            (dListIterator.pCurrentElement->pData);
    
        Sdf_mc_strcpy(dTempType,pTemp->pParam->pName);
        if (icf_port_strlen((icf_uint8_t *)dTempType) < Sdf_co_characterBufferSize - 2)
        {
            Sdf_mc_strcat(dTempType,":");
        }
        /*
        * Invoke stack API to convert the Header name into the stacks
        * en_HeaderType enumeration
        */
        if(sip_getTypeFromString(dTempType,&pType, \
            (SipError*)&(Err.stkErrCode)) == SipFail)
        {
            Err.errCode = Sdf_en_headerManipulationError;
            ret_val = ICF_FAILURE;
        }
        if(pType == SipHdrTypeSupported || pType == SipHdrTypeRequire)
        {
            Sdf_ty_u32bit size,index;
            
            sip_listSizeOf(&(pTemp->pParam->slValue), &size, \
                (SipError*)&(Err.stkErrCode));
            
            for (index = 0; index < size; index++)
            {
                Sdf_ty_s8bit *pTempVal;
                
                if (sip_listGetAt(&(pTemp->pParam->slValue),  \
                    (Sdf_ty_u32bit) index,(Sdf_ty_pvoid *)&pTempVal,  \
                    (SipError*)&(Err.stkErrCode)) == SipFail)
                {
                    Err.errCode=Sdf_en_extraHeaderAccessError;
                    ret_val = ICF_FAILURE;
                }
                
                if(Sdf_mc_strcmp(pTempVal,"100rel")==0)
                {
                    /* Remove this parameter from the header list
                     */
                    sip_listDeleteAt (&(pTemp->pParam->slValue),\
                                        index, (SipError*)&(Err.stkErrCode));
                    ret_val = ICF_SUCCESS;
                    break;
                }
            }/* End of for loop of supported/require header values.*/
    }

    sdf_listNext(&dListIterator, &Err);
    }/* End of while */
        
    /* Add Unsupported 100rel header in the call object profile
    */
    if(ICF_FAILURE != ret_val)
    {
        if(Sdf_co_fail == icf_ssa_addDefaultHeader(
            pInitData,"UnSupported","100rel",Sdf_co_true,&Err))
        {
            ret_val = ICF_FAILURE;
        }
    }
        
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}




icf_return_t icf_ssa_clear_header_from_profile(Sdf_st_initData *pInitData,
                                              icf_uint8_t *pName,
                                              icf_error_t *p_ecode)
{
    icf_uint8_t *current_name = Sdf_co_null;
    Sdf_st_configExtraHeaders *pConfHdr = Sdf_co_null;
    icf_uint8_t curr_pos = 0;
    Sdf_st_error err;
    Sdf_st_error *pErr = &err;
    /* To remove warnings */
    p_ecode=p_ecode;

    for(curr_pos = 0;curr_pos < pInitData->slExtraHeadersList.size;curr_pos ++)
    {
        if(ICF_FAILURE == sdf_listGetAt (&(pInitData->slExtraHeadersList),
            curr_pos, (Sdf_ty_pvoid *)&pConfHdr,pErr))
        {
            return ICF_FAILURE;
        }

        if(pConfHdr->pParam == Sdf_co_null)
        {    
            pErr->errCode=Sdf_en_invalidParamError;
            return ICF_FAILURE;
        }

        if(sip_getNameFromSipParam(pConfHdr->pParam,((Sdf_ty_s8bit ** )&current_name),\
                (SipError*)&(pErr->stkErrCode)) == SipFail)
        {
            pErr->errCode=Sdf_en_headerManipulationError;
            return ICF_FAILURE;
        }
		/*Fix done for SPR-18722 : CSR-1-6068965*/
        if(Sdf_mc_strcasecmp((icf_int8_t *)current_name,(icf_int8_t *)pName) ==0)
        {
            if (Sdf_co_fail == sdf_listDeleteAt (&(pInitData->slExtraHeadersList),
                curr_pos, pErr))
            {
                return ICF_FAILURE;
            }
            curr_pos --;
        }
    }

    return ICF_SUCCESS;
} 

/*****************************************************************************
 ** FUNCTION:           icf_ssa_refresh_supported_content_and_events
 **
 ** DESCRIPTION:        This function refreshes the supported and accept headers 
 **                     in the callobject profile from the header list passed as
 **                     a parameter. The accept and supported headers are removed
 **                     from the header list passed and put in the callobjects 
 **                     profile
 **
 *****************************************************************************/
icf_return_t icf_ssa_refresh_supported_content_and_events(icf_ssa_pdb_st *p_ssa_pdb,
                                                          icf_header_list_st *p_hdr_list,
                                                          icf_error_t *p_ecode)
{
    icf_string_list_st               *p_supported_events = ICF_NULL;
    icf_string_list_st               *p_supported_content = ICF_NULL;
    icf_return_t                     ret_val = ICF_SUCCESS;
    Sdf_st_callObject               *p_call_obj = ((icf_ssa_ctxt_st *)(p_ssa_pdb->p_glb_pdb->p_call_ctx->p_sip_ctx))->p_call_obj;

    if (ICF_FAILURE == icf_cmn_get_strlist_from_hdrlist(
        p_ssa_pdb->p_glb_pdb,
        p_hdr_list,
        (icf_uint8_t *)"Supported",
        &p_supported_events))
    {
        ret_val = ICF_FAILURE;
    }
    else if (ICF_FAILURE == icf_cmn_get_strlist_from_hdrlist(
        p_ssa_pdb->p_glb_pdb,
        p_hdr_list,
        (icf_uint8_t *)"Accept",
        &p_supported_content))
    {
        ret_val = ICF_FAILURE;
    }
    
    else
    {
        if(ICF_NULL != p_supported_events)
        {
            /* Clear the previous accept list */
            if (ICF_NULL != p_supported_events->count)
            {
                ret_val = icf_ssa_clear_header_from_profile(
                    p_call_obj->pInitData,
                    (icf_uint8_t *)"Supported", 
                    p_ecode);
                
                if(ICF_SUCCESS == ret_val)
                {
                    ret_val = icf_ssa_add_string_list_in_default_header(
                        p_call_obj->pInitData,
                        (icf_uint8_t *)"Supported", 
                        p_supported_events,
                        Sdf_co_true,
                        p_ecode);
                    
                }
                /* free the memory allocated to p_supported_events */
                icf_cmn_free_string_list(
                    p_ssa_pdb->p_glb_pdb,
                    p_supported_events,
                    p_ecode);
                
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb, 
                    p_supported_events,
                    ICF_MEM_COMMON,
                    p_ecode, 
                    ret_val)
                    
            }
        }
        if((ICF_SUCCESS == ICF_SUCCESS ) &&
            (ICF_NULL != p_supported_content))
        {
            /* Clear the previous accept list */
            if (ICF_NULL != p_supported_content->count)
            {
                /* Clear the previous supported list */
                ret_val = icf_ssa_clear_header_from_profile(
                    p_call_obj->pInitData,
                    (icf_uint8_t *)"Accept", 
                    p_ecode);
                if(ICF_SUCCESS == ret_val)
                {
                    ret_val = icf_ssa_add_string_list_in_default_header(
                        p_call_obj->pInitData,
                        (icf_uint8_t *)"Accept", 
                        p_supported_content,
                        Sdf_co_true,
                        p_ecode);
                    
                }
                /* free the memory allocated to p_supported_events */
                icf_cmn_free_string_list(
                    p_ssa_pdb->p_glb_pdb,
                    p_supported_content,
                    p_ecode);
                
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb, 
                    p_supported_content,
                    ICF_MEM_COMMON,
                    p_ecode, 
                    ret_val)
            }
        }
    }
    return ret_val;
}

/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_require_header
 * DESCRIPTION:  1.Invoke the SDF API which returns the list
 *                 of entries present in the Require header.
 *               2.Iterate through the list and check for the presence
 *                 of 100 rel.If present and config doesn't support 
 *           PRACK ,retun FAILURE
 *
 ***************************************************************************/

icf_return_t icf_ssa_parse_require_header(
        INOUT icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT    SipMessage          *p_sip_msg,
    INOUT  Sdf_st_error          *p_err)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_ty_slist            slRequiredList;
    Sdf_ty_u32bit           size = 0,iterator = 0;
    icf_uint8_t          *p_list_element = ICF_NULL;
#ifdef ICF_QOS_SUPPORT
    icf_boolean_t            rel_present = ICF_FALSE;
#endif
    icf_uint8_t          supported_list[3][10] = {"100rel", "replaces", "timer"};
    icf_uint8_t          j = 0;
    icf_boolean_t        found = ICF_FALSE;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (Sdf_co_fail == sdf_ivk_uaReturnRequiredList (
                p_sip_msg,&slRequiredList,p_err))
    {
        ret_val = ICF_FAILURE;
    }
    /* Fetch the size of the list */
    else if (Sdf_co_fail == sdf_listSizeOf(
                &slRequiredList,&size,p_err))
    {
        ret_val = ICF_FAILURE;
    }
    /*If list contains elements*/
    else if(size !=0)
    {
        /*Fetch all the entries from the Supported header */
        for(iterator = 0; iterator < size; iterator++)
        {
            if(Sdf_co_fail == sdf_listGetAt(&slRequiredList,
                        iterator, (Sdf_ty_pvoid *)&p_list_element,p_err))
            {
                ret_val = ICF_FAILURE;
            }
             else
            {
                /*Check if value in require header present in local supported list*/
                for (j = 0; j < 3; j++)
                {
                    if (0 == icf_port_strcmp(p_list_element, supported_list[j]))
                    {
                        found = ICF_TRUE;
                        break;
                    }
                }
                if (ICF_FALSE == found)
                {
                    icf_string_list_node_st *p_cur_node = ICF_NULL;
                    /*Compare with app_conf support_events list*/
                    for (j = (icf_uint8_t)p_ssa_pdb->p_app_conf->app_profile.supported_events.count,
                         p_cur_node = p_ssa_pdb->p_app_conf->app_profile.supported_events.p_list;
                         j--; 
                         p_cur_node = p_cur_node->p_next)
                    {
                        if (0 == icf_port_strcmp(p_list_element, p_cur_node->str.str))
                        {
                            found = ICF_TRUE;
                            break;
                        }
                    }
                }
                if (ICF_FALSE == found)
                {
                    p_ssa_pdb->common_bitmask |= ICF_SSA_REQUIRE_VALUE_IS_NOT_SUPPORTED;
                    ret_val = ICF_FAILURE;
                }
            }
            if (ICF_FAILURE == ret_val)
            {
                   /*In case of failure do not iterate further
                    * require list, break*/
                    break;
		    
            }
            else if (ICF_NULL == icf_port_strcmp(
                        p_list_element,(icf_uint8_t *)"100rel"))
            {
#ifdef ICF_QOS_SUPPORT
                rel_present = ICF_TRUE;
#endif 
                /* Check if configuration supports PRACK.
                 * If not ,fail the function
                 */
                if (ICF_NULL == (ICF_CFG_CC_PRACK_REQD & 
                    p_ssa_pdb->p_glb_cfg_data->default_settings))
                {
                    ret_val = ICF_FAILURE;
                    break;
                }    
            }
            else if (ICF_NULL == icf_port_strcmp(
                        p_list_element,(icf_uint8_t *)"precondition"))
            {
                icf_config_data_st*        p_config_data = ICF_NULL;

                /* Get pointer to config data from DBM */
                ret_val = icf_dbm_get_module_glb_data(
                    p_ssa_pdb->p_glb_pdb,
                    (icf_int_module_id_t)ICF_INT_MODULE_CFG,
                    (icf_void_t *)&p_config_data, p_ssa_pdb->p_ecode);

				ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_config_data));

#ifdef ICF_QOS_SUPPORT
                if(Sdf_co_fail == sdf_ivk_uaIsSdpBodyPresent(p_sip_msg, p_err)) 
                {
                    p_err->errCode = ICF_CAUSE_SDP_MISSING_FOR_PRECONDITION;
                    ret_val = ICF_FAILURE;
                }
                if (ICF_SUCCESS == ret_val)
                {
                    if (ICF_TRUE == p_config_data->nw_res_reservation_supported)
                    {
                        /* set the bitmask in call context */
                        p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask |= ICF_NW_RES_RESERV_REQD;
                    }    
                    else
                    {
                        ret_val = ICF_FAILURE;
                        break;
                    }
                }
#else            
                {
                    ret_val = ICF_FAILURE;
                    break;
                }    
#endif
            }
        }
    }

#ifdef ICF_QOS_SUPPORT
ICF_CHECK_QOS_SUPPORT_START(p_ssa_pdb->p_glb_pdb, ICF_TRUE)
    if((ICF_FALSE == rel_present)&&
        (ICF_SUCCESS == ret_val))
    {
        p_err->errCode = ICF_CAUSE_PRECONDITION_PROV_WITHOUT_100REL;
    }
ICF_CHECK_QOS_SUPPORT_END
#endif 

    sdf_listDeleteAll(&slRequiredList,p_err);
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
icf_uint8_t icf_ssa_get_transport_mode(Sdf_st_callObject *pCallObj)
{
    icf_ssa_ctxt_st *p_ssa_ctxt = (icf_ssa_ctxt_st *)(pCallObj->pAppData->pData);
    if((ICF_TRANSPORT_MODE_BOTH == p_ssa_ctxt->transport) &&
            (ICF_TRUE == p_ssa_ctxt->trans_mode_reverted))
    {
        return ICF_TRANSPORT_MODE_UDP;
    }
    return p_ssa_ctxt->transport;
}

#ifdef ICF_DNS_LOOKUP_ENABLED
Sdf_ty_retVal icf_ssa_cbk_FillDestInfoFromUnknownDnsRec (
        Sdf_st_callObject *pCallObj,
        Sdf_st_overlapTransInfo *pOverlapTransaction,
        Sdf_ty_slist *pslDnsRecords,
        Sdf_st_transportInfo *pDestInfo,
        Sdf_st_error            *pErr)
{
    if (sdf_ivk_uaFillDestInfoFromSrvRec (pCallObj, pOverlapTransaction,
                    pslDnsRecords, pDestInfo, pErr) == Sdf_co_fail)
        {
        return Sdf_co_fail;
    }

/*    if (sdf_ivk_uaFillDestInfoFromIpRec (pslDnsRecords, pDestInfo,pErr) \
            == Sdf_co_fail)
    {
        (Sdf_ty_void)sdf_ivk_uaFreeTransportInfo(pDestInfo);
        return Sdf_co_fail;
    }*/


    return Sdf_co_success;
}    

Sdf_ty_retVal icf_ssa_FreeUnknownDnsList (
        Sdf_st_DnsRecord        *pDnsRecord)
{
#ifdef ICF_DNS_LOOKUP_ENABLED
    pDnsRecord = pDnsRecord;
#endif
    return Sdf_co_success;
}
#endif

#ifdef ICF_SSA_UT_NR_CODE
#ifdef ICF_LOOPBACK_SUPPORT
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_util_map_addresses
 *
 * DESCRIPTION:     This function is used by SSA for mapping local and remote
 *                  address with the address received in message.
 *
 ******************************************************************************/
icf_return_t icf_ssa_util_map_addresses(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT  Sdf_st_callObject       *p_call_obj,
        INOUT  SipHeader      *pFrom,
        INOUT  SipHeader      *pTo,
        OUT   icf_ssa_ctxt_st    *p_mapped_ssa_ctxt,
        OUT   Sdf_st_error            *p_sdf_error,
        OUT   icf_error_t    *p_ecode)
{
        icf_return_t             ret_val = ICF_FAILURE;
        SipMessage              *p_temp_msg = Sdf_co_null;
        en_SipMessageType   dMsgType;
        Sdf_ty_s8bit                *p_method = Sdf_co_null;

        ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        (void)p_ecode;

        if (p_call_obj->pUacTransaction->pSipMsg != Sdf_co_null)
                p_temp_msg = p_call_obj->pUacTransaction->pSipMsg;
        else
                p_temp_msg = p_call_obj->pUasTransaction->pSipMsg;
     
        sip_getMessageType(p_temp_msg, &dMsgType, \
                  (SipError*)    &(p_sdf_error->stkErrCode)) ;

        /* Call dialog is matched as follows:
         * If it is request, then
         *   Call id, From, To should map with call id, To and From.
         *   Note that the order of From and To are changed as requests 
         *   have the To and From reversed. 
         * If the message is a response, then
         *    Call id, From and To should map with the call id, From
         *    and To of the original call object.
         */

        if(Sdf_co_fail == 
                  sdf_ivk_uaGetMethodFromSipMessage(
                  p_temp_msg,
                  &p_method, p_sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
        else if ( (SipMessageRequest == dMsgType) && 
            (ICF_FALSE == p_ssa_pdb->is_otg_msg))
        {
             if ( (ICF_SUCCESS == icf_ssa_util_cmp_address(
                        p_ssa_pdb,
                        p_mapped_ssa_ctxt->
                        p_call_obj->pCommonInfo->pKey->pLocalAddr,
                        pTo,
                        p_ecode)) &&
                  (ICF_SUCCESS == icf_ssa_util_cmp_address(
                        p_ssa_pdb,
                        p_mapped_ssa_ctxt->
                        p_call_obj->pCommonInfo->pKey->pRemoteAddr,
                        pFrom,
                        p_ecode)))
               {
                   ret_val = ICF_SUCCESS;
               }
        }
        else
        {
             if ( (ICF_SUCCESS == icf_ssa_util_cmp_address(
                        p_ssa_pdb,
                        p_mapped_ssa_ctxt->
                        p_call_obj->pCommonInfo->pKey->pRemoteAddr,
                        pTo,
                        p_ecode)) &&
                  (ICF_SUCCESS == icf_ssa_util_cmp_address(
                        p_ssa_pdb,
                        p_mapped_ssa_ctxt->
                        p_call_obj->pCommonInfo->pKey->pLocalAddr,
                        pFrom,
                        p_ecode)))
            {
                   ret_val = ICF_SUCCESS;
            }
        }
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
} /* End of Fn icf_ssa_util_map_addresses */
#endif

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_util_cmp_address
 *
 * DESCRIPTION:     This function is used by SSA for comparing ny two address
 *                  specs.
 *
 ******************************************************************************/
icf_return_t icf_ssa_util_cmp_address(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT  SipHeader      *pAddr1,
        INOUT  SipHeader      *pAddr2,
        OUT   icf_error_t    *p_ecode)
{
        icf_return_t           ret_val = ICF_FAILURE,
                               ret_val2 = ICF_FAILURE;
        SipAddrSpec            *p_addr_spec1 = ICF_NULL, 
                               *p_addr_spec2 = ICF_NULL;
        icf_address_st         *p_addr_str1 = ICF_NULL, 
                               *p_addr_str2 = ICF_NULL;

        ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        (void)p_ecode;
        /*((SipToHeader*)p_to->pHeader)->pAddrSpec;*/
        p_addr_spec1 = (SipAddrSpec *)(((SipCommonHeader *)pAddr1->pHeader)->pAddrSpec);
        p_addr_spec2 = (SipAddrSpec *)(((SipCommonHeader *)pAddr2->pHeader)->pAddrSpec);

        ICF_MEMGET(
                                    p_ssa_pdb->p_glb_pdb,
                                    sizeof(icf_address_st),
                                    ICF_MEM_COMMON,
                                    p_addr_str1,
                                    ICF_RET_ON_FAILURE,
                                    p_ssa_pdb->p_ecode,
                                    ret_val)

        if (ICF_SUCCESS == ret_val)
        {
           ICF_MEMGET(
                                    p_ssa_pdb->p_glb_pdb,
                                    sizeof(icf_address_st),
                                    ICF_MEM_COMMON,
                                    p_addr_str2,
                                    ICF_RET_ON_FAILURE,
                                    p_ssa_pdb->p_ecode,
                                    ret_val)

           if (ICF_SUCCESS == ret_val)
           {
             if (ICF_FAILURE == icf_ssa_populate_address_from_sip_addr_spec(
                   p_ssa_pdb,
                   p_addr_spec1,
                   p_addr_str1))
             {
                ret_val = ICF_FAILURE;
             }
             else if (ICF_FAILURE == 
                       icf_ssa_populate_address_from_sip_addr_spec(
                   p_ssa_pdb,
                   p_addr_spec2,
                   p_addr_str2))
             {
                ret_val = ICF_FAILURE;
             }
             else if (p_addr_str1->addr_type != p_addr_str2->addr_type)
             {
                ret_val = ICF_FAILURE;
             }
             else if (p_addr_str1->addr_val.str_len != p_addr_str2->addr_val.str_len)
             {
                ret_val = ICF_FAILURE;
             }
             else if (0 != icf_port_strcmp(p_addr_str1->addr_val.str, 
                                           p_addr_str2->addr_val.str))
             {
                ret_val = ICF_FAILURE;
             }
             ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_addr_str1,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val2)
             ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_addr_str2,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val2)
           } /* end of if second memget for addr_str2 is success */
           else
           {
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_addr_str1,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val2)
           }
        } /* end of if the first memget is a success for addr_str1 */
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
} /* End of Fn icf_ssa_util_cmp_address */
#endif




/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_validate_expires
 ** DESCRIPTION:  This function validates the Expires header value in an 
 **               incoming request.
 **
 ******************************************************************************/
icf_return_t icf_ssa_validate_expires(
        INOUT  icf_ssa_pdb_st            *p_ssa_pdb,
        INOUT  Sdf_st_callObject         *p_call_obj,
        OUT   Sdf_ty_messageValidity    *p_validity,
        OUT   Sdf_st_error              *pErr)
{
    icf_return_t                    ret_val = ICF_SUCCESS;
    Sdf_ty_slist                    slMatchedHeadersList;
    SipHeader                       *pExpiresHeader = Sdf_co_null;
    Sdf_st_headerList               *pExpiresHeaderList = Sdf_co_null;
    icf_duration_t                  expires_duration = ICF_NULL;
    Sdf_ty_u32bit                   size = 0;
    p_ssa_pdb=p_ssa_pdb;  

    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }    

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Get the list of Expires headers received in INVITE */
    if (Sdf_co_fail == sdf_ivk_uaGetHeaderListByType(
                          p_call_obj->pUasTransaction->slUnprocessedHeaders,
                          SipHdrTypeExpiresSec,
                          &slMatchedHeadersList,
                          pErr))
    {
        ret_val = ICF_FAILURE;
    }
    else if(Sdf_co_fail == sdf_listSizeOf(&slMatchedHeadersList,&size, pErr))
    {
        sdf_listDeleteAll(&slMatchedHeadersList,pErr);
        ret_val = ICF_FAILURE;
    }
    else if (ICF_NULL != size)
    {
        /* Get HeaderList at index 0. stack will fail the decode for request 
         * carrying more than one Expires header
         */
        if (Sdf_co_fail == sdf_listGetAt(
                          &slMatchedHeadersList,
                          0,
                          (Sdf_ty_pvoid *)&pExpiresHeaderList,
                          pErr))
        {
            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_listGetAt(
                          &(pExpiresHeaderList)->slHeaders,
                          0,
                          (Sdf_ty_pvoid *)&pExpiresHeader,
                          pErr))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            expires_duration = (((SipExpiresHeader *)
                                  (pExpiresHeader->pHeader))->u).dSec;

            /* If expires duration is 0 then set errCode and return failure */
            if (ICF_NULL == expires_duration)
            {
                *p_validity = Sdf_en_invalid;
                ret_val = ICF_FAILURE;
            }
      }
      sdf_listDeleteAll(&slMatchedHeadersList,pErr);
    }/* size != 0 */

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} /* End function icf_ssa_validate_expires() */

/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_set_param_in_Via
 ** DESCRIPTION:  This function sets the Via header parameters for the outgoing
 **               the SipMessage.
 **
 ******************************************************************************/
icf_return_t    icf_ssa_set_param_in_Via(
                 INOUT     SipMessage          *p_sip_msg,
                 INOUT  icf_ssa_pdb_st      *p_ssa_pdb,
                 INOUT     SipParam            *p_param,
                 OUT    SipError            sip_error
                 )
{
    icf_return_t    ret_val = ICF_SUCCESS;
    SipHeader       hdr;
    icf_uint32_t     count = ICF_NULL;
    Sdf_st_error     sdf_error; 


   if(ICF_NULL == p_ssa_pdb)
   {
       return ICF_FAILURE;
   }

   ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
   p_ssa_pdb=p_ssa_pdb;




    /* Get the Via Header from SIP message
     */
     if(SipFail != sip_getHeaderAtIndex(p_sip_msg,SipHdrTypeVia,&hdr,\
         0,(SipError*)&(sip_error)))     
     {
         if(SipFail == sip_getViaParamCountFromViaHdr(&hdr, &count,\
                    (SipError*)&(sdf_error.stkErrCode)))
         {
#ifdef SDF_ERROR
             sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                 (Sdf_ty_s8bit *)"icf_ssa_set_param_in_Via(): "
                 "Failed to get the Via Param count from Via header of SIP message",\
                 &sdf_error);
#endif
             sdf_error.stkErrCode=Sdf_en_headerManipulationError;
             sip_freeSipHeader(&hdr);
             ret_val = ICF_FAILURE;
         }
         else if(SipFail == sip_insertParamAtIndexInCommonHdr(&hdr,p_param,\
             count,(SipError*)&(sdf_error.stkErrCode)))
         {
#ifdef SDF_ERROR
             sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                 (Sdf_ty_s8bit *)"icf_ssa_set_param_in_Via(): "
                 "Failed to insert the Via params in Via header of SIP message",\
                 &sdf_error);
#endif
             sip_error=Sdf_en_headerManipulationError;
             sip_freeSipHeader(&hdr);
             ret_val = ICF_FAILURE;
         }
         else
         {
             sip_freeSipHeader(&hdr);
             ret_val = ICF_SUCCESS;

         }

     }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)    
    return ret_val;

}


#ifdef ICF_NAT_RPORT_SUPPORT
/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_params_from_Via
 ** DESCRIPTION:  This function extracts the Via header parameters from the Sip
 **               Message and set the various flags for rport status as received 
 **               request/response.
 **
 ******************************************************************************/
icf_return_t    icf_ssa_get_params_from_Via(
                 INOUT  SipMessage          *p_sip_msg,
                 INOUT  icf_ssa_pdb_st      *p_ssa_pdb,
                 IN     en_SipMessageType   dMsgType,
                 OUT    SipError            *sip_error
                 )
{
    icf_return_t                 ret_val = ICF_SUCCESS;    
    icf_uint32_t                  count = 0;
    icf_uint8_t                  index = 0;
    SipParam                     *p_sip_param = SIP_NULL;
    Sdf_ty_s8bit                 *pParamName = SIP_NULL;
    SipHeader                    hdr;
    Sdf_st_error                 sdf_error;
    icf_boolean_t                is_recvd_param_present = ICF_FALSE;    
    icf_boolean_t                is_rport_param_present = ICF_FALSE;    
    icf_line_data_st             *p_line_data = ICF_NULL;
    icf_rport_config_data_st     *p_rport_config_data = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (ICF_CFG_SELF_ADDR_PER_LINE ==
            p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                    p_ssa_pdb->p_glb_pdb, p_ssa_pdb->p_ssa_ctxt->line_id,
                    &p_line_data, p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            p_rport_config_data = p_line_data->p_rport_config_data;
        }
    
    }
    else
    {
        p_rport_config_data = &(p_ssa_pdb->p_glb_cfg_data->rport_config_data);
    }

    if (ICF_NULL == p_rport_config_data)
    {
       return ICF_FAILURE; 
    }  
 
    if(SipFail != sip_getHeaderAtIndex(p_sip_msg,SipHdrTypeVia,&hdr,0,\
        sip_error))
    {
        if(SipFail == sip_getViaParamCountFromViaHdr(&hdr, &count, \
                    (SipError*)&(sdf_error.stkErrCode)))
        {
#ifdef SDF_ERROR
            sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                "Failed to get the Via Param count from Via header of SIP message",\
               &(sdf_error));
#endif
            sdf_error.stkErrCode=Sdf_en_headerManipulationError;
            sip_freeSipHeader(&hdr);
            ret_val = ICF_FAILURE;
        }
        else
        {
            /*for(;index < count; index++)*/
            while(index < count)
            {
               /* get the parameters from Via Header 
                */
                if(SipFail == sip_getViaParamAtIndexFromViaHdr(&hdr,&p_sip_param,\
                    index,(SipError*)&(sdf_error.stkErrCode)))
                {
#ifdef SDF_ERROR
                    sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                        (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                        "Failed to get the Via Param from Via header from SIP message",&sdf_error);
#endif
                    sdf_error.stkErrCode=Sdf_en_headerManipulationError;
                    sip_freeSipHeader(&hdr);
                    return ICF_FAILURE;
                    
                }
                else if(SipFail == sip_getNameFromSipParam(p_sip_param, &pParamName,\
                    (SipError*)&(sdf_error.stkErrCode)))
                {
#ifdef SDF_ERROR
                    sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                        (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                        "Failed to get name from via param of SIP message",&sdf_error);
#endif
                    sdf_error.stkErrCode = Sdf_en_headerManipulationError;
                    sip_freeSipParam(p_sip_param);
                    sip_freeSipHeader(&hdr);
                    return ICF_FAILURE;
                }
                
                else
                {
                    if(0 == icf_port_strcmp(pParamName,"received"))
                    {
                        if(SipMessageResponse == dMsgType)
                        {                 
                            /* Store the received param value in received address
                             * of global config 
                             */
                            icf_ssa_convert_to_tran_addr((icf_uint8_t*)\
                                    (p_sip_param->slValue.head->pData),\
                                    &(p_rport_config_data->received_addr));
                            is_recvd_param_present = ICF_TRUE;

                        }
                    }
                    else if(0 == icf_port_strcmp(pParamName,"rport"))
                    {
                        if(SipMessageResponse == dMsgType)
                        {
                            /* Store the rport value in the received address of 
                             * global config data.
                             */
                            if (ICF_NULL != p_sip_param->slValue.head)
                            {
                                p_rport_config_data->received_addr.port_num =
                                    icf_port_atoi((icf_uint8_t*)(p_sip_param->\
                                                slValue.head->pData));
                                is_rport_param_present = ICF_TRUE;
                            }
                        }
                        else if(SipMessageRequest == dMsgType)
                        {
                            /* Set the bitmask in the ssa context to indicate
                             * that the rport is received in the request message
                             */
                            p_ssa_pdb->p_ssa_ctxt->rport_bitmask|=\
                                                                  ICF_RPORT_RECEIVED;
                            /* Delete the rport parameter from the Via Header
                             */

                            if(SipFail == sip_deleteParamAtIndexInCommonHdr(\
                                        &hdr,index,(SipError*)&(sdf_error.\
                                            stkErrCode)))
                            {
                                return ICF_FAILURE;

                            }
                            else
                            {
                                sip_freeSipParam(p_sip_param);
                                count--;
                                continue;
                            }
                        }
                    }
                }
                sip_freeSipParam(p_sip_param);
                index ++;
            }
       /* Check whether rport and received parameters are received in the response Via Header
        */    
       if(SipMessageResponse == dMsgType)
       {
        if(ICF_FALSE == is_recvd_param_present && ICF_FALSE == is_rport_param_present)
        {
            icf_port_memcpy((icf_void_t*)&(p_rport_config_data->received_addr),\
                (icf_void_t*)&(p_rport_config_data->contact_ip_addr),\
                (icf_uint32_t)ICF_PORT_SIZEOF(icf_transport_address_st));
        }         
        else if(ICF_TRUE == is_recvd_param_present && ICF_FALSE == is_rport_param_present)
        {/* Fix for CSR-1-5140139 */
         icf_port_memcpy((icf_void_t*)&(p_ssa_pdb->p_glb_cfg_data->rport_config_data.received_addr),\
				(icf_void_t*)&(p_ssa_pdb->p_glb_cfg_data->rport_config_data.contact_ip_addr),\
				(icf_uint32_t)ICF_PORT_SIZEOF(icf_transport_address_st));
        }
        else if(ICF_FALSE == is_recvd_param_present && ICF_TRUE == is_rport_param_present)
        {/* Fix for CSR-1-5140139 */
         icf_port_memcpy((icf_void_t*)&(p_ssa_pdb->p_glb_cfg_data->rport_config_data.received_addr),\
				(icf_void_t*)&(p_ssa_pdb->p_glb_cfg_data->rport_config_data.contact_ip_addr),\
				(icf_uint32_t)ICF_PORT_SIZEOF(icf_transport_address_st));    
        }
       }
    }
    }

    sip_freeSipHeader(&hdr);

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;

}





/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_compare_transport_addr
 ** DESCRIPTION:  This function compares the contact address and 
 **               the address received in the Via Hdrs Parameters.
 **
 ******************************************************************************/
icf_boolean_t icf_ssa_compare_transport_addr(
         INOUT icf_ssa_pdb_st              *p_ssa_pdb,
         INOUT icf_transport_address_st    *p_contact_addr,
         INOUT icf_transport_address_st    *p_received_addr
         )
{
    icf_boolean_t               match_found = ICF_FALSE;
    icf_string_st               contact_ip = {0,{'\0'}};
    icf_string_st               received_ip = {0,{'\0'}};

#ifdef ICF_TRACE_ENABLE
     icf_return_t    ret_val = ICF_SUCCESS;
#endif

    if(ICF_NULL == p_ssa_pdb)
    {
       ICF_PRINT(("p_ssa_pdb is null"));
       return ICF_SUCCESS;

    }

        
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Convert the Ip address to the string format*/
    
    if (ICF_SUCCESS == icf_ssa_convert_to_IP_addr(
                    p_contact_addr, (icf_uint8_t*)&(contact_ip.str)))
    {
        contact_ip.str_len = icf_port_strlen(contact_ip.str);
    
        if(ICF_SUCCESS == icf_ssa_convert_to_IP_addr(
                    p_received_addr, (icf_uint8_t*)&(received_ip.str)))
        {
    
         received_ip.str_len = icf_port_strlen(received_ip.str);
           /* Compare the ip address strings
            */
            if( 0 == icf_port_strcmp(contact_ip.str,received_ip.str))
            {
                /* IP matched, now compare the port numbers */
                if(p_contact_addr->port_num == p_received_addr->port_num)
                {
                    match_found = ICF_TRUE;
                }
                else
                {
                    /* Port number mismatch*/
                    match_found = ICF_FALSE;
                }
            }
            else
            {
                /* IP Mismatch */
                match_found = ICF_FALSE;
            }
        }
    }   
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return (match_found);
}


/*******************************************************************************
 * FUNCTION:        icf_ssa_start_binding_refresh_timer
 * DESCRIPTION:    This routine is used for starting the binding refresh timer
 ******************************************************************************/
icf_return_t icf_ssa_start_binding_refresh_timer(
        INOUT icf_ssa_pdb_st*    p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_timer_id_t           timer_id = ICF_TIMER_ID_INVALID;
    icf_timer_data_st        *p_timer_data = ICF_NULL;
    icf_rgm_context_st       *p_rgm_context = ICF_NULL;
    icf_rport_config_data_st *p_rport_config_data = ICF_NULL;   
    icf_boolean_t             match_found= ICF_FALSE;
    icf_line_data_st *p_line_data = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    
    if (ICF_CFG_SELF_ADDR_PER_LINE ==
            p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                    p_ssa_pdb->p_glb_pdb,p_ssa_pdb->p_ssa_ctxt->line_id,
                    &p_line_data, p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            p_rport_config_data = p_line_data->p_rport_config_data;
        }
    
    }
    else
    {
        p_rport_config_data = &(p_ssa_pdb->p_glb_cfg_data->rport_config_data);
    }

    if (ICF_NULL == p_rport_config_data)
    {
        return ICF_FAILURE;
    }

    if ( ICF_FAILURE == icf_dbm_get_mem_from_pool(
                p_ssa_pdb->p_glb_pdb, ICF_MEM_TIMER,
                (icf_void_t **)&p_timer_data, 
                p_ssa_pdb->p_ecode))
    {
        ICF_SSA_DEBUG(("\[SSA]:FailureInAllocatingTimerBlockForBindingRefreshTimer\n"));
        ret_val = ICF_FAILURE;
    }
    else
    {
           if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt)
           {
               p_rgm_context = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt;
               if (ICF_TRUE == icf_dbm_util_cmp_addr(p_ssa_pdb->p_glb_pdb,\
                           &(p_rport_config_data->user_address),\
                    &(p_rgm_context->rgm_user_address)))
               {
                   match_found = ICF_TRUE;

               }
           }
           if(ICF_FALSE == match_found)
           {
               /* Fetch the rgm context for the user address stored in the
                * rport config data.
                */
               ret_val = icf_rgm_get_ctxt_for_pub_uri(p_ssa_pdb->p_glb_pdb,\
                       p_rport_config_data->line_id,&(p_rport_config_data->\
                           user_address),&p_rgm_context,p_ssa_pdb->p_ecode);
               if(ICF_FAILURE == ret_val)
               {
                   ICF_PRINT(("\n Unable to fetch rgm context for line id %d.",\
                               p_rport_config_data->line_id));
                   /*Free the allocated timer block here*/
                   icf_dbm_ret_mem_to_pool(p_ssa_pdb->p_glb_pdb, ICF_MEM_TIMER,
                        p_timer_data, p_ssa_pdb->p_ecode);
                   return ret_val;
               }
           }
        /* fill the timer data structure */
        p_timer_data->timer_type = ICF_BINDING_REFRESH_TIMER_TYPE;
        p_timer_data->module_id = ICF_INT_MODULE_CFG;

        /*
         * In case of timer expiry, eshell will pass the p_timer_data
         * to SSA.SSA will then get the p_ssa_timer_data and invoke
         * UATK callback
         */
        p_timer_data->p_timer_buffer = (icf_void_t*)p_rgm_context;
        p_timer_data->p_glb_pdb = p_ssa_pdb->p_glb_pdb;

        ICF_START_TIMER(p_ssa_pdb->p_glb_pdb, 
                p_timer_data, timer_id,
                p_rport_config_data->binding_refresh_timer,
                p_ssa_pdb->p_ecode, ret_val)

        if ( ICF_FAILURE == ret_val)
        {
            ICF_SSA_DEBUG(("\n[SSA]:Failure!!InStartingBindingRefreshTimer"));
            /*Free the allocated timer block here*/
            icf_dbm_ret_mem_to_pool(p_ssa_pdb->p_glb_pdb, ICF_MEM_TIMER,
                    p_timer_data, p_ssa_pdb->p_ecode);
        }
        else
        {
            p_rport_config_data->binding_refresh_timer_id = timer_id;
            p_rport_config_data->p_binding_refresh_timer = p_timer_data;
        } /* else */
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/*******************************************************************************
 * FUNCTION:        icf_ssa_handle_register_response_for_rport
 * DESCRIPTION:     This routine is used for checking the rport and received 
 *                  parameters in the register response. If the values are 
 *                  different from the contact address then set the binding 
 *                  change boolean flag in the global config data and set the
 *                  rport status bitmask to initial-pending.
 * RETURN Types:    ICF_SUCCESS/ICF_FAILURE                  
 ******************************************************************************/
icf_return_t    icf_ssa_handle_register_response_for_rport
(
 INOUT icf_ssa_pdb_st     *p_ssa_pdb)
{

    icf_return_t                ret_val = ICF_SUCCESS;
    icf_boolean_t               match_found= ICF_FALSE;
    icf_rport_config_data_st    *p_rport_config_data=ICF_NULL;
    icf_line_data_st            *p_line_data = ICF_NULL;
    icf_rgm_context_st          *p_rgm_context = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    p_rgm_context = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt;        

    if (ICF_CFG_SELF_ADDR_PER_LINE ==
            p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                    p_ssa_pdb->p_glb_pdb, p_ssa_pdb->p_ssa_ctxt->line_id,
                    &p_line_data, p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            p_rport_config_data = p_line_data->p_rport_config_data;
        }
    
    }
    else
    {
        p_rport_config_data = &(p_ssa_pdb->p_glb_cfg_data->rport_config_data);
    }

    if (ICF_NULL == p_rport_config_data)
    {
       return ICF_FAILURE;
    }

    /* Reset nat_binding_change flag to FALSE.*/
    p_rport_config_data->nat_binding_chng = ICF_FALSE;
    p_rgm_context->line_id =  p_ssa_pdb->p_ssa_ctxt->line_id;

    /* Compare the received and contact transport address stored in the rport
     * config data.
     */

    if(p_rgm_context->ong_dereg_counter)
    {
       match_found = icf_ssa_compare_transport_addr(p_ssa_pdb,\
            &(p_rport_config_data->temp_contact_ip_addr),&(p_rport_config_data->\
            received_addr));
    }
    else
    {
       match_found = icf_ssa_compare_transport_addr(p_ssa_pdb,\
            &(p_rport_config_data->contact_ip_addr),&(p_rport_config_data->\
            received_addr));
    }

    if(ICF_TRUE == match_found)
    {
        /* Set the rport required flag to FALSE. Set rport status as
         * complete. Donot start the binding refresh timer.
         */
        if(ICF_INITIAL_RPORT_INITIAL == p_rgm_context->rport_status)
        {
             if (ICF_CFG_SELF_ADDR_PER_LINE ==
                p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
            {
               p_rport_config_data->is_rport_reqd = ICF_FALSE;
               p_rport_config_data->is_nat_resolved_sys = ICF_TRUE;
            }
            else if(ICF_FALSE == p_rport_config_data->is_nat_resolved_sys &&
               ICF_TRUE == p_rport_config_data->is_rport_reqd)
            {
               p_rport_config_data->is_rport_reqd = ICF_FALSE;
               p_rport_config_data->is_nat_resolved_sys = ICF_TRUE;
            }
            /* The above elseif condition can fail in following scenarios:
             * is_nat_resolved_sys = TRUE
             *        is_rport_reqd = TRUE - This should not be changed
             *        is_rport_reqd = FALSE - This should not be changed
             *
             * is_nat_resolved_sys = FALSE && is_rport_reqd = FALSE
             *        This is possible in case of non-UDP transport, 
             *        so is_rport_reqd should not be changed.
             */
			p_ssa_pdb->p_glb_cfg_data->rport_config_data.is_rport_completed
					= ICF_TRUE;
			p_rgm_context->rport_status =ICF_INITIAL_RPORT_COMPLETED;
			p_rport_config_data->nat_binding_chng = ICF_FALSE;
        }
        else if(ICF_INITIAL_RPORT_PENDING == p_rgm_context->rport_status\
                || ICF_INITIAL_RPORT_ONGOING == p_rgm_context->rport_status)
        {
            p_rport_config_data->is_rport_reqd = ICF_TRUE;
            if(ICF_INITIAL_RPORT_ONGOING == p_rgm_context->rport_status)
            {
                icf_ssa_start_binding_refresh_timer(p_ssa_pdb);
            }
            p_rport_config_data->is_nat_resolved_sys = ICF_TRUE;

        }
        else
        {
            p_rport_config_data->nat_binding_chng = ICF_FALSE;
            p_rport_config_data->is_nat_resolved_sys = ICF_TRUE;
        }
    }
    else
    {
        /* Set nat_binding_change flag to TRUE.*/
        p_rport_config_data->nat_binding_chng = ICF_TRUE;
    }

  /*  ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)*/
    return ret_val;
}

#endif
/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_del_params_in_Via
 ** DESCRIPTION:  This function deletes the Via header parameters from the Sip
 **               Message.
 **
 ******************************************************************************/
icf_return_t    icf_ssa_del_params_in_Via(
                 INOUT  SipMessage          *p_sip_msg,
                 INOUT  icf_ssa_pdb_st      *p_ssa_pdb,
                 OUT    SipError            *sip_error
                 )
{
    icf_return_t                 ret_val = ICF_SUCCESS;    
    icf_uint32_t                  count = 0;
    icf_uint8_t                  index = 0;
    SipParam                     *p_sip_param = SIP_NULL;
    Sdf_ty_s8bit                 *pParamName = SIP_NULL;
    SipHeader                    hdr;
    Sdf_st_error                 sdf_error;

    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_SUCCESS;
    }
  
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    p_ssa_pdb=p_ssa_pdb;

    if(SipFail != sip_getHeaderAtIndex(p_sip_msg,SipHdrTypeVia,&hdr,0,\
        sip_error))
    {
        if(SipFail == sip_getViaParamCountFromViaHdr(&hdr, &count, \
                    (SipError*)&(sdf_error.stkErrCode)))
        {
#ifdef SDF_ERROR
            sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                "Failed to get the Via Param count from Via header of SIP message",\
               &(sdf_error));
#endif
            sdf_error.stkErrCode=Sdf_en_headerManipulationError;
            sip_freeSipHeader(&hdr);
            ret_val = ICF_FAILURE;
        }
        else
        {
            for(index = (icf_uint8_t)count ;index > 0; index--)
            {
               /* get the parameters from Via Header 
                */
                if(SipFail == sip_getViaParamAtIndexFromViaHdr(&hdr,&p_sip_param,\
                    index-1,(SipError*)&(sdf_error.stkErrCode)))
                {
#ifdef SDF_ERROR
                    sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                        (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                        "Failed to get the Via Param from Via header from SIP message",&sdf_error);
#endif
                    sdf_error.stkErrCode=Sdf_en_headerManipulationError;
                    sip_freeSipHeader(&hdr);
                    ret_val = ICF_FAILURE;
                    
                }
                else if(SipFail == sip_getNameFromSipParam(p_sip_param, &pParamName,\
                    (SipError*)&(sdf_error.stkErrCode)))
                {
#ifdef SDF_ERROR
                    sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                        (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                        "Failed to get name from via param of SIP message",&sdf_error);
#endif
                    sdf_error.stkErrCode = Sdf_en_headerManipulationError;
                    sip_freeSipParam(p_sip_param);
                    sip_freeSipHeader(&hdr);
                    ret_val =  ICF_FAILURE;
                }
                
                else
                {
                    if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)pParamName,(icf_uint8_t *)"received")||\
                            ICF_NULL == icf_port_strcmp((icf_uint8_t *)pParamName,(icf_uint8_t *)"rport") ||
                            ICF_NULL == icf_port_strcmp((icf_uint8_t *)pParamName,(icf_uint8_t *)"alias"))
                    {
                        /* Delete the parameter from the header
                         */

                            if(SipFail == sip_deleteParamAtIndexInCommonHdr(\
                                        &hdr,index-1,(SipError*)&(sdf_error.\
                                            stkErrCode)))
                            {
                                
                                sdf_error.stkErrCode = Sdf_en_headerManipulationError;
                                sip_freeSipParam(p_sip_param);
                                sip_freeSipHeader(&hdr);
                                ret_val = ICF_FAILURE;

                            }
                    }
                    /*if (ICF_FAILURE != ret_val)
                    {
                       sip_freeSipParam(p_sip_param);
                    } */   
                }
                if(ICF_FAILURE == ret_val)
                    break;
            }
            /*if (ICF_SUCCESS == ret_val)
            {
                sip_freeSipHeader(&hdr);
            }*/    
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
#ifdef ICF_DNS_LOOKUP_ENABLED
/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_send_to_peer_no_dns_lookup
 * DESCRIPTION:  1.This function internally calls sdf_ivk_uaSendCallToPeer
 *               after initialising an Event Context and setting the 
 *               SSA ctxt into it.
 *               2.In the case of TCP as transport,
 *               we are populating the current transactions' SockFd
 *               with the one in the ConnDb,  if there is one,if not
 *               we reset it to an invalid value so that UATK attempts a 
 *               connect by itself
 *             
 *               The functionality of this function is similar to function 
 *               icf_ssa_send_to_peer except that is would not do DNS query 
 ***************************************************************************/
icf_return_t icf_ssa_send_to_peer_no_dns_lookup(
        icf_ssa_pdb_st *p_ssa_pdb,
        Sdf_st_callObject *p_call_obj,
        SipMessage *p_sip_msg,
        SipOptions *p_options,
        Sdf_st_error *p_sdf_error)
{
    icf_return_t ret_val = ICF_SUCCESS;
    icf_uint32_t count = 0;
    icf_ssa_ctxt_st  *p_ssa_ctxt =
        (icf_ssa_ctxt_st*)(p_call_obj->pAppData->pData);
    icf_error_t      local_ecode={0};


    SipError                SipErr;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    p_ssa_ctxt->p_ssa_pdb = (struct icf_ssa_pdb_st*)p_ssa_pdb;
    p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;
    p_options = p_options;

    if(ICF_FAILURE == ret_val)
    {
    }
    /*  check for presence of allow header and populate it with only the methods
        which the application supports */
    else if (SipFail == sip_getHeaderCount(p_sip_msg, SipHdrTypeAllow, &count, \
        &SipErr) )
    {
        /*ICF_SSA_TRACE(("\nFailed to get Header Count "))*/
        ret_val = ICF_FAILURE;
    }
    /* Allow header present */
    else if(0 < count )
    {
        SipHeader               *p_allow_hdr = ICF_NULL;
        icf_uint8_t *p_method=ICF_NULL;
        icf_uint32_t index;

        if ((ICF_NULL == p_ssa_pdb->p_app_conf) &&
            ((ICF_SSA_USER_ADDR_FRM_SIC & p_ssa_pdb->common_bitmask) ||
             (
              (ICF_NULL != p_ssa_ctxt->p_sic_ctxt) &&
              (ICF_DUMMY_APP_ID == p_ssa_ctxt->p_sic_ctxt->app_id)
             )
            )
           )
        {
            /* Internal Subscribe */
            if(ICF_FAILURE == icf_ssa_make_allow_hdr_for_int_subscribe(p_ssa_pdb,&p_allow_hdr))
            {
                ret_val = ICF_FAILURE;
            }
        }
        else if(ICF_FAILURE == sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg,
                        (Sdf_ty_s8bit**)&p_method,p_sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
        else if((0 == icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER")) &&
                (ICF_NULL != p_ssa_ctxt->p_rgm_ctxt))
        {
            if(ICF_FAILURE == icf_ssa_make_allow_hdr_for_reg(p_ssa_pdb,&p_allow_hdr))
            {
                ret_val = ICF_FAILURE;
            }
        }
        else if(ICF_NULL!= p_ssa_pdb->p_app_conf)
        {
            if(ICF_FAILURE == icf_ssa_make_allow_hdr_from_app_profile(p_ssa_pdb,&p_allow_hdr))
            {
                ret_val = ICF_FAILURE;
            }
        }
        else
            p_allow_hdr = ICF_NULL;

        /* Set new Allow header */
        if(ICF_FAILURE != ret_val)
        {
            /* Delete all allow headers */
            for(index = 0; index < count; index++)
            {
                if(SipFail == sip_deleteHeaderAtIndex (p_sip_msg,SipHdrTypeAllow, 0, &SipErr))
                {
                    ret_val = ICF_FAILURE;
                    break;
                }
            }
            if(ICF_FAILURE == ret_val)
            {
            }
            else if(ICF_NULL != p_allow_hdr)
            {
                /* Insert header in sip message */
                if(SipFail == sip_insertHeaderAtIndex (p_sip_msg, p_allow_hdr, 0, &SipErr))
                {
                    ret_val = ICF_FAILURE;
                }
            }
        }
        if(ICF_NULL != p_allow_hdr)
        {
            sip_freeSipHeader(p_allow_hdr);
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        }
    }

    if ( ICF_FAILURE != ret_val)
    {
        Sdf_st_eventContext *p_event_context = Sdf_co_null;
        if (Sdf_co_fail ==
                sdf_ivk_uaInitEventContext(&p_event_context, p_sdf_error))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInInitEventCtxt in SSASendToPeer"));
            ret_val = ICF_FAILURE;
        }
        else
        {
            

            Sdf_st_transaction          *p_txn = Sdf_co_null;
            Sdf_st_overlapTransInfo     *p_overlap_txn = Sdf_co_null;
            p_event_context->pData = p_call_obj->pAppData->pData;

            if (Sdf_co_fail == sdf_ivk_uaGetTransactionForSipMsg(
                        p_call_obj, p_sip_msg,
                        &p_txn, &p_overlap_txn, p_sdf_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Can'tGetTxnFromMsg!!!"));
                ret_val = ICF_FAILURE;
            }
                if (ICF_FAILURE != ret_val)
                {
                    /*this flag is used to identify whether a connection
                      has been made fully or not. Tjus is it to be used for
                      TCP/TLS cases only*/
                    icf_boolean_t    ready_to_send = ICF_TRUE;
                    if (ICF_NULL != 
                            (ICF_SSA_EXPLICIT_CONNECT_REQ & p_ssa_ctxt->bitmask))
                    {
                        if (ICF_FAILURE == icf_ssa_attempt_out_of_uatk_connect(
                                    p_ssa_pdb, p_call_obj, p_txn, 
                                    p_overlap_txn, &ready_to_send))
                        {
                            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureFrom AttemptOutOfDlgConnect"));
                            ret_val = ICF_FAILURE;
                        }
                    }/*out of UATK connect*/
                    if ((ICF_TRUE == ready_to_send) &&
                            (Sdf_co_fail == 
                             icf_ssa_initiate_dispatch_sequence(
                                 p_ssa_pdb, p_call_obj,
                                 p_txn, p_overlap_txn, p_event_context,
                                 &local_ecode)))
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in InitiateDispatchSeq!!!"));
                        ret_val = ICF_FAILURE;
                    }
                }/*retval FIALURE check*/
        if ( Sdf_co_null != p_txn)
        {
            sdf_ivk_uaFreeTransaction(p_txn);
        }
        if ( Sdf_co_null != p_overlap_txn)
        {
            sdf_ivk_uaFreeOverlapTransInfo(p_overlap_txn);
        }
        }/*InitEventContext Success leg*/
        sdf_ivk_uaFreeEventContext(p_event_context);
    }/*ret_val != FAILURE*/

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
#endif

/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_validate_content_disp
 ** DESCRIPTION:  This function validates the Content Disposition header value in an 
 **               incoming request.
 **
 ******************************************************************************/
icf_return_t icf_ssa_validate_content_disp(
        INOUT icf_ssa_pdb_st            *p_ssa_pdb,
        INOUT Sdf_st_callObject         *p_call_obj,
        OUT   Sdf_st_error              *p_err)
{
    icf_return_t                    ret_val = ICF_SUCCESS;
    Sdf_ty_slist                    slMatchedHeadersList;
    SipHeader                       *p_content_disp_hdr = Sdf_co_null;
    Sdf_st_headerList               *p_content_disp_hdr_list = Sdf_co_null;
    Sdf_ty_u32bit                   size = 0;
    SIP_S8bit                       *p_disp_type = SIP_NULL;
    icf_boolean_t                   content_type_supported = ICF_FALSE;
  	SIP_S8bit 	                    *p_param_value = SIP_NULL;
	SIP_S8bit  		                *p_param_name = ICF_NULL;
    SipParam                        *p_sip_param = SIP_NULL;
    Sdf_ty_u32bit                   content_type_size = 0;
    Sdf_ty_s8bit                    *pMediaType = Sdf_co_null; 
/* Start: For content Encoding Header Validation */
    Sdf_st_configExtraHeaders 	    *pTemp = Sdf_co_null;
    Sdf_st_configExtraHeaders	    *pAcceptEnc = Sdf_co_null;
    Sdf_ty_u32bit                   IndicateAcceptEnc = 0; 
    Sdf_ty_u32bit                   size2=0,dConEncSize=0,dIndex=0;
    Sdf_ty_s8bit                    *pEncoding=Sdf_co_null;
    Sdf_ty_u32bit                   matched=0,sizeval=0;
    Sdf_st_listIterator             dListIterator;
/* End: For content Encoding Header Validation */

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* First we will extract the Content Type header(if any)
     * from the SIP message.Then we will check it against the
     * supported types in the app profile.If a supported content-type
     * is not found we will set failure bitmask to send a 415.Else
     * we will apply the handling of Content-Disposition header handling
     * only in the case of "application/sdp" Content-Type.
     */

    if(SipFail == sip_getHeaderCount(
                      p_call_obj->pUasTransaction->pSipMsg,
                      SipHdrTypeContentType,
                      &content_type_size,
                      (SipError*)&(p_err->stkErrCode)))
    {
        ret_val = ICF_FAILURE;
    }
    if((0 != content_type_size) && (ICF_SUCCESS == ret_val))
    {
        SipHeader               dHdr;
		icf_string_list_node_st *p_list = ICF_NULL;
        icf_app_conf_st         *p_app_conf = ICF_NULL;
        icf_uint8_t             iterator = 0;

        if(SipFail == sip_getHeader(
                        p_call_obj->pUasTransaction->pSipMsg,
                        SipHdrTypeContentType,
                        &dHdr,
                        (SipError*)&(p_err->stkErrCode)))
        {
            ret_val = ICF_FAILURE;
        }
      else if (SipFail == sip_getMediaTypeFromContentTypeHdr(
                        &dHdr,
                        &pMediaType,
                        (SipError*)&(p_err->stkErrCode)))
        {
            sip_freeSipHeader(&dHdr);
            ret_val = ICF_FAILURE;
        }
        sip_freeSipHeader(&dHdr);
        /* Now checking the accepted content types from the profile*/
        if (ICF_FAILURE == icf_cfg_fetch_app_conf(
                              p_ssa_pdb->p_glb_pdb,
                              p_ssa_pdb->p_app_conf->app_id,
                              &(p_ssa_pdb->p_app_conf),
                              p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
        p_app_conf = p_ssa_pdb->p_app_conf;
        p_list = p_app_conf->app_profile.supported_content_types.p_list;
        for(iterator = 0; 
            iterator <
            p_app_conf->app_profile.supported_content_types.count &&
            p_list != ICF_NULL;
            iterator++)
        {
            /* Compare the Content Type received with each 
             * supported content type in app profile
             */
           /* Added null check for klocwork warning removal */    
             if((ICF_NULL != pMediaType) &&
                (ICF_NULL != p_list->str.str) &&     
                (ICF_NULL == icf_port_strcasecmp((const icf_int8_t *)p_list->str.str,(const icf_int8_t *)pMediaType)))
             {
                 content_type_supported = ICF_TRUE;
                 break;
             }
             p_list = p_list->p_next;
        }
     
        if(ICF_FALSE == content_type_supported)
        {
            /* setting the failure bitmask*/
            p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
    		    ICF_SSA_FAILURE_RESP_CODE_415;
    		ret_val = ICF_FAILURE;
        }
    /* Content type is supported.Proceed with handling of Content-Disposition
     * only in the case of "application/sdp'
     */
    /* Added null check for klocwork warning removal */    
    else if((ICF_NULL != pMediaType) && 
            (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pMediaType,(icf_uint8_t *)"application/sdp")))
    { 
        /* Now extract the content disposition */
        if (Sdf_co_fail == sdf_ivk_uaGetHeaderListByType(
                          p_call_obj->pUasTransaction->slUnprocessedHeaders,
                          SipHdrTypeContentDisposition,
                          &slMatchedHeadersList,
                          p_err))
    {
        ret_val = ICF_FAILURE;
    }
    else if(Sdf_co_fail == sdf_listSizeOf(&slMatchedHeadersList,&size, p_err))
    {
        sdf_listDeleteAll(&slMatchedHeadersList,p_err);
        ret_val = ICF_FAILURE;
    }
    else if (ICF_NULL != size)
    {
        /* Get HeaderList at index 0. Current fix is not handling
         * MIME message bodies where multiple message bodies shall be
         * received along with multiple COntent-Disposition headers
         */
        icf_uint8_t                iterator=0;
        size = 0;/* so that we can re-use this variable */
        if (Sdf_co_fail == sdf_listGetAt(
                          &slMatchedHeadersList,
                          0,
                          (Sdf_ty_pvoid *)&p_content_disp_hdr_list,
                          p_err))
        {
            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_listGetAt(
                          &(p_content_disp_hdr_list)->slHeaders,
                          0,
                          (Sdf_ty_pvoid *)&p_content_disp_hdr,
                          p_err))
        {
            ret_val = ICF_FAILURE;
        }
        /* 
         * First extract the display type from the Content Disposition header 
         * Then extract the parameter count 
         */ 
        else if (SipFail == sip_getDispTypeFromContentDispositionHdr(
                p_content_disp_hdr,&p_disp_type,(SipError *)&(p_err->stkErrCode)))
        {
            ret_val = ICF_FAILURE;
        }
        else if (SipFail == sip_getParamCountFromContentDispositionHdr(
                p_content_disp_hdr,&size,(SipError *)&(p_err->stkErrCode)))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            /* Now we have the content disposition type and 
             * the parameter count.
             */

            /* Now extract the handling parameter*/
            for (iterator = 0;iterator < size; iterator++)
            {
                if (SipSuccess == sip_getParamAtIndexFromContentDispositionHdr(
                            p_content_disp_hdr,&p_sip_param,iterator,
                            (SipError *)&(p_err->stkErrCode)))
                {
                    if (SipFail == sip_getNameFromSipParam(
                        p_sip_param,&p_param_name,(SipError *)&(p_err->stkErrCode)))
                    {
                        ret_val = ICF_FAILURE;
                        sip_freeSipParam(p_sip_param);
                        break;
                    }
                    else if (ICF_NULL != icf_port_strcmp((icf_uint8_t *)p_param_name,(icf_uint8_t *)"handling"))
                    {
                        sip_freeSipParam(p_sip_param);
                        continue;
                    }
                    else
                    {

                        /* Only 1 paramter value is expected to be received for this
                         * parameter according to RFC 3261.
                         * Hence,accessing the first value only
                         */
                        if (SipFail == sip_getValueAtIndexFromSipParam(
                                    p_sip_param,&p_param_value,
                                    0,(SipError *)&(p_err->stkErrCode))) 
                        {
                            ret_val = ICF_FAILURE;
                            sip_freeSipParam(p_sip_param);
                            break;
                        }
                    }
                }     
                else
                {
                     ret_val = ICF_FAILURE;
                     break;
                } 
            }

           /* If content disposition is not null and not "session"*/
                if (ICF_NULL == p_disp_type)
                {
                    /*do nothing*/
                }
                else if(ICF_NULL != icf_port_strcasecmp(p_disp_type,"session"))
                {
                    /* Check the handling parameter */
                    /* If it is "required" or Null(by default "required" is 
                     * assumed acc to RFC 3261), then respond with 488
                     */
					if ((ICF_NULL == p_param_value) ||
                       (ICF_NULL == icf_port_strcasecmp(p_param_value,"required")))
                     {
                                    p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
                                        ICF_SSA_FAILURE_RESP_CODE_488;
                                    ret_val = ICF_FAILURE;
                                    sip_freeSipParam(p_sip_param);
                      }
                    /* If it is optional,we will ignore the SDP and indicate the 
                     * same to the calling function so that this can be now treated
                     * as a Non Fast Call.
                     */
                    else if (ICF_NULL == icf_port_strcasecmp(p_param_value,"optional"))
                    {
                        p_ssa_pdb->common_bitmask |= ICF_SSA_SDP_TO_BE_IGNORED;
                    }
                    sip_freeSipParam(p_sip_param);
				}/* end of content disposition is not "session"*/
                /* If content disposition is "session"*/
else if (ICF_NULL == icf_port_strcasecmp(p_disp_type,"session"))
                {
                    /* Now check the content language.If it is English or 
                     * NULL(in such a case it is assumed to be English acc 
                     * to RFC 3261) or one of the supported languages in our
                     * profile, we proceed normally */
                    
                    icf_uint32_t            iterator = 0,
                                            iterator2 = 0,
                                            count = 0;
                    SipHeader               dHeader;
                    SIP_S8bit               *p_unk_hdr_name = SIP_NULL,
                                            *pBuffer = SIP_NULL ;
                    Sdf_ty_u32bit           buf_count = 0;
                    icf_string_list_node_st *p_list = ICF_NULL;
                    icf_app_conf_st         *p_app_conf;
                    icf_boolean_t           language_supported = ICF_FALSE;
                    SipError                err;
                    
                    /* First extracting the Content Language header */

                    /* get the unknown header count */
                    if(SipFail == sip_getHeaderCount(
                           p_call_obj->pUasTransaction->pSipMsg,
                           SipHdrTypeUnknown,&count,
                           (SipError *)&(p_err->stkErrCode)))
                    {
                        ret_val = ICF_FAILURE ;
                    }
                    /* Iterate through all the unknown headers*/
                    for(iterator=0 ; iterator<count ; iterator++)
                    {
                        if(SipFail == sip_getHeaderAtIndex(
                               p_call_obj->pUasTransaction->pSipMsg,
                               SipHdrTypeUnknown, &dHeader,
                               iterator,&err))
                        {
                            /*In this case we continue to try to fetch other unknown headers*/
                            continue;
                        }
                        if(SipFail == sip_getNameFromUnknownHdr(
                                &dHeader,&p_unk_hdr_name,&err))
                        {
                            /*In this case we continue to try to fetch other unknown headers*/
                            sip_freeSipHeader(&dHeader);
                            continue;
                        }
                        if(ICF_NULL == icf_port_strcasecmp(p_unk_hdr_name,"Content-Language"))
                        {
                            /*Content-Language header processing begins*/
#ifdef ICF_WITH_MUATK_2_2
                            buf_count=icf_port_strlen((icf_uint8_t *)(
							    (SipUnknownHeader *)
							    (dHeader.pHeader))->pStr2);
                            pBuffer = (((SipUnknownHeader *)
							    (dHeader.pHeader))->pStr2);
#else
                            buf_count=icf_port_strlen((
		    					(SipUnknownHeader *)
			    				(dHeader.pHeader))->pBody);            
                            pBuffer = (((SipUnknownHeader *)
					    		(dHeader.pHeader))->pBody);
#endif
                            /*Null terminating the Content-Language Header value*/
                            /* Added null check for klocworks warning removal
                             */
                           if(ICF_NULL != pBuffer)
                           {   
						      pBuffer[buf_count] = '\0';
                           }  
                            sip_freeSipHeader(&dHeader);

						    /* Now we have the header value in pbuffer*/
                        
                            /* Compare the Content-Language received with the languages
                            * added in the app profile
                            */
                           if(ICF_NULL != pBuffer)
                           {
                                if(ICF_FAILURE == icf_cfg_fetch_app_conf(
                                       p_ssa_pdb->p_glb_pdb,
                                       p_ssa_pdb->p_app_conf->app_id,
                                       &(p_ssa_pdb->p_app_conf),
                                       p_ssa_pdb->p_ecode))
                                {
                                    ret_val = ICF_FAILURE;
                                }
                                p_app_conf = p_ssa_pdb->p_app_conf;
                                p_list = p_app_conf->app_profile.supported_languages.p_list;
                                for(iterator2 = 0; 
                                    iterator2 <
                                    p_app_conf->app_profile.supported_languages.count &&
                                    p_list != ICF_NULL;
                                    iterator2++)
                                {
                                    /* Compare the Content Language received with each 
                                     * supported langauge in app profile
                                     */
                                    if(ICF_NULL == icf_port_strcasecmp((const icf_int8_t *)p_list->str.str,(const icf_int8_t *)pBuffer))
                                    {
                                        language_supported = ICF_TRUE;
                                        break;
                                    }
                                    p_list = p_list->p_next;
                                }
                            }/* end of fetching supported languages from profile*/
                        }/* end Content-Language handling*/
                    }/* end of iterating through unknown headers*/
 
                    /* If Content-Language header is not found,by default it is assumed 
                     * to be English acc to RFC 3261
                     */
                    if(ICF_NULL == pBuffer)
                    {
                        language_supported = ICF_TRUE;
                    }

                    if(ICF_TRUE == language_supported)
                    {    
                        p_ssa_pdb->common_bitmask |= ICF_SSA_SESSION_HANDLING_REQUIRED;
                    }
                    /* If none of the above scenario is satisfied, we would 
                     * now check the handling parameter.If it is "required" or NULL
                     * (in that case it is assumed to be "required" by default acc to RFC 3261)
                     * we will send 415 anf if it is "optional" we will ignore
                     * the SDP and indicate the same to the calling function so that 
                     * this can be treated as a Non Fast Start Call.
                     */
                    else
                    {    
                        if((ICF_NULL == p_param_value) ||
                           (ICF_NULL == icf_port_strcasecmp(p_param_value,"required")))
                        {
                            p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
					    	    	ICF_SSA_FAILURE_RESP_CODE_415;
					        ret_val = ICF_FAILURE;
                        }
                        else if(ICF_NULL == icf_port_strcasecmp(p_param_value,"optional"))
                        {
                            p_ssa_pdb->common_bitmask |= ICF_SSA_SDP_TO_BE_IGNORED;
                        }
                    }/* end of language_supported is false*/
                    sip_freeSipParam(p_sip_param);
                }/* end of content-disp is "session"*/
            }/* end of handling of Content-Disposition header*/
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
        }/* end if(size != 0)*/
      }/*end if content type is "application/sdp"*/
    }/* end of content type size != 0*/
    /*Fix for CSR 1-7224724:SPR 19698 Start
     * Check if ACCEPT ACCEPT-ENCODING attribute 
     * had been set in the user profile and take those headers from the profile.
     */
    if(Sdf_co_fail == sdf_listSizeOf(&(p_call_obj->pInitData->slExtraHeadersList),
                       &size2,
                       p_err))
    {
        return ICF_FAILURE;
    }    
    (void)sdf_listInitIterator(&(p_call_obj->pInitData->slExtraHeadersList),
            &dListIterator,p_err);

    while(Sdf_co_null != dListIterator.pCurrentElement)
    {
        pTemp = (Sdf_st_configExtraHeaders*)\
                (dListIterator.pCurrentElement->pData);
		
        if(Sdf_co_null == pTemp->pParam->pName)
        {
            (void)sdf_listNext(&dListIterator, p_err);
            continue;
        }
        if(0 == Sdf_mc_strcasecmp("ACCEPT-ENCODING",pTemp->pParam->pName))
        {
            pAcceptEnc = pTemp;
            IndicateAcceptEnc = 1;
        }
        (void)sdf_listNext(&dListIterator, p_err);
    }
    /*
     * Check if the SipMessage Has a Content-Encoding Header
     */
    if(SipFail == sip_getHeaderCount(p_call_obj->pUasTransaction->pSipMsg,
                          SipHdrTypeContentEncoding, 
                          &dConEncSize, 
                          (SipError*)&(p_err->stkErrCode)))
    {
        return ICF_FAILURE;
    }

    /* If  Content-Encoding Header is present then check for vailidity against
     * the ACCEPT-ENCODING attribute of the profile
     */
    if(dConEncSize !=0)
    {
       SipHeader   dHdr;
       Sdf_ty_u32bit ctr=0;

       /* If no Accept-Encoding attribute present then form 415 */
       if(IndicateAcceptEnc !=1)
       {
           p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
                 ICF_SSA_FAILURE_RESP_CODE_415;
           ret_val = ICF_FAILURE;
           return ret_val;
       }

       for(ctr=0;ctr<dConEncSize;ctr++)
       {
            pEncoding = Sdf_co_null;
            sizeval = 0;
            /*
             * Extract the Coding value present in the CONTENT-ENCODING header.
             */
            if (SipFail == sip_getHeaderAtIndex(p_call_obj->pUasTransaction->pSipMsg,
                SipHdrTypeContentEncoding, &dHdr,\
                (Sdf_ty_u32bit)ctr, (SipError *)&(p_err->stkErrCode)))
            {
                return ICF_FAILURE;
            }
            if(SipFail == sip_getEncodingFromContentEncodingHdr(&dHdr,&pEncoding, \
                  (SipError*)&(p_err->stkErrCode)))
            {
                return ICF_FAILURE;
            }
            sip_freeSipHeader(&dHdr);
            /*
             * Check the EnCoding in the Content-Encoding against the list of
             * Codings  set in the
             * Accept-encoding attribute of the user profile.
             */
            if((Sdf_co_null != pAcceptEnc) &&
               (Sdf_co_null != pAcceptEnc->pParam))
            {   
                if(SipFail == sip_listSizeOf(&(pAcceptEnc->pParam->slValue),&sizeval, \
                     (SipError*)&(p_err->stkErrCode)))
                {
                    return ICF_FAILURE;
                }
            }   
            for(dIndex=0;dIndex<sizeval;dIndex++)
            {
                Sdf_ty_s8bit *pTempVal=Sdf_co_null;

               if(SipFail == sip_listGetAt(&(pAcceptEnc->pParam->slValue),  \
                   (Sdf_ty_u32bit) dIndex,(Sdf_ty_pvoid *)&pTempVal,  \
                   (SipError*)&(p_err->stkErrCode)))
               {
                   return ICF_FAILURE;
               }
               if(Sdf_mc_strcasecmp(pEncoding,pTempVal)==0)
               {
                   matched=1;
                   break;
               }
           }
           if(matched !=1)
           {
                p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
                        ICF_SSA_FAILURE_RESP_CODE_415;
                ret_val = ICF_FAILURE;
            }
            matched=0;
        } /* End of for loop iterating through list of Conent-encoding header */
    }/*End CSR 1-7224724: SPR 19698*/
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} 

/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_is_contact_present_in_hdr_list
 ** DESCRIPTION:  This function checks if Contact header present in header_list
 **               and if present then return its header value
 **
 ******************************************************************************/
icf_boolean_t  icf_ssa_is_contact_present_in_hdr_list(
                    icf_ssa_pdb_st   *p_ssa_pdb,
                    icf_uint8_t      **p_p_str,
                    icf_uint8_t      *p_disp_name,
                    icf_uint8_t      *p_tpt_scheme)
{
    icf_header_list_st      *p_header_list = ICF_NULL;
    icf_header_st           *p_hdr = ICF_NULL,*p_prev = ICF_NULL;
    icf_boolean_t           contact_present = ICF_FALSE;
    icf_return_t            ret_val = ICF_SUCCESS;
   
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /*Fetch header list from call context*/
    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt)
    {
        p_header_list = &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->header_list); 
    }
    else
    {
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return contact_present;
    }
    p_hdr = p_header_list->hdr;
    p_prev = p_header_list->hdr;

    /*Initialize Contact value string*/
    *p_p_str = ICF_NULL;

    while (ICF_NULL != p_hdr)
    {
        /*If contact header is present then return TRUE and the header value*/
        if (0 == sip_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str, (const icf_int8_t *)"Contact"))
        {
            *p_p_str = icf_port_strdup(p_hdr->hdr_value.str);
            contact_present = ICF_TRUE;
            /*Delete the Contact header node*/
            if (p_hdr == p_prev)
                p_header_list->hdr = p_hdr->next;
            else
                p_prev->next = p_hdr->next;
             p_header_list->count--;

            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, p_hdr, ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)

           /*Parse Contact address*/
             icf_ssa_parse_contact_in_hdr_list(p_ssa_pdb, *p_p_str, p_disp_name, *p_p_str, p_tpt_scheme);

            break;
        }
        p_prev = p_hdr;
        p_hdr = p_hdr->next;
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return contact_present;
}

/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_parse_contact_in_hdr_list
 ** DESCRIPTION:  This function parses contact header value string and fetches
 **               display name and contact address from it
 **
 ******************************************************************************/
icf_return_t  icf_ssa_parse_contact_in_hdr_list(
                      icf_ssa_pdb_st     *p_ssa_pdb, 
                      icf_uint8_t        *p_contact_str,
                      icf_uint8_t        *p_disp_name, 
                      icf_uint8_t        *p_cont_addr,
                      icf_uint8_t        *p_tpt_scheme)
{
     icf_return_t   ret_val = ICF_SUCCESS;
     icf_int8_t    *p_rem_str = ICF_NULL;
     icf_uint8_t    *p_str = ICF_NULL;
     icf_uint8_t    temp_str[ICF_MAX_STR_LEN] = {0};
    p_ssa_pdb=p_ssa_pdb;

     if(ICF_NULL == p_ssa_pdb)
     {
        return ICF_FAILURE;
     }    
     ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

     if ((ICF_NULL == p_contact_str) || (ICF_NULL == p_cont_addr))
     {
         ret_val = ICF_FAILURE;
     }
     else
     {
          p_str = icf_port_strchr(p_contact_str, '<');
          
          if (ICF_NULL != p_str) 
          {
              p_rem_str = (icf_int8_t *)(p_str + 1);
              if ('<' == *p_contact_str)
                  p_str = ICF_NULL;
              else
                  *p_str = '\0';
          } 
 
          if (ICF_NULL == p_rem_str)
          {
             /*This case means URI does not contain display name and <> are not present
              *now extract scheme from URI*/
              icf_port_strcpy(temp_str, p_contact_str);

              p_str = (icf_uint8_t *)icf_port_strtokr((icf_int8_t *)temp_str, ":", (char**)&p_rem_str);
              
          if (ICF_NULL == p_rem_str)
              {
                      /*This case means scheme is not present in URI*/
              icf_port_strcpy(p_cont_addr, p_contact_str);
                      icf_port_strcpy(p_tpt_scheme, (icf_uint8_t *)"sip");
              }
              else  if(ICF_NULL == p_str)
              {
                 /* klocwork possible crash removal */
              }
              else if ((0 == icf_port_strcasecmp((const icf_int8_t *)"sip", (const icf_int8_t *)p_str)) ||
                       (0 == icf_port_strcasecmp((const icf_int8_t *)"sips", (const icf_int8_t *)p_str)) ||
                       (0 == icf_port_strcasecmp((const icf_int8_t *)"tel", (const icf_int8_t *)p_str)))
              {
                      /*This case means transport scheme present in URI then copy tpt_scheme and
                       *contact address*/
                      icf_port_strcpy(p_tpt_scheme, p_str);
              icf_port_strcpy((icf_uint8_t *)p_cont_addr, (icf_uint8_t *)p_rem_str);
              }
              else
              {
                      /*This case means port is present in URI*/
              icf_port_strcpy(p_cont_addr, p_contact_str);
                      icf_port_strcpy(p_tpt_scheme, (icf_uint8_t *)"sip");
              }
          }
          else if (ICF_NULL != p_str)
          {
              /*This case means display name is present in URI*/
              /*Copy display name and fetch contact address*/
              icf_port_strcpy(p_disp_name, p_contact_str);
 
              /*Extract URI between < URI >*/
          p_str = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)p_rem_str, (const icf_int8_t *)">");
              
              /*Now extract Scheme from URI*/
              icf_port_strcpy((icf_uint8_t *)temp_str, (icf_uint8_t *)p_rem_str);
              icf_port_strcpy((icf_uint8_t *)p_contact_str, (icf_uint8_t *)p_rem_str);
              
          p_str = (icf_uint8_t *)icf_port_strtokr((icf_int8_t *)temp_str, ":", (char**)&p_rem_str);
              
          if (ICF_NULL == p_rem_str)
              {
                      /*This case means scheme is not present in URI*/
              icf_port_strcpy(p_cont_addr, p_contact_str);
                      icf_port_strcpy(p_tpt_scheme, (icf_uint8_t *)"sip");
              }
             else  if(ICF_NULL == p_str)
             {
                /* klocwork possible crash removal */
             }    
              else if ((0 == icf_port_strcasecmp((const icf_int8_t *)"sip", (const icf_int8_t *)p_str)) ||
                       (0 == icf_port_strcasecmp((const icf_int8_t *)"sips",(const icf_int8_t *)p_str)) ||
                       (0 == icf_port_strcasecmp((const icf_int8_t *)"tel", (const icf_int8_t *)p_str)))
              {
                      /*This case means transport scheme present in URI then copy tpt_scheme and
                       *contact address*/
                      icf_port_strcpy(p_tpt_scheme, p_str);
              icf_port_strcpy(p_cont_addr, p_contact_str);
              }
              else
              {
                      /*This case means port is present in URI*/
              icf_port_strcpy(p_cont_addr, p_contact_str);
                      icf_port_strcpy(p_tpt_scheme, (icf_uint8_t *)"sip");
              }
          }
          else
          {
          p_str = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)p_rem_str, (const icf_int8_t *)">");
              /*Now extract Scheme from URI*/
              icf_port_strcpy((icf_uint8_t *)temp_str, (icf_uint8_t *)p_rem_str);
              icf_port_strcpy((icf_uint8_t *)p_contact_str, (icf_uint8_t *)p_rem_str);
              p_str = (icf_uint8_t *)icf_port_strtokr((icf_int8_t *)temp_str, ":", (char**)&p_rem_str);

              if (ICF_NULL == p_rem_str)
              {
                      /*This case means scheme is not present in URI*/
              icf_port_strcpy(p_cont_addr, p_contact_str);
                      icf_port_strcpy(p_tpt_scheme, (icf_uint8_t *)"sip");
              }
              else  if(ICF_NULL == p_str)
              {
                /* klocwork possible crash removal */
              }
              else if ((0 == icf_port_strcasecmp((const icf_int8_t *)"sip", (const icf_int8_t *)p_str)) ||
                       (0 == icf_port_strcasecmp((const icf_int8_t *)"sips", (const icf_int8_t *)p_str)) ||
                       (0 == icf_port_strcasecmp((const icf_int8_t *)"tel", (const icf_int8_t *)p_str)))
              {
                      /*This case means transport scheme present in URI then copy tpt_scheme and
                       *contact address*/
                      icf_port_strcpy(p_tpt_scheme, p_str);
              icf_port_strcpy((icf_uint8_t *)p_cont_addr, (icf_uint8_t *)p_rem_str);
              }
              else
              {
                      /*This case means port is present in URI*/
              icf_port_strcpy(p_cont_addr, p_contact_str);
                      icf_port_strcpy(p_tpt_scheme, (icf_uint8_t *)"sip");
              }
          }
     }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;
}

/* Start for DSCP parameter */
icf_return_t  icf_ssa_get_line_id_from_glb_pdb( INOUT   icf_glb_pdb_st   *p_glb_pdb,
                                                INOUT icf_ssa_ctxt_st       *p_ssa_ctxt,
                                                OUT     icf_line_id_t   * p_line_id,
                                                OUT     icf_error_t      *p_ecode )
{
 icf_uint8_t loop_index;
 icf_config_data_st   *p_dbm_config_data = ICF_NULL;
 /* Get config data from dbm */
 if (ICF_FAILURE == icf_dbm_get_module_glb_data( p_glb_pdb,
                                                 (icf_module_id_t)(ICF_INT_MODULE_CFG),
                                                 (icf_void_t**)(&p_dbm_config_data),
                                                 p_ecode ) )
  {
    /* Unable to get CFG data */
    return ICF_FAILURE;
  }
  /* Extract line id from cc call ctxt/sic ctxt/mph ctxt */
  if(NULL != p_ssa_ctxt->p_call_ctxt)
  {
    *p_line_id = p_ssa_ctxt->p_call_ctxt->line_id;
    return ICF_SUCCESS;
  }
  if(NULL != p_ssa_ctxt->p_rgm_ctxt)
  {
   if(p_ssa_ctxt->p_rgm_ctxt->p_app_data_list)
   {
    for (loop_index = 0; loop_index < p_dbm_config_data->max_applications; loop_index++)
    {
     if (ICF_FALSE == p_ssa_ctxt->p_rgm_ctxt->p_app_data_list[loop_index].is_valid)
     {
      *p_line_id = p_ssa_ctxt->p_rgm_ctxt->p_app_data_list[loop_index].line_id;
      return ICF_SUCCESS;
     }
    }
   }
 }
 if(ICF_NULL != p_ssa_ctxt->p_sic_ctxt)
 {
   *p_line_id = p_ssa_ctxt->p_sic_ctxt->line_id;
   return ICF_SUCCESS;
 }
 return ICF_FAILURE;
}
/* End for DSCP parameter */
                                               
/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_del_all_other_call_obj
 ** DESCRIPTION:  This function finds all other call object except for one which is 
 **                passed as paramter. And then forcefully deletes all of them
 ******************************************************************************/
  icf_return_t    icf_ssa_del_all_other_call_obj(
                 INOUT  icf_ssa_pdb_st      *p_ssa_pdb
                 )  
{
    icf_ssa_ctxt_st       *p_ssa_temp_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st       *p_ssa_ret_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st       *p_temp = ICF_NULL;
    Sdf_st_callObject     *p_call_obj = ICF_NULL;
#if 0
#ifdef ICF_LOOPBACK_SUPPORT
    Sdf_st_error           p_err ;
#endif
#endif
    icf_error_t            p_ecode = 0;
    icf_return_t           ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if(ICF_NULL == p_ssa_pdb->p_ssa_ctxt)
    {
        return ret_val;
    }
    /* Keep orignal ssa context */
	
	/* CSR 1-6638711: SPR 19235 */
    /* CSR 1-6223345: SPR :18865 check if forked_resp_counter is NULL in call context
     * then don't invoke function to delete other call objects. As more then
     * one call object will be present in case of forked call
     */
     if((ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt) && 
		(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->forked_resp_counter))
     {
    p_ssa_temp_ctxt = p_ssa_pdb->p_ssa_ctxt;
    p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    p_ssa_pdb->hash_index = 0;
    /* Find the call object need to be deleted*/
    ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(
            p_ssa_pdb->p_glb_pdb, p_ssa_pdb->p_ssa_ctxt->p_hash_key,
            (icf_void_t **)&p_ssa_ret_ctxt,&p_ecode);
    if (ICF_SUCCESS == ret_val)
    {
        for (p_temp = p_ssa_ret_ctxt; p_temp != ICF_NULL;)
        {
            if (p_ssa_pdb->p_ssa_ctxt != p_temp->p_ssa_ctxt)
            {
#if 0
#ifdef ICF_LOOPBACK_SUPPORT
                if ( ICF_SUCCESS == 
                        icf_ssa_util_cmp_tags(
                            p_ssa_pdb,
                            p_temp->p_ssa_ctxt->p_call_obj, 
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj, 
                            &p_err)
                   )
                {
#endif
#endif
                    p_ssa_pdb->p_ssa_ctxt = p_temp->p_ssa_ctxt;
                    p_temp = p_temp->p_next;
                    icf_ssa_process_forceful_call_clear(p_ssa_pdb);
                    p_ssa_pdb->p_ssa_ctxt = p_ssa_temp_ctxt;
#if 0
#ifdef ICF_LOOPBACK_SUPPORT
                }
#endif
#endif
            }
            else
            {
                p_temp = p_temp->p_next;
            }
        }
    }
	p_ssa_temp_ctxt = ICF_NULL;

    icf_ssa_remove_ctxt_list_entry(p_ssa_pdb->p_glb_pdb,
                   p_ssa_pdb->p_ssa_ctxt);

	if ( ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_hash_key)
	{
	    	ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_ssa_pdb->p_ssa_ctxt->p_hash_key,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
		p_ssa_pdb->p_ssa_ctxt->p_hash_key = ICF_NULL;
	}

	icf_ssa_add_callid_callobj_map(p_ssa_pdb,p_ssa_pdb->p_ssa_ctxt,p_ssa_pdb->p_ecode);
	
   }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

	return ret_val;
}


/******************************************************************
** FUNCTION: icf_ssa_get_reason_string_from_sip_message
**
** DESCRIPTION:  This function retrives the status code from the
** Sip message
**
******************************************************************/
icf_return_t icf_ssa_get_reason_string_from_sip_message
                                            (SipMessage *pMsg,
                                             SIP_S8bit  **p_reason)
{
        SipStatusLine *pLine = Sdf_co_null;
        en_SipMessageType dType;
        Sdf_st_error      err;
        SIP_S8bit *p_code = ICF_NULL;

        if (sip_getMessageType(pMsg, &dType, (SipError*)&(err.stkErrCode)) \
                ==  SipFail)

       {        err.errCode=Sdf_en_headerManipulationError;
                return Sdf_co_fail;
        }

        if (dType == SipMessageRequest)
        {
                err.errCode=Sdf_en_invalidParamError;
                return Sdf_co_fail;
        }

        /*
         * Extract the status code from the Status line
         */
        if (sip_getStatusLineFromSipRespMsg(pMsg,&pLine,(SipError*)\
                &(err.stkErrCode)) ==  SipFail)
        {
                err.errCode=Sdf_en_headerManipulationError;
                return Sdf_co_fail;
        }
        if (sip_getReasonFromStatusLine(pLine,&p_code,(SipError*)\
                &(err.stkErrCode))  == SipFail)
        {
                sip_freeSipStatusLine(pLine);
                err.errCode=Sdf_en_headerManipulationError;
                return Sdf_co_fail;
        }
      
       *p_reason = p_code;
        
       sip_freeSipStatusLine(pLine);

        err.errCode = Sdf_en_noUaError;
         
        return Sdf_co_success;
}


#ifdef ICF_STAT_ENABLE

/******************************************************************
** FUNCTION: icf_ssa_invite_resp_stats
**
** DESCRIPTION: This function takes the response code and increments
**              the related stats for INBOUND/OUTBOUND INVITE.
**              The direction variable is used to identify the 
**              direction of the request.
**               - direction = 0 for OUTBOUND
**               - direction = 1 for INBOUND
**
******************************************************************/


icf_void_t icf_ssa_invite_resp_stats(INOUT  icf_ssa_pdb_st      *p_ssa_pdb,
                                    IN  icf_uint32_t         response,
                                    IN  icf_boolean_t        direction)
{


    /* direction = 0 for OUTBOUND
       direction = 1 for INBOUND */
     
    if(direction == 0)
    {
            if(response == 100)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                     stat_outbound_invite_resp.stats_100);
            }

            else if(response == 180)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                     stat_outbound_invite_resp.stats_180);
            }
            else if(response == 181)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                     stat_outbound_invite_resp.stats_181);
            }

	    else if(response == 182)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                     stat_outbound_invite_resp.stats_182);
            }
            else if(response == 183)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                     stat_outbound_invite_resp.stats_183);
            }

            else if(response >= 200 &&  response < 300)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                     stat_outbound_invite_resp.stats_2xx);
            }

            else if(response >= 300 && response < 400)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_3xx);
            }

            else if(response == 486)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_486);
            }

            else if(response == 404)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_404);
            }

            else if(response == 415)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_415);
            }

            else if(response == 407)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_407);
            }

            else if(response == 401)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_401);
            }

            else if(response == 491)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_491);
            }

            else if(response == 481)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_481);
            }

            else if(response == 503)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_outbound_invite_resp.stats_503);
            }

            else if(response == 488)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_488);
            }
            
            else if(response == 480)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_480);
            }

            else if(response == 500)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_500);
            }

            else if(response == 403)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_403);
            }

            else if(response == 487)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_487);
            }

            else if(response == 400)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_400);
            }

            else if(response == 420)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_420);
            }

            else if(response == 423)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_423);
            }

            else if(response == 484)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_484);
            }

            else if(response == 485)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_485);
            }
            else if(response == 402)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_402);
            } 
	    
            else if(response == 406)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_406);
            } 

            else if(response == 408)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_408);
            } 

	    else if(response == 409)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_409);
            } 

	    else if(response == 410)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_410);
            } 

	    else if(response == 413)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_413);
            } 

	    else if(response == 482)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_482);
            } 

	    else if(response == 483)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_483);
            } 
	
	    else if(response == 489)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_489);
            }

            else if(response == 501)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_501);
            }

            else if(response == 502)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_502);
            }

            else if(response == 504)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_504);
            }

            else if(response == 505)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_505);
            }

            else if(response == 580)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_580);
            }

            else if(response == 600)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_600);
            }

            	    else if(response == 603)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_603);
            }

	    else if(response == 604)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_604);
            }

	    else if(response == 606)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_606);
            }
            else if(response > 400 && response < 500)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                  stat_outbound_invite_resp.stats_rest_4xx);
            }

            else if(response >500 && response <600)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                 stat_outbound_invite_resp.stats_rest_5xx);
            }

            else if(response >600)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                 stat_outbound_invite_resp.stats_rest_6xx);
            }
    }

    else if(direction == 1)
    {
            if(response == 100)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_100);
            }

            else if(response == 180)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_180);
            }
            else if(response == 181)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_181);
            }

	    else if(response == 182)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_182);
            }
            else if(response == 183)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_183);
            }

            else if(response >= 200 &&  response < 300)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_2xx);
            }

            else if(response >= 300 && response < 400)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_3xx);
            }
            else if(response == 400)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_400);
            }
            else if(response == 486)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_486);
            }

            else if(response == 404)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_404);
            }

            else if(response == 415)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_415);
            }

            else if(response == 407)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_407);
            }

            else if(response == 401)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_401);
            }

            else if(response == 491)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_491);
            }

            else if(response == 481)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_481);
            }

            else if(response == 503)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_503);
            }

            else if(response == 488)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_488);
            }
            
            else if(response == 480)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_480);
            }

            else if(response == 500)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_500);
            }

            else if(response == 403)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_403);
            }

            else if(response == 487)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_487);
            }

            else if(response == 420)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_420);
            }

            else if(response == 423)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_423);
            }

            else if(response == 484)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_484);
            }

            else if(response == 485)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_485);
            }

             	    else if(response == 402)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_402);
            }

 	    else if(response == 406)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_406);
            }

 	    else if(response == 408)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_408);
            }

 	    else if(response == 409)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_409);
            }

 	    else if(response == 410)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_410);
            }

 	    else if(response == 413)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_413);
            }

 	    else if(response == 482)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_482);
            }

 	    else if(response == 483)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_483);
            }

 	    else if(response == 489)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_489);
            }

            else if(response == 501)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_501);
            }

            else if(response == 502)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_502);
            }

            else if(response == 504)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_504);
            }

            else if(response == 505)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_505);
            }

            else if(response == 580)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_580);
            }

            else if(response == 600)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_600);
            }

      	    else if(response == 603)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_603);
            }

	    else if(response == 604)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_604);
            }

            else if(response == 606)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_606);
            }

           

            else if(response >= 400 && response < 500)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                    stat_inbound_invite_resp.stats_rest_4xx);
            }

            else if(response >500 && response <600)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                   stat_inbound_invite_resp.stats_rest_5xx);
            }

            else if(response > 600)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                   stat_inbound_invite_resp.stats_rest_6xx);
            }
    }


}


/******************************************************************
** FUNCTION: icf_ssa_resp_stats
**
** DESCRIPTION: This function takes the response code and increments
**              the related stats for related INBOUND/OUTBOUND 
**              requests except INVITE.
**              The direction variable is used to identify the 
**              direction of the request.
**               - direction = 0 for OUTBOUND
**               - direction = 1 for INBOUND
**
******************************************************************/




icf_void_t icf_ssa_resp_stats(INOUT  icf_ssa_pdb_st      *p_ssa_pdb,
                IN  icf_uint8_t         *p_method,
                            IN  icf_uint32_t         response_code,
                            IN  icf_boolean_t        direction)
{

    if(p_method == ICF_NULL)
     {
         return;
     }
        
    switch(response_code)
    {
        
        case 200: 
                
            if( direction == 0)
        
             {
                    
                if (icf_port_strcmp(p_method,(icf_uint8_t *)"CANCEL") == 0)
                 {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_cancel_resp.stats_200);
                 }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"UPDATE") == 0)
                 {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_update_resp.stats_200);
                  }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                 {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_prack_resp.stats_200);
                 }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_subscribe_resp.stats_200);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"INFO") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                       stat_responses.stat_outbound_info_resp.stats_200);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"BYE") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_outbound_bye_resp.stats_200);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_register_resp.stats_200);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_options_resp.stats_200);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"NOTIFY") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_notify_resp.stats_200);
                }
                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"PUBLISH") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_publish_resp.stats_200);
                }
                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"MESSAGE") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_message_resp.stats_200);
                }





            }
            else 
            {
                if (icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"CANCEL") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_cancel_resp.stats_200);
                }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"UPDATE") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_update_resp.stats_200);
                 }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"PRACK") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                         stat_responses.stat_inbound_prack_resp.stats_200);
                }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"NOTIFY") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_notify_resp.stats_200);
                }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"INFO") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                          stat_responses.stat_inbound_info_resp.stats_200);
                }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"BYE") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                          stat_responses.stat_inbound_bye_resp.stats_200);
                }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"OPTIONS") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_options_resp.stats_200);
                }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"MESSAGE") == 0)

                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_message_resp.stats_200);
                }
            }

                break;

        case 202:

                    
            if(direction == 0)

            {
                if (icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                {
                  ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_refer_resp.stats_202);
                }
            }
            else
            {
                if (icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_inbound_refer_resp.stats_202);
                }
            }

            break;

        case 400:

            if(direction == 0)
            {
                if(icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                 {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_refer_resp.stats_400);
                  }
            }

            else

            {
                if (icf_port_strcmp(p_method,(icf_uint8_t *)"CANCEL") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                       stat_responses.stat_inbound_cancel_resp.stats_400);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_prack_resp.stats_400);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_refer_resp.stats_400);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"NOTIFY") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                       stat_responses.stat_inbound_notify_resp.stats_400);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"INFO") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                         stat_responses.stat_inbound_info_resp.stats_400);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"BYE") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                          stat_responses.stat_inbound_bye_resp.stats_400);
                }
                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"MESSAGE") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                          stat_responses.stat_inbound_message_resp.stats_400);
                }

            }

            break;

        case 401:

            if(direction == 0)

            {
                if (icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                   stat_responses.stat_outbound_subscribe_resp.stats_401);
                }

                else if (icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_register_resp.stats_401);
                }
            }

            break;

        case 403:

            if(direction == 1)
            {
                if(icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                 {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                       stat_responses.stat_inbound_refer_resp.stats_403);
                 }
            }

            break;

	case 405:
	   if(direction == 1)
	   {
		  ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                                   misc_stats.inbound_req_405);
	   }
	   
	   break;


        case 407:

            if(direction == 0)

              {
                 if (icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_subscribe_resp.stats_407);
                  }

                 else if (icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_register_resp.stats_407);
                   }
                }

                break;

        case 489:

              if(direction == 0)

                {
                    if (icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                     {
                       ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_subscribe_resp.stats_489);
                      }
                }

                break;
                
        case 481:

            if(direction == 0)
            {
                if(icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_refer_resp.stats_481);
                 }
                else if (icf_port_strcmp(p_method,(icf_uint8_t *)"CANCEL") == 0)
                 {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_cancel_resp.stats_other_resp);
                 }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"UPDATE") == 0)
                 {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                 stat_responses.stat_outbound_update_resp.stats_other_resp);
                 }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                 {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                 stat_responses.stat_outbound_prack_resp.stats_other_resp);
                 }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                 {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                 stat_responses.stat_outbound_subscribe_resp.stats_other_resp);
                 }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"INFO") == 0)
                 {
                  ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_info_resp.stats_other_resp);
                 }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"BYE") == 0)
                 {
                  ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_bye_resp.stats_other_resp);
                 }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") == 0)
                  {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_register_resp.stats_other_resp);
                  }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_options_resp.stats_other_resp);
                  }
                 
                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PUBLISH") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_publish_resp.stats_other_resp);
                  }
                 
                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"MESSAGE") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_message_resp.stats_other_resp);
                  }

            }

            else

            {
                 if (icf_port_strcmp(p_method,(icf_uint8_t *)"CANCEL") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_inbound_cancel_resp.stats_481);
                  }

                  else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_prack_resp.stats_481);
                   }

                  else if(icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                         stat_responses.stat_inbound_refer_resp.stats_481);
                   }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"NOTIFY") == 0)
                    {
                      ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                         stat_responses.stat_inbound_notify_resp.stats_481);
                    }

                    else if(icf_port_strcmp(p_method,(icf_uint8_t *)"INFO") == 0)
                    {
                      ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                           stat_responses.stat_inbound_info_resp.stats_481);
                    }

                    else if(icf_port_strcmp(p_method,(icf_uint8_t *)"BYE") == 0)
                    {
                      ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                             stat_responses.stat_inbound_bye_resp.stats_481);
                     }

                    else if(icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                     {
                       ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_options_resp.stats_481);
                     }
                    else if(icf_port_strcmp(p_method,(icf_uint8_t *)"UPDATE") == 0)
                     {
                       ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_update_resp.stats_481);
                     }
                    else if(icf_port_strcmp(p_method,(icf_uint8_t *)"MESSAGE") == 0)
                     {
                       ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_message_resp.stats_481);
                     }



               }

               break;

        case 500:

            if(direction == 1)

            {
                /* SPR17862 Corrected the method name from PRRACK to PRACK */
                 if (icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                 {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_prack_resp.stats_500);
                  }
                
                  else if (icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                   stat_responses.stat_inbound_options_resp.stats_other_resp);
                   }
                  else if (icf_port_strcmp(p_method,(icf_uint8_t *)"MESSAGE") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                   stat_responses.stat_inbound_message_resp.stats_500);
                   }

            }

            else
            {
                  if (icf_port_strcmp(p_method,(icf_uint8_t *)"CANCEL") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_cancel_resp.stats_other_resp);
                    }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_prack_resp.stats_other_resp);
                   }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_outbound_subscribe_resp.
                                                      stats_other_resp);
                   }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"INFO") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_info_resp.stats_other_resp);
                    }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"BYE") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_bye_resp.stats_other_resp);
                   }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                           stat_responses.stat_outbound_register_resp.
                                                        stats_other_resp);
                    }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                             stat_responses.stat_outbound_options_resp.
                                                       stats_other_resp);
                   }
                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PUBLISH") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                             stat_responses.stat_outbound_publish_resp.
                                                       stats_other_resp);
                   }
                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"MESSAGE") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                             stat_responses.stat_outbound_message_resp.
                                                       stats_other_resp);
                   }
            }


                break;

        default:

            if( direction == 0)

             {

                if (icf_port_strcmp(p_method,(icf_uint8_t *)"CANCEL") == 0)
                 {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                   stat_responses.stat_outbound_cancel_resp.stats_other_resp);
                  }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                 {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_prack_resp.stats_other_resp);
                  }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                 {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                          stat_responses.stat_outbound_subscribe_resp.
                                                        stats_other_resp);
                  }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"INFO") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_info_resp.stats_other_resp);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"BYE") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_bye_resp.stats_other_resp);
                 }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                           stat_responses.stat_outbound_register_resp.
                                                         stats_other_resp);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_options_resp.stats_other_resp);
                }
                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PUBLISH") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_publish_resp.stats_other_resp);
                }
                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"MESSAGE") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_message_resp.stats_other_resp);
                }



           }

          else
             {
                if (icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                 {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                   stat_responses.stat_inbound_options_resp.stats_other_resp);
                  }
             }
    }


}

/******************************************************************
** FUNCTION: icf_ssa_stat_dns_type
**
** DESCRIPTION: This function takes the dns query type and increments
**              the stats of related dns query.
**
******************************************************************/


icf_void_t icf_ssa_stat_dns_type(
                      IN     icf_uint32_t       dns_query_type)
{

    switch(dns_query_type)
    {

        case Sdf_en_SRVrecord:

              ICF_STATS(p_persistent_glb_pdb->p_stats_info->
                misc_stats.stats_SRV_DNS_QUERY)
        break;


        case Sdf_en_IPv4Address:
   
                ICF_STATS(p_persistent_glb_pdb->p_stats_info->
                                misc_stats.stats_AAA_DNS_QUERY)
                break;
    
    }
}

#endif



#ifdef ICF_TRACE_ENABLE

/******************************************************************************
 *
 * FUNCTION:        icf_ssa_create_criteria_data
 *
 * DESCRIPTION:     This function is invoked to populate criteria data
 *
 *****************************************************************************/
icf_return_t icf_ssa_create_criteria_data(
        INOUT icf_ssa_pdb_st *p_ssa_pdb)
{
    icf_return_t ret_val = ICF_SUCCESS; 
    icf_config_data_st *p_config_data =ICF_NULL;
    icf_trace_criteria_data_st *p_trace_data = ICF_NULL;
    icf_uint32_t     status = ICF_STATUS_CONTINUE;

        ret_val = icf_dbm_get_module_glb_data(
                   p_ssa_pdb->p_glb_pdb,
                   (icf_int_module_id_t)ICF_INT_MODULE_CFG,
                   (icf_void_t *)&p_config_data,p_ssa_pdb->p_ecode);

    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
          ICF_PORT_SIZEOF(icf_trace_criteria_data_st),
          ICF_MEM_COMMON,
          p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_trace_criteria_data,
          ICF_RET_ON_FAILURE,
          p_ssa_pdb->p_ecode,
          ret_val)

    p_trace_data = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_trace_criteria_data;

    p_trace_data->p_calling_party_address =
                &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr);
   p_trace_data->bitmask |= ICF_TRACE_CALLING_PARTY_ADDR_PRESENT;

    p_trace_data->p_called_party_address =
                &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address);
    p_trace_data->bitmask |= ICF_TRACE_CALLED_PARTY_ADDR_PRESENT;

        p_trace_data->p_local_sip_ip_address =
                                &(p_config_data->self_ip_address);
    p_trace_data->bitmask |= ICF_TRACE_LOCAL_SIP_IP_PRESENT;
    p_trace_data->bitmask |= ICF_TRACE_LOCAL_SIP_PORT_PRESENT;

    icf_dbm_get_line_for_inc_call(
	p_ssa_pdb->p_glb_pdb,
        (icf_boolean_t)(ICF_FALSE),
        &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address),
        &(p_trace_data->line_id),
        &status,
        p_ssa_pdb->p_ecode);	
    p_trace_data->bitmask |= ICF_TRACE_LINE_ID_PRESENT;

    if(ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->p_ssa_ctxt->transport)
    {
          p_trace_data->call_transport_mode =
                               ICF_CALL_TRANSPORT_MODE_UDP;
    }
    else if(ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_ssa_ctxt->transport)
    {
          p_trace_data->call_transport_mode =
                                 ICF_CALL_TRANSPORT_MODE_TCP;
    }
    else if(ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)
    {
          p_trace_data->call_transport_mode =
                                ICF_CALL_TRANSPORT_MODE_TLS;
    }
    else
    {
          p_trace_data->call_transport_mode =
                                ICF_CALL_TRANSPORT_MODE_UDP;
    }

    p_trace_data->call_direction = ICF_CALL_DIRECTION_INCOMING;
    p_trace_data->bitmask |= ICF_TRACE_CALL_DIR_PRESENT;
    p_trace_data->bitmask |= ICF_TRACE_TRANSPORT_MODE_PRESENT;

    return ret_val;
}

#endif


icf_return_t icf_ssa_append_to_ssa_ctxt_list(icf_ssa_ctxt_list_st *p_source,
        icf_ssa_ctxt_list_st * p_dest)
{
    icf_ssa_ctxt_list_st *p_temp;

    if (p_source == ICF_NULL)
        return ICF_FAILURE;

    for (p_temp = p_source; p_temp->p_next != ICF_NULL;  p_temp = p_temp->p_next);
    p_temp->p_next = p_dest;
    return ICF_SUCCESS;
}


/******************************************************************
** FUNCTION: icf_ssa_cmp_replaces_tags
**
** DESCRIPTION: Compares the to and from tags to identiy a matching 
**              transaction 
**
******************************************************************/
icf_return_t icf_ssa_cmp_replaces_tags(
    icf_ssa_pdb_st *p_ssa_pdb,
    Sdf_st_callObject *pNewCallObject, 
    icf_uint8_t       *p_from_tag,
    icf_uint8_t       *p_to_tag,
    Sdf_st_error *p_sdf_error)
{
    icf_return_t ret_val = ICF_FAILURE;
    SipMessage     *p_temp_msg = Sdf_co_null;
    Sdf_st_commonInfo *pNewCommonInfo = ICF_NULL;
    Sdf_st_callObjectKey *pNewKey = ICF_NULL;
    en_SipMessageType   dMsgType;

    SipHeader *pNewHeaderFrom = Sdf_co_null, 
              *pNewHeaderTo = Sdf_co_null; 

    Sdf_ty_s8bit *pNewTagFrom=Sdf_co_null, 
                 *pNewTagTo=Sdf_co_null; 
    p_ssa_pdb = p_ssa_pdb;


    if (pNewCallObject->pUacTransaction->pSipMsg != Sdf_co_null)
        p_temp_msg = pNewCallObject->pUacTransaction->pSipMsg;
    else
        p_temp_msg = pNewCallObject->pUasTransaction->pSipMsg;


    if(Sdf_co_fail == sdf_ivk_uaGetCommonInfoFromCallObject(pNewCallObject, 
                &pNewCommonInfo,p_sdf_error))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        pNewKey = pNewCommonInfo->pKey;

        pNewHeaderFrom = pNewKey->pLocalAddr;
        pNewHeaderTo = pNewKey->pRemoteAddr;

        if (sip_getTagAtIndexFromFromHdr(pNewHeaderFrom, &pNewTagFrom, 0, \
                    (SipError *)&(p_sdf_error->stkErrCode)) == SipFail)
        {
            ret_val = ICF_FAILURE;
        }
        else if (sip_getTagAtIndexFromFromHdr(pNewHeaderTo, &pNewTagTo, 0, \
                    (SipError *)&(p_sdf_error->stkErrCode)) == SipFail)
        {
            ret_val = ICF_FAILURE;
        }

        sip_getMessageType(p_temp_msg, &dMsgType, 
                (SipError*)&(p_sdf_error->stkErrCode)) ;

        if(((ICF_NULL != pNewTagTo) && (ICF_NULL != p_from_tag)&&
                    (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagTo, (icf_uint8_t *)p_from_tag))) &&
                ((ICF_NULL != p_to_tag) && (ICF_NULL != pNewTagFrom)&&
                 (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagFrom,(icf_uint8_t *) p_to_tag))))
        {
            ret_val = ICF_SUCCESS;
        }
        /*  Fix for CSR 1-7473533: SPR 19823
         *  The code has been removed as if replaces header 
         *  is received in INVITE the IPTK must compare the
         *  To tag with Local tag and From tag with Remote tag
		 */
        /*special handling for early notify*/
    }/* else... */
    if(pNewCommonInfo)
    {
        sdf_ivk_uaFreeCommonInfo(pNewCommonInfo);
    }
    return ret_val;
}



#ifdef ICF_LOOPBACK_SUPPORT
/******************************************************************
** FUNCTION: icf_ssa_util_cmp_tags
**
** DESCRIPTION: Compares the to and from tags to identiy a matching 
**              transaction 
**
******************************************************************/
icf_return_t icf_ssa_util_cmp_tags(
    icf_ssa_pdb_st *p_ssa_pdb,
    Sdf_st_callObject *pNewCallObject, 
    Sdf_st_callObject *pExistingCallObject, 
    Sdf_st_error *p_sdf_error)
{
  icf_return_t ret_val = ICF_FAILURE;
  SipMessage     *p_temp_msg = Sdf_co_null;
    Sdf_ty_s8bit *p_method = ICF_NULL;
  Sdf_st_commonInfo *pNewCommonInfo = ICF_NULL, 
                    *pExistingCommonInfo = ICF_NULL;
  Sdf_st_callObjectKey *pNewKey = ICF_NULL;
  Sdf_st_callObjectKey *pExistingKey = ICF_NULL;
  en_SipMessageType   dMsgType;

  SipHeader *pNewHeaderFrom = Sdf_co_null, 
            *pExistHeaderFrom = Sdf_co_null,
            *pNewHeaderTo = Sdf_co_null, 
            *pExistHeaderTo = Sdf_co_null;

  Sdf_ty_s8bit *pNewTagFrom=Sdf_co_null, 
               *pExistingTagFrom=Sdf_co_null,
               *pNewTagTo=Sdf_co_null, 
               *pExistingTagTo=Sdf_co_null;


  if (pNewCallObject->pUacTransaction->pSipMsg != Sdf_co_null)
    p_temp_msg = pNewCallObject->pUacTransaction->pSipMsg;
  else
    p_temp_msg = pNewCallObject->pUasTransaction->pSipMsg;

  p_ssa_pdb = p_ssa_pdb;

  if(Sdf_co_fail == sdf_ivk_uaGetCommonInfoFromCallObject(pNewCallObject, 
        &pNewCommonInfo,p_sdf_error))
  {
    ret_val = ICF_FAILURE;
  }
  else if(Sdf_co_fail == sdf_ivk_uaGetCommonInfoFromCallObject(
        pExistingCallObject, 
        &pExistingCommonInfo, p_sdf_error))
  {
    ret_val = ICF_FAILURE;
  }
  else
  {
    pNewKey = pNewCommonInfo->pKey;
    pExistingKey = pExistingCommonInfo->pKey;

    pNewHeaderFrom = pNewKey->pLocalAddr;
    pExistHeaderFrom = pExistingKey->pLocalAddr;
    pNewHeaderTo = pNewKey->pRemoteAddr;
    pExistHeaderTo = pExistingKey->pRemoteAddr;
    sip_getMessageType(p_temp_msg, &dMsgType, 
        (SipError*)&(p_sdf_error->stkErrCode)) ;
/* For backward compatibility of older SIP RFC */

    if (sip_getTagAtIndexFromFromHdr(pNewHeaderFrom, &pNewTagFrom, 0, \
          (SipError *)&(p_sdf_error->stkErrCode)) == SipFail)
    {
      ret_val = ICF_FAILURE;
    }
    else if (sip_getTagAtIndexFromFromHdr(pExistHeaderFrom, 
          &pExistingTagFrom, 0, 
          (SipError *)&(p_sdf_error->stkErrCode)) == SipFail)
    {
      ret_val = ICF_FAILURE;
    }
    else if (sip_getTagAtIndexFromFromHdr(pNewHeaderTo, &pNewTagTo, 0, \
          (SipError *)&(p_sdf_error->stkErrCode)) == SipFail)
    {
      ret_val = ICF_FAILURE;
    }
    else if (sip_getTagAtIndexFromFromHdr(pExistHeaderTo, &pExistingTagTo, 0, \
          (SipError *)&(p_sdf_error->stkErrCode)) == SipFail)
    {
      ret_val = ICF_FAILURE;
    }
    else if ((SipMessageRequest == dMsgType) &&
              (((pExistingTagFrom == ICF_NULL) && (pNewTagFrom == ICF_NULL)) ||
               ((pExistingTagTo == ICF_NULL) && (pNewTagTo == ICF_NULL))))
    {
        ret_val = ICF_SUCCESS;
    }
    else if((ICF_NULL != pExistingTagTo) && (ICF_NULL != pNewTagTo))
    {
        if ((ICF_NULL != pExistingTagFrom) && (ICF_NULL != pNewTagFrom))
        {
            if (((ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagTo, (icf_uint8_t *)pExistingTagTo))) &&
                 (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagFrom, (icf_uint8_t *)pExistingTagFrom)))
            {
                ret_val = ICF_SUCCESS;
            }
            else
                ret_val = ICF_FAILURE;
        }
        else if (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagTo, (icf_uint8_t *)pExistingTagTo))
        {
            ret_val = ICF_SUCCESS;
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
    }  
    else if((SipMessageResponse == dMsgType)&&
    ((ICF_NULL != pExistingTagFrom) && (ICF_NULL != pNewTagFrom)&&
      ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagFrom, (icf_uint8_t *)pExistingTagFrom)))
    {
      ret_val = ICF_SUCCESS;
    }
    /*special handling for early notify*/
    else if(Sdf_co_success == 
           sdf_ivk_uaGetMethodFromSipMessage(
           p_temp_msg, &p_method, p_sdf_error))
    {
        if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"NOTIFY"))
        {
            /*SPR17542 Added the NULL check for parameters passed into 
              icf_port_strcmp function */
            if ((ICF_NULL != pExistingTagFrom) && (ICF_NULL != pNewTagFrom))
            {   
               if((ICF_NULL == pExistingTagTo) && (ICF_NULL != pNewTagTo)&&
                 (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagFrom, (icf_uint8_t *)pExistingTagFrom)))
                {
                   ret_val = ICF_SUCCESS;
                }
            }  
        }/* if(ICF_NULL == icf_p... */
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"CANCEL"))
        {
            if((ICF_NULL != pExistingTagTo) && (ICF_NULL != pNewTagTo)&&
              (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagTo,(icf_uint8_t *) pExistingTagTo)))
            {
                ret_val = ICF_SUCCESS;
            }
        }
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"ACK"))
        {
            if(((ICF_NULL == pExistingTagTo) && (ICF_NULL == pNewTagTo))||
            ((ICF_NULL == pExistingTagFrom) && (ICF_NULL == pNewTagFrom)))
            {
                ret_val = ICF_SUCCESS;
            }
        }
    }/* else if(Sdf_co_success == ... */
  }/* else... */
  if(pNewCommonInfo)
  {
    sdf_ivk_uaFreeCommonInfo(pNewCommonInfo);
  }
  if(pExistingCommonInfo)
  {
    sdf_ivk_uaFreeCommonInfo(pExistingCommonInfo);
  }
  return ret_val;
}/*End icf_ssa_util_cmp_tags*/
#endif


icf_return_t icf_ssa_remove_ctxt_list_entry(icf_glb_pdb_st *p_glb_pdb,
                   icf_ssa_ctxt_st *p_ssa_ctxt)
{
    icf_ssa_ctxt_list_st *p_temp_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st *p_ret_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st *p_hold_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st *p_prev_ctxt = ICF_NULL;
    icf_uint8_t           flag = ICF_FALSE;
    icf_ssa_ctxt_st       *p_tmp_ssa_ctxt = ICF_NULL;
    icf_error_t          ecode;
    icf_return_t         ret_val = ICF_FAILURE;

    ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(p_glb_pdb,
            p_ssa_ctxt->p_hash_key,
            (icf_void_t **)&p_ret_ctxt,&ecode);
    if (ICF_FAILURE == ret_val)
    {
        return ICF_FAILURE;
    }
    for (p_temp_ctxt = p_ret_ctxt; p_temp_ctxt != ICF_NULL; p_temp_ctxt = p_temp_ctxt->p_next)
    {
        if (p_temp_ctxt->p_ssa_ctxt == p_ssa_ctxt)
        {
            flag = ICF_TRUE;
            break;
        }
        p_prev_ctxt = p_temp_ctxt;
    }
    if ((ICF_TRUE == flag) && (ICF_NULL != p_temp_ctxt))
    {
        ICF_PRINT(((icf_uint8_t *)"Got the list context to be deleted." 
                    "Searchin whether any linked node is present"));
        p_hold_ctxt = p_temp_ctxt->p_next;

        if (p_temp_ctxt == p_ret_ctxt)
        {
#ifdef ICF_LOAD_DEBUG
    printf("\nSSA CTXT DE-Allocated: %x %s\n", p_ssa_ctxt,p_ssa_ctxt->p_hash_key);
#endif
            icf_dbm_hash_remove_ssa_ctxt(p_glb_pdb,
                    p_ssa_ctxt->p_hash_key,
                    p_tmp_ssa_ctxt,&ecode);
            if (ICF_NULL != p_hold_ctxt)
            {
                ICF_PRINT(((icf_uint8_t *)"There is another entry present so adding this entry"));
                icf_dbm_hash_add_ssa_ctxt(p_glb_pdb,
                        p_ssa_ctxt->p_hash_key,
                        (icf_void_t *)p_hold_ctxt,&ecode);
            }

            else
            {
                ICF_PRINT(((icf_uint8_t *)"Only one context is there so removing it"));
            }

        }
        else
        {
            ICF_PRINT(((icf_uint8_t *)"Removing only link as it is not the first entry"));
            if (ICF_NULL != p_prev_ctxt)
                p_prev_ctxt->p_next = p_hold_ctxt;
        }
        ICF_MEMFREE(
                p_glb_pdb,
                p_temp_ctxt,
                ICF_MEM_COMMON,
                &ecode,
                ret_val);
    }

    return ret_val;

}


/*****************************************************************************
 * FUNCTION:        icf_ssa_is_update_present_in_allow_hdr
 *
 * DESCRIPTION:     This function checks that whether update
 *                  method is present in the ALLOW header of 
 *                  a received SIP message.
 *
 *****************************************************************************/
Sdf_ty_retVal icf_ssa_is_update_present_in_allow_hdr(SipMessage *p_message,
                                                     icf_glb_pdb_st *p_glb_pdb,
                                                     icf_ssa_ctxt_st **p_ssa_ctxt,
                                                     Sdf_st_error *pErr)
{
      
    SipHeader dAllowHeader;
    SIP_S8bit *p_allow_value;
    Sdf_ty_u32bit no_of_allow_headers = 0;
    Sdf_ty_u32bit index =0;

#ifdef ICF_TRACE_ENABLE
        icf_return_t    ret_val = 0;
#endif

    if(ICF_NULL == p_glb_pdb)
    {
       ICF_PRINT(((icf_uint8_t *)"p_glb_pdb is null"));
       return ICF_FAILURE;  
    }

    ICF_FUNCTION_ENTER(p_glb_pdb);


    /* Get the Allow headers count and find for UPDATE method in all headers. if 
     * UPDATE method is present in Allow Header then set the flag allowed_value
     * in call context to ICF_UPDATE_ALLOWED_IN_200OK  */
      
    if(sip_getHeader(p_message,
        SipHdrTypeAllow, &dAllowHeader,(SipError*)&(pErr->stkErrCode)) != SipFail){

        if(sip_getHeaderCount(p_message,SipHdrTypeAllow,
            &no_of_allow_headers,(SipError*)&(pErr->stkErrCode)) != SipFail){
                        sip_freeSipHeader(&dAllowHeader);
            for(index = 0;index < no_of_allow_headers;index++){

                if(sip_getHeaderAtIndex(p_message,
                    SipHdrTypeAllow, &dAllowHeader,
                    index, (SipError*)&(pErr->stkErrCode)) != SipFail){

                    if(sip_getMethodFromAllowHdr(&dAllowHeader,&p_allow_value,
                        (SipError*)&(pErr->stkErrCode)) != Sdf_co_fail){

                        if(strcmp(p_allow_value,"UPDATE") == 0){
         
                            /* Setting value of allowed_value to ICF_UPDATE_PRESENT_IN_ALLOW_HDR  */
                          (*p_ssa_ctxt)->p_call_ctxt->allowed_value = ICF_UPDATE_PRESENT_IN_ALLOW_HDR ; 
         
                        }
                    }
                                        sip_freeSipHeader(&dAllowHeader);
                }
            }
        }
                else
                {
                        sip_freeSipHeader(&dAllowHeader);
                }
    }

    ICF_FUNCTION_EXIT(p_glb_pdb);
    return Sdf_co_success ;
}


/*****************************************************************************
 * FUNCTION:       icf_ssa_validate_challenge 
 *
 * DESCRIPTION:    This function first checks the nonce value.It returns failure
 * if the new nonce value received is similar to the previous nonce value.
 * 
 * It then checks the ICF_IGNORE_STALE_PARAM_IN_CHALLENGE, if it is set it ignores 
 * the stale parameter.
 *
 * If the bit is not set,it checks if the stale parameter is true in
 * the authentication header, if yes then it returns success else it returns
 * failure.
 *  
 *
 *****************************************************************************/



icf_return_t
icf_ssa_validate_challenge( Sdf_st_callObject               **ppCallObj,
    Sdf_st_overlapTransInfo         *pOverlapTransInfo,
    Sdf_ty_u16bit	             resp_code,
    icf_ssa_pdb_st                   *p_ssa_pdb,
    Sdf_st_error                    *pErr,
    icf_uint8_t                     *p_method)
{
  Sdf_ty_slist                          *p_auth_params_list = ICF_NULL;
  icf_return_t                           ret_val = ICF_FAILURE;
  icf_return_t                           dummy_ret_val = ICF_SUCCESS;
  icf_uint32_t                           loop_list = 0 ;
  en_HeaderType                          header_type=0;
  icf_uint32_t                           list_size = 0;
  Sdf_ty_pvoid                           p_list_member  = ICF_NULL;
  icf_boolean_t                          list_to_be_deleted = ICF_TRUE;
  icf_uint8_t                            *p_temp_unq_string = ICF_NULL,
                                         *p_temp_string = ICF_NULL;
  icf_uint32_t                           temp_len = 0;
    
  if((ICF_NULL == ppCallObj) ||
    ((0 != icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"INVITE")) &&
     (0 != icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"BYE")) &&
     (ICF_NULL == pOverlapTransInfo)))
  {
    return ICF_FAILURE;
  }

  /*If the old nonce value in p_ssa_ctxt is NULL that means this is the first time
    this request is being challenged. So process it w/o checking nonce/stale values*/

  if(ICF_NULL == p_ssa_pdb->p_ssa_ctxt->p_old_nonce)
  {
    return ICF_SUCCESS;
  }

  if(resp_code == 401)
  {
    header_type =  SipHdrTypeWwwAuthenticate;
  }
  else
  {
    header_type = SipHdrTypeProxyAuthenticate;
  }

  ICF_MEMGET(
      p_ssa_pdb->p_glb_pdb,
      ICF_PORT_SIZEOF(Sdf_ty_slist),
      ICF_MEM_COMMON,
      p_auth_params_list,
      ICF_RET_ON_FAILURE,
      p_ssa_pdb->p_ecode,
      dummy_ret_val) 
  if(ICF_FAILURE == dummy_ret_val)
  {
      return ICF_FAILURE;
  }

  if (Sdf_co_fail == sdf_listInit(
        p_auth_params_list,
        __sdf_fn_uaFreeAuthenticationParams,
        Sdf_co_false,
        pErr))
  {
    list_to_be_deleted = ICF_FALSE;
  }

  else if (Sdf_co_fail == sdf_ivk_uaGetAuthParams(
        *ppCallObj,
        pOverlapTransInfo,
        p_auth_params_list,
        pErr))
  {
    list_to_be_deleted = ICF_FALSE;
  }

  else 
  {
    sdf_listSizeOf(p_auth_params_list, &list_size, pErr);

    for (loop_list = 0; loop_list < list_size; loop_list++ )
    {
      /* for loop: begin processing */
      if (Sdf_co_fail == sdf_listGetAt (p_auth_params_list,
            loop_list,
            &p_list_member, 
            pErr))
      {
        continue;
      }
      else
      {
        /* else: auth_params member read safely: processing begins */

        if(((Sdf_st_authenticationParams*)(p_list_member))->dHdrType == header_type)
        {
          /* We have found the header type we were looking for:
           * Now copy the challenge and run out of the loop */
      
          /* Compare the new and old nonce values, if same return FAILURE */

          if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pNonce) 
          {
              p_temp_string =  
                       (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pNonce;
                    
              temp_len = icf_port_strlen(p_temp_string);
              ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                  temp_len+1,
                  ICF_MEM_COMMON, p_temp_unq_string,
                  ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, dummy_ret_val)
              /* unqouting the nonce string */
              sdf_fn_uaUnq((icf_int8_t *)p_temp_string,(icf_int8_t *) p_temp_unq_string);

              /* Comparing the old and new nonce values */
              
              if(0 == icf_port_strcmp(p_temp_unq_string,
                       p_ssa_pdb->p_ssa_ctxt->p_old_nonce))
              {
                      ret_val = ICF_FAILURE;
              }
             
              /* different nonce value received,proceed to check the bit */
              else if((ICF_IGNORE_STALE_PARAM_IN_CHALLENGE !=
                       (ICF_IGNORE_STALE_PARAM_IN_CHALLENGE & 
                       p_ssa_pdb->p_glb_cfg_data->default_settings)))
              {
                  /* stale parameter not to be ignored.*/
                  if(ICF_NULL != 
                      ((Sdf_st_authenticationParams *)(p_list_member))->pStale) 
                  {
                      if(icf_port_strcmpi((icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pStale,
                             (icf_uint8_t *)"true")==0)
                      {
                          ret_val = ICF_SUCCESS;
                      }
                  }
              }
              else
              {
                  /* nonce is different,stale parameter to be ignored */
                  ret_val = ICF_SUCCESS;
              }
          }
        }/* if(((Sdf_st_authenticationParams* ....*/
      }/*else for if(Sdf_co_fail == sdf_listGetAt (p_auth_params_list ... */ 
    }
  }
  if(list_to_be_deleted == ICF_TRUE)
  {
    sdf_listDeleteAll(
        p_auth_params_list,
        pErr);
  }
  ICF_MEMFREE(
      p_ssa_pdb->p_glb_pdb,
      p_auth_params_list,
      ICF_MEM_COMMON,
      p_ssa_pdb->p_ecode,
      dummy_ret_val)

  ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
      p_temp_unq_string, 
      ICF_MEM_COMMON, p_ssa_pdb->p_ecode, dummy_ret_val)
 
  return ret_val;
}

/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_extract_nonce_from_challenge
 *
 * DESCRIPTION: The function extracts the nonce value from the challenge
 *              from the auth_params_list and stores this extracted nonce
 *              in the ssa_ctxt to be further used by the function
 *              icf_ssa_validate_challenge for nonce comparision.
 *              
 * RETURNS: icf_return_t 
 *
************************************************************************/  
icf_return_t icf_ssa_extract_nonce_from_challenge(
    icf_ssa_pdb_st                    *p_ssa_pdb,
    Sdf_ty_u16bit                     resp_code)
{
    icf_uint32_t        list_size = ICF_NULL;
    Sdf_st_error        err;
    icf_uint32_t        loop_list = ICF_NULL;
    Sdf_ty_pvoid        p_list_member;
    icf_uint8_t         *p_temp_string = ICF_NULL;        
    icf_return_t        ret_val = ICF_FAILURE, dummy_ret_val = ICF_SUCCESS;
    icf_uint8_t         *p_temp_unq_string = ICF_NULL; /* unquoted string */
    icf_uint32_t        temp_len = 0;
    Sdf_ty_slist        *p_auth_params_list = ICF_NULL;
    en_HeaderType       header_type = 0;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
   
    if(resp_code == 401)
    { 
        header_type =  SipHdrTypeWwwAuthenticate;
    }
    else
    {  
        header_type = SipHdrTypeProxyAuthenticate;
    }
 
    p_auth_params_list = p_ssa_pdb->p_ssa_ctxt->p_auth_params_list;

    if(ICF_NULL == p_auth_params_list)
    {
       return ICF_FAILURE;
    }

    sdf_listSizeOf(p_auth_params_list, &list_size,
                                &err);

    for (loop_list = 0; loop_list < list_size; loop_list++ )
    {
        /* for loop: begin processing */
        if (Sdf_co_fail == sdf_listGetAt (p_auth_params_list,
            loop_list,
            &p_list_member, 
            &err))
        {
            continue;
        }
        else
        {
            /* else: auth_params member read safely: processing begins */
            
            if(header_type == ((Sdf_st_authenticationParams *)(p_list_member))->
                dHdrType)
            {
                /* We have found the header type we were looking for */
                               
                if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pNonce) 
                {
                    /* Non null Nonce begins*/
                
                    /* Clear the contents of old nonce in ssa context */

                    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_old_nonce)
                    {
					    /*Fix done for SPR-18722 : CSR-1-6068965*/
                        /* memfree the nonce string */
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                       p_ssa_pdb->p_ssa_ctxt->p_old_nonce,
                                       ICF_MEM_COMMON,
                                       p_ssa_pdb->p_ecode,
                                       dummy_ret_val)
                        p_ssa_pdb->p_ssa_ctxt->p_old_nonce = ICF_NULL;
                    }

                    /* Start processing the new set of challenge */

                    p_temp_string =  
                        (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pNonce;
                    
                    temp_len = icf_port_strlen(p_temp_string);
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        temp_len+1,
                        ICF_MEM_COMMON,
                        (p_temp_unq_string),
                        ICF_RET_ON_FAILURE,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                                        
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        temp_len+1,
                        ICF_MEM_COMMON,
                        (p_ssa_pdb->p_ssa_ctxt->p_old_nonce),
                        ICF_RET_ON_FAILURE,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                                    
                    sdf_fn_uaUnq((icf_int8_t *)p_temp_string,(icf_int8_t *) p_temp_unq_string);

                    icf_port_strcpy(p_ssa_pdb->p_ssa_ctxt->p_old_nonce,
                                    p_temp_unq_string);

                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_temp_unq_string, 
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        dummy_ret_val)
    
                    ret_val = ICF_SUCCESS;
                    break;
                }
                else 
                {
                    /* NULL nonce received */
                    ret_val = ICF_FAILURE;
                    break;
                }
            }
            else
            {  
                /* hdr type not matched yet: continue */
                continue;
            }
        }/* else: auth_params member read safely: processing ends */
    }/* for loop ends*/
    return ret_val;
}/* Function icf_ssa_extract_nonce_from_challenge() ends here */


/***********************************************************************************
* FUNCTION    :  icf_ssa_validate_join_header_and_get_call_id
*  
* IN          :  icf_ssa_pdb  *p_ssa_pdb
* 	         icf_uint8_t  *join_call_id
*                icf_uint8_t  orig_call_id
* 
* OUTPUT      :  ICF_SUCCESS/ICF_FAILURE
*
* DESCRIPTION :  This function validates whether or not join header can be applied 
*                or not on this call.If any error is found, error is returned else, 
*                internal call id to be joined is returned
************************************************************************************/
icf_return_t  icf_ssa_validate_join_header_and_get_call_id(
                    icf_ssa_pdb_st  *p_ssa_pdb,  icf_call_id_t  *join_call_id,
                    icf_call_id_t orig_call_id )
{

    icf_return_t             ret_val = ICF_SUCCESS;
    Sdf_ty_slist             slMatchedHeadersList, slMatchedHeadersList1;
    Sdf_ty_u32bit            size = 0;
    Sdf_ty_u32bit            size1 = 0;
    SipError                 err = E_NO_ERROR;
    Sdf_ty_s8bit             *p_replaces_call_id = Sdf_co_null;
    Sdf_ty_s8bit             *p_from_tag = Sdf_co_null;
    Sdf_ty_s8bit             *p_to_tag = Sdf_co_null;

    icf_error_t              *p_ecode = p_ssa_pdb->p_ecode;
    icf_ssa_ctxt_st          *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    icf_ssa_ctxt_list_st     *p_ssa_list = ICF_NULL;
    icf_ssa_ctxt_list_st     *p_ssa_temp = ICF_NULL;
    icf_ssa_ctxt_st          *p_mapped_ssa_ctxt = ICF_NULL;
    Sdf_st_callObject        *p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    Sdf_st_error             sdf_err ;
    Sdf_st_error             *p_err = &sdf_err ;
    icf_uint16_t             count=0; 

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    *join_call_id = ICF_INVALID_CALL_ID;
        /* Extract Join header */
        if(Sdf_co_fail == sdf_ivk_uaGetHeaderListByType(p_call_obj->
                    pUasTransaction->slUnprocessedHeaders,SipHdrTypeJoin,
                    &slMatchedHeadersList,&sdf_err))
        {
            /*Remove all elements from the list and free the node data of each node*/
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            return ICF_SUCCESS;
        }/*if(Sdf_co_fail == sdf_ivk_uaGetHeader... */


    /* If replace header too is found, return error as both join and replaces should not be supported */
        else if(Sdf_co_fail == sdf_ivk_uaGetHeaderListByType(p_call_obj->
                    pUasTransaction->slUnprocessedHeaders, SipHdrTypeReplaces,
                    &slMatchedHeadersList1,p_err))
        {
            /*Remove all elements from the list and free the node data of each node*/
            sdf_listDeleteAll(&slMatchedHeadersList1,p_err);                 
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_400;
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        }/*if(Sdf_co_fail != sdf_ivk_uaGetHeader... */

    /* Extract the size of the matched header list */
        else if(Sdf_co_fail == sdf_listSizeOf (&slMatchedHeadersList,
                    &size, p_err))
        {
            /*Remove all elements from the list and free the node data of each node*/
            ICF_PRINT(((icf_uint8_t *)"No Join header found\n"))
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_400;
            ret_val = ICF_FAILURE;
        }/*if(Sdf_co_fail == sdf_listSizeOf... */
        else if(Sdf_co_fail == sdf_listSizeOf (&slMatchedHeadersList1,
                    &size1, p_err))
        {
            /*Remove all elements from the list and free the node data of each node*/
            ICF_PRINT(((icf_uint8_t *)"Join header found\n"))
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_400;
            ret_val = ICF_FAILURE;
        }/*if(Sdf_co_fail == sdf_listSizeOf... */
        else if (size1 >0)
        {
            /*Remove all elements from the list and free the node data of each node*/
            ICF_PRINT(((icf_uint8_t *)"Join header found\n"))
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_400;
            ret_val = ICF_FAILURE;
        }/*if(Sdf_co_fail == sdf_listSizeOf... */

    /* Join header present */
        else if(size > 0)
        {
            SipHeader *p_replaces_hdr;
            Sdf_st_headerList *p_replaces_hdr_list = Sdf_co_null;

            /* Get HeaderList at index 0*/
            /* If more than one join header is present. Treat it as normal
             * call */
            if (size > 1)
            {
                /*Remove all elements from the list and free the node data of each node*/
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                *join_call_id = ICF_INVALID_CALL_ID;
                ret_val = ICF_SUCCESS;
            }/*if(Sdf_co_fail != sdf_listGetAt....*/ 
            else if( Sdf_co_fail == sdf_listGetAt(
                        &slMatchedHeadersList,0
                        ,(Sdf_ty_pvoid)&p_replaces_hdr_list,p_err))
            {
                /*Join header has a call ID  which matches with more than one dialog
                  Set the failure bitmask which will send 481 on the network */

                p_ssa_ctxt->failure_bitmask |= 
                    ICF_SSA_FAILURE_RESP_CODE_400;
                ret_val = ICF_FAILURE;
                ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                    return ret_val;
            }/*if( Sdf_co_fail == sdf_listGetAt... */

            /* Extarct the first Join header */
            else if(Sdf_co_fail == sdf_listGetAt(
                        &(p_replaces_hdr_list)->slHeaders,0,
                        (Sdf_ty_pvoid *)&p_replaces_hdr,
                        p_err))
            {
                /*Remove all elements from the list and free the node data of each node*/
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                p_ssa_ctxt->failure_bitmask |= 
                    ICF_SSA_FAILURE_RESP_CODE_400;
                ret_val = ICF_FAILURE;
            }/*if(Sdf_co_fail == sdf_listGetAt... */


            /* Extract the Replaces Call ID from the Join header */
            else if(SipFail == sip_getCallidFromJoinHdr(
                        p_replaces_hdr,
                        &p_replaces_call_id,
                        &err))
            {
                /*Remove all elements from the list and free the node data of each node*/
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                *join_call_id = ICF_INVALID_CALL_ID;
                ret_val = ICF_SUCCESS;
            }/*else if(SipFail == sip_getCallidFromJoinHdr....*/
            else if(SipFail == sip_getFromTagFromReplacesHdr(
                        p_replaces_hdr,
                        &p_from_tag,
                        &err))
            {
                /*Remove all elements from the list and free the node data of each node*/
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                *join_call_id = ICF_INVALID_CALL_ID;
                ret_val = ICF_SUCCESS;
            }/*else if(SipFail == sip_getFromTagFromReplacesHdr...*/
            else if(SipFail == sip_getToTagFromReplacesHdr(
                        p_replaces_hdr,
                        &p_to_tag,
                        &err))
            {
                /*Remove all elements from the list and free the node data of each node*/
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                *join_call_id = ICF_INVALID_CALL_ID;
                ret_val = ICF_SUCCESS;
            }/*else if(SipFail == sip_getToTagFromReplacesHdr...*/
            else 
            {
                /*Remove all elements from the list and free the node data of each node*/
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);

                /*Search for a matching SSA context corresponding to the Replaces call ID
                  in the global map between the SSA contexts and network call ID's     */ 

                ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(
                        p_ssa_pdb->p_glb_pdb,(icf_uint8_t *)p_replaces_call_id,
                        (icf_void_t **)&p_ssa_list,p_ecode);
                /*Now checking whether more than one dialog matches or not */
                if(ICF_SUCCESS == ret_val)
                {
#ifdef ICF_LOOPBACK_SUPPORT
                    count = 0;
                    for(p_ssa_temp = p_ssa_list;p_ssa_temp != ICF_NULL; p_ssa_temp = p_ssa_temp->p_next)
                    {
                        if(ICF_SUCCESS == icf_ssa_cmp_replaces_tags(p_ssa_pdb, 
                                    p_ssa_temp->p_ssa_ctxt->p_call_obj, 
                                    (icf_uint8_t *)p_from_tag,(icf_uint8_t *)p_to_tag,p_err))
                        {
                            p_mapped_ssa_ctxt = p_ssa_temp->p_ssa_ctxt;
                            ret_val =  ICF_SUCCESS;
                        }/*if(ICF_SUCCESS == icf_ssa_cmp_replaces_tags....*/
                        count ++;
                    }
                    if(0 == count)
                    {
                        ret_val = ICF_FAILURE;
                    }/*if(ICF_NULL == p_ssa_temp)*/
#else
                    p_mapped_ssa_ctxt = p_ssa_list->p_ssa_ctxt;
                    ret_val =  ICF_SUCCESS;
                    count = 1;
#endif
                }/*if(ICF_SUCCESS == ret_val)*/
                if(ICF_FAILURE == ret_val)
                {
                    /*Treat it as normal call */
                    ICF_PRINT(((icf_uint8_t *)"No matching cotext found\n"))
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_from_tag),p_err);
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_to_tag),p_err);
                    return ICF_SUCCESS;
                }/*if(ICF_FAILURE == ret_val)*/
                else if (ICF_NULL == p_mapped_ssa_ctxt)
                {
                    ICF_PRINT(((icf_uint8_t *)"No matching cotext found\n"))
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_from_tag),p_err);
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_to_tag),p_err);
                    return ICF_SUCCESS;
                }/*if(ICF_FAILURE == ret_val)*/
                else if(count > 1)
                {  
                    /*Join header has a call ID  which matches with more than one dialog
                      Set the failure bitmask which will send 481 on the network      */
#if 0                
                    p_ssa_ctxt->failure_bitmask |= 
                        ICF_SSA_FAILURE_RESP_CODE_481;
                    ret_val = ICF_FAILURE;
#endif
                    ICF_PRINT(((icf_uint8_t *)"More than one contexts found. Treating it as normal call\n"))
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                        return ICF_SUCCESS;
                }/*else if(count > 1)*/
                else if(p_mapped_ssa_ctxt->p_call_ctxt == ICF_NULL)
                {
                    /*Join header has a call ID  which matches with more than one dialog
                      Set the failure bitmask which will send 481 on the network      */
                    p_ssa_ctxt->failure_bitmask |= 
                        ICF_SSA_FAILURE_RESP_CODE_481;
                    ICF_PRINT(((icf_uint8_t *)"This call is not of INVITE. Nothing to be done\n"))
                    ret_val = ICF_FAILURE;
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                    return ret_val;
                }/*else if(p_mapped_ssa_ctxt->p_call_ctxt....*/
                else if(p_mapped_ssa_ctxt->p_call_ctxt-> release_type != ICF_REL_CAUSE_INVALID)
                {
                    /*Join header has a call ID which is in terminated state
                      Set the failure bitmask which will send 603 on the network      */
                    ICF_PRINT(((icf_uint8_t *)"Call is getting released. Failure\n"))

                    p_ssa_ctxt->failure_bitmask |=
                        ICF_SSA_FAILURE_RESP_CODE_603;
                    ret_val = ICF_FAILURE;
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                        return ret_val;
                }/*else if(p_mapped_ssa_ctxt->p_call_ctxt->.......*/
                else
                {
                    ICF_PRINT(((icf_uint8_t *)"Passed all the cases.\n"))
                    ret_val = ICF_SUCCESS;
                    *join_call_id = p_mapped_ssa_ctxt->p_call_ctxt->call_id;
                    p_mapped_ssa_ctxt->p_call_ctxt->call_to_be_joined = orig_call_id; 

                }/*else */
            }/*if(ICF_FAILURE != ret_val)*/
        }/* else if(size > 0) */
        else
        {
            ret_val = ICF_SUCCESS;
        }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}


/**************************************************************************
FUNCTION   icf_ssa_get_conn_db
Input:  int fd , icf_ssa_tcpm_conn_data_st *
Output: pointer to the table entry if found else NULL

Description:  This is a utility function for searching a connection table entry on key as connection fd
****************************************************************************/


icf_ssa_tcpm_conn_data_st * icf_ssa_get_conn_db (icf_uint32_t fd ,
                                     icf_ssa_tcpm_conn_data_st * p_table)
/* Shall return pointer to connection db */
{
    icf_uint16_t i;
    icf_ssa_tcpm_conn_data_st  *p_ret = ICF_NULL;
    if (ICF_INVALID_SOCKFD == (icf_int16_t)fd)
        return ICF_NULL;
    for (i = 0; i < ICF_MAX_NO_OF_PERSISTENT_CONNECTIONS; i++)
    {
        if (p_table[i].conn_fd == (icf_int16_t)fd)
                p_ret =  &p_table[i];
    }
    return p_ret;
}

/**************************************************************************
FUNCTION   icf_ssa_get_conn_db_by_ip
Input:  icf_ssa_pdb_st * , icf_ssa_tcpm_conn_data_st *
Output: pointer to the table entry if found else NULL

Description:  This is a utility function for searching a connection table entry on key as destinatioin IP, port and protocol
****************************************************************************/

icf_ssa_tcpm_conn_data_st * icf_ssa_get_conn_db_by_ip (icf_ssa_pdb_st * p_ssa_pdb,
                              icf_ssa_tcpm_conn_data_st * p_table)
{
		/* Returns table entry by matching IP, port and protocol*/
		icf_uint16_t i;
		icf_ssa_tcpm_conn_data_st  *p_ret = ICF_NULL;
		ICF_PRINT(((icf_uint8_t *)"Entering function icf_ssa_get_conn_db_by_ip"));
		for (i = 0; i < ICF_MAX_NO_OF_PERSISTENT_CONNECTIONS; i++)
		{
				if ((strcmp((const icf_int8_t *)p_table[i].peer_ip, p_ssa_pdb->dest_ip) == 0) &&
								(p_table[i].peer_port_num == p_ssa_pdb->dest_port) && 
								(p_table[i].prot_conn_bitmask & p_ssa_pdb->protocol))
				{
						if (p_ssa_pdb->conn_type == ICF_CONN_TYPE_BOTH)
						{
								p_ret =  &p_table[i];
								break;
						}
						else if (p_table[i].prot_conn_bitmask & p_ssa_pdb->conn_type)
						{
								p_ret =  &p_table[i];
								break;
						}
				}
		}
        /*Initialize the bitmask here*/
		if(ICF_NULL != p_ret)
		{
				p_ret->bitmap = ICF_NULL;
		}
		ICF_PRINT(((icf_uint8_t *)"Returning pointer %lu", p_ret));
		return p_ret;
}

/**************************************************************************
FUNCTION   icf_ssa_add_conn_entry
Input:  int fd , icf_ssa_tcpm_conn_data_st *
Output: pointer to the table entry if found else NULL

Description:  This is a utility function for adding a connection table entry on connection fd
****************************************************************************/
icf_ssa_tcpm_conn_data_st *  icf_ssa_add_conn_entry (
        icf_ssa_tcpm_conn_data_st *p_table )/* Shall add entry to connection db table */
{
    icf_uint16_t i;
    icf_ssa_tcpm_conn_data_st  *p_ret = ICF_NULL;

    for (i = 0; i < ICF_MAX_NO_OF_PERSISTENT_CONNECTIONS; i++)
    {
        if (p_table[i].conn_fd == ICF_INVALID_SOCKFD)
        {
            icf_ssa_init_conn_db (&p_table[i]);
            p_ret = &p_table[i];
            break;
        }
    }
    return p_ret;
}
/**************************************************************************
FUNCTION   icf_ssa_remove_conn_entry
Input:  int fd , icf_ssa_tcpm_conn_data_st *
Output: pointer to the table entry if found else NULL

Description:  This is a utility function for adding a connection table entry on connection fd
****************************************************************************/
icf_return_t  icf_ssa_remove_conn_entry ( icf_ssa_pdb_st  *p_ssa_pdb,
        icf_uint32_t fd)/* Shall add entry to connection db table */
{
    icf_uint16_t i;
    icf_return_t ret_val = ICF_FAILURE;
    icf_ssa_tcpm_conn_data_st *p_table =ICF_NULL; 
    p_table = p_ssa_pdb->p_ssa_glb_data->p_ssa_tcpm_conn_db;
    if (ICF_INVALID_SOCKFD == (icf_int16_t)fd)
        return ret_val;
    for (i = 0; i < ICF_MAX_NO_OF_PERSISTENT_CONNECTIONS; i++)
    {
        if (p_table[i].conn_fd == (icf_int16_t)fd)
        {
#ifdef ICF_SECURE_SUPPORT
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_table[i].p_peer_name,
                    ICF_MEM_COMMON, 
                    p_ssa_pdb->p_ecode, ret_val)
#endif
           icf_ssa_init_conn_db(&p_table[i]);
            ret_val = ICF_SUCCESS;
            break;
        }
    }
    ICF_SSA_PRINT_ALL_CONNECTION(p_ssa_pdb)
    return ret_val;
}


/**************************************************************************
FUNCTION   icf_ssa_get_msg_type
Input:  Sdf_st_callObject  *
Output: Message type (SipMessageRequest or SipMessageResponse)

Description:  This is a utility function for getting message type from sip message
****************************************************************************/

en_SipMessageType icf_ssa_get_msg_type(icf_ssa_pdb_st *p_ssa_pdb,Sdf_st_callObject  *p_call_obj)
{
    /* Returns msg type of the incoming message */
    en_SipMessageType   dMsgType;
    SipMessage              *p_temp_msg = Sdf_co_null;
    icf_uint8_t      method[ICF_MAX_SIZE_INT_USAGE_STR];
    Sdf_st_error            sdf_error;
    Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;
    if (p_call_obj->pUacTransaction->pSipMsg != Sdf_co_null)
        p_temp_msg = p_call_obj->pUacTransaction->pSipMsg;
    else if (p_call_obj->pUasTransaction->pSipMsg != Sdf_co_null)
        p_temp_msg = p_call_obj->pUasTransaction->pSipMsg;
    else
    {
        icf_ssa_get_method_name(p_ssa_pdb->p_ssa_ctxt->bitmask,
                method);
        if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_pending_txn)
        {
            p_overlap_trans_info = (Sdf_st_overlapTransInfo*)
                (p_ssa_pdb->p_ssa_ctxt->p_pending_txn);
        }
        else
        {
            p_overlap_trans_info =
           (Sdf_st_overlapTransInfo*)p_ssa_pdb->p_ssa_ctxt->p_call_obj->slOverlapTransInfo.head->pData;
        }
        p_temp_msg = p_overlap_trans_info->pSipMsg;
    }


    sip_getMessageType(p_temp_msg, &dMsgType, \
            (SipError*)    &(sdf_error.stkErrCode)) ;
    return dMsgType;
}

/**************************************************************************
FUNCTION   icf_ssa_fill_conn_info_from_Via


Description:  This function is used get connection information from VIA header sent by field 
 ****************************************************************************/
 icf_return_t  icf_ssa_fill_conn_info_from_Via(icf_ssa_pdb_st *p_ssa_pdb,
         icf_ssa_tcpm_conn_data_st *p_conn)
{
    /* Function is used to fill port and host address from Via headers sent by field */
    SipHeader dTempHeader;
    icf_return_t ret_val = ICF_SUCCESS;
    Sdf_ty_s8bit *pRemoteIp = Sdf_co_null, *pSentBy = Sdf_co_null;
    Sdf_ty_s8bit *pHostAddress = Sdf_co_null, *pHostPort = Sdf_co_null;
    Sdf_ty_u16bit dPort;
    Sdf_ty_s8bit dTempSentby[Sdf_co_mediumBufferSize]={'\0'};
    Sdf_st_callObject  *p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    Sdf_st_error            err;
    SipMessage      *p_temp_msg = ICF_NULL;
#ifdef ICF_SECURE_SUPPORT
    icf_return_t   dummy_ret_val = ICF_SUCCESS;
#endif
                            

    ICF_PRINT(((icf_uint8_t *)"Entering function icf_ssa_fill_conn_info_from_Via"));
    /* 
     * If the topmost Via header of the incoming request has the IP/port 
     * set in this profile, the message should be discarded. Else, this 
     * user agent would end up sending a response to itself.
     */
    if (p_call_obj->pUacTransaction->pSipMsg != Sdf_co_null)
        p_temp_msg = p_call_obj->pUacTransaction->pSipMsg;
    else if (p_call_obj->pUasTransaction->pSipMsg != Sdf_co_null)
        p_temp_msg = p_call_obj->pUasTransaction->pSipMsg;
    else
    {
        ICF_PRINT(((icf_uint8_t *)"Neither sip message is in Uac nor in Uas transaction\n"))
        return ICF_FAILURE;
    }

    if (SipFail == sip_getHeaderAtIndex(
                p_temp_msg, SipHdrTypeVia,
                &dTempHeader, 0, (SipError*)&(err.stkErrCode)))
    {
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }
    else
    {
        ret_val = ICF_SUCCESS;
    }    

    if (ICF_SUCCESS == ret_val)
    {
        if (SipFail == sip_getSentByFromViaHdr(
                    &dTempHeader, &pSentBy, (SipError*)&(err.stkErrCode)))
        {        
            sip_freeSipHeader(&dTempHeader);
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return ret_val; /*SPR fix 17569*/ 
        }
        else
        {
            ret_val = ICF_SUCCESS;
        }
    }    

    Sdf_mc_strcpy(dTempSentby, pSentBy);

    pHostAddress = Sdf_mc_strtokr(dTempSentby, ":",&pHostPort);

    if (Sdf_co_null == pHostAddress)
    {
         sip_freeSipHeader(&dTempHeader);
         ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
         return ICF_FAILURE;       
    }
    /* resolve the hostname into ip addr */
    if (ICF_SUCCESS == ret_val)
    {
        if (Sdf_co_fail == 
                (sdf_fn_uaGetHostIp(pHostAddress, &pRemoteIp, &err)))
        {
            sip_freeSipHeader(&dTempHeader);
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        }
        else
        {
            ret_val = ICF_SUCCESS;
        }
    }
    /* resolve the local hostname into ip addr */
#if 0
    if (ICF_SUCCESS == ret_val)
    {
        if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
        {
            if (Sdf_co_fail == (sdf_fn_uaGetHostIp(
                            p_ssa_pdb->p_glb_cfg_data->self_ip_address.
                            addr.addr.domain.str, 
                            &p_local_ip, 
                            &err)))
            {
                ICF_PRINT(("Error in getting Host IP"));
                sip_freeSipHeader(&dTempHeader);
                ret_val = ICF_FAILURE;
                ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
            }
            else
            {
                ret_val = ICF_SUCCESS;
            }
            icf_port_strcpy(pLocal, p_local_ip);
            sdf_memfree(Sdf_mc_callHandlerMemId, 
                    (Sdf_ty_pvoid*)&(p_local_ip),&err);
        }
        else 
        {
            icf_ssa_convert_to_IP_addr(
                    &(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                    pLocal);
        }
    }
    /* Setting the default port incase port is not found in request */
#endif
    if (pHostPort != NULL)
        dPort = (icf_uint16_t)icf_port_atoi(pHostPort);
    else
        dPort = 5060;
    /* 
     * If the IP/port in the topmost Via header matches with that in the 
     * user profile's transport information, the message should be 
     * discarded 
     */

    /* Free the local reference */
    if (ICF_SUCCESS == ret_val)
    {
        p_conn->peer_port_num = dPort;
#ifdef ICF_SECURE_SUPPORT
        if (ICF_NULL == p_conn->p_peer_name)
    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            (icf_port_strlen(pHostAddress) + 1),
            ICF_MEM_COMMON,
            p_conn->p_peer_name,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            dummy_ret_val)
        icf_port_strcpy((icf_uint8_t *)p_conn->p_peer_name,
               (icf_uint8_t*) pHostAddress);
#endif
        icf_port_strcpy(p_conn->peer_ip, (icf_uint8_t *)pRemoteIp);
        ICF_PRINT(((icf_uint8_t *)"IP is %s", p_conn->peer_ip));
        ICF_PRINT(((icf_uint8_t *)"Port is %d", p_conn->peer_port_num));
#ifdef ICF_SECURE_SUPPORT
        if (ICF_NULL != p_conn->p_peer_name)
        ICF_PRINT(("Destination name is %s", p_conn->p_peer_name));
#endif
    }
    sip_freeSipHeader(&dTempHeader);
    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(pRemoteIp),&err);
    return ret_val;
}

/*********************************************************************************
 * FUNCTION   icf_ssa_check_isfocus_in_contact_header
 *
 * Description: It checks whether isfocus is present in contact or not.
 *              The function returns ICF_FAILURE if isfocus is absent 
 *              else it returns ICF_SUCCESS.  
 *
 * *****************************************************************************/

icf_return_t  icf_ssa_check_isfocus_in_contact_header(
        icf_ssa_pdb_st    *p_ssa_pdb)
{
    en_HeaderType                 dType = SipHdrTypeAny;
    icf_return_t                  ret_val = ICF_FAILURE;
    icf_uint8_t                   index = 0;
    icf_uint32_t                  dCount = 0;
    SipMessage                    *pSipMsg = ICF_NULL;
    SipError                      sip_err = 0 ;
    Sdf_st_error                  sip_err_1 = {0,0,0,{0}} ;
    icf_uint8_t                   *p_temp_buff = ICF_NULL;
    icf_uint8_t                   *p_colon_ind = ICF_NULL;
    icf_uint8_t                   is_focus[10] = "isfocus";
    icf_address_st                *p_addr = ICF_NULL;
    Sdf_st_overlapTransInfo       *p_ovtxn = Sdf_co_null;

    if (p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUasTransaction->pSipMsg != 
            Sdf_co_null)
    {
        /* This is for RE-INVITE */
        pSipMsg = p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUasTransaction->pSipMsg;
    }
    else if(ICF_SUCCESS == icf_ssa_fetch_matching_overlap_txn(
                p_ssa_pdb,Sdf_en_update,Sdf_en_transactionReceived,
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,&p_ovtxn))
    {
        /* this leg is for UPDATE method */
        if(p_ovtxn->pSipMsg != Sdf_co_null)
        {   
           pSipMsg = p_ovtxn->pSipMsg;
        }   
    }
    else
    {
        /* This is for 200OK */
        pSipMsg = p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg;
    }

    icf_ssa_get_hdr_type_from_name((icf_uint8_t *)"contact", 
                                   &dType, 
                                   &sip_err);


    /* There can be multiple hdrs for that type */
    if (sip_getHeaderCount(pSipMsg, dType, &dCount, \
                &sip_err) == SipFail)
    {
        return ICF_FAILURE;
    }
    /* Iterate through the list to get all headers of type dType*/
    /* Construct Header from SipMessage */
    if (dCount == 0)
    {
        return ICF_FAILURE;
    }
    sip_getHeaderAsStringAtIndex(pSipMsg,dType,((SIP_S8bit **)&p_temp_buff)\
            ,index, &sip_err);
    if (p_temp_buff != ICF_NULL)
    {
        p_colon_ind = (icf_uint8_t *)icf_port_strstr((const icf_int8_t *)p_temp_buff, (const icf_int8_t *)";");
        if (p_colon_ind != ICF_NULL)
        {
            if (ICF_NULL != icf_port_strstr((icf_int8_t *)p_colon_ind, (icf_int8_t *)is_focus))
            {
                ret_val = ICF_SUCCESS;
            }
            else
            {
                ret_val = ICF_FAILURE;
            }
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
        fast_memfree(0, p_temp_buff, &sip_err);
    }
    else
    {
        ret_val = ICF_FAILURE;
    }
    if (ICF_SUCCESS == ret_val)
    {

        ret_val = icf_ssa_populate_contact_addr(
                p_ssa_pdb,
                pSipMsg,
                &p_addr,
                &sip_err_1) ;
        if (ICF_NULL != p_addr)
        {
            icf_port_memcpy((void *)&p_ssa_pdb->conference_uri,
                    (void *)p_addr, sizeof (p_ssa_pdb->conference_uri));
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_addr,
                    ICF_MEM_COMMON, 
                    p_ssa_pdb->p_ecode, ret_val)
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
    } 
    return ret_val;
}



icf_return_t    icf_ssa_is_alias_present_in_Via(
                 INOUT  SipMessage          *p_sip_msg
                 )
{
    icf_return_t                 ret_val = ICF_FAILURE;    
    icf_uint32_t                  count = 0;
    icf_uint8_t                  index = 0;
    SipParam                     *p_sip_param = SIP_NULL;
    Sdf_ty_s8bit                 *pParamName = SIP_NULL;
    SipHeader                    hdr;
    Sdf_st_error                 sdf_error;
    SipError                     sip_error;
   
    if(SipFail != sip_getHeaderAtIndex(p_sip_msg,SipHdrTypeVia,&hdr,0,\
        &sip_error))
    {
        if(SipFail == sip_getViaParamCountFromViaHdr(&hdr, &count, \
                    (SipError*)&(sdf_error.stkErrCode)))
        {
#ifdef SDF_ERROR
            sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                "Failed to get the Via Param count from Via header of SIP message",\
               &(sdf_error));
#endif
            sdf_error.stkErrCode=Sdf_en_headerManipulationError;
            sip_freeSipHeader(&hdr);
            ret_val = ICF_FAILURE;
        }
        else
        {
            for(;index < count; index++)
            {
                /* get the parameters from Via Header 
                 */
                if(SipFail == sip_getViaParamAtIndexFromViaHdr(&hdr,&p_sip_param,\
                            index,(SipError*)&(sdf_error.stkErrCode)))
                {
#ifdef SDF_ERROR
                    sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                            (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                            "Failed to get the Via Param from Via header from SIP message",&sdf_error);
#endif
                    sdf_error.stkErrCode=Sdf_en_headerManipulationError;
                    sip_freeSipHeader(&hdr);
                    return ICF_FAILURE;

                }
                else if(SipFail == sip_getNameFromSipParam(p_sip_param, &pParamName,\
                            (SipError*)&(sdf_error.stkErrCode)))
                {
#ifdef SDF_ERROR
                    sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                            (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                            "Failed to get name from via param of SIP message",&sdf_error);
#endif
                    sdf_error.stkErrCode = Sdf_en_headerManipulationError;
                    sip_freeSipParam(p_sip_param);
                    sip_freeSipHeader(&hdr);
                    return ICF_FAILURE;
                }

                else
                {
                    if(0 == icf_port_strcmp((icf_uint8_t *)pParamName,(icf_uint8_t *)"alias"))
                    {
                        ret_val = ICF_SUCCESS;
                        sip_freeSipParam(p_sip_param);
                        break;
                    }
                }
                sip_freeSipParam(p_sip_param);
            }
        }

    }
    sip_freeSipHeader(&hdr);

    return ret_val;

}

/*******************************************************************************************
 * FUNCTION           icf_ssa_free_list
 *
 *
 * Description:  It frees the entire linked list
 *
 * ***************************************************************************************/

icf_void_t      icf_ssa_free_list(icf_ssa_pdb_st  *p_ssa_pdb, 
        icf_list_st  *p_root)
{
    icf_list_st  *p_temp = ICF_NULL;
    icf_error_t  dummy_ret_val;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) 


    for (; ICF_NULL != p_root; )
    {
        p_temp = p_root;
        p_root = p_root->p_next;
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_temp,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val);
    }
    ICF_PRINT(((icf_uint8_t *)"Exiting icf_ssa_free_list\n"))
}

/*****************************************************************************
 * FUNCTION: 		icf_ssa_form_and_insert_warning_hdr
 *
 * DESCRIPTION:    	This function forms and inserts a warning 
 *                  header into the SIP message passed  to it.
 *****************************************************************************/
icf_return_t icf_ssa_form_and_insert_warning_hdr (
         icf_ssa_pdb_st  *p_ssa_pdb,
         SipMessage 	  *p_sip_msg)
{
    icf_return_t 	         ret_val = ICF_SUCCESS;
    icf_return_t 	         dummy_ret_val = ICF_SUCCESS;
    SipHeader	                 *p_sip_header = SIP_NULL;
    SipError	                 sip_error;
    icf_transport_address_st     self_addr = {{0,{{0,"\0"}}},0};
    icf_uint8_t                  host_name[ICF_MAX_STR_LEN], *p_host_name = ICF_NULL;
    icf_uint8_t                  *p_warning_text = ICF_NULL; 

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
   /* 
    * If the p_warning_text is a blank string,do not 
    * insert the warning header,just return ICF_SUCCESS
    */
    if (0 == p_ssa_pdb->warning_text.str_len || ICF_NULL == p_ssa_pdb->warning_header_code)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Warning Text in Warning Header is not there.\n"));
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }

    icf_port_memset(
            (icf_void_t*)&host_name,
            '\0',
            (icf_uint32_t) ICF_PORT_SIZEOF(ICF_MAX_STR_LEN));

    /* Get glb cfg data, if it is null.*/
    if (ICF_NULL == p_ssa_pdb->p_glb_cfg_data)
    {
       if (ICF_FAILURE == icf_dbm_get_module_glb_data(
                            p_ssa_pdb->p_glb_pdb,
                            ICF_INT_MODULE_CFG,
                            (icf_void_t **)&(p_ssa_pdb->p_glb_cfg_data),
                            p_ssa_pdb->p_ecode))
       {
          ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in fetching glb cfg data for Warning Header.\n"));
          return ret_val;
       }
    }
    /* Get line data, if it is null.*/
    if (ICF_NULL == p_ssa_pdb->p_line_data)
    {
       if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                p_ssa_pdb->p_glb_pdb, p_ssa_pdb->p_ssa_ctxt->line_id,
                &(p_ssa_pdb->p_line_data), p_ssa_pdb->p_ecode))	
       {
          ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in fetching line data for Warning Header.\n"));
          return ret_val;
       }
    } 
      
    /*If per line self transport then copy address from line_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE == p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                        sizeof(icf_transport_address_st));
    }
    else
    {
        icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                        sizeof(icf_transport_address_st));
    }

    if (ICF_FAILURE == icf_cmn_convert_transport_addr_to_string(&(self_addr.addr),host_name))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailure in converting IP Addr to String.\n"));
        return ret_val;
    }
    /* 
     * If the p_host_name is a blank string,do not 
     * insert the warning header,just return ICF_SUCCESS
     */
    if ((ICF_NULL == icf_port_strlen(host_name)) 
        ||(ICF_NULL == icf_port_strlen(p_ssa_pdb->warning_text.str)) )
    {
        ICF_SSA_DEBUG(("\[SSA]:Unable to get Host Name or Warning text for Warning Header.\n"));
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }
    else
    {
        ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            icf_port_strlen(host_name) + 1,
            ICF_MEM_COMMON,
            p_host_name,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val)

         ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            icf_port_strlen(p_ssa_pdb->warning_text.str) + 1,
            ICF_MEM_COMMON,
            p_warning_text,
            ICF_DONOT_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val)

        if (ICF_FAILURE == ret_val)
        {
           ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_host_name,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
           return ICF_FAILURE;
        }

        icf_port_strcpy(p_host_name, host_name);
        icf_port_strcpy(p_warning_text,p_ssa_pdb->warning_text.str);
    }
   
    /* Init the unknown hdr */
    if (SipFail == sip_initSipHeader(
                &p_sip_header,SipHdrTypeWarning,&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Set the Code in the warning hdr */
    else if (SipFail == sip_setCodeInWarningHdr(
                p_sip_header,p_ssa_pdb->warning_header_code,&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Set the Host into the warning hdr */
    else if (SipFail == sip_setAgentInWarningHdr(
            p_sip_header,(icf_int8_t *)p_host_name,&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Set the Text into the warning hdr */
    else if (SipFail == sip_setTextInWarningHdr(
            p_sip_header,(icf_int8_t *)p_warning_text,&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Insert the warning hdr into the SIP message */
    else if (SipFail == sip_insertHeaderAtIndex(
            p_sip_msg, p_sip_header,0,&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Free the header memoryr  */
    if (SIP_NULL != p_sip_header)
    {
        sip_freeSipHeader(p_sip_header);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_sip_header,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
    }


/* No need to free p_host_name and p_warning_text here, these will be freed by stack.*/
/* 
    if (ICF_NULL != p_host_name)
    {
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_host_name,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
    }

    if (ICF_NULL != p_warning_text)
    {
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_warning_text,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
    }
*/  
  
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}



/*****************************************************************************
 * FUNCTION:        icf_ssa_parse_p_early_media_hdr
 *
 * DESCRIPTION:     This function will parse the Header list present in the  
 *                  sip message for header P-Early-Media.It then parses that 
 *                  header and populates the corresponding value in the call ctxt.
 *****************************************************************************/
icf_boolean_t icf_ssa_parse_p_early_media_hdr(
        icf_ssa_pdb_st   *p_ssa_pdb,
        SipMessage       *p_sip_msg,
        icf_internal_sdp_stream_st *p_int_sdp)
{
    icf_boolean_t         ret_val = ICF_FALSE;

    Sdf_ty_u32bit           iterator=0,count=0;
    SipError                err;
    SipHeader               dHeader;
    SIP_S8bit                *p_unk_hdr_name = ICF_NULL;
    icf_config_data_st		*p_config_data = ICF_NULL;
    icf_error_t		   ecode = ICF_ERROR_NONE;
    p_ssa_pdb=p_ssa_pdb;   

    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if(ICF_FAILURE == icf_dbm_get_module_glb_data(
                        p_ssa_pdb->p_glb_pdb,
                        (icf_int_module_id_t)ICF_INT_MODULE_CFG,
                        (icf_void_t *)&p_config_data, &ecode))
     {
          return ret_val;
     }

    /*If the P-Early-Media Hdr is already been received, then donot process
     * next P-Early-Media Hdr and if IPTK does not support it also
     */ 
    if((ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx) && 
        (!(ICF_EARLY_MEDIA_HDR_SUPPORTED & 
          p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask_2) && 
          (ICF_CALL_CONFIG_EARLY_MEDIA_HDR_SUPPORTED & p_config_data->default_settings)))
    { 
    /* get the unknown header count */
    if(SipFail == sip_getHeaderCount(
                p_sip_msg,
                SipHdrTypeUnknown,&count,
                &err))
    {
        return ret_val;
    }
    /* Iterate through all the unknown headers*/
    for(iterator=0 ; iterator<count ; iterator++)
    {
        SIP_S8bit  *p_buffer = SIP_NULL ;

        if(SipFail == sip_getHeaderAtIndex(
                    p_sip_msg,
                    SipHdrTypeUnknown, &dHeader,
                    iterator,&err))
        {
            /*In this case we continue to try to fetch other unknown headers*/
            continue;
        }
        if(SipFail == sip_getNameFromUnknownHdr(
                    &dHeader,&p_unk_hdr_name,&err))
        {
            /*In this case we continue to try to fetch other unknown headers*/
            sip_freeSipHeader(&dHeader);
            continue;
        }
        /* Check for the unknown header */
        if(ICF_NULL == sip_strcasecmp(p_unk_hdr_name,"P-Early-Media"))
        {
            icf_uint8_t  *p_token = ICF_NULL;
#ifdef ICF_WITH_MUATK_2_2
            p_buffer = (((SipUnknownHeader *)
                        (dHeader.pHeader))->pStr2);
#else
            p_buffer = (((SipUnknownHeader *)
                        (dHeader.pHeader))->pBody);
#endif
 
            p_token = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)p_buffer,(const icf_int8_t *)",");
            if (ICF_NULL != p_token)
            {

              /* On encountering an id parameter we return SUCCESS */
              if (ICF_NULL == icf_port_strcmp(p_token, (icf_uint8_t *)"sendrecv")) 
              {
                 p_int_sdp->media_mode = ICF_MEDIA_MODE_SEND_RECV;
              }
              else if (ICF_NULL == icf_port_strcmp(p_token, (icf_uint8_t *)"sendonly")) 
              {
                  p_int_sdp->media_mode = ICF_MEDIA_MODE_SEND_ONLY;
              }
              else if (ICF_NULL == icf_port_strcmp(p_token, (icf_uint8_t *)"recvonly")) 
              {
                  p_int_sdp->media_mode = ICF_MEDIA_MODE_RECV_ONLY;
              }
              else if (ICF_NULL == icf_port_strcmp(p_token, (icf_uint8_t *)"inactive")) 
              {
                 p_int_sdp->media_mode = ICF_MEDIA_MODE_INACTIVE;
              }
              else if(ICF_NULL == icf_port_strcmp(p_token, (icf_uint8_t *)"invalid"))
              {
                  p_int_sdp->media_mode = ICF_MEDIA_MODE_INVALID;
              }
              sip_freeSipHeader(&dHeader);
              p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask_2 |= 
                                        ICF_EARLY_MEDIA_HDR_SUPPORTED; 
              
              p_ssa_pdb->common_bitmask |= ICF_SSA_MEDIA_MODE_RECEIVED;
              ret_val = ICF_TRUE;
              break;
            } 

        } 
        sip_freeSipHeader(&dHeader);
    }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


/*****************************************************************************
 * FUNCTION: 	    icf_ssa_form_and_insert_p_early_media_hdr 
 *
 * DESCRIPTION:     This function forms and inserts an P-Early-Media
 *                  header into the SIP message passed  to it
 * 
 *****************************************************************************/
 icf_return_t icf_ssa_form_and_insert_p_early_media_hdr(
         icf_ssa_pdb_st  *p_ssa_pdb,
         SipMessage 	    *p_sip_msg)
{
    icf_return_t 	ret_val = ICF_SUCCESS;
    icf_return_t 	dummy_ret_val = ICF_SUCCESS;
    SipHeader	        *p_sip_header = SIP_NULL;
    SipError	        sip_error;
    icf_internal_list_st	*p_stream_sdp_info_node= p_ssa_pdb->p_glb_pdb->
						p_call_ctx->p_stream_sdp_info;
    icf_stream_sdp_info_st	*p_stream_sdp_info_data = ICF_NULL;
    icf_uint8_t         mode_str[10] = {"\0"}, 
                        media_mode[10] = {"\0"} ;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    while(p_stream_sdp_info_node != NULL)
    {
       	p_stream_sdp_info_data = (icf_stream_sdp_info_st *)
   					(p_stream_sdp_info_node->p_payload);
        
	if(ICF_MEDIA_MODE_INACTIVE == p_stream_sdp_info_data->mm_applied_mode)
	{
	    icf_port_strcpy(media_mode,(icf_uint8_t *)"inactive");
	}
	else if (ICF_MEDIA_MODE_SEND_ONLY == p_stream_sdp_info_data->mm_applied_mode)
	{
            icf_port_strcpy(media_mode,(icf_uint8_t *)"sendonly");
	}
	else if(ICF_MEDIA_MODE_RECV_ONLY ==p_stream_sdp_info_data->mm_applied_mode)
	{
    	    icf_port_strcpy(media_mode,(icf_uint8_t *)"recvonly");
	}
	else if(ICF_MEDIA_MODE_SEND_RECV ==p_stream_sdp_info_data->mm_applied_mode)
	{                
    	    icf_port_strcpy(media_mode,(icf_uint8_t *)"sendrecv");
        }	
	else if(ICF_MEDIA_MODE_INVALID ==p_stream_sdp_info_data->mm_applied_mode)
	{                
    	    icf_port_strcpy(media_mode,(icf_uint8_t *)"invalid");
        }	
        
        if(ICF_NULL != icf_port_strcmp(mode_str, media_mode))
        {
           /* Init the unknown hdr */
          if (SipFail == sip_initSipHeader(
                &p_sip_header,SipHdrTypeUnknown,&sip_error))
          {
             ret_val = ICF_FAILURE;
          }
		  /*Fix done for SPR-18722 : CSR-1-6068965*/
         /* Set the name into the unknown hdr */
          else if (SipFail == sip_setNameInUnknownHdr(
                p_sip_header,(icf_int8_t *)icf_port_strdup((icf_uint8_t *)"P-Early-Media"),&sip_error))
          {
              ret_val = ICF_FAILURE;
          }
         /* Set the contents into the unknown hdr */
          else if (SipFail == sip_setBodyInUnknownHdr(
              p_sip_header,(icf_int8_t *)icf_port_strdup((icf_uint8_t *)media_mode),&sip_error))
         {
            ret_val = ICF_FAILURE;
         }
         /* Insert the unknown hdr into the SIP message */
         else if (SipFail == sip_insertHeaderAtIndex(
                 p_sip_msg, p_sip_header,0,&sip_error))
        { 
             ret_val = ICF_FAILURE;
        }
        /* Free the header memoryr  */
        if (SIP_NULL != p_sip_header)
        {
            sip_freeSipHeader(p_sip_header);
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_sip_header,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
        }
          p_stream_sdp_info_node = (icf_internal_list_st *)(p_stream_sdp_info_node->p_next);
 
          /*In case the next mode for m-line is same,
           * then donot form the header otherwise form it.
           */ 
          icf_port_strcpy(mode_str, media_mode);
      }
    }
     
    /*Reset the bitmask*/
    p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask_2 &= 
                                         ~(ICF_EARLY_MEDIA_HDR_SUPPORTED); 

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/*****************************************************************************
* Function    : icf_ssa_delete_param_from_addr_spec
*
* Description : This function is a utility function which deletes any parameter
*               from Sip Address Specification.It takes the parameter to be
*               deleted as an argument.
*
******************************************************************************/

icf_return_t icf_ssa_delete_param_from_addr_spec(
    SipAddrSpec *p_addr_spec,
    icf_uint8_t *param)
{
    SipList      *p_list = ICF_NULL;
    icf_uint8_t  index = 0;
    SipError     error;
    icf_uint8_t  param_to_del[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t  temp_param[ICF_MAX_STR_LEN] = "\0";
    icf_return_t ret_val = ICF_SUCCESS;
   
    if(p_addr_spec)
    {
        icf_port_strcpy(param_to_del,param);

        /*if the address if of type SIP or SIPS URI*/ 
        if(SipAddrSipUri == p_addr_spec->dType ||
           SipAddrSipSUri == p_addr_spec->dType)
        {
            p_list = &(p_addr_spec->u.pSipUrl->slParam);        

            /*iterating through the list*/
            while(p_list->head && index < p_list->size)
            {
                icf_port_strcpy(temp_param,
                               (icf_uint8_t *)((SipParam*)(p_list->head->pData))->pName);

                if(0 == icf_port_strcmp(temp_param,param_to_del)) 
                {
                    /*deleting the parameter*/
                    if(SipFail == sip_listDeleteAt(p_list,index,&error))
                    {
                        ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Paramter\n"));
                        ret_val = ICF_FAILURE;
                        return ret_val;
                    }
                }
                index ++;
                if(p_list->head)
                {
                    p_list->head = p_list->head->next;
                }
            }
        }/*end if SipAddrSipUri == p_addr_spec->dType*/
    }/*end if(p_addr_spec)*/
    else
    {
        /*SipAddrSpec received is Null*/
        ret_val = ICF_FAILURE;
    }
    return ret_val;
}/*end of icf_ssa_delete_param_from_addr_spec */


#ifdef ICF_SESSION_TIMER
/*****************************************************************************
 * FUNCTION: 	 icf_ssa_chk_n_insert_timer_in_supp_hdr
 *
 * DESCRIPTION:  The function checks if the negotiated rerfesher is none for 
 *               incoming INVITE/UPDATE requests (that is the refresher
 *               received from network and the one set by application is
 *               none). In such cases no session timer needs to be started and
 *               hence no session timer related (expiry, refresh method etc) 
 *               information is provided to UATK. UATK if it doesn't
 *               have session timer related information does not send timer in 
 *               supported header so this would be inserted here.
 *                  
 *****************************************************************************/
icf_return_t icf_ssa_chk_n_insert_timer_in_supp_hdr(icf_ssa_pdb_st *p_ssa_pdb)
{
    Sdf_st_callObject      *pCallObj = Sdf_co_null;
    Sdf_ty_refresher       refresher;
    icf_return_t           ret_val = ICF_SUCCESS;
    icf_line_data_st       *p_line_data = ICF_NULL;  

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if((p_ssa_pdb->p_ssa_ctxt != ICF_NULL) && 
       (p_ssa_pdb->p_ssa_ctxt->p_call_ctxt != ICF_NULL))
    {       
        pCallObj = p_ssa_pdb->p_ssa_ctxt->p_call_obj ;

        icf_dbm_fetch_line_cntxt_blk(p_ssa_pdb->p_glb_pdb,
                         p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->line_id,
                         &p_line_data,
                         p_ssa_pdb->p_ecode);

        if(Sdf_co_success == sdf_ivk_uaGetRefresher(pCallObj,&refresher,
                                     (Sdf_st_error*)p_ssa_pdb->p_ecode))
        {
            /* 
             * If the refresher value is not received from network in
	     * incoming request (INVITE/UPDATE) and 
             * application has also locally set the refresher to be
             * none, IPTK would not set an refresher value in the
             * 200 OK response. In such cases UATK doesn't send "timer" in
	     * supported list of headers. To overcome this issue add "timer" in
             * header_list present in call context so it would be inserted 
             * in outgoing message
	     */   
            if(refresher == Sdf_en_refresherNone && 
			    ICF_SESSION_REFRESHER_NONE == 
			    p_line_data->session_timer_refresher)
	    {
#ifdef ICF_SESSION_TIMER

	       SipHeader       *pSupportedHeader = Sdf_co_null;
	       SipError        SipErr;
	       SIP_U32bit      count=0;
	       if (sip_initSipHeader(&pSupportedHeader,SipHdrTypeSupported,\
				       &(SipErr)) == SipFail)
	       {
		       ret_val = ICF_FAILURE;
	       }
	       else if(sip_setOptionInSupportedHdr(pSupportedHeader,
				       sip_strdup("timer",Sdf_mc_initMemId), \
				       &SipErr)==SipFail)
	       {
		       ret_val = ICF_FAILURE;
	       }
	       else if(SipFail == 
			       sip_getHeaderCount(
				       p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUasTransaction->pSipMsg,
				       SipHdrTypeSupported,&count,&SipErr))
	       {
		       ret_val = ICF_FAILURE;
	       }
	       else if (sip_insertHeaderAtIndex(
				       p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUasTransaction->pSipMsg,
				       pSupportedHeader,count, \
				       &(SipErr)) == SipFail)
	       {
		       ret_val = ICF_FAILURE;
	       }
               /* Freeing the Local reference */
	       
		/* purify */
		if(ICF_NULL != pSupportedHeader)
		{
			sip_freeSipHeader(pSupportedHeader); 
			sdf_memfree(Sdf_mc_callHandlerMemId,(Sdf_ty_pvoid *)\
						&pSupportedHeader, Sdf_co_null); 
		}
#endif
	    }
        }
        else
        {
            ret_val = Sdf_co_fail;
        }
    }
    else
    {
        ret_val = Sdf_co_fail;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
    return ret_val;
}
#endif

/*****************************************************************************
 * FUNCTION:     icf_ssa_remove_port_from_address
 *
 * DESCRIPTION:  The function checks if the port is attached in the address 
 *               it strips the port.
 *                  
 *****************************************************************************/
icf_return_t icf_ssa_remove_port_from_address(
               icf_ssa_pdb_st   *p_ssa_pdb,
               icf_uint8_t      *p_address)
{
     icf_return_t    ret_val = ICF_SUCCESS;
     /* This variable will be used to store the position of 
        pointer */ 
     icf_uint8_t     temp_pos = 0;
     /* This pointer is pointing the initial address of remaining
        string after performing the strchr operation.*/   
     icf_uint8_t     *p_remain_str = ICF_NULL;

     icf_string_st   temp_str;

     ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

     icf_port_strcpy(temp_str.str, p_address);
     temp_str.str_len = (icf_uint16_t )icf_port_strlen(p_address);

    /* Gets the position of last occurence of the character ':' */ 
     do
     {
         p_remain_str = icf_port_strchr(&(temp_str.str[temp_pos]), ':');

         if (ICF_NULL != p_remain_str)
         {
             temp_pos += (icf_uint16_t)(icf_port_strlen(&(temp_str.str[temp_pos])) -
                          icf_port_strlen(p_remain_str)) + 1;
         }
     } while (ICF_NULL != p_remain_str);

    /* Check that if the substring is numeric then strip it*/
  
     if (0 != temp_pos)
     {
          if (ICF_TRUE == icf_port_isnumeric(&(temp_str.str[temp_pos])))
          {
              *(p_address + (temp_pos - 1)) = '\0';
          }
     }

     /* warning removal in case of traces off*/

     p_ssa_pdb = p_ssa_pdb;

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
     return ret_val;
}


/*****************************************************************************
 * FUNCTION:        icf_ssa_parse_AcceptHdr_for_supported_Msgbody
 *
 * DESCRIPTION:     This function parse the Accept header of incoming
 *                  SIP message and determines whether the msg body
 *                  present in Accept header is supported by application
 *                  or not.
 *
 *****************************************************************************/
Sdf_ty_retVal icf_ssa_parse_AcceptHdr_for_supported_Msgbody(SipMessage *p_message,
                                                     icf_glb_pdb_st *p_glb_pdb,
                                                     Sdf_st_error *pErr)
{

    SipHeader dAcceptHeader;
    SIP_S8bit *p_accepted_value = ICF_NULL;
    Sdf_ty_u32bit no_of_accept_headers = 0;
    Sdf_ty_u32bit index =0;
    Sdf_ty_retVal retval = Sdf_co_fail;


#ifdef ICF_TRACE_ENABLE
        icf_return_t    ret_val = 0;
#endif


    if(ICF_NULL == p_glb_pdb)
    {
       ICF_PRINT(((icf_uint8_t *)"p_glb_pdb is null"));
       return Sdf_co_fail;
    }
    ICF_FUNCTION_ENTER(p_glb_pdb);

    /* Get the Accept headers count and find for application/sdp content type 
     *  in all the Accept headers.If found in any Accept header,stop the search 
     * and return success fron the function */
      
    if(sip_getHeader(p_message,
        SipHdrTypeAccept, &dAcceptHeader,(SipError*)&(pErr->stkErrCode)) != SipFail)
     {

        if(sip_getHeaderCount(p_message,SipHdrTypeAccept,
            &no_of_accept_headers,(SipError*)&(pErr->stkErrCode)) != SipFail)
           {
             
            sip_freeSipHeader(&dAcceptHeader);

            for(index = 0;index < no_of_accept_headers;index++)
            {

                if(sip_getHeaderAtIndex(p_message,
                    SipHdrTypeAccept, &dAcceptHeader,
                    index, (SipError*)&(pErr->stkErrCode)) != SipFail)
                  {

                    if(sip_getStr1FromCommonHdr(&dAcceptHeader,&p_accepted_value,
                        (SipError*)&(pErr->stkErrCode)) != Sdf_co_fail)
                     {
                                  
                                  if(icf_port_strcmp((icf_uint8_t *)p_accepted_value,(icf_uint8_t *)"application/sdp") == 0)                              
                                    {
                                      retval = Sdf_co_success;
                                      sip_freeSipHeader(&dAcceptHeader);
                                      break;
                                    }                             
		     } 
                     sip_freeSipHeader(&dAcceptHeader);
                }
            }
           }
           else
            {
                sip_freeSipHeader(&dAcceptHeader);
            }
    }
    else /*incoming call getting failed when incoming invite does not contain accept header */
    {
         retval = Sdf_co_success;
    }

    ICF_FUNCTION_EXIT(p_glb_pdb);
    return retval;
}

/*Fix for CSR 1-6792719 referred from SPR : 18432*/
/*****************************************************************************
 * FUNCTION:        icf_ssa_free_sip_txn_data_on_failure
 *
 * DESCRIPTION:     This function Iterate thru all TxnKeys in UATK
 *                  pGlbToolkitData and compare if it is the given key
 *                  to be freed then free both transaction key and buffer
 *
 *****************************************************************************/
icf_void_t     icf_ssa_free_sip_txn_data_on_failure(
        SipTxnKey *pSipTxnKey)
{
    SipTxnKey           *pTempSipTxnKey = Sdf_co_null;
    SipTxnBuffer        *pSipTxnBuffer = Sdf_co_null;
    Sdf_st_error        sdf_error = {0,0,0,"\0"};
    Sdf_st_hashIterator dIterator = {Sdf_co_null, 0};

    /*Iterate thru all TxnKeys in UATK pGlbToolkitData
     *and compare if it is the given key to be freed then
     *free both transaction key and buffer*/
    if (Sdf_co_null == pGlbToolkitData->pTxnFetchFunc)
    {
        sdf_ivk_uaHashInitIterator(&(pGlbToolkitData->dSipTxnHash), \
                &dIterator);

        while (Sdf_co_null != dIterator.pCurrentElement)
        {
            pTempSipTxnKey =
                (SipTxnKey *)((dIterator.pCurrentElement)->pKey);
            pSipTxnBuffer =
                (SipTxnBuffer *)((dIterator.pCurrentElement)->pElement);

            if(SipSuccess ==
                    sip_txn_compareTxnKeys(pTempSipTxnKey,
                        pSipTxnKey,
                        (SipError *)&sdf_error.errCode))
            {
                (void)sdf_ivk_uaHashRemove(
                        &(pGlbToolkitData->dSipTxnHash), \
                        (Sdf_ty_pvoid) pSipTxnKey);

                sip_freeSipTxnKey(pSipTxnKey);
                sip_freeSipTxnBuffer(pSipTxnBuffer);
            }
            sdf_ivk_uaHashNext(&(pGlbToolkitData->dSipTxnHash),
                    &dIterator);

        }
    }
}

/*********************************************************
** FUNCTION: icf_ssa_handle_chal_resp
**
** DESCRIPTION: This Function handles Challange response for
**              the request origionated in call 
**              
**
**********************************************************/
Sdf_ty_retVal icf_ssa_handle_chal_resp(
        Sdf_st_callObject               **ppCallObj,
        Sdf_st_eventContext             *pEventContext, 
        Sdf_st_overlapTransInfo         *pOverlapTransInfo,
        Sdf_ty_u16bit                    dRespCode, 
        Sdf_st_error                    *pErr)
{
    icf_ssa_pdb_st   *p_ssa_pdb = ICF_NULL;
    icf_boolean_t    authenticate_req = ICF_TRUE;
    icf_ssa_ctxt_st  *p_ssa_ctxt = ICF_NULL;
    icf_return_t     ret_val = ICF_SUCCESS;

    /* Extract the pointer to SSA CTXT from the event context */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)(pEventContext->pData);
    /* Extract the pointer to SSA PDB from the event context */
    p_ssa_pdb = (icf_ssa_pdb_st*)(p_ssa_ctxt->p_ssa_pdb);
    p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) /* function entry trace */

    /* Challenge is received for a request generated by module sic*/
    if(ICF_NULL != p_ssa_ctxt->p_sic_ctxt)
    {
        if(ICF_FAILURE == icf_ssa_validate_challenge(ppCallObj,
				pOverlapTransInfo,
				dRespCode,p_ssa_pdb,pErr,p_ssa_pdb->p_method))
        {
            authenticate_req = ICF_FALSE;
        }
    }
    /*  If NOTIFY has already been challenged the fail  the successive
     *  authentication request to avoid the loop of NOTIFY:401/407.
     */
    else if(ICF_NULL != (ICF_NOTIFY_AUTHENTICATION_REQ & 
	   p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask_2))
    {
        authenticate_req = ICF_FALSE;
        ret_val = ICF_FAILURE;
    }
    /*
     * The challenge is received for a request in call. Proceed with
     * authentication if this is the first request being challenged
     * during the call or a challenge received due to nonce expiry.
     */
    else if (((ICF_NULL == (ICF_CALL_AUTHENTICATION_REQ & 
	   p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask)) ||
	(ICF_FAILURE == 
	 icf_ssa_validate_challenge(ppCallObj,pOverlapTransInfo,
		 dRespCode,p_ssa_pdb,pErr,p_ssa_pdb->p_method))) && 
		(ICF_NULL != (ICF_CALL_AUTHENTICATION_REQ & 
	     p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask)))
    {
        authenticate_req = ICF_FALSE;
		ret_val = ICF_FAILURE;
    }
    
    if(ICF_TRUE == authenticate_req)
    {
	 icf_ssa_fetch_auth_param_list(p_ssa_pdb,
			 ppCallObj,pOverlapTransInfo);

	 /* If list is not null and auth param are configured on line
	  * send bye with auth params else clear the call */
	 if(ICF_NULL != p_ssa_ctxt->auth_params_list_size )
	 {
            /* Fetch Line data from DBM */
	    if (ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
				    p_ssa_pdb->p_glb_pdb,
				    p_ssa_ctxt->line_id,
				    &(p_ssa_pdb->p_line_data),
				    p_ssa_pdb->p_ecode))
	    {
		ret_val = ICF_FAILURE;
	    }
	    else if((p_ssa_pdb->p_line_data->line_data_received &
				    ICF_CFG_LINE_DATA_AUTH_KEY_RECD) &&
			    (p_ssa_pdb->p_line_data->line_data_received &
			     ICF_CFG_LINE_DATA_AUTH_PASSWD_RECD))
	    {
		if(ICF_TRUE == ICF_IS_BIT_SET(
			    p_ssa_pdb->p_line_data->line_data_received, 
			    ICF_CFG_LINE_DATA_REALM_RECD))
		{
		    /* We have to compare the received realm with configured
		     * one */
		    Sdf_st_authenticationParams *pAuthenticationParams = 
				    Sdf_co_null;
		    if(Sdf_co_success == sdf_listGetAt(
					p_ssa_ctxt->p_auth_params_list, 0, 
					(Sdf_ty_pvoid *)&pAuthenticationParams, 
					pErr))
		    {
		        if(Sdf_co_null != pAuthenticationParams->pRealm)
			{
			    icf_string_st temp_unq_realm;
			    temp_unq_realm.str[0]='\0';
			    temp_unq_realm.str_len=0;
			    sdf_fn_uaUnq(pAuthenticationParams->pRealm,temp_unq_realm.str);
			    if(0 != icf_port_strcmp(p_ssa_pdb->p_line_data->configured_realm.str, 
							temp_unq_realm.str))
			    {
				authenticate_req = ICF_FALSE;

				/*ICF_RESET_BIT(p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask,
						ICF_CALL_AUTHENTICATION_REQ)*/
			    }
			}/*if(Sdf_co_null != pAuthenticationPa...*/
		    }/*if(Sdf_co_success == sdf_listGetAt( ...*/
		}/*if(ICF_TRUE == ICF_IS_BIT_SET( ...*/
	    }/*else if((p_ssa_pdb->p_line_data->line_data ...*/
	 }/* ICF_NULL != p_ssa_ctxt->auth_para ...*/ 
	 else
	 {
             authenticate_req = ICF_FALSE;
	 }
    }/*if(ICF_TRUE == authentica ...*/
    
   if(ICF_FAILURE != ret_val &&
		   ICF_TRUE == authenticate_req)
   {
       /* Fetch and store the old nonce in the ssa context */

       if(ICF_FAILURE == icf_ssa_extract_nonce_from_challenge(
			       p_ssa_pdb,
			       dRespCode))
       {
           ret_val = ICF_FAILURE;
       }
       /* 
        * If p_app_conf is NULL in SSA PDB then retreive the same.
        * The app_conf would be used to form the allow header for 
        * the new request being generated.
        */
       else if(ICF_NULL == p_ssa_pdb->p_app_conf)
       {
           icf_app_id_t app_id = ICF_INVALID_APP_ID;
           if(ICF_NULL != p_ssa_ctxt->p_sic_ctxt)
           {
               app_id = p_ssa_ctxt->p_sic_ctxt->app_id;
           }
           else
           {
               app_id = p_ssa_ctxt->p_call_ctxt->app_id;
           }

           /* retreive app_conf corresponding to the app_id */
           ret_val = icf_cfg_fetch_app_conf(
                   p_ssa_pdb->p_glb_pdb,
                   app_id,
                   &(p_ssa_pdb->p_app_conf),
                   p_ssa_pdb->p_ecode);
       }/* End else if(ICF_NULL == p_ssa_pdb-> ... */

       if(ICF_FAILURE != ret_val)
       {
           ret_val = icf_ssa_send_authorized_req(p_ssa_pdb);
       }
       
   }/* ICF_TRUE == authenti ...*/
   else
   {
       ret_val = ICF_FAILURE;
   }

   return ret_val;
}/* end Function icf_ssa_handle_chal_resp*/

/*Fix for SPR: 19788*/
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_clear_div_info
 *
 * DESCRIPTION:     This function would clear the diversion information from 
 *                  call context
 *
 ******************************************************************************/
icf_return_t icf_ssa_clear_div_info(
        INOUT icf_ssa_pdb_st *p_ssa_pdb)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_diversion_data_st            *p_div_data = ICF_NULL;
    icf_diversion_data_st            *p_div_data_temp = ICF_NULL;


    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) /* function entry trace */
      

    /* Free the diversion header list - This is a list */
    if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list)
    {
                  
        /* Free the contact addr if present */
        if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx->
                p_diversion_header_list->p_contact_addr)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list->
                    p_contact_addr, ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode, ret_val)

            p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list->p_contact_addr
                    = ICF_NULL;
        }
        
        /* Free the contact name if present */
        if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx->
                p_diversion_header_list->p_contact_name)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list->
                    p_contact_name, ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode, ret_val)

            p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list->p_contact_name
                    = ICF_NULL;
        }

        /*Read the next element in list */
        p_div_data = 
            p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list->p_diversion_data;
  
       if(ICF_NULL !=  p_div_data)
       {
           /* If next element is not null, copy it in list */ 
           while(ICF_NULL != p_div_data->p_next)
           {
               p_div_data_temp = p_div_data->p_next;

               ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                      p_div_data, ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
               p_div_data = p_div_data_temp;
           } 
           ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                   p_div_data,
                   ICF_MEM_COMMON,p_ssa_pdb->p_ecode, ret_val)
           p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list->p_diversion_data =
               ICF_NULL;
       }
        
        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list,
                ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)

        p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list = ICF_NULL;
    }

    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb) /* function exit trace */
    return ret_val;
}/* end of icf_cc_clear_div_info */

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_insert_hdr_in_persistent_list_in_call_obj
 *
 * DESCRIPTION:     The function inserts an the header into persistent
 *                  header list in call objects with the passed correlation
 *
 ******************************************************************************/
icf_return_t icf_ssa_insert_hdr_in_persistent_list_in_call_obj(
                Sdf_st_callObject       *pCallObject,
                SipHeader               *pHeader,
                en_HeaderType           dType,
                Sdf_ty_s8bit            *pCorrelation,
                Sdf_st_error            *pErr)
{
    Sdf_st_headerList                   *pHeaderList = Sdf_co_null;
    icf_return_t ret_val=ICF_SUCCESS;

    /* Initialise a headerlist of */
    if(Sdf_co_fail == sdf_ivk_uaInitHeaderList(&pHeaderList,
                            dType,pCorrelation, pErr))
    {
        /*Klocwork warning removal*/
        (void)sdf_ivk_uaFreeHeaderList(pHeaderList);
        ret_val = ICF_FAILURE;
    }
    /* Add the header into the  list */
    else if(Sdf_co_fail == sdf_listAppend(&(pHeaderList->slHeaders),
                            (Sdf_ty_pvoid)pHeader,pErr))
    {
        (void)sdf_ivk_uaFreeHeaderList(pHeaderList);
        ret_val = ICF_FAILURE;
    }
    /*
     * Append the pHeaderList to the slPersistentHeaders
     * header list structures in the call object
     */
    else if ((sdf_listAppend(&(pCallObject->slPersistentHeaders),
                        (Sdf_ty_pvoid)pHeaderList, pErr)) == Sdf_co_fail)
    {
        (void)sdf_ivk_uaFreeHeaderList(pHeaderList);
        ICF_PRINT(("Failed to add the header list of headers to the PersistentHeaders list of callObject"));
        ret_val = ICF_FAILURE;
    }

    return ret_val;
}

