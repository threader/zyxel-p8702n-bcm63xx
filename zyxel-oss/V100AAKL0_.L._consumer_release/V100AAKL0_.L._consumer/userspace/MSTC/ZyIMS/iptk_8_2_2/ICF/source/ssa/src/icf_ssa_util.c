/*****************************************************************************
 **
 ** FILENAME:           icf_ssa_util.c
 **
 ** DESCRIPTION:        This file contains utility functions invoked by the SSA
 **
 ** DATE                NAME            REFERENCE               REASON
 ** ----                ----            ---------               ------
 ** 28-Jan-2005     Umang Singh         SSA LLD             INITIAL CREATION
 ** 29-JAN-2005     Aashish Suchdev
 ** 24-May-2005     Umang Singh         SPR 7541
 ** 31-MAY-2005     Jalaj Negi          IMS CLIENT          Added Code for 
 **                                                         IMS CLIENT           
 ** 07-Jun-2005     Umang Singh         SPR 7650
 ** 08-Jun-2005     Pankaj Negi         SPR 7648
 ** 14-Jun-2005     Umang Singh         SPR 7663            Privacy header handling
 ** 24-Jun-2005     Jalaj Negi          IMS CLIENT          Added code for 
 **                                                         bandwidth support
 **                                                         in SDP
 ** 07-JUL-2005     Aashish Suchdev                         TCP checkin            
 ** 12-AUG-2005     Shekhar Thakur      ICF                 ICF additions 
 ** 13-AUG-2005     Ram Narayan         ICF                 Added utility functions
 **                                                         for header/tag/body 
 **                                                         stream list & some new 
 **                                                         headers.
 ** 20-AUG-2005        Jyoti Narula        ICF                    ICR_CRM: Registration
 ** 02-SEP-2005     Jalaj Negi          ICF                 Changed code for 
 **                                                         extracting URI from
 **                                                            addr_spec.
 ** 03-SEP-2005     Jalaj Negi          ICF                 Changed function for
 **                                                            filling stream list 
 **                                                            SDP message.
 ** 05-SEP-2005     Jalaj Negi          ICF                 Modified list 
 **                                                         implementation for
 **                                                         populating application
 **                                                         specific headers.
 ** 10-SEP-2005     Ram Narayan         None                icf_ssa_extract_challenge
 **                                                         core was fixed, No check on 
 **                                                         NULL Challenge value
 **
 ** 06-DEC-2005        Jyoti Narula        ICF 4.0                Changes under ICF_4_CRM_START and END
 **
 ** 09-DEC-2005     Jalaj Negi          ICF_4_0             Added function for 
 **                                                         extracting P-Media-Authorization
 **                                                         header
 **    25-DEC-2005        Rohit Aggarwal                            Fixed SPR 8978
 **
 ** 28-Dec-2005        Jyoti Narula        SPR 9086            In the send_register() SipMsg formation for
 **                                                            Dereg to be made before using SipMsg
 **
 ** 06-Jan-2006        Jyoti Narula        SPR 9043            To make auts param in 
 **                                                            icf_ssa_chk_n_append_auts()
 **
 ** 09-Jan 2006        Jyoti Narula        SPR 8054            In 
 **                                                            icf_ssa_make_
 **                                                            contact_of_app_data()
 **                                                            changes done to 
 **                                                            add expires 
 **                                                            parameter in
 **                                                            contact header
 ** 11-Jan-2005     Aman Arora          IPSEC               added code to support IPSEC 
 **                                                         on UDP and TCP
 ** 16-Jan-2006        Priyanka Dua        MPH                    added "make request digest"
 **                                                            utility for MPH
 **
 ** 18-Jan-2006        Jyoti Narula        SPR 9042            New functions 
 **                                                            for fixing the 
 **                                                            duplicity of 
 **                                                            application 
 **                                                            specfied 
 **                                                            tags in 
 **                                                            From/To header.
 **    18-Jan-2006        Aman Arora            SPR 9591            set the correct SDP
 **                                                            in the otg re-invte
 **                                                            for session refresh
 ** 27-Jan-2005        Aman Arora            SPR 9864
 ** 08-Feb-2006     Amit Sharma                             Network PDU Logging API from ICF
 ** 22-Feb-2005        Amit Sharma                             Added code for auth support
 ** 03-Mar-2006     Amit Sharma                             ICF merging with ICF2.0
 ** 07-Mar-2006        Anuradha Gupta        None                Added new CC reasons for rejection of media change req
 ** 02-Apr-2006        Puneet Sharma    ICF5.0 LLD                changes done in the comments 
 **                                                            Multiple Public Users ICF5.0
 **
 ** 31-Mar-2006    Deepti Goyal        ICF 5.0              Message Body Header
 **                                                         Changes.
 **
 ** 25-Apr-2006     Deepti Goyal       SPR 10907             Set the content-type
 **                                                          as application/sdp.
 **                                    SPR 10934             Handling of multiple
 **                                                          message bodies in notify
 **                                                          for refer.
 **                                    SPR 10936             Handling of multipart/mixed
 **                                                          in internal subscribe.
 **
 ** 29-July-2006    Aman Aggarwal       ICF_6_0              Multiple m-lines changes
 **                 Deepti Goyal 
 ** 22-Jun-2006     Umang Singh         Rel 5.2              TLS and SIPS URI additions
 ** 01-Sep-2006     Amit Sharma         SPR:12688
 **
 ** 4-Sep-2006      Deepti Goyal        SPR 12759            Merged Options timer code.
 ** 6-Sep-2006        Deepti Goyal        SPR 12719             Memory Leaks in 
 **                                                             Profile
 ** 6-Sep-2006      Deepti Goyal        SPR 12699            New Reason code for
 **                                                          remote media not
 **                                                          received.
 ** 06-Sep-2006     Umang Singh         SPR 12855         Parsing of Require hdr for 100rel
 ** 08-Sep-2006     Umang Singh         SPR 12918
 ** 27-Nov-2006     Deepti Goyal        ICF Rel 6.2      NAT Feature Support
 ** 11-Dec-2006        Deepti Goyal        SPR 14029         Handling for rport in response updated.
 ** 
 ** 12-Dec-2006     Deepti Goyal        SPR 14034        Update the if condition
 **                                                      check for the initial
 **                                                      rport handling.
 **
 ** 12-Dec-2006     Deepti Goyal        SPR 14036        Handling of sending the 
 **                                                      rport and received in 
 **                                                      response messages updated.
 ** 13-Dec-2006     Deepti Goyal        SPR 14040        Binding Refresh timer 
 **                                                      expiry handling.
 ** 14-Dec-2006     Deepti Goyal        SPR 14063        The binding refresh timer
 **                                                       block is set to NULL, 
 **                                                       after freeing the memory.
 ** 15-Dec-2006     Deepti Goyal        SPR 14076        Memory Leaks in Via 
 **                                                      Header Fixed.         
 ** 28-Dec-2006     Deepti Goyal        SPR 14173        Start the binding refresh 
 **                                                      timer for the user address
 **                                                      stored in the 
 **                                                      rport_config_data   
 ** 20-Nov-2006     Umang Singh         SPR 13794
 ** 20-Nov-2006     Umang Singh         SPR 13861
 ** 23-Nov-2006     Umang Singh         SPR 13894/CSR-1-4022527
 ** 24-Nov-2006     Umang Singh         SPR 13908/CSR-1-3704087
 ** 19-Dec-2006     Puneet Sharma       SPR 14054 added checks for header-value
 **                                    in default and unknown header
 ** 13-Jan-2007     Umang Singh        SPR 14068 
 ** 18-Jan-2007     Umang Singh        SPR 14130
 ** 15-Jan-2006     Abhishek Dhammawat  ICF 6.3          Per Line Feature - Added
 **                                                      For SIP DSCP parameter
 ** 08-JAN-2007    Mohit Sharma     ICF Rel 6.3     Forking and Multianswer support 
 ** 1-Feb-2007     Mohit Sharma        SPR 14411          Modification in del_all_
 **                                                       other_call_obj
 ** 05-Feb-2007    Umang Singh        SPR 14445
 ** 06-Feb-2007    Umang Singh        SPR 14483
 ** 26-Mar-2007    Rajat Chandna                        Added func. icf_ssa_is_update_present_in_allow_hdr
 **                                                     as a part of Update/reinvite enhancement.
 ** 31-Jul-2007    Amit Mahajan       SPR 15164 
 ** 08-JUN-2007    Alok Tiwari        IPTK              Added utility functions for STAT handling.
 ** 09-JUL-2007    Neha Choraria      ICF Rel 7.0       Changes for Forking &
 **                                                     Multiple Answer
 ** 10-Jul-2007    Abhishek Dhammawat SPR14958          modified icf_ssa_populate_address_from_sip_addr_spec
 **                                                     for escape char handling 
 **                                                     in request URI
 ** 13-JUL-2007    Tarun Gupta       CSR 1-4816236/SPR 15269
 **                                                     Added a utility function:
 **                                                     icf_ssa_delete_param_from_addr_spec 
 **                                                     called from icf_ssa_revert_to_udp
 ** 3-OCT-2007     Abhishek Dhammawat SPR16408          Modified
 **                                                     icf_ssa_AppendMsgBodyListToSipMessage
 ** 10-OCT-2007    Abhishek Dhammawat SPR16926          Modified icf_ssa_send_authorized_req
 **                                                     related CSR1-5228570 
 **
 ** 22-Aug-2007    Deepti Goyal      ICF 6.5            Changes for DNS/TCP.
 **                                                     DNS buffer stores listen
 **                                                     ing IP address of server
 **                                                     instead of ephemeral port.
 ** 19-Nov-2007   Abhishek Dhammawat SPR17542           Modified icf_ssa_util_cmp_tags
 ** 28-Nov-2007   Jagmohan Chauhan   SPR17569           Modified icf_ssa_fill_conn_info_from_Via
 ** 05-Dec-2007   Jagmohan Chauhan   SPR17557           To print correct traces for ICF_TRACE_NOTIFY_FOR_SUBS 
 ** 06-Dec-2007   Jagmohan Chauhan   SPR17648           To print traces for out of dailog 
 **                                                     options received from network  
 ** 06-Dec-2007   Jagmohan Chauhan   SPR17649           To print correct trace
 **                                                     for in dialog options sent on network 
 ** 23-Dec-2007   Abhishek Dhammawat SPR17855           Modified icf_ssa_trace 
 **                                                     icf_ssa_validate_content_disp
 ** 16-Jan-2008   Kamini Gangwani    Rel 8.0            Added a utility function 
 **                                                     icf_ssa_parse_p_called_party_id_hdr
 **                                                     to parse the Call party address from 
 **                                                     incoming Sip Message.
 ** 16-Jan-2008   Kamini Gangwani    Rel 8.0            Changes to add P-Acces1.275.2.21.2.25s-Network-
 **                                                     Info in requests and modified fn
 **                                                     icf_ssa_form_and_insert_access_nw_info_hdr.
 ** 22-Jan-2008   Anurag Khare       IPTK 8.0            Changes for DHCP
 **
 ** 17-Jan-2008   Shruti Thakral                        Enhancements for Rel 8.0
 ** 27-Jan-2008   Tarun Gupta        IPTK Rel 8.0 LLD   Changes done for AKA handling.
 ** 27-Jan-2008   Rajiv Kumar        ICF 8.0            Registration Procedure
 **                                                     Enhancement
 ** 27-Jan-2008   Abhishek Dhammawat Rel8.0             Additions for
 **                                                     precondition feature
 ** 08-Mar-2008   Alok Tiwari        Rel8.0          Modified Function
                                                     icf_ssa_map_cc_reason_code
 ** 10-Mar-2008   Alok Tiwari        Rel8.0          Changes done in function
 **                                                  icf_ssa_del_params_in_Via
 **                                                  and icf_ssa_send_to_peer
 **                                               (MLK 252 bytes on TLS fixed)
 ** 13-Mar-2008  Alok Tiwari        Rel8.0        Changes done to resolve crash
 **                                               on NAT for incoming call.
 ** 12-Mar-2008   Abhishek Dhammawat Rel 8.0         Added function
 **                                               icf_ssa_modify_callobj_profile_for_precondition
 ** 13-Mar-2008   Abhishek Dhammawat Rel8.0       Remove precondition from
 **                                               supported list of REGISTER,
 **                                               SUBSCRIBE, OPTIONS request.
 ** 11-Mar-2008   Divij Agarwal     SPR 18122     Support for async AKA 
 **                                               negotiation
 ** 19-Mar-2008   Shruti Thakral    SPR 18248     Klocwork warning removal
 ** 24-Mar-2008   Tarun Gupta       IPTK Rel 8.0  Merged User Param and
 **                                               Dynamic Payload Enhancements
 ** 25-Mar-2008   Shruti Thakral    SPR 18283     Klocwork warning removal
 ** 26-Mar-2008   Shruti Thakral    SPR 18300,    Klocwork warning removal
 **                                     18301,
 **                                     18302,
 **                                     18303
 ** 28-Mar-2008  Tarun Gupta       SPR 18311     Merged Publish-Message Enhancements
 ** 28-Mar-2008  Shruti Thakral    SPR 18316     Klocwork warning removal
 ** 01-Apr-2008  Tarun Gupta       SPR 18238     Modified icf_ssa_parse_p_called_party_id_hdr
 ** 08-Apr-2008  Alok Tiwari       SPR 18364     Klocwork warning removal
 ** 08-Apr-2008  Tarun Gupta       SPR 18355     Merged Windows Porting Changes
 ** 15-Apr-2008 Abhishek Dhammawat SPR18392      Modified
 **                                              icf_ssa_set_to_in_reg_callobj function
 ** 17-Apr-2008 Tarun Gupta        SPR 18446     Changes done for Publish Message in IMS mode
 ** 18-Apr-2008  Alok Tiwari       SPR 18456     Klocwork warning removal
 ** 19-Apr-2008 Abhishek Dhammawat SPR 18435     modified icf_ssa_set_unknown_hdr_in_MimeHdr
 **                                              removed unnecessary memfree
 ** 19-Apr-2008  Alok Tiwari       SPR 18456     Klocwork warning removal
 ** 21-Apr-2008  Alok Tiwari       SPR 18456     Klocwork warning removal
 ** 23-Apr-2008  Alok Tiwari       SPR 18456     Klocwork warning removal
 ** 24-Apr-2008 Abhishek Dhammawat SPR 18452     modified 
 **                                              icf_ssa_validate_join_hdr_and_get_call_id
 ** 27-Apr-2008  Rajiv Kumar       SPR 18463     Adding application/reginfo+xml 
 **                                              in application profile if auto
 **                                              subscription for reg enent is ON.
 ** 29-Apr-2008  Alok Tiwari       SPR 18456     Klocwork warning removal
 ** 01-May-2008  Alok Tiwari       SPR 18120     Function icf_ssa_send_refer_req
 **                                              and icf_ssa_capture_trace
 **                                              modified for TRACE of refer.
 ** 01-May-2008  Amit Sharma       SPR 18390     Fix for IPTK crash in TLS case
 **                                              when Pri-server is not responding
 ** 02-May-2008  Shruti Thakral    SPR 18283     Klocwork warning removal
 **                                SPR 18316
 ** 02-May-2008  Shruti Thakral    SPR 18316     Klocwork warning removal
 ** 06-May-2008  Alok Tiwari       SPR 18503     modified function
 **                                              icf_ssa_remove_conn_entry 
 ** 08-May-2008  Rajiv Kumar       SPR 18517     Changes in
 **                                              icf_ssa_handle_notify_out_of_dialog
 **                                              for handling out of dialog
 **                                              NOTIFY in IMS MODE
 ** 08-May-2008  Amit Sharma       SPR 18390     Klocwork warning removal
 ** 11-May-2008 Abhishek Dhammawat SPR 18535     modified
 **                                              icf_ssa_remove_port_from_address
 ** 11-May-2008  Amit Sharma       SPR 18503     Reinit pending_pdu_length in
 **                                              conn_db
 ** 14-May-2008  Amit Sharma       SPR 18546     Correct trace data for TCP_CONN_OPEN
 **                                              and TCP_CONNECTION_CLOSE
 ** 17-May-2008  Amit Sharma       SPR 18577     Add function which allocates APP context
 **                                              into p_glb_pdb
 ** 23-May-2008  Tarun Gupta       SPR 18585     Modified icf_ssa_make_send_auth_req
 ** 28-May-2008  Tarun Gupta       SPR 18585     Modified icf_ssa_send_options_req
 ** 02-Jun-2008  Tarun Gupta       SPR 18585     Modified icf_ssa_validate_challenge and icf_ssa_handle_chal_resp
 ** 07-Jun-2008  Jagmohan Chauhan  IPTK 8.0 SRTP LLD      SRTP Enhancements
 ** 13-Jun-2008  Tarun Gupta       SPR 18585     Modified icf_ssa_validate_challenge and icf_ssa_set_refresher_method
 ** 18-JUn-2008  Anurag Khare      SPR 18684     Modified for handling Maddr
 ** 18-Jun-2008  Anurag Khare      SPR 18684     CSR 1-5990682 Merge 
 ** 19-Jun-2008  Tarun Gupta       SPR 18686     Modified icf_ssa_send_authorized_req
 ** 20-Jun-2008  Anurag Khare      SPR 18684     CSR 1-6032268 Merge 
 ** 25-Jun-2008 Abhishek Dhammawat IPTK Rel8.0 modified icf_ssa_init_pdb
 **                                            to init qos_call_check
 ** 26-Jun-2008  Amit Sharma      SPR:18725      Populate warning text
 ** 29-Jun-2008  Amit Sharma      SPR:17030      Populate SipParams after converting hex
 ** 1-Jul-2008 Abhishek Dhammawat P-Hdr Enhancement Modified 
 **                                       icf_ssa_form_insert_access_nw_info_hdr
 ** 3-Jul-2008   Tarun Gupta      SPR 18754      Modified icf_ssa_addDefaultHeader
 ** 03-jul-2008  Anurag Khare     SPR 18684      Compilation issue on gcc 4.2.3
 ** 4-Jul-2008   Tarun Gupta      SPR 18749      Added handling for SIPS preferred identity
 ** 08-Jul-2008  Anuradha Gupta   SPR 18795      In case of message retransmissions , the 
 **                                              ssa context in ssa pdb was getting modified
 ** 08-Jul-2008 Abhishek Dhammawat SPR 18769      Modified
 **                                              icf_ssa_extract_challenge
 ** 09-July-2008 Amit Sikka        SPR 18782     Klocwork Warning removal
 ** 10-Jul-2008 Abhishek Dhammawat SPR 18630     Modified 
 **                                              icf_ssa_init_pdb
 ** 16-Jul-2008  Anuradha Gupta   SPR 18814      Insert warning header only when sending
 **                                              a response message. Check have been added
 ** 17-Jul-2008  Anuradha Gupta   SPR 18767      Modifed icf_ssa_init_pdb for p_ecode
 ** 17-Jul-2008 Abhishek Dhammawat SPR 18815/18724 Modified
 **                                             icf_ssa_validate_content_disp 
 ** 18-Jul-2008  Anuradha Gupta   SPR 18803      Modifed prototype for 
 **                                                 icf_ssa_fill_conn_info_from_Via
 ** 22-Jul-2008  Anuradha Gupta   SPR 18786      Modified the function icf_ssa_find_
 **                                              registrar_address_list for memory leak
 ** 24-July-2008 Anuradha Gupta   SPR 18830      New function 
 **                                              icf_ssa_set_transport_scheme_in_transaction 
 **                                              added for settign the transport scheme.
 ** 04-Nov-2008  Tarun Gupta      SPR 19189      Merged Rel 7.1.2 SPR 18880
 ** 03-Nov-2008  Rajiv Kumar      SPR 19188      Rel 7.1.2 SPR merging (SPR
 **                                              19143)
 ** 04-Nov-2008 Abhishek Dhammawat SPR 19189     Merge the SPR 188461.275.2.21.2.25
 ** 04-Nov-2008 Rajiv Kumar        SPR 19188     Rel 7.1.2 SPR merging (SPR
 **                                              19156)
 ** 05-Nov-2008 Tarun Gupta        SPR 19189     Merged Rel 7.1.2 SPR 19013
 ** 05-Nov-2008 Rajiv Kumar        SPR 19188     Rel 7.1.2 SPR merging (SPR
 **                                              18867)
 ** 06-Nov-2008 Abhishek Dhammawat SPR 19189     Merge the SPR 18879
 ** 07-Nov-2008 Tarun Gupta        SPR 19189     Merged Rel 7.1.2 SPR 18999
 ** 10-Nov-2008 Anuradha Gupta     SPR 19188     Rel 7.1.2 SPR Merging
 ** 12-Nov-2008 Tarun Gupta        SPR 19189     Merged Rel 7.1.2 SPR 18872
 ** 17-Nov-2008 Tarun Gupta        SPR 19189     Merged Rel 7.1.2 SPR 19007
 ** 17-Nov-2008 Rajiv Kumar        SPR 19188     Rel 7.1.2 SPR merging (SPR
 **                                              18885) 
 ** 17-Nov-2008 Rajiv Kumar        SPR 19188     Rel 7.1.2 SPR merging (SPR
 **                                              19139) 
 ** 19-Nov-2008 Rajiv Kumar        SPR 19188     Rel 7.1.2 SPR merging (SPR
 **                                              18918) 
 ** 20-Nov-2008 Abhishek Dhammawat SPR 19189     Merge SPR 18882 
 ** 21-Nov-2008 Rajiv Kumar        SPR 19188     Rel 7.1.2 SPR merging (SPR
 **                                              18988)  
 ** 24-Nov-2008 Abhishek Dhammawat SPR 19189     Merge SPR 18882 cycle2
 ** 26-Nov-2008 Abhishek Dhammawat SPR 19189     Merge SPR 18882 cycle4
 ** 27-Nov-2008 Tarun Gupta        SPR 19218     Merged CSR 1-6223345
 ** 27-Nov-2008 Rajiv Kumar        SPR 19215     CSR-1-6250701 Merged
 ** 01-Dec-2008 Rajiv Kumar        SPR 19188     Rel 7.1.2 SPR merging (SPR
 **                                              19066)  
 ** 01-Dec-2008 Rajiv Kumar        SPR 19215     CSR-1-6212448 Merged
 ** 03-Dec-2008 Tarun Gupta        SPR 19218     Merged CSR 1-6188936
 ** 04-Dec-2008 Tarun Gupta        SPR 19218     Merged CSR 1-6178201
 ** 04-Dec-2008 Rajiv Kumar        SPR 19218     CSR-1-6369301 Merged
 ** 08-Dec-2008 Tarun Gupta        SPR 19218     Merged CSR 1-6458139
 ** 08-Dec-2008 Rajiv Kumar        SPR 19218     CSR-1-6421580 Merged
 ** 08-Dec-2008 Rajiv Kumar        SPR 19218     Merged CSR 1-6431768
 ** 09-Dec-2008 Anurag Khare       SPR 19218     CSR 1-6179301 Merged
 ** 10-Dec-2008 Tarun Gupta        SPR 19218     Merged UATK CSR 1-6613911,
 **                                              CSR 1-6457307
 ** 11-Dec-2008 Anurag Khare       SPR 19218     CSR 1-6456839 Merged
 ** 12-Dec-2008 Rajiv Kumar        SPR 19218     Merged CSR 1-6240518
 ** 12-Dec-2008 Tarun Gupta        SPR 19218     Merged SPR 18097
 ** 15-Dec-2008 Anurag Khare       SPR 19218     SPR 18901 Merged
 ** 18-Dec-2008 Rajiv Kumar        SPR 19218     Merged CSR 1-6102712
 ** 29-Jan-2009 Alok Tiwari        Rel_8.1       compilation warning resolved
 **                                after enabling the flag SDF_THREAD_SAFE and
 **                                SIP_LOCKEDREFCOUNT.
 ** 12-Feb-2009 Rajiv Kumar        Rel 8.1       Changes done for handling
 **                                              icf_tunnelled_sdp_info_st
 ** 13-Feb2009  Anurag Khare       ICF Rel 8.1   Supported content type enhancements
 ** 13-Feb-2009 Alok Tiwari        Rel 8.1      Changes done to handle request
 **                                        with Pres URL/IM URL in request URI.   
 ** 13-Feb-2009 Ashutosh Mohan     Rel8.1       Changes done to handle 415/488 for tunnel mode
 ** 16-Feb-2009 Anurag Khare       Rel 8.1      Call modify Enhancements in
 **                                             forking scenario.
 ** 16-Feb-2009 Abhishek Dhammawat Rel 8.1      SDP Tunnelling feature
 ** 17-Feb-2009 Tarun Gupta        Rel 8.1      Modified icf_ssa_send_subscribe_req : 
 **                                             Klokworks warning resolution
 ** 17-Feb-2009 Alok Tiwari        Rel 8.1      Modified function 
 **                                     icf_ssa_send_register_req_with_auth :
 **                                             Klokworks warning resolution 
 ** 17-Feb-2009 Anurag Khare       Rel 8.1      KlocWorks Warning Resolution
 ** 18-Feb-2009 Rajiv Kumar        Rel 8.1      Klokworks warning resolution 
 ** 18-Feb-2009 Rajiv Kumar        Rel 8.1      Klokworks warning resolution
 ** 02-Mar-2009 Alok Tiwari        Rel 8.1      Changes done to replace the 
 **                                             open source Digest APIs invocation with
 **                                             aDigest API and removal of Base-64 API invocation
 ** 02-Mar-2009 Anurag Khare      Rel 8.1       Function modified
 **                                             icf_ssa_set_tunneled_sdp_in_sdpmessage
 ** 02-Mar-2009     Alok Tiwari      IPTK Rel8.1 IPTK open source replacement:
 **                                              Data related to ares has
 **                                              been removed.
 ** 04-Mar-2009 Saurabh Gupta	 SPR 19349       Klocworks fix		
 ** 13-Mar-2009 Rajiv Kumar      IPTK Rel8.1     Merging CSR-1-6452321
 ** 15-Mar-2009 Anuradha Gupta   IPTK Rel8.1     Timer Enhancements
 ** 17-Mar-2009 Saurabh Gupta	 SPR 19349      Klocworks fix		
 ** 18-Mar-2009 Alok Tiwari      IPTK Rel8.1     Registration Enhancement(
 **                                              Multiple Contact Feature)
 ** 18-Mar-2009 Rajiv Kumar      IPTK Rel8.1     UT Defect Fix   
 ** 19-Mar-2009 Alok Tiwari      IPTK Rel 8.1    New Function added
 **                           icf_ssa_extract_contact_list_from_register_resp 
 ** 20-Mar-2009 Anuradha Gupta   IPTK Rel 8.1     UT Defect Fix   
 ** 20-Mar-2009 Alok Tiwari      IPTK Rel 8.1    UT issue fixed.
 ** 21-Mar-2009 Tarun Gupta      Rel 8.1         Modified
 **                                              icf_ssa_get_tunneled_sdp_from_sdpmessage
 ** 22-Mar-2009 Anuradha Gupta   IPTK Rel 8.1     UT Defect Fix 
 ** 30-Mar-2009 Anurag Khare     Rel 8.2         Changes done for PRACK Enh
 ** 31-Mar-2009 Tarun Gupta      Rel 8.2         REFER/NOTIFY Enhancements1.275.2.21.2.25
 ** 31-Mar-2009 Rajiv Kumar      SPR 19307       Fix For SPR: 19307  
 ** 31-Mar-2009 Rajiv Kumar      SPR 19315       Fix For SPR: 19315  
 ** 31-Mar-2009 Rajiv Kumar      SPR 19312       Fix For SPR: 19312  
 ** 31-Mar-2009 Alok Tiwari      IPTK Rel 8.2    New Functions added:
 **                           icf_ssa_form_and_insert_security_agreement_hdrs
 **                           icf_ssa_extract_n_populate_security_server_hdr
 ** 06-Apr-2009 Alok Tiwari      IPTK Rel 8.2    UT defect fixed.
 ** 06-Apr-2009 Rajiv Kumar      SPR 19423       Klocwork Warning Fix. 
 ** 19-Apr-2009 Abhishek Dhammawat SPR 19465     Modified
 **                                              icf_ssa_get_tunneled_sdp_from_sdpmessage
 ** 21-Apr-2009 Abhishek Dhammawat SPR 19476     Modified
 **                                              icf_ssa_populate_app_specific_hdrs
 ** 22-Apr-2009 Anuradha Gupta     SPR 19436     Modified icf_ssa_update_dialog_for_sec_addr
 ** 23-Apr-2009 Abhishek Dhammawat SPR 19502     Moved icf_ssa_map_interface_reason_code
 **                                              as icf_cmn_map_interface_reason_code
 ** 24-Apr-2009 Tarun Gupta        SPR 19481     Added icf_ssa_fetch_and_remove_txn_key
 ** 01-May-2009 Anuradha Gupta     SPR 19535     Modified fn icf_ssa_send_failure_to_app_module
 ** 02-May-2009 Rajiv Kumar        SPR 19531     Klocwork Fix
 ** 02-May-2009 Abhishek Dhammawat SPR 19571     Codenomicon Fix merge
 ** 05-Apr-2009 Rajiv Kumar        IPTK Rel8.2   Fix for SPR: 19593
 ** 05-May-2009 Rajiv Kumar        SPR 19531     Klocwork Fix
 ** 06-May-2009 Abhishek Dhammawat SPR 19574      Modified
 **                                              icf_ssa_find_matching_ssa_ctx
 ** 12-May-2009 Kamal Ashraf       SPR 19604     Modified icf_ssa_insert_rport_params_in_via
 ** 12-May-2009 Anuradha Gupta     SPR 19601     Modified icf_ssa_initiate_dispatch_sequence
 ** 18-May-2009 Anuradha Gupta    SPR 19672     CSR_1-6347417 merging
 ** 18-May-2009 Ashutosh Mohan     CSR-1-6896295 Modified icf_ssa_parse_require_header
 ** 20-May-2009 Kamal Ashraf       SPR 19672     CSR_1_7027627 Merged 
 ** 21-May-2009 Kamal Ashraf       SPR 19672     CSR_1_7199359 Merged
 ** 22-May-2009 Kamal Ashraf       SPR 19672     CSR_1_6763883 Merged
 ** 22-May-2009 Kamal Ashraf       SPR 19672     CSR_1_7113244 Merged
 ** 25-May-2009 Kamal Ashraf       SPR 19672     SPR 19519 Merged 
 ** 25-May-2009 Ashutosh Mohan     SPR 19672     CSR-1-6967056 Modified 
 **                                              icf_ssa_populate_address_from_sip_addr_spec
 ** 25-May-2009 Rajiv Kumar        SPR 19666     Fix For SPR: 19666 
 ** 26-May-2009 Anuradha Gupta     SPR 19672     CSR 1-6727350 merging
 ** 28-May-2009 Tarun Gupta        Rel 8.2       Async NOTIFY Support
 ** 29-May-2009 Ashutosh Mohan     SPR 19672     CSR-1-6797427 Merged
 ** 
 ** 10-Jun-2009 Kamal Ashraf       SPR 19590     Added icf_ssa_get_msg_body_frm_sip_message_
 **                                              in_call_ctx and modified icf_ssa_set_to_in_callobj
 ** 10-Jun-2009 Abhishek Dhammawat SPR 19590     header list overwrite enh
 ** 12-Jun-2009 Tarun Gupta        Rel 8.2       Modified icf_ssa_populate_app_specific_hdrs
 ** 11-Jun-2009 Ashutosh Mohan     SPR 19737     Changes done for GCC 4.1 warnings removal
 ** 14-Jun-2009 Abhishek Dhammawat SPR 19590     header list overwrite enh
 ** 18-Jun-2009 Rajiv Kumar        Rel 8.2       Fix For SPR 19494
 ** 19-Jun-2009 Abhishek Dhammawat SPR 19590     header list overwrite enh
 ** 19-Jun-2009 Anuradha Gupta     SPR 19746     Modified icf_ssa_populate_app_specific_hdrs
 ** 22-Jun-2009 Anuradha Gupta     SPR 19768     Modified icf_ssa_session_timer_toggle
 ** 22-Jun-2009 Abhishek Dhammawat SPR 19769     resolved warnings in VxWorks
 ** 29-Jun-2009 Abhishek Dhammawat SPR 18928     Modified
 **                                              icf_ssa_clear_options_context 
 ** 30-Jun-2009 Abhishek Dhammawat SPR 19794     Modified icf_ssa_error
 ** 13-Jul-2009 Rajiv Kumar        IPTK Rel 8.2  Openssl Removal
 ** 16-Jul-2009 Tarun Gupta        SPR 19858     Modified icf_ssa_start_binding_refresh_timer
 ** 21-Jul-2009 Anuradha Gupta     SPR 18906     Added new fn icf_ssa_handle_parser_error
 ** 28-Jul-2009 Rajiv Kumar        SPR 19886     Merged CSR-1-7297673
 ** 29-Jul-2009 Tarun Gupta        SPR 19886     Merged CSR 1-7233780
 ** 29-Jul-2009 Tarun Gupta        SPR 19886     Merged CSR 1-7436288
 ** 30-Jul-2009 Anuradha Gupta     SPR 19776     Modified fn 
 **                                               icf_ssa_make_profile_for_internal_subscribe
 ** 30-Jul-2009 Anuradha Gupta     UT Defect     Modified fn icf_ssa_send_refer_req
 ** 30-Jul-2009 Rajiv Kumar        SPR 19886     Merged CSR 1-7226823 
 ** 30-Jul-2009 Rajiv Kumar        SPR 19886     Merged CSR 1-7334757  
 ** 31-Jul-2009 Rajiv Kumar        SPR 19886     Merged CSR 1-7329950  
 ** 02-Aug-2009 Rajiv Kumar        SPR 19886     Merged CSR 1-7444867 
 ** 02-Aug-2009 Rajiv Kumar        SPR 19886     Merged SPR 19839/19842
 ** 03-Aug-2009 Tarun Gupta        SPR 19886     Merged CSR 1-7334184
 ** 04-Aug-2009 Abhishek Dhammawat SPR 19886     Modified
 **                                              icf_ssa_insert_header_list_in_sip_msg
 ** 14-Aug-2009 Tarun Gupta        SPR 19928     Modified icf_ssa_extract_challenge
 ** 17-Aug-2009 Tarun Gupta        SPR 19933     Modified icf_ssa_is_alias_present_in_Via
 ** 17-Aug-2009 Anuradha Gupta     SPR 19927     klocworks warning removal
 ** 18-Aug-2009 Abhishek Dhammawat SPR 19917     Modified
 **                                              icf_ssa_get_msg_body_frm_sip_message_in_call_ctx
 ** 20-Aug-2009 Anuradha Gupta     SPR 19917     GCC Warning Removal
 ** 21-Aug-2009 Tarun Gupta        SPR 19935     Modified 
 **                                              icf_ssa_get_tunneled_sdp_from_sdpmessage
 ** 25-Aug-2009 Abhishek Dhammawat SPR 19953     Modified
 **                                          icf_ssa_extract_contact_list_from_register_resp
 ** 03-Sep-2009 Rajiv Kumar        SPR 19999     Merged CSR 1-7413863
 ** 03-Sep-2009 Rajiv Kumar        SPR 19999     Merged CSR 1-7615941 
 ** 31-Aug-2009 Rajiv Kumar        SPR 19999     Merged CSR 1-7502322
 ** 03-Sep-2009 Anuradha Gupta     SPR 19999     Modified icf_ssa_get_conn_db
 **
 ** 04-Sep-2009 Preksha            SPR 19999     Merged SPR 19805
 ** 04-Sep-2009 Preksha            SPR 19999     Merged CSR 1-7586154 
 ** 04-Sep-2009 Rajiv Kumar        SPR 19999     Merged CSR 1-7471533
 ** 08-Sep-2009 Rajiv Kumar        SPR 19999     Merged CSR 1-7586127
 ** 09-Sep-2009 Preksha            SPR 19999     Merged SPR 19924
 ** 11-Sep-2009 Rajiv Kumar        SPR 19999     Merged CSR 1-7547597
 ** 12-Sep-2009 Rajiv Kumar        SPR 19999     Merged CSR 1-7467002
 ** 15-Sep-2009 Anuradha Gupta     SPR 19999     Merged CSR 1-7618644
 **
 ** 15-Sep-2009 Rajiv Kumar        SPR 19999     Merged CSR 1-7605218
 ** 15-Sep-2009 Abhishek Dhammawat SPR 20048     Modified
 **                                           icf_ssa_find_registrar_address_list
 ** 16-Sep-2009 Anuradha Gupta     SPR 19999     Merged CSR 1-7473533
 ** 16-Sep-2009 Rajiv Kumar        SPR 19999     Merged CSR 1-7615966
 ** 22-Sep-2009 Preksha            SPR 19999     Merged SPR 20043
 ** 23-Sep-2009 Tarun Gupta        SPR 20063     Merged CSR 1-7680323
 ** 07-Oct-2009 Tarun Gupta        SPR 20097     Modified icf_ssa_parse_require_header
 ** 07-Oct-2009 Rajiv Kumar        SPR 20110     Fix for SPR:20110
 ** 08-Oct-2009 Abhishek Dhammawat SPR 20063     Merged CSR 1-7407479
 ** 08-Oct-2009 Abhishek Dhammawat SPR 20063     Merged CSR 1-7507275
 ** 14-Oct-2010 Rajiv Kumar        SPR 20135     Fix for SPR: 20135  
 ** 15-Oct-2009 Anuradha Gupta     SPR 20121     Vxworks compilation issue resolved
 ** 20-Oct-2009 Anuradha Gupta     SPR 20158     Modified icf_ssa_start_session_timer
 ** 21-Oct-2009 Anurag Khare       SPR 20172     Modifed function 
 **                                              icf_ssa_validate_join_header_and_get_call_id
 ** 27-Oct-2009 Anuradha Gupta     SPR 20174     Modified icf_ssa_handle_register_response_for_rport
 ** 27-Oct-2009 Anuradha Gupta     SPR 20195     Modified icf_ssa_session_timer_toggle
 ** 27-Oct-2009 Rajiv Kumar        SPR 20192     Fix For SPR:20192
 ** 28-Oct-2009 Abhishek Dhammawat SPR 20197     Merged coverity fix
 ** 29-Oct-2009 Abhishek Dhammawat SPR 20193     Modified icf_ssa_start_session_timer
 ** 31-Oct-2009 Anuradha Gupta     SPR 20202     Modified icf_ssa_parse_p_early_media_hdr
 ** 04-Mar-2010  Rohit Aggarwal	SPR 20317	Add Replaces header when INVITE with
 **											Replaces is challenged
 ** 07-May-2010 Aman Aggarwal      SPR 20391    Merged fixes in CSR 1-8561947
 ** 25-May-2010 Preksha            SPR 20412    Merged CSR 1-8389294
 ** 28-May-2010 Preksha            SPR 20412    Merged CSR 1-7991608
 ** 29-May-2010 Alok Tiwari        SPR 20412    Merged CSR 1-8223807
 ** 11-Oct-2010 Sachin Sharma      SPR 20697   CSR 1-9012191 Fixed.
 ** 25-Jan-2013 Pratishtha         Bug273        Fix for CSR 00024478
 *****************************************************************************
 **                 Copyrights 2013, Aricent.
 *****************************************************************************/

/*Message body header changes Start*/
#define SIP_MIME_PARSING
/*Message body header changes Ends*/
#include "icf_feature_flags.h"
#include "icf_tunnelled_media.h"
#include "stack_headers.h"
#include "uatk_headers.h"

#include "icf_internal_api_id.h"
#include "icf_common_types.h"
#include "icf_common_defs.h"



#include "icf_common_prototypes.h"

#ifdef ICF_DNS_LOOKUP_ENABLED
#include "sdf_lookup.h"
#endif

#include "icf_port_prototypes.h"
#include "icf_macro.h"
#include "icf_ssa_prototypes.h"
#include "icf_ssa_macro.h"
#include "icf_common_prototypes.h"
#include "icf_dbm_prototypes.h"
#include "icf_regm_types.h"
#include "icf_regm_prototypes.h"
#include "icf_dbm_regm_prototypes.h"

#include "icf_ssa_common_types.h"
#include "icf_cfg_defs.h"

#ifdef ICF_IPSEC_ENABLED
#include "icf_port_intf_prototypes.h"
#endif

#include "icf_ecode.h"
/*Fix for CSR 1-7160359: SPR 19509 */
#include "icf_utils.h"
#ifdef ICF_PORT_WINDOWS
#pragma warning(disable:4701)
#pragma warning ( disable : 4702 )
#endif


/* Global defintion of persistent global pdb */
extern icf_glb_pdb_st        *p_persistent_glb_pdb;

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_initiate_dispatch_sequence
 * DESCRIPTION:  1.This function is the last stop before invocation of 
* SendCallToPeer API. It expects that p_ssa_pdb contains pointer to 
* glb_pdb, global cfg data and global ssa data
*       The function does following steps:
*       1. sets options field for compaction of msg if required
        2. set the conn FD in all transactions in case of TCP/TLS call
        3. Invokes Send Call To Peer
        4. In case of IPSEC checks if count of number of transctions on the SA
                need to be increased or decreased
 ***************************************************************************/
icf_return_t icf_ssa_initiate_dispatch_sequence(
        icf_ssa_pdb_st          *p_ssa_pdb,
        Sdf_st_callObject               *p_call_obj,
        Sdf_st_transaction              *p_txn,
        Sdf_st_overlapTransInfo         *p_overlap_txn,
    Sdf_st_eventContext         *p_event_context,
        icf_error_t             *p_ecode)
{

        Sdf_st_transportInfo 		*p_dest_Info = Sdf_co_null;
        Sdf_st_transportInfo 		*p_temp_dest_Info = Sdf_co_null;
       icf_return_t    ret_val = ICF_SUCCESS;
        icf_ssa_ctxt_st  *p_ssa_ctxt =
                (icf_ssa_ctxt_st*)(p_call_obj->pAppData->pData);
        Sdf_ty_s8bit        *p_method = Sdf_co_null;

#ifdef ICF_NAT_RPORT_SUPPORT
    icf_rport_config_data_st            *p_rport_config_data = ICF_NULL;
#endif

#ifdef ICF_IPSEC_ENABLED
        icf_config_data_st    *p_cfg_data = p_ssa_pdb->p_glb_cfg_data;
        icf_uint8_t            *pTemp = ICF_NULL;
#endif
        SipOptions      options = {0};
        SipMessage      *p_sip_msg = SIP_NULL;
        en_SipMessageType       dReqRespType;
        SipError        sip_error;
/*UMR Fix*/
        Sdf_st_error    sdf_error = {0,0,0,"\0"};
        icf_line_data_st    *p_line_data = ICF_NULL;
        icf_line_id_t        line_id = ICF_INVALID_LINE_ID;
        icf_config_data_st        *p_config_data = ICF_NULL;

        /* Fix for SPR 20412: CSR 1-8223807 merged*/
        Sdf_ty_s8bit     *p_remove_hdr_list = ICF_NULL;
        icf_return_t      dummy_ret_val = ICF_SUCCESS;

        ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

        p_ecode = p_ecode;

        options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM|SIP_OPT_RETRANSCALLBACK;

        /* Changes done for CSR 1-7413863 is applicable to NON-IMS mode only,In
         * IMS mode bitmask ICF_SSA_REGISTRAR_ADDR_PRESENT_IN_ROUTE_HEADER is
         * not set.*/ 
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_FALSE)        
        /* Fix for SPR: 19999(Merged CSR 1-7413863: SPR-19883 fixed)*/
        /* Set the dOption as SIP_OPT_REMOVEROUTE to remove the route header
         * which contains the Registrar address.
         */
        if(ICF_SSA_REGISTRAR_ADDR_PRESENT_IN_ROUTE_HEADER == 
             (ICF_SSA_REGISTRAR_ADDR_PRESENT_IN_ROUTE_HEADER & 
                                            p_ssa_ctxt->bitmask_1))
        {
           options.dOption |= SIP_OPT_REMOVEROUTE;
        }        
        /* Reset the ICF_SSA_REGISTRAR_ADDR_PRESENT_IN_ROUTE_HEADER bit.*/
        ICF_RESET_BIT(p_ssa_ctxt->bitmask_1,
                ICF_SSA_REGISTRAR_ADDR_PRESENT_IN_ROUTE_HEADER);
ICF_CHECK_IMS_END

        /* SipMessage retreival starts*/
        if (ICF_NULL != p_overlap_txn)
        {
            /*overlap transaction*/
            p_sip_msg = p_overlap_txn->pSipMsg;
        }
        else if ( Sdf_co_null != p_txn)
        {
                p_sip_msg = p_txn->pSipMsg;
        }
        else
        {
            return ICF_FAILURE;
        } 
        if ( SIP_NULL == p_sip_msg)
        {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in SipMsg retreival from DnsEvtCtxt"));
                ret_val = ICF_FAILURE;
        }
        /* SipMessage retreival end*/

        if ( (ICF_FAILURE != ret_val) &&
                (SipFail != sip_getMessageType(p_sip_msg,
                &dReqRespType, &sip_error)))
        {
            if (SipMessageRequest == dReqRespType)
            {
                p_ssa_pdb->p_conn_table_entry = p_ssa_pdb->p_ssa_ctxt->p_conn_table_req_entry;
            }
            else
            {
                p_ssa_pdb->p_conn_table_entry = p_ssa_pdb->p_ssa_ctxt->p_conn_table_resp_entry;
            }
 
            if (ICF_NULL != p_txn)
            {
                p_temp_dest_Info = p_txn->pDestInfo;
            }
            /*Klocwork warning removal*/
            else if (ICF_NULL != p_overlap_txn)
            {
                p_temp_dest_Info = p_overlap_txn->pDestInfo;
            }

            if ((ICF_NULL != p_ssa_pdb->p_conn_table_entry) && ((0 != 
                icf_port_strcmp((icf_uint8_t *)p_temp_dest_Info->pIp, (icf_uint8_t *)p_ssa_pdb->p_conn_table_entry->peer_ip)) || 
                (p_temp_dest_Info->dPort != p_ssa_pdb->p_conn_table_entry->peer_port_num)))
            {
                /*p_txn->dSocket.dSockfd = Sdf_co_InvalidSocketFd;*/
                p_ssa_pdb->p_conn_table_entry = ICF_NULL;
            }

                /* Check the configuration and determine if the headers are 
                   to be sent in full form or short form */
                if(0 != p_ssa_pdb->p_glb_cfg_data->sip_compact_hdrs)
                {
                        /* Compact headers is on, use the compact form */
                        options.dOption &= ~SIP_OPT_FULLFORM; /* Unset fullform bit */
                        options.dOption |= SIP_OPT_SHORTFORM; /* Set Shortform bit */
                }
                /*Set the TCP connection FD in the transaction structures of callObj*/
                if (( ICF_SSA_TCP_TRANSPORT ==
                                        (ICF_SSA_TCP_TRANSPORT & p_ssa_ctxt->bitmask) ||
                                        (ICF_SSA_TLS_TRANSPORT ==
                                         (ICF_SSA_TLS_TRANSPORT & p_ssa_ctxt->bitmask))))
                {
                        /*Here we are populating the current transaction's SockFd
                         * with the one in the ConnDb,  if there is one,if not
                         * we reset it to an invalid value so taht UATK attempts a 
                         * connect by itself*/
                        icf_uint16_t fd;
                        Sdf_st_listIterator dListIterator;
                        if ( ICF_NULL == p_ssa_pdb->p_conn_table_entry)
                        {       
                                fd = Sdf_co_InvalidSocketFd;
                        }
                        else
                        {
                                fd = p_ssa_pdb->p_conn_table_entry->conn_fd;
                        }
                        if ( ICF_NULL != p_call_obj->pUasTransaction)
                        {
                                p_call_obj->pUasTransaction->dSocket.dSockfd = fd;
#ifdef ICF_SECURE_SUPPORT                
                                if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
                                {
                                        p_call_obj->pUasTransaction->dSocket.dProtocol = Sdf_en_protoTls;
                                }
                                else
                                {
#endif                    
                                        p_call_obj->pUasTransaction->dSocket.dProtocol = Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
                                }
#endif                    
                        }
                        if ( ICF_NULL != p_call_obj->pUacTransaction)
                        {
                                p_call_obj->pUacTransaction->dSocket.dSockfd = fd;
#ifdef ICF_SECURE_SUPPORT                
                                if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
                                {
                                        p_call_obj->pUacTransaction->dSocket.dProtocol = Sdf_en_protoTls;
                                }
                                else
                                {
#endif                    
                                        p_call_obj->pUacTransaction->dSocket.dProtocol = Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
                                }
#endif                    
                        }
                        sdf_listInitIterator(&(p_call_obj->slOverlapTransInfo), \
                                        &dListIterator, &sdf_error);

                        while (dListIterator.pCurrentElement != Sdf_co_null)
                        {
                                Sdf_st_overlapTransInfo *pOverlapTransInfo;

                                pOverlapTransInfo = (Sdf_st_overlapTransInfo *) \
                                        (dListIterator.pCurrentElement->pData);
                                if ( Sdf_co_null != pOverlapTransInfo)
                                {
                                        pOverlapTransInfo->dSocket.dSockfd = fd;
#ifdef ICF_SECURE_SUPPORT                
                                        if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
                                        {
                                                pOverlapTransInfo->dSocket.dProtocol = Sdf_en_protoTls;
                                        }
                                        else
                                        {
#endif                    
                                                pOverlapTransInfo->dSocket.dProtocol = Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
                                        }
#endif                    
                                }
                                sdf_listNext(&dListIterator, &sdf_error);
                        }

                }/*end of loop for filling FD in the transaction structures*/
        if ( ICF_NULL != p_ssa_ctxt->p_call_ctxt)
        {
            line_id = p_ssa_ctxt->p_call_ctxt->line_id;
        }
        else if ( ICF_NULL != p_ssa_ctxt->p_sic_ctxt)
        {    
            line_id = p_ssa_ctxt->p_sic_ctxt->line_id;

            /* Fix for SPR 20412: CSR 1-8223807 merged*/
            if(ICF_NULL != p_ssa_ctxt->p_sic_ctxt->p_remove_hdrs)
            {
              ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                      icf_port_strlen((icf_uint8_t *)p_ssa_ctxt->p_sic_ctxt->p_remove_hdrs) + 1,
                      ICF_MEM_COMMON,
                      p_remove_hdr_list,
                      ICF_RET_ON_FAILURE,
                      p_ssa_pdb->p_ecode,
                      ret_val);
              icf_port_strcpy(p_remove_hdr_list,
                           p_ssa_ctxt->p_sic_ctxt->p_remove_hdrs);
            }
        }
        else if((ICF_NULL != p_ssa_ctxt->p_rgm_ctxt) && ((p_ssa_ctxt->p_rgm_ctxt->num_of_lines-1) < ICF_MAX_NUM_OF_LINES) && ((p_ssa_ctxt->p_rgm_ctxt->num_of_lines-1) >= 0))
        {
            line_id = p_ssa_ctxt->p_rgm_ctxt->rgm_list_of_lines[p_ssa_ctxt->p_rgm_ctxt->num_of_lines-1];
        }


        if (ICF_SUCCESS ==
           icf_dbm_fetch_line_cntxt_blk(
           p_ssa_pdb->p_glb_pdb, line_id,
           (icf_line_data_st **)(&p_line_data),
           p_ecode))
        {
             p_event_context->dTimerOption |= SIP_OPT_TIMER_T1;
             p_event_context->dTimerOption |= SIP_OPT_TIMER_F;
             p_event_context->dTimerOption |= SIP_OPT_TIMER_B;
             p_event_context->dTimerOption |= SIP_OPT_TIMER_T2;
             p_event_context->dTimerOption |= SIP_OPT_TIMER_H;
             p_event_context->dTimerOption |= SIP_OPT_TIMER_I;
             p_event_context->dTimerOption |= SIP_OPT_TIMER_K;

             p_event_context-> dTimeoutValues.dT1 =
                  p_line_data->sip_timer_t1;

             p_event_context-> dTimeoutValues.dT2 =
                  p_line_data->sip_timer_t2;

             p_event_context-> dTimeoutValues.dTimerB =
                  p_line_data->sip_timer_invite;

             p_event_context-> dTimeoutValues.dTimerF_T3 =
                  p_line_data->sip_timer_non_invite;

             p_event_context-> dTimeoutValues.dTimerH =
                  p_line_data->sip_timer_t1 * 64;

             p_event_context-> dTimeoutValues. dTimerI_T4 =
                  p_line_data->sip_timer_t4;

             p_event_context-> dTimeoutValues. dTimerK_T4 =
                  p_line_data->sip_timer_t4;

             /*Changes for CSR 1-7334184 Start */
             /* If remove_route_hdr is TRUE, set the option with
             * SIP_OPT_REMOVEROUTE which will be used by STACK 
             * in API sdf_ivk_uaSendCallToPeer to strip route 
             * header from outgoing requests.   
             */
             if(ICF_TRUE == p_line_data->remove_route_hdr)
             {
                  options.dOption |= SIP_OPT_REMOVEROUTE;    
             }
             /*Changes for CSR 1-7334184 End */
        }

#ifdef ICF_DNS_LOOKUP_ENABLED

        /* DNS-Buffer code starts here-- this code is for making the retries
		   configurable iff line data is filled with default values */ 

        if(p_event_context-> dTimeoutValues.dT1 == ICF_CFG_DEF_SIP_TIMER_T1 &&

                p_event_context-> dTimeoutValues.dT2 == ICF_CFG_DEF_SIP_TIMER_T2 &&

                p_event_context->dTimeoutValues.dTimerB == ICF_CFG_DEF_SIP_TIMER_INVITE &&

                p_event_context->dTimeoutValues.dTimerF_T3 == ICF_CFG_DEF_SIP_TIMER_NON_INVITE)

        {



            if(ICF_FAILURE == icf_dbm_get_module_glb_data(

                        p_ssa_pdb->p_glb_pdb,

                        (icf_int_module_id_t)ICF_INT_MODULE_CFG,

                        (icf_void_t *)&p_config_data, p_ecode))

            {

                /* didn't get the config data can't make the retry to be configurable

                   raise the error */

            }

            else if (ICF_NULL != p_config_data )

            {

                p_event_context->dTimerOption |= SIP_OPT_TIMER_T1;

                p_event_context->dTimerOption |= SIP_OPT_TIMER_F;

                p_event_context->dTimerOption |= SIP_OPT_TIMER_B;

                p_event_context->dTimerOption |= SIP_OPT_TIMER_T2;

                p_event_context->dTimeoutValues.dT1= ICF_CFG_DEF_SIP_TIMER_T1; /* default value */

                /* for NON-Invite x-saction */

                p_event_context->dTimeoutValues.dTimerF_T3=  

                    (icf_ssa_dns_2_pow(p_config_data->sip_req_retry)) * p_event_context->dTimeoutValues.dT1; 

                /* for INvite X-saction */

                p_event_context->dTimeoutValues.dTimerB= 

                    (icf_ssa_dns_2_pow(p_config_data->sip_req_retry)) * p_event_context->dTimeoutValues.dT1;

                /* configure the T2 */

                /*if(6==p_config_data->sip_req_retry)

                {

                    p_event_context-> dTimeoutValues.dT2 = 2 * ICF_CFG_DEF_SIP_TIMER_T2;

                }
                
                if(7==p_config_data->sip_req_retry)

                {

                    p_event_context-> dTimeoutValues.dT2 = 4 * ICF_CFG_DEF_SIP_TIMER_T2;

                }

                else*/

                {

                    p_event_context-> dTimeoutValues.dT2 = ICF_CFG_DEF_SIP_TIMER_T2;/* default value */

                }





            }

        }

#endif

		  /* Fix for SPR Bug273 */
        /* If any failure response code other than 401 and 407 of 
         * ReInvite is received and fax type is 
         * ICF_T38_FAX_CALL_FAILURE_SWITCH_PT_CALL then set the bit
         * ICF_CALL_CHALLENGE_T38_FAILURE_SWITCH_PT was set in callback
         * sdf_cbk_uaReInviteFailed(). In such a case, send
         * ReIvite for T.38 switch to PT with credentials.  
         */ 
		    if((ICF_SUCCESS == ret_val) && (ICF_FALSE == p_ssa_pdb->authorised_req) && 
		      (ICF_NULL != p_ssa_ctxt->p_call_ctxt) &&
		      ((ICF_CALL_AUTHENTICATION_REQ & 
		        p_ssa_ctxt->p_call_ctxt->common_bitmask)||
              (ICF_CALL_CHALLENGE_T38_FAILURE_SWITCH_PT & 
		        p_ssa_ctxt->p_call_ctxt->common_bitmask_3)))
      {
        if(Sdf_co_fail == sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg, 
                                                            &p_method, 
                                                            &sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
        else if((icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"ACK" ) == 0))
        {
           /*
            * We would not be calling sdf_fn_uaUpdateAuthorization API as 
            * ACK would be using the same authentication credential as 
            * INVITE
            */
        }
        else if(Sdf_co_fail == sdf_fn_uaUpdateAuthorization(p_call_obj,
                                                             p_sip_msg,
                                                             p_method,
                                                             &sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
      }
        /* Fix for SPR 20412: CSR 1-8223807 merged*/
        if ((ICF_SUCCESS == ret_val)&&
            ( Sdf_co_fail == sdf_ivk_uaSendCallToPeer(p_call_obj, p_sip_msg,
                                            options, 0, p_event_context,
                                            p_remove_hdr_list, &sdf_error)))
        {
#ifdef ICF_DNS_LOOKUP_ENABLED
            /*As per discussion with Mayank, it has been decided
              that we will not probe the next available IP in case
              TCP send fails. Logic being that we have already 
              confirmed peer by establishing a connection.However if a UATK 
              triggerd Connect fails we will check for next available IP*/
            if (((ICF_TRANSPORT_TYPE_TCP == p_ssa_ctxt->transport) ||
                        (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport) ||
                        (ICF_TRANSPORT_MODE_BOTH == p_ssa_ctxt->transport)) &&
                    (Sdf_en_tcpConnectError != sdf_error.errCode)
               )
            {
                /*connection oriented transport, failure in send call*/
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSendCallToPeer"));
                ret_val = ICF_FAILURE;
            }
            else
            {
                /* p_ssa_pdb in p_ssa_ctxt is set to null in
                 * sdf_cbk_uaSendMsgOnNetwork ;so it is assigned again for
                 * further processing. */
                p_ssa_ctxt->p_ssa_pdb = p_ssa_pdb;

                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSendCallToPeer,Going for reattempt "));
                /*If more IP addresses present of DNS response received, then try on next IP address
                 *in the list, this function will return failure if no more IP addresses are present*/
                if(ICF_SUCCESS == icf_ssa_resend_ongoing_txn(p_call_obj, 
                            p_sip_msg, p_overlap_txn,\
                            options))
                {
                    ret_val = ICF_SUCCESS;
                }
                /*If no more IP addresses are present for current domain name, then check it secondary 
                 *address is present then try on this secondary address*/
                else if(ICF_SUCCESS == icf_ssa_resend_on_sec_address(p_call_obj,
                        p_overlap_txn, p_ssa_ctxt, &sdf_error))
                {
                    ret_val = ICF_SUCCESS;
                }
                else
                {
#endif
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSendCallToPeer"));
                    ret_val = ICF_FAILURE;
#ifdef ICF_DNS_LOOKUP_ENABLED
                }
            }
#endif
        }

#ifdef ICF_DNS_LOOKUP_ENABLED
       /*This is to save the Ip and the port at which the request is sent,So that when the response comes 
        *from this Ip,Iptk willl buffer it.
        */ 
        else if (sdf_ivk_uaGetDestInfoFromTransaction(p_txn,
              p_overlap_txn,
			  &p_dest_Info, 
              &sdf_error) == Sdf_co_fail)
         {
             ret_val = Sdf_co_fail;
         }
        else
        {
              /* Fix for SPR 19522 */
            icf_port_strncpy((icf_int8_t *)p_ssa_ctxt->ip_fr_req,
					(const icf_int8_t *)p_dest_Info->pIp,
                    ICF_MAX_IPV4_ADDRESS_LENGTH - 1);
            p_ssa_ctxt->ip_fr_req[ICF_MAX_IPV4_ADDRESS_LENGTH - 1] = '\0';
            p_ssa_ctxt->port_fr_req = (icf_uint16_t)p_dest_Info->dPort;

             if(Sdf_co_null != p_txn)
             {
              	(void)sdf_ivk_uaFreeTransportInfo(p_txn->pDestInfo);
             }
             else if(Sdf_co_null != p_overlap_txn)
             {
                (void)sdf_ivk_uaFreeTransportInfo(p_overlap_txn->pDestInfo);
             }
	}
#endif
        }/*End of ICF_FAILURE check*/

        /* Fix for SPR 20412: CSR 1-8223807 merged*/
        if(ICF_NULL != p_remove_hdr_list)
        {
            ICF_MEMFREE(
                 p_ssa_pdb->p_glb_pdb,
                 p_remove_hdr_list,
                 ICF_MEM_COMMON,
                 p_ssa_pdb->p_ecode,
                 dummy_ret_val);

            p_remove_hdr_list = ICF_NULL;
        }

        if ( ICF_FAILURE != ret_val)
        {
#ifdef ICF_NAT_RPORT_SUPPORT

           if (ICF_CFG_SELF_ADDR_PER_LINE ==
              p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
           {
                if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                    p_ssa_pdb->p_glb_pdb, p_ssa_ctxt->line_id,
                    &p_line_data, p_ssa_pdb->p_ecode))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    p_rport_config_data = p_line_data->p_rport_config_data;
                }
        
           }
           else
           {
                 p_rport_config_data = &(p_ssa_pdb->p_glb_cfg_data->rport_config_data);
           }

           if (ICF_NULL == p_rport_config_data)
           {
              return ICF_FAILURE; 
           }
            /* SPR 19601: Restart the binding refresh timer value if rport required 
             * flag is TRUE and rport discovery completed flag is also TRUE then on
             * every outgoing request, restart the timer.
             */
            if(ICF_TRUE == p_rport_config_data->is_rport_reqd && \
                    ICF_TRUE == p_rport_config_data->is_rport_completed)
            {
                    /* Start the timer for this binding */
                    icf_ssa_start_binding_refresh_timer(p_ssa_pdb);
            }

#endif    
        }/*end of segment for freeing sip msg and slMsgBodyList*/

#ifdef ICF_IPSEC_ENABLED
        if (  ICF_FAILURE != ret_val)
        {
                /* get config data to check if IPsec is enabled */

                /* get config data from DBM */
                if ((dReqRespType == SipMessageRequest) &&
                                (ICF_TRUE == p_cfg_data->ipsec_enabled) &&
                                (ICF_NULL != p_ssa_ctxt->ssa_sa_context.p_sa_context))
                {
                        SipReqLine                *pReqLine = ICF_NULL;
                        /* for an outgoing request, this will be a new 
                        * transaction incase of all 
                         * requests- but for ACK. */
                        if (SipFail ==
                                sip_getReqLineFromSipReqMsg(p_sip_msg,&pReqLine, &sip_error))
                        {
                                ret_val = ICF_FAILURE;
                        }
                        else
                        {
                                /* get method name from the request URI */
                                if (SipFail == sip_getMethodFromReqLine
                                        (pReqLine,((SIP_S8bit **)&pTemp),&sip_error))
                                {
                                        ret_val = ICF_FAILURE;
                                }
                                sip_freeSipReqLine(pReqLine);
                        }
                        if ((ICF_FAILURE != ret_val) && (icf_port_strcmp(pTemp, "ACK")))
                        {
                                /* increment the active transaction count for the SA */
                                /* we will not increase the count for ACK, since it 
                                * has no response and there is no way we can decrement
                                 * the corresponding counter for the ACK transaction 
                                 */
                                p_ssa_pdb->p_sa_context->num_active_trans += 1;
                                ICF_PRINT(("[SSA]: num_active_trans incremented, current value = %d",
                                                        p_ssa_pdb->p_sa_context->num_active_trans));
                        }
                }
                else if ((dReqRespType == SipMessageResponse) &&
                                (ICF_TRUE == p_cfg_data->ipsec_enabled) &&
                                (ICF_NULL != p_ssa_pdb->p_sa_context))
                {
                        /* decrement the active transaction count for the SA */
                        p_ssa_pdb->p_sa_context->num_active_trans -= 1;
                        ICF_PRINT(("[SSA]: num_active_trans decremented, current value = %d",
                                                p_ssa_pdb->p_sa_context->num_active_trans));

                        if (ICF_NULL == p_ssa_pdb->p_sa_context->num_active_trans)
                        {
                                /* this function will send a trigger to REGM if there are no
                                 * pending transactions on the old SA. If the trans count is
                                 * 0 for the new SA, then no trigger will be sent to REGM */
                                ret_val = icf_ssa_rgm_delete_old_sa_ind(p_ssa_pdb);
                        }
                }
        }
#endif
        
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val; 
}

#ifdef ICF_DNS_LOOKUP_ENABLED
icf_return_t    icf_ssa_get_msg_mthd_type_frm_txn(icf_ssa_pdb_st *p_ssa_pdb, 
        Sdf_st_transaction    *p_txn,
        Sdf_st_overlapTransInfo    *p_overlap_txn,
        en_SipMessageType    *p_msg_type,
        Sdf_ty_s8bit        *p_mthd)
{
    icf_return_t    ret_val = ICF_SUCCESS;

    SipError        sip_error;
    SipMessage      *p_sip_msg = ICF_NULL;
    Sdf_st_error    sdf_error;
    Sdf_ty_s8bit    *p_method = Sdf_co_null;

    if(ICF_NULL == p_ssa_pdb)
    {
          return ICF_FAILURE;
    
    }
    
	p_ssa_pdb = p_ssa_pdb;

	if (Sdf_co_null == p_overlap_txn)
	{
		p_sip_msg = p_txn->pSipMsg;
	}
	else
	{
		p_sip_msg = p_overlap_txn->pSipMsg;
	}
	if ( (ICF_NULL == p_sip_msg) ||
			( SipFail == sip_getMessageType(p_sip_msg, p_msg_type,
							&(sip_error))) ||
			(Sdf_co_fail == 
			 sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg, &p_method, &sdf_error))
	   )
	{
		ret_val = ICF_FAILURE;

    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)p_mthd, (icf_uint8_t *)p_method);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)    
    return ret_val;
}

#endif
/************************************************************************
* Static Function Only Used in this File
*************************************************************************/
#ifdef ICF_SIGCOMP_SUPPORT
static icf_return_t
icf_ssa_checkForSigCompParam(
     INOUT     Sdf_st_callObject              *pObject,
     INOUT     SipMessage                     *pMessage, 
     OUT    icf_boolean_t               *p_isSigcompParamPres,
     OUT    icf_error_t   
     *p_ecode);
#endif
/*Message body header changes Start*/
static icf_return_t icf_ssa_SetMsgBodyListInSipMessage
    (Sdf_ty_slist *pMsgBodyList,
    SipMessage    *pMsg,
    Sdf_ty_s8bit  *p_content_type,
    Sdf_st_error  *pError);

static icf_return_t icf_ssa_AppendMsgBodyListToSipMessage
    (Sdf_ty_slist *pMsgBodyList,
    SipMessage    *pMsg,
    Sdf_ty_s8bit  *p_content_type,
    Sdf_st_error  *pError);

static icf_void_t icf_get_content_type_from_msg_body(
        INOUT  icf_ssa_pdb_st  *p_ssa_pdb,
        OUT icf_uint8_t     **p_p_content_type);
static icf_return_t icf_ssa_IsSupportedMediaTypeInMsgBody(
        INOUT    en_SipMessageType dReqRespType, 
        INOUT    Sdf_st_initData   *pInitData,
        INOUT    Sdf_ty_s8bit      *pMediaType,
        OUT   Sdf_st_error      *pErr);

static icf_return_t icf_ssa_get_status_frm_notify_from_mime_body(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT      SipMsgBody           *p_sip_msg_body,
        OUT     icf_boolean_t        *p_status);

/*Message body header changes Ends*/
/************************************************************************
* External Function Only Used Only in this File
*************************************************************************/
#ifdef ICF_SIGCOMP_SUPPORT
extern icf_return_t icf_sigsa_get_sigcomp_proxy_addrs_from_ctxt(
        INOUT  icf_void_t                *p_sigsa_ctxt,
        OUT icf_transport_address_st   **p_sigcomp_proxy_addr,
        OUT icf_boolean_t              *p_is_to_add_sigcomp_param_in_route,
        OUT icf_error_t                *p_ecode);


#endif

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_and_populate_self_ip
 * DESCRIPTION:     This function calls UATK callbacks, implemented in SSA,
 *                  to get the system host name, then system ip address
 *                  and then sets the resolved ip address in config data
 ******************************************************************************/
icf_return_t icf_ssa_get_and_populate_self_ip(
        INOUT  icf_ssa_pdb_st             *p_ssa_pdb,
        INOUT  icf_transport_address_st *p_self_address,
        INOUT  icf_uint8_t *p_self_ip_str)
{
    icf_return_t     ret_val = ICF_SUCCESS;

    Sdf_ty_s8bit        *p_host_name = Sdf_co_null,
                        *p_host_ip = Sdf_co_null;
    Sdf_st_error        sdf_error;
    (void)p_ssa_pdb;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        
    /* UMR fix */
    icf_port_memset(
        (icf_void_t *)&sdf_error,
        0,
        ICF_PORT_SIZEOF(Sdf_st_error));

    if (Sdf_co_fail == sdf_fn_uaGetHostName(&p_host_name, &sdf_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in GetHostName"));
        ret_val = ICF_FAILURE;
    }
    else{ 
	
		if ( p_host_name ) 
		{
			if ( Sdf_co_fail == sdf_fn_uaGetHostIp(p_host_name, &p_host_ip,
						&sdf_error))
			{
				ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in GetHostIp"));
				ret_val = ICF_FAILURE;
			}
			else
			{
				/* The sdf_cbk_uaGetHostIp callback allocates memory for 
				 * p_host_ip. Now we will copy the string ip address to
				 * p_self_ip_str argument and then release this memory.
				 * Then we will proceed to set the 4-Octets in transport 
				 * address st argument*/
				if (p_host_ip) icf_port_strcpy(p_self_ip_str, (icf_uint8_t *)p_host_ip);


				if (ICF_FAILURE == icf_ssa_convert_to_tran_addr(p_self_ip_str,
							p_self_address))
				{
					ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in icf_ssa_convert_to_tran_addr"));
					ret_val = ICF_FAILURE;
				}
			}
		}


	}
    /* Klocwork warning removal*/
    sdf_memfree(0, (Sdf_ty_pvoid *)&p_host_ip, &sdf_error);
    sdf_memfree(0, (Sdf_ty_pvoid *)&p_host_name, &sdf_error);

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_convert_to_tran_addr
 *
 * DESCRIPTION:     This function converts the IP address
 *                  stored in the SDP body of SIP message
 *                  to the transport address understandable by the
 *                  ICF
 *
 ******************************************************************************/
icf_return_t icf_ssa_convert_to_tran_addr(
        INOUT icf_uint8_t *p_remoteIP,
        OUT icf_transport_address_st *p_rtp_address)
{
    /* Codenomicon CSR 1-7132323: SPR 19484 */
    return (icf_port_str_to_trans_addr(p_remoteIP, &(p_rtp_address->addr)));
}

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_convert_to_IP_addr
 *
 * DESCRIPTION:     This function converts the transport address to a string
 *                  to be  sored in the SDP body of the SIP message     
 *
 ******************************************************************************/
icf_return_t icf_ssa_convert_to_IP_addr(
        INOUT icf_transport_address_st *p_rtp_address,
        OUT icf_uint8_t *p_remoteIP)
{
    if(p_rtp_address->addr.addr_type == ICF_TRANSPORT_ADDRESS_IPV4_ADDR){
        icf_port_sprintf((icf_int8_t *)p_remoteIP,"%d.%d.%d.%d",
            p_rtp_address->addr.addr.ipv4_addr.octet_1,
            p_rtp_address->addr.addr.ipv4_addr.octet_2,
            p_rtp_address->addr.addr.ipv4_addr.octet_3,
            p_rtp_address->addr.addr.ipv4_addr.octet_4);
    }
#ifdef ICF_IPV6_ENABLED
    else if( p_rtp_address->addr.addr_type == ICF_TRANSPORT_ADDRESS_IPV6_ADDR){
        strcpy(p_remoteIP, p_rtp_address->addr.addr.ipv6_addr.str);
    }
#endif
    return ICF_SUCCESS;
}

#ifdef ICF_ERROR_ENABLE
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_error
 *
 * DESCRIPTION:     This function is used by SSA for error handling.
 *
 ******************************************************************************/
icf_void_t icf_ssa_error(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        IN     Sdf_ty_s8bit	  *p_method, 
        INOUT  icf_error_t    ecode)
{
    icf_error_data_st                error_data;
    icf_glb_pdb_st                   *p_glb_pdb = ICF_NULL;
    icf_rgm_context_st               *p_rgm_ctx = ICF_NULL;
    icf_uint8_t                      int_count = ICF_NULL; 
    icf_uint8_t                      str_count = ICF_NULL; 
    icf_uint8_t                      loop_index = ICF_NULL; 
    icf_app_id_t                     app_id = ICF_NULL;
    icf_line_id_t                    line_id = ICF_NULL;
    icf_call_id_t                    call_id = ICF_NULL;
    Sdf_ty_u16bit                    response_code = ICF_NULL;

    p_glb_pdb = p_ssa_pdb->p_glb_pdb;

    icf_port_memset((icf_void_t *)(&error_data),ICF_NULL,
                    (icf_uint32_t)ICF_PORT_SIZEOF(icf_error_data_st));
    error_data.num_of_integer_values = 0;
   
   /* icf_port_memset((void *)&error_data, 0 , sizeof(error_data)); */
   if (ICF_NULL != p_method)
   {
    if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"REGISTER" ) == 0)
    {
        /* Fetch the app id and line id from the rgm context.
         */
        p_rgm_ctx = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt;
        if(ICF_NULL != p_rgm_ctx)
        {
            /* Form the error data structure for registration DNS 
             * Query Failure/TCP connection failure etc.
             */

            for (loop_index = 0; (loop_index < p_ssa_pdb->p_glb_cfg_data->\
                        max_applications); loop_index++)
            {
                if (ICF_FALSE == p_rgm_ctx->p_app_data_list[loop_index].is_valid)
                {
                    continue;
                }

                else
                {

                    app_id = p_rgm_ctx->p_app_data_list[loop_index].app_id;
                    line_id = p_rgm_ctx->p_app_data_list[loop_index].line_id;
                    break;
                }
            }
            if(ICF_ERROR_AUTHENTICATION_FAILURE == ecode)
            {
                response_code = 401;
            }
        }
            call_id = ICF_INVALID_CALL_ID;
            icf_port_strcpy(error_data.string_val[str_count].str, 
                    (icf_uint8_t *)p_method);
            error_data.string_val[str_count].str_len=\
                                                     (icf_uint16_t )icf_port_strlen((icf_uint8_t *)p_method);
            (str_count)++;
    }
    else if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt)
    {
        if(!(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"INVITE" ) == 0))
        {
            /* Method other than Invite Failed. So send p_method and "INVITE" 
             * in the error indication.
             */
            icf_port_strcpy(error_data.string_val[str_count].str, 
            (icf_uint8_t *)p_method);
            error_data.string_val[str_count].str_len=\
                                                    (icf_uint16_t ) icf_port_strlen((icf_uint8_t *)p_method);
            (str_count)++;

            icf_port_strcpy(error_data.string_val[str_count].str, 
                    (icf_uint8_t *)"INVITE");
            error_data.string_val[str_count].str_len=\
                                                     (icf_uint16_t )icf_port_strlen((icf_uint8_t *)"INVITE");
            (str_count)++;
        }
        else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"INVITE" ) == 0)
        {
            icf_port_strcpy(error_data.string_val[str_count].str, 
                    (icf_uint8_t *)p_method);
            error_data.string_val[str_count].str_len=\
                                                     (icf_uint16_t )icf_port_strlen((icf_uint8_t *)p_method);
            (str_count)++;

        }
        /* Fetch the app id and line id from the call context.
         */
        app_id = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->app_id;
        line_id = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->line_id; 
        call_id = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->call_id;
        response_code = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->\
                        inc_response_code;
    }
    else if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt)

    {
        /* Fetch the app id and line id from sic context
        */
        app_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->app_id;
        line_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->line_id;
        call_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->call_id;
        if(ICF_ERROR_AUTHENTICATION_FAILURE == ecode)
        {
            response_code = 401;
        }
        icf_port_strcpy(error_data.string_val[str_count].str, 
                (icf_uint8_t *)p_method);
        error_data.string_val[str_count].str_len=\
                                             (icf_uint16_t )icf_port_strlen((icf_uint8_t *)p_method);
        (str_count)++;
    }
    else
    {
        return;
    }

    if(ICF_NULL != app_id)
    {
        error_data.int_val[ICF_MAX_INT_ERROR_DATA-1]= app_id;
    }
    else
    {
        error_data.int_val[ICF_MAX_INT_ERROR_DATA-1]= ICF_DUMMY_APP_ID;
    }   
    error_data.int_val[int_count]= line_id;
    int_count++;

    error_data.int_val[ICF_MAX_INT_ERROR_DATA - 2] = call_id;

    error_data.num_of_integer_values = int_count;

    error_data.number_of_string_values = str_count;
   }
    switch (ecode)
    {
        case ICF_ERROR_DNS_QUERY_FAILURE:
            icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_DNS_QUERY_FAILURE");
            error_data.err_string.str_len = (icf_uint16_t )icf_port_strlen(error_data.err_string.str);
            break;
        
        case ICF_ERROR_AUTHENTICATION_FAILURE:
            icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_AUTHENTICATION_FAILURE");
            error_data.err_string.str_len = (icf_uint16_t )icf_port_strlen(error_data.err_string.str);

            break;
        
        case ICF_ERROR_RETRANSMISSION_TIMEOUT:
            icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_RETRANSMISSION_TIMEOUT");
            error_data.err_string.str_len = (icf_uint16_t )icf_port_strlen(error_data.err_string.str);
            if(ICF_NULL != response_code)
              {
                error_data.int_val[error_data.num_of_integer_values]= (icf_uint32_t)response_code;
                (error_data.num_of_integer_values) ++;
              }
            break;

        case ICF_ERROR_OPEN_SOCKET:
            icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_OPEN_SOCKET");
            error_data.err_string.str_len = (icf_uint16_t )icf_port_strlen(error_data.err_string.str);
            break;

        case ICF_ERROR_FAILURE_RESPONSE:
            icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_FAILURE_RESPONSE");
            error_data.err_string.str_len =(icf_uint16_t ) icf_port_strlen(error_data.err_string.str);
            error_data.int_val[error_data.num_of_integer_values]= (icf_uint32_t)p_ssa_pdb->resp_code;

            (error_data.num_of_integer_values) ++;

            break;
        case ICF_ERROR_INTERMIDIATE_RETRANSMISSION_TIMEOUT:
             icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_INTERMIDIATE_RETRANSMISSION_TIMEOUT");
             error_data.err_string.str_len = (icf_uint16_t )icf_port_strlen(error_data.err_string.str);
             error_data.int_val[error_data.num_of_integer_values]= (icf_uint32_t)p_ssa_pdb->retrans_count;
             (error_data.num_of_integer_values) ++;
             if(ICF_NULL != response_code)
              {
                error_data.int_val[error_data.num_of_integer_values]= (icf_uint32_t)response_code;
                (error_data.num_of_integer_values) ++;
              }
             break;

     	/* CSR_1_6763883 Merged SPR 19672 Start */
        case ICF_ERROR_INCOMPLETE_MSG_FROM_NW:
             icf_port_strcpy(error_data.err_string.str,(icf_uint8_t *)"ICF_ERROR_INCOMPLETE_MSG_FROM_NW");
             error_data.err_string.str_len =(icf_uint16_t ) icf_port_strlen(error_data.err_string.str);
            
             if(ICF_NULL != p_ssa_pdb->resp_code)
             {
                 error_data.int_val[error_data.num_of_integer_values]= (icf_uint32_t)p_ssa_pdb->resp_code;
                 (error_data.num_of_integer_values)++;
                 /*SPR 19794 Removed the reset of the ssa pdb resp_code field
                   as it is required for the contact hdr list population in
                   funtion icf_ssa_populate_app_specific_hdr where we check
                  the response code for population*/
             }

      	     icf_port_strcpy(error_data.string_val[1].str, (icf_uint8_t *)p_ssa_pdb->err_str);
      	     error_data.string_val[1].str_len= 
             (icf_uint16_t)icf_port_strlen((icf_uint8_t *)p_ssa_pdb->err_str);
             error_data.number_of_string_values = 2;
             p_ssa_pdb->err_str[0] = '\0';
             break;
        /* CSR_1_6763883 Merged SPR 19672 End */  
  
        default:
            error_data.num_of_integer_values = ICF_NO_INT_PRESENT;
            error_data.number_of_string_values = ICF_NO_STRING_PRESENT;
            break;
    }
    
    ICF_SET_ERROR(p_glb_pdb,&error_data,ecode,&ecode) 
} /* end of icf_ssa_error() */
#endif

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_add_callid_callobj_map
 *
 * DESCRIPTION:     This function is used by SSA for adding SSA ctxt
 * - nw call id mapping to the SSA db.
 *
 ******************************************************************************/
icf_return_t icf_ssa_add_callid_callobj_map(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        OUT   icf_ssa_ctxt_st  *p_ssa_ctxt,
        OUT   icf_error_t    *p_ecode)
{
    /*icf_uint8_t              count = 0;*/
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_list_st          *p_map_ssa_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st          *p_map_temp_ssa_ctxt = ICF_NULL;
#ifndef ICF_LOOPBACK_SUPPORT
    icf_return_t			dummy_ret_val = ICF_SUCCESS;
#else
    icf_uint32_t            key_length = 0;
#endif
    /* icf_ssa_glb_data_st      *p_ssa_glb_data = (icf_ssa_glb_data_st*)
       (p_ssa_pdb->p_ssa_glb_data);*/

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    

 if(ICF_NULL == p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid)
    {
        return  ICF_FAILURE;
    }
        (void)p_ecode;

#ifdef ICF_LOAD_DEBUG
    printf("\nSSA CTXT Allocated: %x %s\n", p_ssa_ctxt, 
           p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid);
#endif
#ifndef ICF_LOOPBACK_SUPPORT 
    ret_val = icf_dbm_hash_add_ssa_ctxt(p_ssa_pdb->p_glb_pdb,
            p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid,
            p_ssa_ctxt,p_ecode);
    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            (icf_port_strlen(p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid) + 1),
            ICF_MEM_COMMON,
            p_ssa_ctxt->p_hash_key,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            dummy_ret_val)
        icf_port_strcpy(p_ssa_ctxt->p_hash_key,p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid);

#else
    key_length = icf_port_strlen((icf_uint8_t *)p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid) ; 
    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            key_length+ 1,
            ICF_MEM_COMMON,
            p_ssa_ctxt->p_hash_key,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val);
    icf_port_strcpy(p_ssa_ctxt->p_hash_key,(icf_uint8_t *)p_ssa_ctxt->p_call_obj->pCommonInfo->pCallid);
#if 0  
    HASH_ENH 
        icf_port_strcat(p_ssa_ctxt->p_hash_key,local_addr_str.addr_val.str);
    icf_port_strcat(p_ssa_ctxt->p_hash_key,remote_addr_str.addr_val.str);
    if ( 0 != p_ssa_pdb->hash_index)
    {
        icf_port_strcat(p_ssa_ctxt->p_hash_key,hash_index_str);
    }
#endif
    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            sizeof(icf_ssa_ctxt_list_st),
            ICF_MEM_COMMON,
            p_map_ssa_ctxt,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val);
    p_map_ssa_ctxt->p_ssa_ctxt = p_ssa_ctxt;
    p_map_ssa_ctxt->p_next = ICF_NULL;
    ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(p_ssa_pdb->p_glb_pdb,
            p_ssa_ctxt->p_hash_key,
            (icf_void_t **)&p_map_temp_ssa_ctxt,p_ecode);
    if ( ICF_SUCCESS == ret_val)
    {
        /*  append it to linkek list */
        icf_ssa_append_to_ssa_ctxt_list(p_map_temp_ssa_ctxt, p_map_ssa_ctxt);
    }
    else
    {

        ret_val = icf_dbm_hash_add_ssa_ctxt(p_ssa_pdb->p_glb_pdb,
                p_ssa_ctxt->p_hash_key,
                p_map_ssa_ctxt,p_ecode);
    }


#endif	

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}
    

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_map_nw_callid
 *
 * DESCRIPTION:     This function is used by SSA for trace handling.
 *
 ******************************************************************************/
icf_return_t icf_ssa_map_nw_callid(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
#ifdef ICF_LOOPBACK_SUPPORT
        INOUT  Sdf_st_callObject       *p_call_obj,
#endif
        INOUT  icf_uint8_t    *p_nw_call_id,
        OUT   icf_ssa_ctxt_st    **p_p_mapped_ssa_ctxt,
#ifdef ICF_LOOPBACK_SUPPORT
        OUT   Sdf_st_error            *p_sdf_error,
#endif
        OUT   icf_error_t    *p_ecode)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_list_st  *p_ssa_list = ICF_NULL;
    icf_ssa_ctxt_list_st  *p_ssa_temp = ICF_NULL;
    /*
       icf_ssa_glb_data_st      *p_ssa_glb_data = (icf_ssa_glb_data_st*)
       p_ssa_pdb->p_ssa_glb_data;
     */

#ifdef ICF_LOOPBACK_SUPPORT
    SipMessage              *p_temp_msg = Sdf_co_null;
    en_SipMessageType		dMsgType;
    icf_return_t			dummy_ret_val = ICF_SUCCESS;
#endif	
    icf_uint8_t				*p_hash_key = ICF_NULL;
    icf_uint32_t			key_length = 0;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

        (void)p_ecode;

    key_length = icf_port_strlen(p_nw_call_id) + 1;

    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            key_length,
            ICF_MEM_COMMON,
            p_hash_key,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val);

    icf_port_strcpy(p_hash_key,p_nw_call_id);

    ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(
            p_ssa_pdb->p_glb_pdb,p_hash_key,
            (icf_void_t **)&p_ssa_list,p_ecode);
    if ((ret_val == ICF_SUCCESS) &&
            (ICF_NULL != p_ssa_list))
    {
        *p_p_mapped_ssa_ctxt = p_ssa_list->p_ssa_ctxt ;
#ifdef ICF_LOOPBACK_SUPPORT
        if (p_call_obj->pUacTransaction->pSipMsg != Sdf_co_null)
            p_temp_msg = p_call_obj->pUacTransaction->pSipMsg;
        else
            p_temp_msg = p_call_obj->pUasTransaction->pSipMsg;

        sip_getMessageType(p_temp_msg, &dMsgType, \
                (SipError*)    &(p_sdf_error->stkErrCode)) ;
        /* Call dialog is matched as follows:
         * If it is request, then
         *   Call id, From, To should map with call id, To and From.
         *   Note that the order of From and To are changed as requests 
         *   have the To and From reversed. 
         * If the message is a response, then
         *    Call id, From and To should map with the call id, From
         *    and To of the original call object.
         */

        if (ICF_SUCCESS == ret_val)
        {
            for (p_ssa_temp = p_ssa_list;p_ssa_temp != ICF_NULL; p_ssa_temp = p_ssa_temp->p_next)
            {
                p_ssa_pdb->notify_tag_mismatch = ICF_TRUE;
                if(ICF_SUCCESS == icf_ssa_util_cmp_tags(
                            p_ssa_pdb,
                            p_call_obj, 
                            p_ssa_temp->p_ssa_ctxt->p_call_obj,
                            p_sdf_error))
                {
                    *p_p_mapped_ssa_ctxt = p_ssa_temp->p_ssa_ctxt;
                    p_ssa_pdb->notify_tag_mismatch = ICF_FALSE;
                    ret_val =  ICF_SUCCESS;
                    break;
                }
            }
            if (ICF_NULL == p_ssa_temp)
            {

                if ( (SipMessageRequest == dMsgType) && 
                        (ICF_FALSE == p_ssa_pdb->is_otg_msg))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    *p_p_mapped_ssa_ctxt = p_ssa_list->p_ssa_ctxt ;
                    ret_val =  ICF_SUCCESS;
                }
            }
        }


#endif
    }
    else
        *p_p_mapped_ssa_ctxt = ICF_NULL;

    ICF_MEMFREE(
            p_ssa_pdb->p_glb_pdb,
            p_hash_key,
            ICF_MEM_COMMON,
            p_ssa_pdb->p_ecode,
            dummy_ret_val);
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}


#ifdef ICF_TRACE_ENABLE
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_trace
 *
 * DESCRIPTION:     This function is used by SSA for trace handling.
 *
 ******************************************************************************/
icf_void_t icf_ssa_trace(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT icf_trace_id_t trace_id)
{
    icf_trace_data_st                trace_data;

    switch(trace_id)
    {
        default:
            trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;

            trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
            break;

    } /* end of switch-case for trace_id */

    /* Finally, invoke the common macro for trace handling */
    ICF_TRACE(p_ssa_pdb->p_glb_pdb, trace_id, &trace_data)
} /* end of icf_ssa_trace() */




/*******************************************************************************
*
* FUNCTION:        icf_ssa_app_trace
*
* DESCRIPTION:     This function is used by SSA for trace handling.
*
******************************************************************************/
   icf_return_t icf_ssa_app_trace(
          INOUT  icf_ssa_pdb_st *p_ssa_pdb,
          INOUT icf_trace_id_t trace_id)
   {
        icf_trace_data_st               trace_data;
   		icf_trace_criteria_data_st    	*p_criteria_data = ICF_NULL;
	    icf_app_id_t    app_id = ICF_INVALID_APP_ID;
	    icf_call_id_t	call_id = ICF_INVALID_CALL_ID;
	    icf_line_id_t	line_id = ICF_INVALID_LINE_ID;
        icf_line_data_st        *p_line_data = ICF_NULL;
        icf_uint8_t              registrar_addr[100] = {0};
		icf_return_t    ret_val = ICF_SUCCESS;
		icf_uint8_t     p_transp_addr_str[100] = "";

        icf_generic_string_st   *p_msg = ICF_NULL;
        icf_glb_pdb_st        *p_glb_pdb = ICF_NULL;

        /*Fix for SPR : 18999*/
        if (ICF_NULL == p_ssa_pdb)
        {
            ICF_PRINT(((icf_uint8_t *)"\np_ssa_pdb is null \n"));
            return ICF_FAILURE;
        } 
        p_glb_pdb = p_ssa_pdb->p_glb_pdb;
      
        icf_port_memset(&trace_data,0,
                    ICF_PORT_SIZEOF(icf_trace_data_st));

        /*Fix for SPR : 18999*/
        if (ICF_NULL == p_glb_pdb)
        {
            ICF_PRINT(((icf_uint8_t *)"\np_glb_pdb is null \n"));
            return ICF_FAILURE;
        }
	
        if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt)
        {
            if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt)
            {
                icf_uint8_t loop_index;

                /*Fix for SPR : 18999*/
                ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                         p_ssa_pdb->p_glb_cfg_data)

                for (loop_index = 0; (loop_index < 
                            p_ssa_pdb->p_glb_cfg_data->max_applications); loop_index++)
                {
                    /*Fix for SPR : 18999*/
                    ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                            p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->p_app_data_list+loop_index)

                    if (ICF_FALSE == p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->
                            p_app_data_list[loop_index].is_valid)         
                    {
                        continue;
                    }
                    else
                    {
                        app_id = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->
                            p_app_data_list[loop_index].app_id;
                        line_id = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->
                            p_app_data_list[loop_index].line_id;
                        break;
                    }
                } 	    
                call_id = ICF_INVALID_CALL_ID;
                /* SPR 19189 */
                if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->
                        p_trace_criteria_data)
                {
                    p_criteria_data = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->
                        p_trace_criteria_data;
                }
            }
            else if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt)
            {
                app_id = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->app_id;
                call_id = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->call_id;
                line_id = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->line_id;
                if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->
                        p_trace_criteria_data)
                {
                    p_criteria_data = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->
                        p_trace_criteria_data;
                }
            }
            else if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt)
            {
                app_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->app_id;
                call_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->call_id;
                line_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->line_id;
                /* SPR 19189 */
                if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                        p_trace_criteria_data)
                {
                    p_criteria_data = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                        p_trace_criteria_data;
                }
            }
            else if(ICF_NULL != p_glb_pdb->p_call_ctx)
            {
                app_id = p_glb_pdb->p_call_ctx->app_id;
                call_id = p_glb_pdb->p_call_ctx->call_id;
                /* SPR 19189 */
                if(ICF_NULL != p_glb_pdb->p_call_ctx->p_trace_criteria_data)
                {
                    p_criteria_data = p_glb_pdb->p_call_ctx->
                        p_trace_criteria_data;
                }
            }
            else
            {
                /*  CSR 1-5385208 Merge */
                if(ICF_TRACE_SIP_PDU == trace_id)
                {
                    app_id = 1;
                    call_id = ICF_INVALID_CALL_ID;
                    /* SPR 19189 */
                    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_criteria_data)
                    {
                        p_criteria_data = p_ssa_pdb->p_ssa_ctxt->p_criteria_data;
                    }
                }
                /* This is done here to avoid any crashes that may occur
                   if criteria data is not formed because of any reason.
                   Sending success from here will save crashes but traces 
                   will not be sent to app as criteria data is NULL.*/
                if(ICF_NULL == p_criteria_data)
                {
                    return ICF_SUCCESS;
                }
            }
        }
        else
        {
            /* Added for the system traces */
            if (ICF_NULL != p_ssa_pdb->p_glb_pdb->p_recv_msg)
            {
                if (0 == p_ssa_pdb->p_glb_pdb->p_recv_msg->hdr.app_id)
                {
                    /*Fix for SPR : 18999*/
                    ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                            p_ssa_pdb->p_glb_pdb->p_glb_data)
                    app_id = p_ssa_pdb->p_glb_pdb->p_glb_data->app_trace_info.app_id;
                    call_id = p_ssa_pdb->p_glb_pdb->p_glb_data->app_trace_info.call_id;
                }
                else
                {
                    app_id = p_ssa_pdb->p_glb_pdb->p_recv_msg->hdr.app_id;
                    call_id = p_ssa_pdb->p_glb_pdb->p_recv_msg->hdr.call_id;
                }
            }
        }
        /* For out of dialog options we will the criteria data here */     
        if((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) && (((ICF_TRACE_INC_OPTIONS == trace_id) && 
                    (0 ==  p_ssa_pdb->dialog_status)) ||((ICF_TRACE_OTG_OPTIONS == trace_id)        
                                                         && (0 ==  p_ssa_pdb->dialog_status))))
        {
            if((ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt) && 
                    (ICF_NULL == p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                     p_trace_criteria_data))
            {
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        ICF_PORT_SIZEOF(icf_trace_criteria_data_st),
                        ICF_MEM_COMMON,
                        p_criteria_data,
                        ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)

                    p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_trace_criteria_data = 
                    p_criteria_data;
            }
            /* Added null check for klocworks warning removal*/
            if(ICF_NULL != p_criteria_data)
            {   
                if(ICF_TRACE_INC_OPTIONS == trace_id) /* If incoming options */
                {
                    p_criteria_data->line_id =
                    (icf_uint16_t)(p_ssa_pdb->p_ssa_ctxt->line_id);
                    p_criteria_data->bitmask |= ICF_TRACE_LINE_ID_PRESENT;
                }
                if(ICF_TRACE_OTG_OPTIONS == trace_id) /* if out of dialog outgoing options */
                {
                    /*Fix For SPR : 18999*/
                    ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                           p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt)
                    p_criteria_data->line_id =
                    (icf_uint16_t)(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->line_id);
                    p_criteria_data->bitmask |= ICF_TRACE_LINE_ID_PRESENT;
                }
            }   
        }
       
       ret_val = icf_cmn_check_app_trace(p_ssa_pdb->p_glb_pdb,
                                        trace_id,
					p_criteria_data);
       if( ICF_FAILURE == ret_val)
       {
         return ret_val;
       }
       else
       {
        /*Fix For SPR : 18999*/
        ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                p_ssa_pdb->p_glb_pdb->p_glb_data) 
    	p_ssa_pdb->p_glb_pdb->p_glb_data->app_trace_info.app_id =
                app_id;

    	p_ssa_pdb->p_glb_pdb->p_glb_data->app_trace_info.call_id =
                call_id;
 
        switch(trace_id)
        {

            case ICF_TRACE_SIP_PDU:
               
                /* SPR 17555 Fix: Send Call Direction(Incoming/Outgoing) to
                 * application
                 */
                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] = (icf_uint32_t)(p_ssa_pdb->call_direction);
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;

                /*CERT Fix: If SIP PDU length is greater than max supported
                 *then send trace to application with length of ICF_MAX_API_PAYLOAD_LENGTH*/
                if (ICF_MAX_API_PAYLOAD_LENGTH < p_ssa_pdb->len)
                {
                    p_ssa_pdb->len = ICF_MAX_API_PAYLOAD_LENGTH;
                }
                	
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                     ICF_PORT_SIZEOF(icf_generic_string_st),
                     ICF_MEM_COMMON,
                     p_msg,
                     ICF_RET_ON_FAILURE,
                     p_ssa_pdb->p_ecode,ret_val)

                p_msg->p_buff = p_ssa_pdb->p_buf;
                p_msg->len = p_ssa_pdb->len;
		        trace_data.p_var_data = (icf_void_t *)p_msg;	
                break;
               
            case ICF_TRACE_INC_INFO:
            case ICF_TRACE_OTG_INFO:
                if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) && 
                        (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt))
                {
                    trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                    trace_data.int_val[0] =
                        (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->line_id);

                    trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                }
                break;
            
         case ICF_TRACE_INC_INFO_RESP:
         case ICF_TRACE_OTG_INFO_RESP:
                if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) && 
                        (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt))
                {
                    trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
                    trace_data.int_val[0] =
                        (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->line_id);
                    trace_data.int_val[1] = p_ssa_pdb->resp_code;

                    trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                }
                break;

            case ICF_TRACE_INVITE_SENT:
		    {
                if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) && 
                        (ICF_NULL != p_criteria_data))
                {
                    icf_transport_addr_st *p_local_addr = ICF_NULL;
                    /*Fix For SPR : 18999*/
                    ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                      p_criteria_data->p_local_sip_ip_address)
                    p_local_addr =
                        &(p_criteria_data->p_local_sip_ip_address->addr);
                    trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                    trace_data.int_val[0] = p_ssa_pdb->p_ssa_ctxt->transport;

                    trace_data.number_of_string_values = ICF_THREE_STRING_PRESENT;
                    /*Fix For SPR : 18999*/
                    ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                       p_ssa_pdb->p_ssa_ctxt->p_call_ctxt)
                    icf_port_strcpy(trace_data.string_val[0].str,
                            p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->
                            local_address.addr_val.str);

                    trace_data.string_val[0].str_len =
                        (icf_uint16_t )icf_port_strlen(trace_data.string_val[0].str);

                    icf_port_strcpy(trace_data.string_val[1].str,
                            (icf_uint8_t *)p_ssa_pdb->p_ssa_ctxt->
                            p_call_ctxt->remote_party_addr.addr_val.str);
                    trace_data.string_val[1].str_len =
                        (icf_uint16_t )icf_port_strlen(trace_data.string_val[1].str);
                    if(ICF_NULL !=p_local_addr)
                    {      
                        if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                                p_local_addr->addr_type)
                        {
                            icf_port_strcpy(trace_data.string_val[2].str,
                                    p_local_addr->addr.domain.str);
                        }
                        else if(ICF_TRANSPORT_ADDRESS_IPV4_ADDR == 
                                p_local_addr->addr_type)
                        {
                            icf_port_sprintf((icf_int8_t *)trace_data.string_val[2].str,
                                    "%d.%d.%d.%d",
                                    p_local_addr->addr.ipv4_addr.octet_1,
                                    p_local_addr->addr.ipv4_addr.octet_2,
                                    p_local_addr->addr.ipv4_addr.octet_3,
                                    p_local_addr->addr.ipv4_addr.octet_4);
                        }
                    } 
                    trace_data.string_val[2].str_len =
                        (icf_uint16_t)icf_port_strlen(trace_data.string_val[2].str);
                }
                break;
            }
            

         case ICF_TRACE_INVITE_RECVD:
			{
                if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) && 
                        (ICF_NULL != p_criteria_data))
                {
                    icf_transport_addr_st *p_local_addr = ICF_NULL;
                    /*Fix For SPR : 18999*/
                    ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                       p_criteria_data->p_local_sip_ip_address)
                    p_local_addr =
                        &(p_criteria_data->p_local_sip_ip_address->addr);

                    trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
                    trace_data.int_val[0] = p_ssa_pdb->p_ssa_ctxt->transport;
					/* CSR 1-6212448: SPR 18873: Fill sdp_present in correct trace data
 					 * int_val */
                    trace_data.int_val[1] = p_ssa_pdb->sdp_present;                    

                    trace_data.number_of_string_values = ICF_THREE_STRING_PRESENT;
                    /*Fix For SPR : 18999*/
                    ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                          p_ssa_pdb->p_ssa_ctxt->p_call_ctxt)

                    icf_port_strcpy(trace_data.string_val[0].str,
                            (icf_uint8_t *)p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->
                            remote_party_addr.addr_val.str);

                    trace_data.string_val[0].str_len =
                        (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                    icf_port_strcpy(trace_data.string_val[1].str,
                            (icf_uint8_t *)p_ssa_pdb->p_ssa_ctxt->
                            p_call_ctxt->local_address.addr_val.str);
                    trace_data.string_val[1].str_len =
                       (icf_uint16_t) icf_port_strlen(trace_data.string_val[1].str);

                    /* SPR 19189 */
                    if(ICF_NULL != p_local_addr)
                    {
                        if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                               p_local_addr->addr_type)
                        {
                            icf_port_strcpy(trace_data.string_val[2].str,
                                    p_local_addr->addr.domain.str);
                        }
                        else if(ICF_TRANSPORT_ADDRESS_IPV4_ADDR == 
                                p_local_addr->addr_type)
                        {
                            icf_port_sprintf((icf_int8_t *)trace_data.string_val[2].str,
                                    "%d.%d.%d.%d",
                                    p_local_addr->addr.ipv4_addr.octet_1,
                                    p_local_addr->addr.ipv4_addr.octet_2,
                                    p_local_addr->addr.ipv4_addr.octet_3,
                                    p_local_addr->addr.ipv4_addr.octet_4);
                        }
                    }
                    trace_data.string_val[2].str_len =
                        (icf_uint16_t)icf_port_strlen(trace_data.string_val[2].str);

                }
                break;
         }
             
         case ICF_TRACE_PRACK_SENT:
         case ICF_TRACE_PRACK_RECVD:
         case ICF_TRACE_UPDATE_SENT:
         case ICF_TRACE_UPDATE_RECVD:
         case ICF_TRACE_REINVITE_RECVD:
         case ICF_TRACE_REINVITE_SENT:

                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] =
                     (icf_uint32_t)p_ssa_pdb->sdp_present;

                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;

	    case ICF_TRACE_PROVISIONAL_RESP_SENT:
      	case ICF_TRACE_PROVISIONAL_RESP_RECVD:

                trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
                trace_data.int_val[0] = p_ssa_pdb->resp_code;
                trace_data.int_val[1] = p_ssa_pdb->sdp_present;

                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                icf_port_strcpy(trace_data.string_val[0].str,
			                 p_ssa_pdb->p_method);
                trace_data.string_val[0].str_len =
                    (icf_uint16_t )icf_port_strlen(trace_data.string_val[0].str);

                break;

     case ICF_TRACE_FAILURE_RESP_SENT:
     case ICF_TRACE_FAILURE_RESP_RECVD:
                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] = p_ssa_pdb->resp_code;

                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                icf_port_strcpy(trace_data.string_val[0].str,
			                 p_ssa_pdb->p_method);
                trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                break;

        case ICF_TRACE_100_SENT:
        case ICF_TRACE_100_RECVD:
        case ICF_TRACE_302_SENT:
        case ICF_TRACE_302_RECVD:
               trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;

                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                icf_port_strcpy(trace_data.string_val[0].str,
                                         p_ssa_pdb->p_method);
                trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                break;               
	
         case ICF_TRACE_183_SENT:
         case ICF_TRACE_180_SENT:
         case ICF_TRACE_183_RECVD:
         case ICF_TRACE_180_RECVD:
        case ICF_TRACE_200_SENT:
        case ICF_TRACE_200_RECVD:
        case ICF_TRACE_202_SENT:
        case ICF_TRACE_202_RECVD:

                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] =
                     (icf_uint32_t)p_ssa_pdb->sdp_present;

                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                icf_port_strcpy(trace_data.string_val[0].str,
			          p_ssa_pdb->p_method);
                trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                break;

     case ICF_TRACE_BYE_SENT:
     case ICF_TRACE_BYE_RECVD:
     case ICF_TRACE_ACK_SENT:
     case ICF_TRACE_ACK_RECVD:
     case ICF_TRACE_CANCEL_SENT:
     case ICF_TRACE_CANCEL_RECVD:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;

     case ICF_TRACE_OUT_OF_DIALOG_MESSAGE_RECVD:
     case ICF_TRACE_OUT_OF_DIALOG_MESSAGE_SENT:

                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;

                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                icf_port_strcpy(trace_data.string_val[0].str,
			         p_ssa_pdb->p_method);
                trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                break;


 	case ICF_TRACE_DNS_QUERY_FAILURE:

           trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;

           trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
           
           /*  SPR 18901 Merge*/
            if(ICF_DNS_SRV_QUERY == p_ssa_pdb->dns_query_type)
           {
              icf_port_strcpy(trace_data.string_val[0].str,
                  (icf_uint8_t *)"Srv Query");
           }
           else
            {
           icf_port_strcpy(trace_data.string_val[0].str,
                  (icf_uint8_t *)"AAA Querry");
           }
           trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);
            
            
            break;

           case ICF_TRACE_REFER_SENT:
                if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) && 
                        (ICF_NULL !=  p_ssa_pdb->p_ssa_ctxt->p_call_ctxt))
                {
                    trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                    trace_data.int_val[0] = p_ssa_pdb->replace_header_present;

                    trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

                    icf_port_strcpy(trace_data.string_val[0].str,
                            p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_val.str);
                    trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                    icf_port_strcpy(trace_data.string_val[1].str,
                            p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->
                            remote_party_name.str);

                    trace_data.string_val[1].str_len =
                   (icf_uint16_t) icf_port_strlen(trace_data.string_val[1].str);
                }

                break;  

          case ICF_TRACE_NOTIFY_FOR_REFER_RECVD:

                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] = p_ssa_pdb->resp_code;			
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
 
                
                break;

           case ICF_TRACE_NOTIFY_FOR_REFER_SENT:

                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] = p_ssa_pdb->resp_code;

                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;

                
                break;

           case ICF_TRACE_INC_OPTIONS:

                trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
                if((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) &&
                        (0 == p_ssa_pdb->dialog_status))
                {
                    /*Fix for SPR : 18873 ---> CSR-1-6212448*/
                    /*Populate the line id from ssa context*/
                    trace_data.int_val[0] =
                        (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->line_id); 

                }
                if((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) && 
                        ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt) && 
                        (1 == p_ssa_pdb->dialog_status)))
                {
                    trace_data.int_val[0] =
                        (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->line_id);

                    trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;
                    icf_port_strcpy(trace_data.string_val[0].str,
                            p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_val.str);
                    trace_data.string_val[0].str_len =
                        (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                    icf_port_strcpy(trace_data.string_val[1].str,
                            p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_val.str);
                    trace_data.string_val[1].str_len =
                       (icf_uint16_t) icf_port_strlen(trace_data.string_val[1].str);
                }
                trace_data.int_val[1] =
                    p_ssa_pdb->dialog_status;
                break;

           case ICF_TRACE_INC_OPTIONS_RESP:

             trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
             if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) && 
                     (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt))
             {
                 trace_data.int_val[0] =
                     (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->
                                    p_sic_ctxt->line_id);
             }
             trace_data.int_val[1] =
                     (icf_uint32_t)(p_ssa_pdb->resp_code);
             
             trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

             /*icf_port_strcpy(trace_data.string_val[0].str,
                                  p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_val.str);*/ 
             trace_data.string_val[0].str_len =
                    (icf_uint16_t) icf_port_strlen(trace_data.string_val[0].str);

            /*icf_port_strcpy(trace_data.string_val[1].str,
                                p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_val.str);*/
             trace_data.string_val[1].str_len =
                        (icf_uint16_t)icf_port_strlen(trace_data.string_val[1].str);
             
             break;
    
       case ICF_TRACE_OTG_OPTIONS:

             if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt)
             {
                 trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
                 if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt)
                 {
                     trace_data.int_val[0] =
                         (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->
                                        p_sic_ctxt->line_id);
                 }
                 trace_data.int_val[1] = p_ssa_pdb->dialog_status;

                 if(1==p_ssa_pdb->dialog_status)
                 {
                     /*Fix For SPR : 18999*/
                     ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                         p_ssa_pdb->p_ssa_ctxt->p_call_ctxt)

                     trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

                     icf_port_strcpy(trace_data.string_val[0].str,
                             p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_val.str);
                     trace_data.string_val[0].str_len =
                         (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                     icf_port_strcpy(trace_data.string_val[1].str,
                             p_ssa_pdb->remote_addr.addr_val.str);
                     trace_data.string_val[1].str_len =
                         (icf_uint16_t) icf_port_strlen(trace_data.string_val[1].str); 
                 }
                 else
                 {
                     trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
                     icf_port_strcpy(trace_data.string_val[0].str,
                             p_ssa_pdb->remote_addr.addr_val.str);
                     trace_data.string_val[0].str_len =
                         (icf_uint16_t) icf_port_strlen(trace_data.string_val[0].str);
                 }
             }/*end if ICF_NULL != p_ssa_pdb->p_ssa_ctxt */
             break;

        case ICF_TRACE_OTG_OPTIONS_RESP:

             trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
             if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) && 
                     (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt))
             {
                 trace_data.int_val[0] =
                     (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->
                              p_sic_ctxt->line_id);
             }
             trace_data.int_val[1] =
                     (icf_uint32_t)(p_ssa_pdb->resp_code);
             
             trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

             /*icf_port_strcpy(trace_data.string_val[0].str,
                             p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_val.str);*/
             trace_data.string_val[0].str_len =
                    (icf_uint16_t) icf_port_strlen(trace_data.string_val[0].str);

             icf_port_strcpy(trace_data.string_val[1].str,
                                        p_ssa_pdb->remote_addr.addr_val.str);
             trace_data.string_val[1].str_len =
                        (icf_uint16_t)icf_port_strlen(trace_data.string_val[1].str);
             
             break;

        case ICF_TRACE_REG_AUTH_401:
        case ICF_TRACE_REG_AUTH_407:
             if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) && 
                     (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt))
             {
                 if (ICF_FAILURE != icf_dbm_fetch_line_cntxt_blk(
                             p_ssa_pdb->p_glb_pdb,
                             p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->rgm_list_of_lines[0],
                             &p_line_data, p_ssa_pdb->p_ecode))
                 {
                     /*Fix For SPR  : 18999*/ 
                     ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,p_line_data)
                     if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                             p_line_data->registrar_addr.addr.addr_type)
                     { 
                         icf_port_strcpy(
                                 registrar_addr,
                                 p_line_data->registrar_addr.addr.addr.domain.str);
                     }
                     else if (ICF_TRANSPORT_ADDRESS_IPV4_ADDR ==
                             p_line_data->registrar_addr.addr.addr_type)
                     {
            	  icf_port_sprintf((icf_int8_t *)registrar_addr,"%d.%d.%d.%d:%d",
                                 p_line_data->registrar_addr.addr.addr.ipv4_addr.octet_1,
                                 p_line_data->registrar_addr.addr.addr.ipv4_addr.octet_2,
                                 p_line_data->registrar_addr.addr.addr.ipv4_addr.octet_3,
                                 p_line_data->registrar_addr.addr.addr.ipv4_addr.octet_4,
                                 p_line_data->registrar_addr.port_num);
                     }
                 }


                 trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                 trace_data.int_val[0] = line_id;

                 trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;
                 icf_port_strcpy(trace_data.string_val[0].str,registrar_addr);
                 trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                 icf_port_strcpy(trace_data.string_val[1].str,
                         p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->rgm_user_address.addr_val.str);
                 trace_data.string_val[1].str_len =
                        (icf_uint16_t )icf_port_strlen(trace_data.string_val[1].str); 
             }  
             break;


        case ICF_TRACE_SUBS_AUTH_401:
        case ICF_TRACE_SUBS_AUTH_407:
               if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) && 
                       (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt))
               {
                   trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                   trace_data.int_val[0] =
                       (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->line_id);

                   if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
                   {
                       trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

                       icf_port_strcpy(trace_data.string_val[0].str,
                               p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->dest_addr.addr_val.str);
                       trace_data.string_val[0].str_len =
                    (icf_uint16_t)icf_port_strlen(trace_data.string_val[0].str);

                       icf_port_strcpy(trace_data.string_val[1].str,
                               p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_val.str);
                       trace_data.string_val[1].str_len =
                        (icf_uint16_t )icf_port_strlen(trace_data.string_val[1].str);
                   }
                   else
                   {
                       trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                       icf_port_strcpy(trace_data.string_val[0].str,
                               p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->dest_addr.addr_val.str);
                       trace_data.string_val[0].str_len =
                   (icf_uint16_t ) icf_port_strlen(trace_data.string_val[0].str);
               }
             }
             break;
   
        case ICF_TRACE_NOTIFY_FOR_SUBS:
              if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) && 
                      (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt))
              {
                  /*Fix Merge of CSR 1-6179301 In case the subs state is not present no need to 
                    send the trace to APP*/

                  if(ICF_NULL == p_ssa_pdb->p_subs_state)
                  {
                      return ICF_SUCCESS;
                  }
                  trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;

                  trace_data.int_val[0] =
                      (icf_uint32_t)(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->line_id);

                  trace_data.int_val[1] =
                      (icf_uint32_t)(p_ssa_pdb->notify_duration);

                  if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
                  {
                      trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

                      icf_port_strcpy(trace_data.string_val[0].str,
                                        (icf_uint8_t *)p_ssa_pdb->p_subs_state);
                      trace_data.string_val[0].str_len =
                    (icf_uint16_t )icf_port_strlen(trace_data.string_val[0].str);

                      icf_port_strcpy(trace_data.string_val[1].str,
                              p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                              p_preferred_identity->addr_val.str);
                      trace_data.string_val[1].str_len =
                     (icf_uint16_t)icf_port_strlen(trace_data.string_val[1].str);
                  }
                  else
                  {
                      trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

                      icf_port_strcpy(trace_data.string_val[0].str,
                                        (icf_uint8_t *)p_ssa_pdb->p_subs_state);
                      trace_data.string_val[0].str_len =
                    (icf_uint16_t )icf_port_strlen(trace_data.string_val[0].str);
                  }
              }
              break;

         case ICF_TRACE_TCP_CONNECTION_OPEN:
         case ICF_TRACE_TLS_CONNECTION_OPEN:

              /* Fix For SPR  19189 */
              ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                                   p_ssa_pdb->p_conn_table_entry)

             /*Send Remote IP address and port where connect is done*/
             trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;
             trace_data.int_val[0] = (icf_uint32_t)(p_ssa_pdb->result);
             trace_data.int_val[1] = p_ssa_pdb->p_conn_table_entry->peer_port_num;
             trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
             icf_port_strcpy(trace_data.string_val[0].str, 
                                   p_ssa_pdb->p_conn_table_entry->peer_ip);
             break;

         case ICF_TRACE_UDP_SERVER_OPEN:
         case ICF_TRACE_TCP_SERVER_OPEN:
         case ICF_TRACE_TLS_SERVER_OPEN:
             
              trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;

              trace_data.int_val[0] =
                     (icf_uint32_t)(p_ssa_pdb->result);

              /*Fix For SPR : 18999*/
              ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                            p_ssa_pdb->p_glb_cfg_data)

              /*Added traces for per line configuration*/
			if (ICF_CFG_SELF_ADDR_PER_LINE ==
                       p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)

            {
                trace_data.int_val[1] = 
                    p_ssa_pdb->p_line_data->self_addr.port_num;

              trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
	          if( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME 
			       == p_ssa_pdb->p_line_data->self_addr.addr.addr_type)
	          {
	     	   	  icf_port_strcpy(trace_data.string_val[0].str,
                       p_ssa_pdb->p_line_data->self_addr.addr.addr.domain.str);
	    	  }
	          else if(ICF_TRANSPORT_ADDRESS_IPV4_ADDR
				== p_ssa_pdb->p_line_data->self_addr.addr.addr_type)
	          {
		     	icf_ssa_convert_to_IP_addr(&(p_ssa_pdb->p_line_data->self_addr),
                	            p_transp_addr_str);
	    		icf_port_strcpy(trace_data.string_val[0].str,
                                        p_transp_addr_str);
	    	  }
	    	  else if(ICF_TRANSPORT_ADDRESS_IPV6_ADDR
					== p_ssa_pdb->p_line_data->self_addr.addr.addr_type)
	      	  {
              	icf_port_strcpy(trace_data.string_val[0].str,
                    p_ssa_pdb->p_line_data->self_addr.addr.addr.ipv6_addr.str);
	    	  }

			}
			else
			{
	          trace_data.int_val[1] = 
                     p_ssa_pdb->p_glb_cfg_data->self_ip_address.port_num;
             
              trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
	          if( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME 
			       == p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
	          {
	     	   	  icf_port_strcpy(trace_data.string_val[0].str,
                       p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr.domain.str);
	    	  }
	          else if(ICF_TRANSPORT_ADDRESS_IPV4_ADDR
				== p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
	          {
		     	icf_ssa_convert_to_IP_addr(&(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                	            p_transp_addr_str);
	    		icf_port_strcpy(trace_data.string_val[0].str,
                                        p_transp_addr_str);
	    	  }
	    	  else if(ICF_TRANSPORT_ADDRESS_IPV6_ADDR
					== p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
	      	  {
              	icf_port_strcpy(trace_data.string_val[0].str,
                    p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr.ipv6_addr.str);
	    	  }
            }
              trace_data.string_val[0].str_len =
                    (icf_uint16_t )icf_port_strlen(trace_data.string_val[0].str);
              break;
	 
         case ICF_TRACE_TCP_CONNECTION_CLOSE:
         case ICF_TRACE_TLS_CONNECTION_CLOSE:

              /* Fix For SPR  19189 */
              ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                                   p_ssa_pdb->p_conn_table_entry)

             /*Send Remote IP address and port where connect was done*/
             trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
             trace_data.int_val[0] = p_ssa_pdb->p_conn_table_entry->peer_port_num;
             trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
             icf_port_strcpy(trace_data.string_val[0].str, 
                                   p_ssa_pdb->p_conn_table_entry->peer_ip);
             break;

         case ICF_TRACE_UDP_SERVER_CLOSE:
         case ICF_TRACE_TCP_SERVER_CLOSE:
         case ICF_TRACE_TLS_SERVER_CLOSE:
            
               
             trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;

             /*Fix For SPR : 18999*/
             ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                            p_ssa_pdb->p_glb_cfg_data)

               trace_data.int_val[0] =
                     p_ssa_pdb->p_glb_cfg_data->self_ip_address.port_num;
             
            
            trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
            /* To check if self address per line feature is enabled or not*/
            /* If yes then fetch the data for trace from p_line_data */
            if (ICF_CFG_SELF_ADDR_PER_LINE ==
                       p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)

            {
                  /*Fix For SPR : 18999*/
                  ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                            p_ssa_pdb->p_line_data)
                  trace_data.int_val[0] =
                         p_ssa_pdb->p_line_data->self_addr.port_num;        
                  if( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME
                        == p_ssa_pdb->p_line_data->self_addr.addr.addr_type)
                  { 
                        icf_port_strcpy(trace_data.string_val[0].str,
                             p_ssa_pdb->p_line_data->self_addr.addr.addr.domain.str);
                  } 
                  else if(ICF_TRANSPORT_ADDRESS_IPV4_ADDR
                                == p_ssa_pdb->p_line_data->self_addr.addr.addr_type)
                  { 
                        icf_ssa_convert_to_IP_addr(&(p_ssa_pdb->p_line_data->self_addr),
                                    p_transp_addr_str);
                        icf_port_strcpy(trace_data.string_val[0].str,
                                        p_transp_addr_str);
                  } 
                  else if(ICF_TRANSPORT_ADDRESS_IPV6_ADDR
                           == p_ssa_pdb->p_line_data->self_addr.addr.addr_type)
                  {
                        icf_port_strcpy(trace_data.string_val[0].str,
                             p_ssa_pdb->p_line_data->self_addr.addr.addr.ipv6_addr.str);
                  }

            }
            /* Else fetch the trace data from cfg data */   
            else
            {
                  trace_data.int_val[0] =
                     p_ssa_pdb->p_glb_cfg_data->self_ip_address.port_num;

                  if( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME
                        == p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
                  {
                        icf_port_strcpy(trace_data.string_val[0].str,
                             p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr.domain.str);
                  }
                  else if(ICF_TRANSPORT_ADDRESS_IPV4_ADDR
                                == p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
                  {
                        icf_ssa_convert_to_IP_addr(&(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                                    p_transp_addr_str);
                        icf_port_strcpy(trace_data.string_val[0].str,
                                        p_transp_addr_str);
                  }
                  else if(ICF_TRANSPORT_ADDRESS_IPV6_ADDR
                           == p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
                  {
                        icf_port_strcpy(trace_data.string_val[0].str,
                        p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr.ipv6_addr.str);
                  }
            }
            trace_data.string_val[0].str_len =
                    (icf_uint16_t )icf_port_strlen(trace_data.string_val[0].str);
             break;

        /* This code is not in use since these traces are also defined in 
         * common module in file icf_cmn_util.c and invoked in code through 
         * ICF_CMN_APP_TRACE */ 
#if 0
        case ICF_TRACE_UDP_SEND_ERROR:
        case ICF_TRACE_TCP_SEND_ERROR:
        case ICF_TRACE_TLS_SEND_ERROR:

              trace_data.num_of_integer_values = ICF_NO_INT_PRESENT; 
              /*
              trace_data.num_of_integer_values = ICF_TWO_INT_PRESENT;

               trace_data.int_val[0] =
                     (icf_uint32_t)(p_ssa_pdb->local_port_num);

                trace_data.int_val[1] =
                     (icf_uint32_t)(p_ssa_pdb->remote_port_num); */
   
              trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
            /*
             trace_data.number_of_string_values = ICF_TWO_STRING_PRESENT;

                  icf_port_strcpy(trace_data.string_val[0].str,
                                        p_ssa_pdb->p_ssa_ctxt->local_transport_addr.str);
             trace_data.string_val[0].str_len =
                    icf_port_strlen(trace_data.string_val[0].str);

               icf_port_strcpy(trace_data.string_val[1].str,
                                        p_ssa_pdb->p_ssa_ctxt->remote_transport_addr.str);
             trace_data.string_val[1].str_len =
                    icf_port_strlen(trace_data.string_val[1].str);
               */
               break;
#endif

         case ICF_TRACE_SIP_MSG_RETRANSMISSION_TIMEOUT:

               trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;

               /* trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;*/

               trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

               icf_port_strcpy(trace_data.string_val[0].str,
                       p_ssa_pdb->p_method);
               trace_data.string_val[0].str_len =
                   icf_port_strlen(trace_data.string_val[0].str);
                                                                   
             break;

         case ICF_TRACE_SDP_RTP_AVP_RECVD:
   
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
                icf_port_strcpy(trace_data.string_val[0].str,
                                        (icf_uint8_t*)"SDP RTP/AVP Received");
               trace_data.string_val[0].str_len =
                    icf_port_strlen(trace_data.string_val[0].str);

             break;

         case ICF_TRACE_SDP_RTP_SAVP_RECVD:

                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
                icf_port_strcpy(trace_data.string_val[0].str,
                                        (icf_uint8_t*)"SDP RTP/SAVP Received");
               trace_data.string_val[0].str_len =
                    icf_port_strlen(trace_data.string_val[0].str);
             break;

         case ICF_TRACE_PRIMARY_PROXY_NOT_RESPONDING:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;
         case ICF_TRACE_SECONDARY_PROXY_NOT_RESPONDING:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;
         case ICF_TRACE_PRIMARY_DNS_SERVER_NOT_RESPONDING:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;
         case ICF_TRACE_PRIMARY_REGISTRAR_ACTIVE:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;
         case ICF_TRACE_SECONDARY_REGISTRAR_ACTIVE:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;
         case ICF_TRACE_PRIMARY_REGISTRAR_NOT_RESPONDING:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;
         case ICF_TRACE_SECONDARY_REGISTRAR_NOT_RESPONDING:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;
         case ICF_TRACE_PRIMARY_PROXY_SERVER_ACTIVE:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;
         case ICF_TRACE_SECONDARY_PROXY_SERVER_ACTIVE:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;
         case ICF_TRACE_PRIMARY_DNS_SERVER_ACTIVE:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;
         case ICF_TRACE_SECONDARY_DNS_SERVER_ACTIVE:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;
         case ICF_TRACE_SECONDARY_DNS_SERVER_NOT_RESPONDING:
                trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
                trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;

        case ICF_TRACE_INVALID_AKA_AUTH_STATUS:
                trace_data.num_of_integer_values = ICF_ONE_INT_PRESENT;
                trace_data.int_val[0] =
                    (icf_uint32_t)line_id;
            
                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
                icf_port_strcpy(trace_data.string_val[0].str,
                        p_ssa_pdb->p_method);
                trace_data.string_val[0].str_len =
                    icf_port_strlen(trace_data.string_val[0].str);
                break;
                
        /* Invalid assoc uri trace send to application.This invalid assoc uri
         * is received in the 200 ok response to register request and send to
         * application in report_trace_ind*/        
                
        case  ICF_TRACE_INVALID_ASSOC_URI:
                trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
                /* Fix For SPR 19189 */
                ICF_CHECK_IF_VAR_IS_NULL_THEN_RETURN(p_glb_pdb,
                                                     p_ssa_pdb->p_invalid_assoc_uri)

                icf_port_strcpy(trace_data.string_val[0].str,
                       p_ssa_pdb->p_invalid_assoc_uri);
                trace_data.string_val[0].str_len =
                    icf_port_strlen(p_ssa_pdb->p_invalid_assoc_uri); 
                
                break ;

        case ICF_TRACE_SRTP_FALLBACK_INVOCATION:
               trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
               trace_data.number_of_string_values = ICF_NO_STRING_PRESENT;
                break;

 
	    default:
               trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
    
               trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;
             
               return ICF_SUCCESS;
     
        } /* end of switch-case for trace_id */
        if((p_ssa_pdb->common_bitmask & ICF_SSA_MSG_TRACE_ALREADY_SENT))
        {
        }
        else
        {
            /* Finally, invoke the common macro for trace handling */
            ICF_APP_TRACE(p_ssa_pdb->p_glb_pdb, trace_id, &trace_data,
                    p_criteria_data)
        }

     if(ICF_NULL != p_msg)
        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_msg,ICF_MEM_COMMON, 
             p_ssa_pdb->p_ecode,ret_val)

     return ret_val;
   }
} /* end of icf_ssa_app_trace() */

/*****************************************************************************
 * FUNCTION:           icf_ssa_port_stack_trace
 *
 * DESCRIPTION:        This function is used to print stack traces
 *
 *****************************************************************************/
icf_return_t icf_ssa_port_stack_trace(
              Sdf_ty_uaTraceLevel dLevel,
              Sdf_ty_traceType dType,
              const Sdf_ty_s8bit *pStr,
              Sdf_ty_u32bit dLen,
              Sdf_st_error *pErr)
{
    icf_trace_data_st                trace_data;

    if(ICF_NULL == p_persistent_glb_pdb)
        return ICF_SUCCESS;

    if (ICF_NULL != pStr)
        icf_port_strcpy(trace_data.string_val[0].str, 
                (icf_uint8_t *)pStr);
   
    trace_data.num_of_integer_values = ICF_NO_INT_PRESENT;
    trace_data.number_of_string_values = ICF_ONE_STRING_PRESENT;

    if(dLevel || Sdf_en_briefTraces)
    {
/*        ICF_TRACE(p_persistent_glb_pdb, ICF_SIP_STACK_BRIEF_TRACE,*/
/*                &trace_data)*/
    }
    else 
    {
/*        ICF_TRACE(p_persistent_glb_pdb, ICF_SIP_STACK_DETAILED_TRACE,*/
/*                &trace_data)*/
    }

    dLevel= dLevel;
    dType= dType;
    dLen = dLen;
    pErr=pErr;
    return ICF_NULL;
}
#endif /* end of #ifdef ICF_TRACE_ENABLE */

#ifdef ICF_DEBUG_TRACE_ENABLE
/****************************************************************************
 * FUNCTION:           icf_ssa_port_stack_debug
 *
 * DESCRIPTION:        This function is used to print stack debug traces
 *
 *****************************************************************************/
icf_void_t icf_ssa_port_stack_debug(
              const Sdf_ty_s8bit *pStr)
{
    icf_sm_glb_data_st               *p_sm_data =  ICF_NULL;
    icf_trace_type_t glb_trace_type =  ICF_NULL;

    if(ICF_NULL == p_persistent_glb_pdb)
        return;

    p_sm_data = 
     p_persistent_glb_pdb->p_glb_data->p_module_data[ICF_INT_MODULE_SM];

     glb_trace_type = p_sm_data->trace_type;

    if (ICF_TRACE_TYPE_SIP_STACK_DEBUG & glb_trace_type)
    {
        if (ICF_NULL != pStr)
        {
            printf("\n[SDF]: %s\n", pStr);
        }
    }
}
#endif /* end of #ifdef ICF_DEBUG_TRACE_ENABLE */

/*****************************************************************************
 ** FUNCTION:           icf_ssa_isHeaderPresent
 **
 ** DESCRIPTION:        This function checks for the presence of given header
 **                                     inside a SipMessage structure.
 **
 *****************************************************************************/
icf_return_t icf_ssa_isHeaderPresent
        (SipMessage             *p_sipMsg,
         en_HeaderType          dHeader,
         Sdf_st_error           *p_err)
{
        SipHeader dSipHdr;

        if (SipFail == sip_getHeader(
                    p_sipMsg,dHeader,&dSipHdr,
                    (SipError*)&p_err->stkErrCode))
        {
                return ICF_FAILURE;
        }
        sip_freeSipHeader(&dSipHdr);

        return ICF_SUCCESS;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_get_new_call_obj
 **
 ** DESCRIPTION:        This function checks if a new call obj can be allocated
 **                     by checking against the ssa ctxt - nw call id map.
 **                     This routine first iterates through the map array
 **                     to see if an entry can be added.  This is essentially
 **                     the same traversal we do in adding the actual map
 **                     Can be avoided for better performance
 **                     This routine also updates the PDB with the call obj
 **                     pointer.
 *****************************************************************************/
icf_return_t icf_ssa_get_new_call_obj
        (INOUT   icf_ssa_pdb_st      *p_ssa_pdb,
         INOUT   Sdf_st_callObject      **p_p_call_obj)
{ 
    icf_return_t         ret_val = ICF_SUCCESS;
    icf_glb_pdb_st       *p_glb_pdb = 
        p_ssa_pdb->p_glb_pdb;

    /*
    icf_ssa_glb_data_st  *p_ssa_glb_data = 
        p_ssa_pdb->p_ssa_glb_data;
    icf_uint16_t         count = 0;
    */
    Sdf_st_error sdf_error;

    ICF_FUNCTION_ENTER(p_glb_pdb)
    p_glb_pdb = p_glb_pdb;
           /* UMR fix */
           icf_port_memset(
               (icf_void_t *)&sdf_error,
               0,
               ICF_PORT_SIZEOF(Sdf_st_error));
           /*Fix for CSR 1-7407479*/
           if(ICF_SSA_MAX_CALL_OBJ == p_ssa_pdb->p_glb_pdb->no_of_call_obj)
           {
               ret_val = ICF_FAILURE;
           }
           else
           {
                if (Sdf_co_fail == 
                   sdf_ivk_uaInitCall(p_p_call_obj, &sdf_error))
                {
                   /*
                    * This means a memory allocation failed in SDF, 
                    * so  it must have been taken care of there only
                    * so we will attempt a MINOR error here
                    */
                   p_p_call_obj = ICF_NULL;
                   ret_val = ICF_FAILURE;
                }
                else
                {
                   /*Fix for CSR 1-7407479*/
                  p_ssa_pdb->p_ssa_ctxt->p_call_obj = *p_p_call_obj;
                  p_ssa_pdb->p_glb_pdb->no_of_call_obj++;
                }  
           }
   ICF_FUNCTION_EXIT(p_glb_pdb)
   return ret_val;
}



/*****************************************************************************
 ** FUNCTION:           icf_ssa_update_callobj_for_profile
 **
 ** DESCRIPTION:        This  routine:
 **                     1. Forms strings for From and Contact headers
 **                     2. Clones the global profile
 **                     3. Sets default From and Contact in the cloned profile
 **                     using the API received from CC.
 **                     5. Sets the profile in the callobject
 *****************************************************************************/
icf_return_t icf_ssa_update_callobj_for_profile(
        INOUT   icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_glb_pdb_st                   *p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    icf_error_t                      *p_ecode = p_ssa_pdb->p_ecode;
    icf_config_data_st               *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    icf_address_st                   *p_user_address = ICF_NULL;
    Sdf_st_initData                  *p_callobj_spec_profile = Sdf_co_null;
    Sdf_st_error                     sdf_error; 
    Sdf_ty_s8bit                     tpt_scheme_from[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                     tpt_scheme_contact[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                     from_user_addr[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                     display_name[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                     contact_addr[ICF_MAX_STR_LEN] = "\0";
    icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;
    icf_uint8_t                      *p_temp = ICF_NULL;
    /*  Fix merged for CSR 1-6456839 */
    icf_uint16_t                     port_us = ICF_NULL,default_port = ICF_NULL,final_from_port = ICF_NULL;
    icf_app_id_t                     app_id = ICF_APP_ID_INVALID;
#ifdef ICF_IPSEC_ENABLED
    icf_transport_address_st         *p_transport_address = ICF_NULL;
    icf_uint8_t                      p_transp_addr_str[20] = "";
#endif
    Sdf_ty_s8bit                    self_ip[ICF_MAX_STR_LEN] = "\0";
    icf_boolean_t                req_from_reg = ICF_FALSE;
    icf_boolean_t                int_subscribe_req = ICF_FALSE;
    icf_boolean_t                use_app_add_profile = ICF_FALSE;
    icf_transport_address_st      *p_contact_address = ICF_NULL;
    icf_transport_address_st     self_addr ;
    icf_uint8_t                  *p_contact_str = ICF_NULL;
   Sdf_ty_s8bit                     contact_user_id[ICF_MAX_STR_LEN] = "\0";   
    Sdf_ty_s8bit                     contact_scheme[ICF_MAX_STR_LEN] = "sip";

#ifdef ICF_NAT_RPORT_SUPPORT
    icf_rport_config_data_st            *p_rport_config_data = ICF_NULL;
#endif
 
    ICF_FUNCTION_ENTER(p_glb_pdb)

    p_ecode = p_ecode;

    /* UMR fix */
    icf_port_memset(
        (icf_void_t *)&sdf_error,
        0,
        ICF_PORT_SIZEOF(Sdf_st_error));
    ICF_SSA_INIT_TRANS_ADDR(&self_addr)

    /*
     * If call object's initdata is not null, this function need not do 
     * anything since the From and Contact will alraedy be set
     */
    if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData)
    {
        ICF_FUNCTION_EXIT(p_glb_pdb)
        return ret_val;
    }
    /*
     * If the bit ICF_SSA_USER_ADDR_FRM_CC is set in the SSA
     * PDB,it indicates that the address to be used for
     * the population of the From and Contact header is the local
     * address of the call contetx,else pick the user address stored 
     * in the RGM context.
     */

    if (ICF_SSA_USER_ADDR_FRM_CC & p_ssa_pdb->common_bitmask)
    {
        p_user_address = &(p_glb_pdb->p_call_ctx->local_address);

        if ( ICF_LOCAL_NAME_PRESENT &
                p_glb_pdb->p_call_ctx->common_bitmask)
        {
            icf_port_strcpy((icf_uint8_t *)display_name, 
                    (icf_uint8_t *)p_glb_pdb->p_call_ctx->local_name.str);
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)display_name,(icf_uint8_t *) "");
        }
        app_id = p_glb_pdb->p_call_ctx->app_id;
    }
    else if (ICF_SSA_USER_ADDR_FRM_SIC & p_ssa_pdb->common_bitmask)
    {
        p_user_address = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_user_address;
        app_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->app_id;
        if(ICF_DUMMY_APP_ID == app_id)
        {
            /* This is the case for SUBSCRIBE initiated by ICF */
            int_subscribe_req = ICF_TRUE;
        }
        /*If this a subscribe request for reg event package,triggered by IPTK
         * set the int_subscribe_req to TRUE*/
        if ((p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->bitmask &
                    ICF_SIC_AUTO_SUBSCRIPTION_FOR_REG_EVENT))
       {
           int_subscribe_req = ICF_TRUE;
       }    

        /* Code for display name to be added */
        icf_port_strcpy((icf_uint8_t *)display_name, (icf_uint8_t *)"");
    }
    else
    {
        p_ssa_ctxt = 
            (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
        ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))
        /* SPR 9849 Fix start */
        /*following is valid for IMS/Non-IMS*/
        p_user_address = &(p_ssa_ctxt->p_rgm_ctxt->rgm_user_address);
#if 0

ICF_CRM_START
        p_user_address = p_ssa_ctxt->p_rgm_ctxt->p_rgm_uris;
ICF_CRM_END
#endif
        /* SPR 9849 Fix end  */
        if ( ICF_NULL != p_ssa_pdb->p_line_data->user_name.str_len)
        {
            icf_port_strcpy((icf_uint8_t *)display_name, 
                    (icf_uint8_t *)p_ssa_pdb->p_line_data->user_name.str);
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)display_name, (icf_uint8_t *)"");
        }
        req_from_reg = ICF_TRUE;
    }

    
    /*
     * We are not checking whether there is atleast one user address
     * configured on this line. Assumed it has already been done
     * by some upstream module
     */

    /*Assumption: Address type validation must have 
     * been done in CFG*/
    if ( (ICF_ADDRESS_PLAN_SIP_URI == 
                p_user_address->addr_type) ||
            (ICF_ADDRESS_PLAN_E164 ==
             p_user_address->addr_type))
    {
        icf_port_strcpy((icf_uint8_t *)tpt_scheme_from, (icf_uint8_t *)"sip");
        icf_port_strcpy((icf_uint8_t *)tpt_scheme_contact, (icf_uint8_t *)"sip");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    else if (ICF_ADDRESS_PLAN_SIPS_URI == 
            p_user_address->addr_type)
    {
        icf_port_strcpy((icf_uint8_t *)tpt_scheme_from, (icf_uint8_t *)"sips");
        icf_port_strcpy((icf_uint8_t *)tpt_scheme_contact, (icf_uint8_t *)"sips");
        icf_port_strcpy((icf_uint8_t *)contact_scheme, (icf_uint8_t *)"sips"); /* By default it should be sips */
        default_port = ICF_DEFAULT_SIPS_SERVER_PORT;
    }
    /* Acc to RFC 3261 Section 8.1.1.8, the Contact header in an 
     * INVITE request must always be SIP/SIPS
     */
    else if (ICF_ADDRESS_PLAN_TEL_URI == 
            p_user_address->addr_type)
    {
        icf_port_strcpy((icf_uint8_t *)tpt_scheme_from, (icf_uint8_t *)"tel");
        if(ICF_TRANSPORT_TYPE_TLS == 
          p_ssa_pdb->p_ssa_ctxt->transport)
        {
            icf_port_strcpy((icf_uint8_t *)tpt_scheme_contact, (icf_uint8_t *)"sips");
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)tpt_scheme_contact, (icf_uint8_t *)"sip");
        }
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    /*
     * We copy the complete user address string from the local
     * address and then check if it is a E164, if it is then 
     * we append the self user address from global config data
     * to the string to get complete userid@hostname string
     */
    icf_port_strcpy((icf_uint8_t *)from_user_addr,
            (icf_uint8_t *)p_user_address->addr_val.str);
    
    /*If per line self transport then copy address from line_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
    {
        icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                        sizeof(icf_transport_address_st));
#ifdef ICF_NAT_RPORT_SUPPORT
        p_rport_config_data = p_ssa_pdb->p_line_data->p_rport_config_data;
#endif
    }
    else
    {
        icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                        sizeof(icf_transport_address_st));
#ifdef ICF_NAT_RPORT_SUPPORT
        p_rport_config_data = &(p_glb_cfg_data->rport_config_data);
#endif
    }
    
#ifdef ICF_NAT_RPORT_SUPPORT

    if(ICF_TRUE == p_rport_config_data->is_rport_reqd)
    {
        p_contact_address = &(p_rport_config_data->contact_ip_addr);
    }
    else
    {
        p_contact_address = &(self_addr); 
    }
#else
    p_contact_address = &(self_addr);
#endif

    /* ------------------------------------------------- */
    /* The userId in Contact header should be the userid configured through 
     * set_line_params api. If this is not configured, then the userid part
     * of From header should be used.
     */
    if (ICF_NULL != p_ssa_pdb->p_line_data->contact_user_info.str_len)
    {
        icf_port_strcpy((icf_uint8_t *)contact_user_id, 
            (icf_uint8_t *)p_ssa_pdb->p_line_data->contact_user_info.str);
    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)contact_user_id, (icf_uint8_t *)from_user_addr);
        p_temp = icf_port_strchr((icf_uint8_t *)contact_user_id,(icf_uint8_t)'@');
        if (p_temp)
        {
            *p_temp = '\0';
        }        
        /* Merged CSR 1-8314017.Fix in CSR 1-8561947*/
        /* Don't send the user info in contact if the user part is not
         * present in user address.
         */
        else if ((ICF_ADDRESS_PLAN_SIP_URI ==
                       p_user_address->addr_type) 
			||  (ICF_ADDRESS_PLAN_SIPS_URI ==
                      p_user_address->addr_type)
			    )
        {
            contact_user_id[0] = '\0';
    }
    }

    /* Merged CSR 1-8314017.Fix in CSR 1-8561947*/
    /* When address typr is sip or sips, NULL value of contact_user_id
     * indicates that user part is not present.then contact should not 
     * contain the user part in SIP URI address.
     */
    if (((ICF_ADDRESS_PLAN_SIP_URI ==
                       p_user_address->addr_type) 
		|| (ICF_ADDRESS_PLAN_SIPS_URI ==
                       p_user_address->addr_type)
		) && ('\0' == contact_user_id[0]))
    {
        /* Do nothing*/;
    }
    else
    {
    icf_port_strcat((icf_uint8_t *)contact_user_id,(icf_uint8_t *)"@");
    icf_port_strcpy((icf_uint8_t *)contact_addr, (icf_uint8_t *)contact_user_id);
    }

    /* ------------------------------------------------- */

    if ( ICF_ADDRESS_PLAN_E164 ==
            p_user_address->addr_type)
    {
	icf_transport_address_st       *p_from_address = ICF_NULL;

        icf_port_strcat((icf_uint8_t *)from_user_addr,(icf_uint8_t *)"@");

	 /* ----------- Form the From address ------------------ */
         /* In case of REGISTER message, if the configured user is E.164,
          * the From and To header should carry Registrar domain/IP and not
          * self address
          */
         if (ICF_SSA_USER_ADDR_FRM_RGM & p_ssa_pdb->common_bitmask)
         {
             p_from_address = &(p_ssa_pdb->p_line_data->registrar_addr);
         }
         else
         {
             p_from_address = &self_addr;
         }

if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
               p_from_address->addr.addr_type) 
        {
            icf_port_strcat(
				(icf_uint8_t *)from_user_addr,
                (icf_uint8_t *)p_from_address->addr.addr.domain.str);

        }
        else/*Assumption that it will be IPV4*/
        {
           /* icf_uint8_t remote_ip[16];
            icf_uint8_t contact_ip[16];
            if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                        &(self_addr), remote_ip))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                icf_port_strcat(from_user_addr, remote_ip);
                if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                            p_contact_address, contact_ip))
                {
                    ret_val = ICF_FAILURE;
                }   
                else
                {
                    icf_port_strcat(contact_addr, contact_ip);
                }
            }
	    */
	    icf_uint8_t from_ip[16] = "\0";
            if (ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                                                p_from_address, from_ip))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                icf_port_strcat((icf_uint8_t *)from_user_addr, (icf_uint8_t *)from_ip);
            }
        }

	/* ----------- Form the Contact address ------------------ */
        if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
               p_contact_address->addr.addr_type)
        {
            icf_port_strcat(
                   (icf_uint8_t *)contact_addr,
                   (icf_uint8_t *)p_contact_address->addr.addr.domain.str);
        }
        else/*Assumption that it will be IPV4*/
        {
            icf_uint8_t contact_ip[16] = "\0";
            if (ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                         p_contact_address, contact_ip))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                icf_port_strcat((icf_uint8_t *)contact_addr, (icf_uint8_t *)contact_ip);
            }
        }
    }

    /*
     * If the address type is SIP URI ,then we will
     * extract the userid from the SIP URI and then 
     * append the self IP address and port in order
     * to form the contact header
     */

     if (( ICF_ADDRESS_PLAN_SIP_URI ==
            p_user_address->addr_type) ||
            (ICF_ADDRESS_PLAN_SIPS_URI ==
            p_user_address->addr_type))
    {
        if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
               p_contact_address->addr.addr_type)
        {
            icf_port_strcat((icf_uint8_t *)contact_addr,
                    (icf_uint8_t *)p_contact_address->addr.addr.domain.str);
        }
        else/*Assumption that it will be IPV4*/
        {
            icf_uint8_t remote_ip[16];

            if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                        p_contact_address, remote_ip))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                icf_port_strcat((icf_uint8_t *)contact_addr, (icf_uint8_t *)remote_ip);
            }
        }
    }
    else if ( ICF_ADDRESS_PLAN_TEL_URI ==
            p_user_address->addr_type)
    {
        if(ICF_FAILURE ==
                icf_ssa_get_hostname_str_frm_trans_addr(
                    p_ssa_pdb,p_contact_address,(icf_uint8_t *)self_ip))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)contact_addr,(icf_uint8_t *)self_ip);
        }
    }
    if ( ICF_SUCCESS == ret_val)
    {
        /* Init the Initdata */
        if( Sdf_co_fail == sdf_ivk_uaInitInitData(&p_callobj_spec_profile, &sdf_error))
        {
           sdf_ivk_uaFreeInitData(p_callobj_spec_profile);
        /* Return from here, in all other failure legs we free the Initdata
            before returning */
            return ICF_FAILURE;
        }
        else if(ICF_TRUE == req_from_reg)
        {
            /* We will not do anything for registration */
          /* Make a profile by cloning the default profile and 
            adding the extra headers given in app_profile */
        }
        else if(ICF_TRUE == int_subscribe_req)
        {
            ret_val = icf_ssa_make_profile_for_internal_subscribe(
                p_callobj_spec_profile,p_ssa_pdb);

        }

        else if(ICF_FAILURE == icf_cfg_fetch_app_conf(p_ssa_pdb->p_glb_pdb,app_id,&(p_ssa_pdb->p_app_conf),p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
        /* Make the application profile */
        /* For INVITE/SUBSCRIBE/MESSAGE/PUBLISH/out-of-dialog-REFER, Supported 
         * and Accept headers will be populated from the request header list and
         * not from the app profile */
        /*Only in case of REGISTER request Call Object Profile should be populated from 
         *APP profile in all other cases it should be populated through header lists*/
        if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt)
        {
            use_app_add_profile = ICF_FALSE;
        }
        else
        {
            use_app_add_profile = ICF_TRUE;
        }
        if ((ICF_SUCCESS == ret_val) && 
            (ICF_FALSE == req_from_reg) && 
            (ICF_FALSE == int_subscribe_req))
        {
            if (ICF_FALSE == use_app_add_profile)
            {
                ret_val = icf_ssa_make_otg_app_profile(
                            p_callobj_spec_profile,p_ssa_pdb);
            }
            else
            {
                ret_val = icf_ssa_make_app_profile(
                            p_callobj_spec_profile,p_ssa_pdb);
            }
        }

        /* I observed a case where ret_val was equal to value 92, hence this */
        if (ICF_FAILURE != ret_val)
        {
#ifdef ICF_IPSEC_ENABLED
            
            /* If IPSec is enabled, set the port in Via and Contact headers to 
             * be the UE protected server port, for subsequent protected 
             * messages */

            if ((ICF_TRUE == p_glb_cfg_data->ipsec_enabled) &&
                (ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context))
            {
                /* For Registration message, rgm ctxt would have been already 
                 * copied in ssa pdb from ssa ctxt. For non-reg message, rgm ctx
                 * would have been fetched from uri and placed in ssa pdb */
                if (ICF_NULL != 
                        ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
                            p_ue_security_params)
                {
                    /* this means an SA exists */
                    port_us = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
                                p_ue_security_params->port_s;
                    
                    /* this code for getting p_transp_addr_str has been copied 
                     * from the function icf_ssa_process_open_nw_servers()
                     */

                    p_transport_address = &(self_addr);
                    if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                            p_transport_address->addr.addr_type)
                    {
                        icf_port_strcpy(p_transp_addr_str, 
                            p_transport_address->addr.addr.domain.str);
                    }
                    else if (ICF_TRANSPORT_ADDRESS_IPV4_ADDR == 
                                p_transport_address->addr.addr_type)
                    {
                        icf_ssa_convert_to_IP_addr(p_transport_address,
                            p_transp_addr_str);

                        if (0 == icf_port_strcmp(
                                    "0.0.0.0", 
                                    p_transp_addr_str))
                        {
                            ret_val = icf_ssa_get_and_populate_self_ip(
                                        p_ssa_pdb,
                                        p_transport_address,
                                        p_transp_addr_str);
                        }
                    }
#ifdef ICF_IPV6_ENABLED
                    else if(ICF_TRANSPORT_ADDRESS_IPV6_ADDR == 
                            p_transport_address->addr.addr_type)
                    {
                        icf_ssa_convert_to_IP_addr(p_transport_address,
                            p_transp_addr_str);
                        if( (0 == icf_port_strcmp("",p_transp_addr_str)) 
                                    || ( 0 == icf_port_strcmp("::",p_transp_addr_str))){
                            ret_val = icf_ssa_get_and_populate_self_ip(
                                        p_ssa_pdb,
                                        p_transport_address,
                                        p_transp_addr_str);
                        }
                    }
#endif
                    else
                    {
                        /* Raise a Major Category Error from here */
                        ret_val = ICF_FAILURE;
                    }

                    if (ICF_FAILURE != ret_val)
                    {
                        /* change the Via header in the default profile */
                        if (Sdf_co_fail == sdf_ivk_uaSetDefaultTransport(
                                            p_callobj_spec_profile,     
                                            (Sdf_ty_s8bit *)p_transp_addr_str,
                                            port_us,
                                            &sdf_error))
                        {
                            /*Raise A Major Error here-SDF PROCESSING FAILURE*/
                            ret_val = ICF_FAILURE;
                        }
                    }
                }
            } /* End if(ipsec_enabled) */
            else
            {
#endif
                  if (ICF_ADDRESS_PLAN_SIPS_URI ==
                        p_user_address->addr_type)         
                {
                    port_us = p_glb_cfg_data->p_tls_init_data->tls_sip_serv_port_num;
            /* Update the Via header stored in the profile with the TLS server port number */
            p_callobj_spec_profile->pTransport->dPort = port_us;
            icf_port_strcpy((icf_uint8_t *)contact_scheme, (icf_uint8_t *)"sips");            
                }
                else
                {
                    port_us = p_contact_address->port_num;
                }
#ifdef ICF_IPSEC_ENABLED
            }
#endif
        }

        if (ICF_SUCCESS == ret_val)
    {
        if(ICF_TRUE == req_from_reg)
        {

            if(Sdf_co_fail == sdf_ivk_uaSetDefaultFrom(
                        p_callobj_spec_profile,
                        display_name,
                        from_user_addr,
                        ICF_NULL,
                        (Sdf_ty_s8bit*)(&tpt_scheme_from),
                        &sdf_error))
            {
                /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                 * major ERROR*/
                ret_val = ICF_FAILURE;
            }
        }
        else
        {
           /*  Fix Merged for CSR 1-6456839 */
           /*  SCENARIO :
               iF APPLICATION explicitly asked for not sending port 
               then do not send otherwise send port in from header */
               
            final_from_port = (port_us == default_port)?ICF_NULL:port_us;
            if (final_from_port != ICF_NULL)
            {
                if (ICF_FALSE == p_glb_cfg_data->port_to_be_sent_in_from_header)
                {
                    final_from_port = ICF_NULL;
                }
            }
/*  CSR MERGE START : 1-5338324 */
#ifdef ICF_IPSEC_ENABLED
            if(Sdf_co_fail == sdf_ivk_uaSetDefaultFrom(
                        p_callobj_spec_profile,
                        display_name,
                        from_user_addr,
                        /* fix - default port should not go in header */
                        (Sdf_ty_u16bit)(final_from_port),
                        (Sdf_ty_s8bit*)(&tpt_scheme_from),
                        &sdf_error))
            {
                /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                 * major ERROR*/
                ret_val = ICF_FAILURE;
            }
#else
	if(Sdf_co_fail == sdf_ivk_uaSetDefaultFrom(
					p_callobj_spec_profile,
					display_name,
					from_user_addr,
					(Sdf_ty_u16bit)(final_from_port),
					(Sdf_ty_s8bit*)(&tpt_scheme_from),
					&sdf_error))
	{
                  /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                   * major ERROR*/
                   ret_val = ICF_FAILURE;
        }
#endif
/*  CSR MERGE END : 1-54338324 */
        }
    }/*end of ICF_SUCCESS check*/
        /*If Contact header is present in header_list then Add default Contact
         *from call context header list*/
        if (ICF_FAILURE == ret_val)
        {}
        else if (ICF_TRUE == icf_ssa_is_contact_present_in_hdr_list(p_ssa_pdb, &p_contact_str, (icf_uint8_t *)display_name,
                                                             (icf_uint8_t *)contact_scheme))

        {
             if (Sdf_co_fail == sdf_ivk_uaAddDefaultContact(
                    p_callobj_spec_profile,
                    display_name,
                    (Sdf_ty_s8bit *)p_contact_str,
                    ICF_NULL,
                    contact_scheme,
                    &sdf_error))
         {
             /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
              * major ERROR*/
             sdf_ivk_uaFreeInitData(p_callobj_spec_profile);
             ret_val = ICF_FAILURE;
         }
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_contact_str,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
    }
        else
        {
/* CSR MERGE START : 1-54338324 */
#ifdef ICF_IPSEC_ENABLED
            if (Sdf_co_fail == sdf_ivk_uaAddDefaultContact(
                p_callobj_spec_profile, display_name, contact_addr,
                /* fix - default port should not go in header */
                (Sdf_ty_u16bit)((port_us == default_port)?ICF_NULL:port_us),
                /* incase of IPSEC this will be the protected 
                 * server port in the protected  message 
                 */
                (Sdf_ty_s8bit*)(&contact_scheme), &sdf_error))

            {
                /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                 * major ERROR*/
                ret_val = ICF_FAILURE;
            }
#else
	if (Sdf_co_fail == sdf_ivk_uaAddDefaultContact(
                    p_callobj_spec_profile,
                    display_name,
                    contact_addr,
                    (Sdf_ty_u16bit)(port_us),
                    (Sdf_ty_s8bit*)(&tpt_scheme_contact),
                    &sdf_error))
        {
            /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
             * major ERROR*/
            ret_val = ICF_FAILURE;
        }
#endif

/* CSR MERGE END : 1-54338324 */
        }
        if ( ICF_FAILURE == ret_val)
        {
             /*do nothing*/
        }
        else
        {
#ifdef ICF_SIGCOMP_SUPPORT
            /* Check The Config data whether we are supporting 
             * sigcomp or not,If Yes then add comp=sigcomp param
             * in the contact header
             */
            if(ICF_TRUE == 
                p_glb_cfg_data->sigcomp_required)
            {
                /* ABOVE CHECK COMMENTED AS CFG CODING IS NOT DONE */
                if(ICF_FAILURE == 
                    icf_ssa_AddParamToContactHdrList
                                   (&(p_callobj_spec_profile->slContact),
                                   "comp=sigcomp",
                                   &sdf_error))
                {
                    /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                    * major ERROR*/
                    ret_val = ICF_FAILURE;
                }

            }
#else
            ret_val = ICF_SUCCESS;
#endif
        }
         
        if ((ICF_FAILURE != ret_val)
                && (ICF_TRUE == p_ssa_pdb->send_trans_param)
                && (ICF_TRANSPORT_MODE_BOTH != 
                    p_ssa_pdb->p_ssa_ctxt->transport))
        {
            /*Add transport paramater in Contact header if TCP/UDP*/
            ret_val = icf_ssa_add_transport_param_in_contact_hdr(
                    p_ssa_pdb,
                    p_callobj_spec_profile,
                    &sdf_error);
            /* Sone servers like Cisco, Nortel CS1K do not insert the 
             * ';transport=udp' in To URI, due to which strict URI comparison
             * in UATK fails and message is rejected. To Ensure interop for now,
             * IPTK will not send transport URI param when the value is UDP.
             */
            /* As per RFC 3261 Table 1, transport-param should not be 
             * sent in From and To headers. so once the param is inserted
             * in Contact Header, reset the flag so that it is not inserted 
             * later in To header
             */
            p_ssa_pdb->send_trans_param = ICF_FALSE;
        }

        if(ret_val == ICF_FAILURE)
        {
           /* Free the Init Data for all failure cases */
            sdf_ivk_uaFreeInitData(p_callobj_spec_profile);
        }
        /*Set the Init Data*/
        else if ( Sdf_co_fail == sdf_ivk_uaSetInitDataInCallObject(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_callobj_spec_profile,
                    &sdf_error))
        {
            /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
             * major ERROR*/
            sdf_ivk_uaFreeInitData (p_callobj_spec_profile);
            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_ivk_uaFreeInitData (p_callobj_spec_profile))
        {
               /*Raise a Major error*/
               ret_val = ICF_FAILURE;
        }
        /*This FreeInitData will be called irrespective of the return 
         * value from the call to SetInitDataInCallObject.
         * In case of success, the ref count of profile has been incr-
         * -mented and we need to decrease it to allow a future Free-
         * -InitData release the memory.
         * In case of failure, we need to free the profile right here.*/
        /*sdf_ivk_uaFreeInitData(pInitData);*/
    }
    /*
    else
    {
        sdf_ivk_uaFreeInitData(p_callobj_spec_profile);
    }
    */
    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * 
 * FUNCTION:           icf_ssa_find_proxy_address_list
 * 
 * DESCRIPTION:        This routine finds the proxy address for the REQUEST.
 *                  1 a.Primary (and secondary) proxy address(es) are picked 
 *                    from the DHCP response in icf_config_data_st (if DHCP 
 *                    Server has been configured by application)
 *                  1 b.Else, primary (and secondary) proxy address(es) are 
 *                    picked from icf_line_data_st.
 *                  2.Initially, p_rem_addr_active contains the primary proxy. 
 *                    p_rem_addr_inactive contains secondary proxy(if present)
 *                  3.Next this routine will check which of these is already 
 *                    present in the DNS buffer
 *                  4.If secondary address is present in the DNS buffer, 
 *                    p_rem_addr_active and p_rem_addr_inactive will be swapped
 *                    and secondary will now become active
 ******************************************************************************/
icf_return_t icf_ssa_find_proxy_address_list(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_transport_address_st    *p_active_proxy_addr = ICF_NULL;
    icf_transport_address_st    *p_inactive_proxy_addr = ICF_NULL;
    icf_transport_address_st    *p_temp_addr = ICF_NULL;
    icf_return_t                ret_val = ICF_SUCCESS;
    icf_return_t                dummy_ret_val = ICF_SUCCESS;
    icf_dns_buffer_st           *p_dns_buffer = ICF_NULL;
    icf_boolean_t               *p_sec_server_active = ICF_NULL;
   
    /* For KLOCWORKS warning removal */ 
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) 

    ICF_MEMGET(
        p_ssa_pdb->p_glb_pdb,
        ICF_PORT_SIZEOF(icf_transport_address_st),
        ICF_MEM_COMMON,
        p_active_proxy_addr,
        ICF_RET_ON_FAILURE,
        p_ssa_pdb->p_ecode,
        ret_val)
    
    /*klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_active_proxy_addr);

    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            ICF_PORT_SIZEOF(icf_transport_address_st),
            ICF_MEM_COMMON,
            p_inactive_proxy_addr,
            ICF_DONOT_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val)
    /*klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_inactive_proxy_addr);

    /*If mem allocation failed for inactive address then
     *free memory for active server address and return failure*/
    if (ICF_FAILURE == ret_val)
    {
         ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_active_proxy_addr,
                ICF_MEM_COMMON, 
                p_ssa_pdb->p_ecode, 
                dummy_ret_val)
          return ICF_FAILURE;
    }

    p_ssa_pdb->p_ssa_ctxt->bitmask_1 |= ICF_SSA_REQ_ROUTED_THROUGH_PROXY;
    
    /* Incrementing rem_servers_tried to 1 */
    p_ssa_pdb->p_ssa_ctxt->rem_servers_tried++;
    
    /* If DHCP server address was configured by application, 
     * then fetch proxy addresses from p_dhcp_resp */
    if (ICF_NULL != p_ssa_pdb->p_glb_cfg_data->p_dhcp_resp)
    {
        p_sec_server_active = 
            &(p_ssa_pdb->p_glb_cfg_data->sec_proxy_server_active);

        if (ICF_FAILURE == icf_cmn_convert_ip_string_to_transport_address(
                    p_ssa_pdb->p_glb_cfg_data->p_dhcp_resp->proxy_list[0].str,
                    p_active_proxy_addr))
        {
            ret_val = ICF_FAILURE;
        }
        /*Check if secondary proxy address is available in p_dhcp_resp, 
         *then copy to inactive address*/
        else if (0 != 
            icf_port_strlen(
                p_ssa_pdb->p_glb_cfg_data->p_dhcp_resp->proxy_list[1].str))
        {
            if (ICF_FAILURE == icf_cmn_convert_ip_string_to_transport_address(
                    p_ssa_pdb->p_glb_cfg_data->p_dhcp_resp->proxy_list[1].str,
                    p_inactive_proxy_addr))
            {
                ret_val = ICF_FAILURE;
            }
        }
        else
        {
            /*If secondary address is not found in list then free 
             * inactive server address*/
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_inactive_proxy_addr,
                ICF_MEM_COMMON, 
                p_ssa_pdb->p_ecode, 
                dummy_ret_val)
        }
    }
    /* Else if proxy is configured by application */
    else if (ICF_NULL != (p_ssa_pdb->p_line_data->line_data_received
                & ICF_CFG_LINE_DATA_PROXY_RECD))
    {
        p_sec_server_active = 
            &(p_ssa_pdb->p_line_data->sec_proxy_server_active);
            
        /*Copy primary proxy_addr to active server address in ssa_ctxt*/
        icf_cmn_copy_transport_address(p_active_proxy_addr,
            &(p_ssa_pdb->p_line_data->proxy_addr),
            p_ssa_pdb->p_glb_pdb,p_ssa_pdb->p_ecode);
            
        /*Check if secondary proxy is also available then copy secondary 
         *proxy address to inactive server address in ssa_ctxt*/
        if (ICF_NULL != (p_ssa_pdb->p_line_data->line_data_received 
                    & ICF_CFG_LINE_DATA_SEC_PROXY_RECD))
        {
            icf_cmn_copy_transport_address(
                    p_inactive_proxy_addr,
                    p_ssa_pdb->p_line_data->p_sec_proxy_addr,
                    p_ssa_pdb->p_glb_pdb,p_ssa_pdb->p_ecode);
        }
        else
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_inactive_proxy_addr,
                    ICF_MEM_COMMON, 
                    p_ssa_pdb->p_ecode, 
                    dummy_ret_val)
        }
    }
    /* return failure if proxy is not configured at all */
    else
    {
        ret_val = ICF_FAILURE;
    }

    /* As of now, active server address contains primary proxy
     * and inactive server address contains secondary proxy.
     * 
     * If, secondary proxy server is marked active i.e previous 
     * request was sent through secondary proxy, thus current 
     * request also needs to be sent through secondary proxy.
     * Thus, swap active and inactive server addresses so that 
     * secondary proxy is treated as active server
     * p_inactive_proxy_addr will be NULL when secondary server was 
     * active but then it is deleted from line*/

    if ((ICF_SUCCESS == ret_val) && 
            (ICF_TRUE == *p_sec_server_active) &&
            (ICF_NULL != p_inactive_proxy_addr))
    {
        p_temp_addr = p_active_proxy_addr;
        p_active_proxy_addr = p_inactive_proxy_addr;
        p_inactive_proxy_addr = p_temp_addr;
    }

    if ((ICF_FAILURE == ret_val) || (ICF_NULL == p_active_proxy_addr))
    {
        ret_val = ICF_FAILURE;
    }
    /*If active server addr is IP address or domain name and found in DNS cache
     *then use active server as primary remote*/
    else if ((ICF_TRANSPORT_ADDRESS_DOMAIN_NAME != 
                p_active_proxy_addr->addr.addr_type) || 
            ((ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
              p_active_proxy_addr->addr.addr_type) && 
             (ICF_SUCCESS == icf_ssa_dns_get_ip_from_fqdn(
                               p_active_proxy_addr->addr.addr.domain.str,
                               &(p_dns_buffer),
                               p_ssa_pdb->p_ecode))))
    {
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active = p_active_proxy_addr;
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive = p_inactive_proxy_addr;

        if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_active_proxy_addr->addr.addr_type)
        {
            if (ICF_NULL ==  p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr)
            {
                p_ssa_pdb->p_ssa_ctxt->bitmask |= ICF_SSA_CONTACT_IP_PRESENT;
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        ICF_PORT_SIZEOF(icf_dns_buffer_st),ICF_MEM_COMMON,\
                        p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr,\
                        ICF_DONOT_RET_ON_FAILURE,\
                        p_ssa_pdb->p_ecode, ret_val);
            }
            /* Copy if memory allocation has not failed */
            if (ICF_NULL !=  p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr)
            {
                icf_port_memcpy(p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr, 
                        p_dns_buffer, sizeof(icf_dns_buffer_st));
            }
        }
    }
    /*Check if secondary server address is configured and if domain name it
     *is available in DNS cache then use inactive address 
     * as primary remote address*/
    /*SPR 20048 - The problem was that IPTK was using the secondary address 
     when it was configured as IP and not the primary address which was
     configured as domain. IPTK should not use self intelligence and give 
     precedence to the primary address, therefore the check for the secondary
     address not domain is removed from below condition disabling usage of 
     secondary address.*/
    else if ((ICF_NULL != p_inactive_proxy_addr) && 
             ((ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
               p_inactive_proxy_addr->addr.addr_type) && 
              (ICF_SUCCESS == icf_ssa_dns_get_ip_from_fqdn(
                    p_inactive_proxy_addr->addr.addr.domain.str,
                    &(p_dns_buffer),
                    p_ssa_pdb->p_ecode))))
    {
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active = p_inactive_proxy_addr;
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive = p_active_proxy_addr;

        /*Because active proxy address is not found in DNS buffer and 
         * inactive is found so making this active proxy address*/
        if (ICF_TRUE == *p_sec_server_active)
        {
            *p_sec_server_active = ICF_FALSE;
        }
        else
        {
            *p_sec_server_active = ICF_TRUE;
        }

        /*Update SSA context with DNS buffer entry only when proxy address
         *is IP address. This code leg can be invoked when proxy server address
         *is IP address so in that case DNS entries should not be tried for updation*/
        if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_inactive_proxy_addr->addr.addr_type)
        {
            if (ICF_NULL ==  p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr)
            {
                p_ssa_pdb->p_ssa_ctxt->bitmask |= ICF_SSA_CONTACT_IP_PRESENT;
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        ICF_PORT_SIZEOF(icf_dns_buffer_st),ICF_MEM_COMMON,\
                        p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr,\
                        ICF_DONOT_RET_ON_FAILURE,\
                        p_ssa_pdb->p_ecode, ret_val);
            }
            /* Copy if memory allocation has not failed */
            if (ICF_NULL !=  p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr)
            {
                icf_port_memcpy(p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr, 
                        p_dns_buffer, sizeof(icf_dns_buffer_st));
            }
        }
    }/* end if - secondary configured */
    /*If not active as well as inactive found in DNS cache then use active 
     *as primary remote*/
    else
    {
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active = p_active_proxy_addr;
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive = p_inactive_proxy_addr;
    }

    /*If failure in any of above statements then free both active
     *and inactive server addresses*/
    if (ICF_FAILURE == ret_val)
    {
        if (ICF_NULL != p_active_proxy_addr)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_active_proxy_addr,
                    ICF_MEM_COMMON, 
                    p_ssa_pdb->p_ecode, 
                    dummy_ret_val)
        }
        if (ICF_NULL != p_inactive_proxy_addr)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_inactive_proxy_addr,
                    ICF_MEM_COMMON, 
                    p_ssa_pdb->p_ecode, 
                    dummy_ret_val)
        }
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active = p_active_proxy_addr;
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive = p_inactive_proxy_addr;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}

/*******************************************************************************
 * 
 * FUNCTION:           icf_ssa_find_registrar_address_list
 * 
 * DESCRIPTION:        This routine finds the registrar address for the REQUEST.
 *                  1.If configured, then primary (and secondary) registrar
 *                    address(es) are picked from icf_line_data_st.
 *                    p_rem_addr_inactive contains the secondary registrar
 *                    (if present)
 *                  3.Next this routine will check which of these is already 
 *                    present in the DNS buffer
 *                  4.If secondary address is present in the DNS buffer, 
 *                    p_rem_addr_active and p_rem_addr_inactive will be swapped
 *                    and secondary will now become active
 ******************************************************************************/
icf_return_t icf_ssa_find_registrar_address_list(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_transport_address_st    *p_active_reg_addr = ICF_NULL;
    icf_transport_address_st    *p_inactive_reg_addr = ICF_NULL;
    icf_transport_address_st    *p_temp_addr = ICF_NULL;
    icf_return_t                ret_val = ICF_SUCCESS;
    icf_return_t                dummy_ret_val = ICF_SUCCESS;
    icf_dns_buffer_st           *p_dns_buffer = ICF_NULL;
    icf_boolean_t               *p_sec_server_active = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            ICF_PORT_SIZEOF(icf_transport_address_st),
            ICF_MEM_COMMON,
            p_active_reg_addr,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val)

    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            ICF_PORT_SIZEOF(icf_transport_address_st),
            ICF_MEM_COMMON,
            p_inactive_reg_addr,
            ICF_DONOT_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val)

    /*If mem allocation failed for inactive address then
     *free memory for active server address and return failure*/
    if (ICF_FAILURE == ret_val)
    {
        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_active_reg_addr,
                ICF_MEM_COMMON, 
                p_ssa_pdb->p_ecode, 
                dummy_ret_val)
        return ICF_FAILURE;
    }

    /* Incrementing rem_servers_tried to 1 */
    p_ssa_pdb->p_ssa_ctxt->rem_servers_tried++;

    if (ICF_NULL != (p_ssa_pdb->p_line_data->line_data_received
                & ICF_CFG_LINE_DATA_REGISTRAR_RECD))
    {
        p_sec_server_active = 
            &(p_ssa_pdb->p_line_data->sec_registrar_active);

        /*Copy primary reg_addr to active server address in ssa_ctxt*/
        icf_cmn_copy_transport_address(p_active_reg_addr,
            &(p_ssa_pdb->p_line_data->registrar_addr),
            p_ssa_pdb->p_glb_pdb,p_ssa_pdb->p_ecode);
            
        /*Check if secondary reg is also available then copy secondary 
         *reg address to inactive server address in ssa_ctxt*/
        if (ICF_NULL != (p_ssa_pdb->p_line_data->line_data_received 
                    & ICF_CFG_LINE_DATA_SEC_REGISTRAR_RECD))
        {
            icf_cmn_copy_transport_address(p_inactive_reg_addr,
                    p_ssa_pdb->p_line_data->p_sec_registrar_addr,
                    p_ssa_pdb->p_glb_pdb,p_ssa_pdb->p_ecode);
        }
        else
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_inactive_reg_addr,
                    ICF_MEM_COMMON, 
                    p_ssa_pdb->p_ecode, 
                    dummy_ret_val)
        }
    }

    /* As of now, active server address contains primary 
     * registrar and inactive server address contains sec
     * registrar.
     * 
     * If, secondary registrar is marked active i.e previous 
     * REGISTER request was sent through sec registrar, thus 
     * current request also needs to be sent through sec 
     * registrar. Thus, swap active and inactive registrars 
     * so that secondary registrar is treated as active 
     * p_inactive_proxy_addr will be NULL when secondary server was 
     * active but then it is deleted from line*/
    
    if (p_sec_server_active && ((ICF_TRUE == *p_sec_server_active) && 
            (ICF_NULL != p_inactive_reg_addr)))
    {
        p_temp_addr = p_active_reg_addr;
        p_active_reg_addr = p_inactive_reg_addr;
        p_inactive_reg_addr = p_temp_addr;
    }

    /* SPR 18786: In all the following if-elseif-else blocks
     * the ssa context remote address active and inactive are
     * assigned so there is a possibility of memory leak,when
     * the same call leg is executed for register request and
     * then deregister request. Therefore free the existing pointer
     * and then assign the new one.
     */ 
    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active)
    {
         ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active,
                    ICF_MEM_COMMON, 
                    p_ssa_pdb->p_ecode, 
                    dummy_ret_val)
    }

    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive)
    {
         ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive,
                    ICF_MEM_COMMON, 
                    p_ssa_pdb->p_ecode, 
                    dummy_ret_val)
    }

    /*If active server addr is IP address or domain name and found in DNS cache
     *then use active server as primary remote*/
    if ((ICF_TRANSPORT_ADDRESS_DOMAIN_NAME != 
                p_active_reg_addr->addr.addr_type) || 
            ((ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
              p_active_reg_addr->addr.addr_type) && 
             (ICF_SUCCESS == icf_ssa_dns_get_ip_from_fqdn(
                 p_active_reg_addr->addr.addr.domain.str,
                 &(p_dns_buffer),
                 p_ssa_pdb->p_ecode))))
    {
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active = p_active_reg_addr;
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive = p_inactive_reg_addr;

        if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == p_active_reg_addr->addr.addr_type)
        {
            if (ICF_NULL ==  p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr)
            {
                p_ssa_pdb->p_ssa_ctxt->bitmask |= ICF_SSA_CONTACT_IP_PRESENT;

                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                    ICF_PORT_SIZEOF(icf_dns_buffer_st),ICF_MEM_COMMON,\
                    p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr,\
                    ICF_DONOT_RET_ON_FAILURE,\
                    p_ssa_pdb->p_ecode, ret_val);
            }
            /* Copy if memory allocation has not failed */
            if (ICF_NULL !=  p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr)
            {
                icf_port_memcpy(p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr, 
                        p_dns_buffer, sizeof(icf_dns_buffer_st));
            }
        }
    }
    /*Check if secondary server address is configured and if domain name is
      available in DNS cache then use inactive address as primary remote
      address*/
    /*SPR 20048 - The problem was that IPTK was using the secondary address 
     when it was configured as IP and not the primary address which was
     configured as domain. IPTK should not use self intelligence and give 
     precedence to the primary address, therefore the check for the secondary
     address not domain is removed from below condition disabling usage of 
     secondary address.*/
    else if ((ICF_NULL != p_inactive_reg_addr) && 
              ((ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_inactive_reg_addr->addr.addr_type) && 
                (ICF_SUCCESS == icf_ssa_dns_get_ip_from_fqdn(
                    p_inactive_reg_addr->addr.addr.domain.str,
                    &(p_dns_buffer),
                    p_ssa_pdb->p_ecode))))
    {
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active = p_inactive_reg_addr;
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive = p_active_reg_addr;

        /*Because active proxy address is not found in DNS buffer and 
         * inactive is found so making this active proxy address*/
		if ( p_sec_server_active ) {
        if (ICF_TRUE == *p_sec_server_active)
        {
            *p_sec_server_active = ICF_FALSE;
        }
        else
        {
            *p_sec_server_active = ICF_TRUE;
        }
		}

        if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == p_inactive_reg_addr->addr.addr_type)
        {
            if (ICF_NULL ==  p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr)
            {
                p_ssa_pdb->p_ssa_ctxt->bitmask |= ICF_SSA_CONTACT_IP_PRESENT;
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                    ICF_PORT_SIZEOF(icf_dns_buffer_st),ICF_MEM_COMMON,\
                    p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr,\
                    ICF_DONOT_RET_ON_FAILURE,\
                    p_ssa_pdb->p_ecode, ret_val);
            }
            /* Copy if memory allocation has not failed */
            if (ICF_NULL !=  p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr)
            {
                icf_port_memcpy(p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr, 
                        p_dns_buffer, sizeof(icf_dns_buffer_st));
            }
        }
    }/* end if - secondary configured */
    /*If not active as well as inactive found in DNS cache then use active 
     *as primary remote*/
    else
    {
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active = p_active_reg_addr;
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive = p_inactive_reg_addr;
    }

    /*If failure in any of above statements then free both active
     *and inactive server addresses*/
    if (ICF_FAILURE == ret_val)
    {
        if (ICF_NULL != p_active_reg_addr)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_active_reg_addr,
                ICF_MEM_COMMON, 
                p_ssa_pdb->p_ecode, 
                dummy_ret_val)
        }
        if (ICF_NULL != p_inactive_reg_addr)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_inactive_reg_addr,
                    ICF_MEM_COMMON, 
                    p_ssa_pdb->p_ecode, 
                    dummy_ret_val)
        }
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active = p_active_reg_addr;
        p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive = p_inactive_reg_addr;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * 
 * FUNCTION:           icf_ssa_set_to_in_reg_callobj
 * 
 * DESCRIPTION:        This routine sets the To header for REGISTER request.
 *                  1.The To header is populated on the basis of the user 
 *                  addr stored in the RGM context.
 *                  2.If the user address is E164,then self address
 *                  (IP/domain name) is appended.
 *                  3.Invoke the sdf_ivk_uaSetTo API which sets the To header
 *                  4. Check if taranport mode in reg_addr and in line_data
 *                  is different then return failure else if transport is 
 *                  TCP/UDP and transport is preset in user_addr then create 
 *                  transport=tcp/udp parameter and insert in TO header
 *
 ******************************************************************************/
icf_return_t icf_ssa_set_to_in_reg_callobj(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_uint8_t                      proxy_address[ICF_MAX_STR_LEN];
    icf_address_st                   *p_user_address = ICF_NULL;
    icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;
    Sdf_st_error                     sdf_error;
    icf_uint16_t                     dest_port_num = ICF_NULL;
    /* CAUTION: if we modify the size of char array
     * in icf_string_st, we should do the same 
     * here in this local variable*/
    icf_uint8_t                      dest_request_uri[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t                      display_name[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t                      proto[ICF_MAX_SIZE_INT_USAGE_STR] = "\0";
    icf_uint8_t                      scheme[ICF_MAX_SIZE_INT_USAGE_STR] = "\0";
    icf_uint8_t                      reg_route_addr[ICF_MAX_STR_LEN] = "\0";
    icf_transport_address_st         self_addr ;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    ICF_SSA_INIT_TRANS_ADDR(&self_addr)

    /* UMR fix */
    icf_port_memset(
        (icf_void_t *)&sdf_error,
        0,
        ICF_PORT_SIZEOF(Sdf_st_error));

    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))

    /*If per line self transport then copy address from line_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE == 
        p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                        sizeof(icf_transport_address_st));
    }
    else
    {
        icf_port_memcpy(&self_addr, 
                        &(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                        sizeof(icf_transport_address_st));
    }
 
    /*Merge decision: assumed that this function will be called for setting
     * the To header for outgoing SUBSCRIBE requests also*/
    if (ICF_SSA_USER_ADDR_FRM_SIC & p_ssa_pdb->common_bitmask)
    {
        p_user_address = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_user_address;
        icf_port_strcpy(display_name,(icf_uint8_t *) "");    
    }
    else
    {/*if not from SIC, then must be from REG module*/
        /* SPR 9849 Fix start */
        p_user_address = &(p_ssa_ctxt->p_rgm_ctxt->rgm_user_address);        
                
#if 0
        /* Picking the URI from the rgm_uri list */
        p_user_address = p_ssa_ctxt->p_rgm_ctxt->p_rgm_uris;
#endif
        /* SPR 9849 Fix end  */
    }

    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_user_address))
    
    if (( ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type) &&
            (ICF_TRANSPORT_TYPE_TLS != p_ssa_pdb->p_glb_cfg_data->self_mode))
    {
        ret_val = ICF_FAILURE;
        return ret_val;
    }

    /* Get the scheme type sip/tel) */
    if ( ICF_ADDRESS_PLAN_TEL_URI == p_user_address->addr_type)
    {
        icf_port_strcpy(scheme, (icf_uint8_t *)"tel");
    }
    else if ( ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type)
    {
        icf_port_strcpy(scheme, (icf_uint8_t *)"sips");
    }
    else
    {
        icf_port_strcpy(scheme, (icf_uint8_t *)"sip");
    }

ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_FALSE)

    if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_line_data->reg_mode) ||
        (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_line_data->reg_mode))
    {
        icf_port_strcpy(proto, (icf_uint8_t *)"TCP");
    }
    else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_line_data->reg_mode)
    {
        icf_port_strcpy(proto, (icf_uint8_t *)"TLS");
    }
    else if (ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->p_line_data->reg_mode)
    {
        icf_port_strcpy(proto, (icf_uint8_t *)"UDP");
    }
    else
    {
       icf_port_strcpy(proto, (icf_uint8_t *)"");
    }

    /* In case the application wants to send the Register request via NAT or 
     * proxy then add the Route header specifying the configured next hop */
    if ((ICF_SUCCESS == ret_val) && 
        (ICF_CFG_LINE_DATA_REG_ROUTE_ADDR_RECD & 
        p_ssa_pdb->p_line_data->line_data_received))
    {
        dest_port_num = p_ssa_pdb->p_line_data->reg_route_addr.port_num;

        if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
            p_ssa_pdb->p_line_data->reg_route_addr.addr.addr_type)
        {
            icf_port_strcpy(reg_route_addr,
                p_ssa_pdb->p_line_data->reg_route_addr.addr.addr.domain.str);
        }
        else
        {
            /* No need to check return value of 
              * icf_ssa_convert_to_IP_addr. Always
              * returns SUCCESS */
            icf_ssa_convert_to_IP_addr(
                &(p_ssa_pdb->p_line_data->reg_route_addr),
                reg_route_addr);
        }
        if (Sdf_co_fail == sdf_ivk_uaAddDefaultPreLoadedRoute(
                              p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                              Sdf_co_null,
                              (Sdf_ty_s8bit *)reg_route_addr,
                              dest_port_num,
                              "lr",/*pParam*/
                              ((ICF_TRANSPORT_TYPE_TLS == 
                              p_ssa_pdb->p_line_data->reg_mode)?"sips":"sip"),
                              &sdf_error))
        {

            ret_val = ICF_FAILURE;
        }
    } /* send Route header in REGISTER */
ICF_CHECK_IMS_END

ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
    if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_line_data->transport_mode) ||
        (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_line_data->transport_mode))
    {
        icf_port_strcpy(proto, (icf_uint8_t*)"TCP");
    }
    else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_line_data->transport_mode)
    {
        icf_port_strcpy(proto, (icf_uint8_t*)"TLS");
    }
    else if (ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->p_line_data->transport_mode)
    {
        icf_port_strcpy(proto, (icf_uint8_t*)"UDP");
    }
    else
    {
       icf_port_strcpy(proto, (icf_uint8_t*)"");
    }

    /* In IMS mode, validation fails if reg_route is present, thus no need to 
    * check here */
    /* Detect active registrar and set in dest_request_uri  */
    if (ICF_SUCCESS == icf_ssa_find_proxy_address_list(p_ssa_pdb))
    {
         icf_transport_address_st    *p_transport = ICF_NULL;

         if (p_ssa_pdb->common_bitmask & ICF_SSA_USE_REM_SERVER_INACTIVE)
         {
             /*if secondary proxy server is deleted by applicaiton in between
             *the call setup phase then this parameter will be NULL for 
             *attept on secondary proxy address, so mark proxy_cfg as FALSE
             *to initiate call clear*/
            if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive)
            {
                p_transport = p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive;
                p_ssa_pdb->p_ssa_ctxt->bitmask_1 |= ICF_SSA_SEC_SERVER_ADDRESS_IS_USED;
                p_ssa_pdb->p_ssa_ctxt->rem_servers_tried = p_ssa_pdb->rem_srv_cnt;
            }
            else
            {
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
                 ret_val = ICF_FAILURE;
            }
         }
         else
         {
             p_transport = p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active;
         }
         if (ICF_SUCCESS == ret_val)
         {
             dest_port_num = p_transport->port_num;

             if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_transport->addr.addr_type)
             {
                  icf_port_strcpy(proxy_address,
                          p_transport->addr.addr.domain.str);
             }
             else
             {
                 /* No need to check return value of 
                  * icf_ssa_convert_to_IP_addr. Always
                  * returns SUCCESS */
                  icf_ssa_convert_to_IP_addr(p_transport,
                      proxy_address);
             }
         }
    }/* end if SUCCESS - find_proxy_address_list */
    else
    {
        ret_val = ICF_FAILURE;
    }/* end if FAILURE - find_proxy_address_list */
#ifdef ICF_SIGCOMP_SUPPORT
    if(ICF_PEER_SUPPORTS_SIGCOMP == 
        p_ssa_pdb->p_line_data->sigcomp_support_by_proxy)
    {
        if ( Sdf_co_fail == 
            sdf_ivk_uaAddDefaultPreLoadedRoute(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
            Sdf_co_null,
            proxy_address,
            dest_port_num,
            "lr;comp=sigcomp",/*pParam*/
            ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_line_data->reg_mode)?"sips":"sip"),
            &sdf_error))
        {
            /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
        
    }
    else
    {
        if ( Sdf_co_fail == 
            sdf_ivk_uaAddDefaultPreLoadedRoute(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
            Sdf_co_null,
            proxy_address,
            dest_port_num,
            "lr",/*pParam*/
            ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_line_data->reg_mode) ? "sips":"sip"),
            &sdf_error))
        {
            /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
        
    }
#else
    if(ICF_FAILURE == ret_val)
    {
        /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
        
    }
    else if ( Sdf_co_fail == 
        sdf_ivk_uaAddDefaultPreLoadedRoute(
        p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
        Sdf_co_null,
        (Sdf_ty_s8bit*)proxy_address,
        dest_port_num,
        "lr",/*pParam*/
        ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_line_data->reg_mode)?"sips":"sip"),
        &sdf_error))
    {
        /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
#endif
    if(ICF_FAILURE == ret_val)
    {
        /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
        
    }
ICF_CHECK_IMS_END

    if(ICF_SUCCESS == ret_val)
    {
        dest_port_num = self_addr.port_num;

        /*Form the Request URI String*/
        icf_port_strcpy(
                dest_request_uri,
                p_user_address->addr_val.str);

        if ( (ICF_ADDRESS_PLAN_E164  == 
                    p_user_address->addr_type ))
        {
            icf_uint8_t         reg_addr[ICF_MAX_STR_LEN] = "";

            /*In IMS MODE: Use primary registrar always
             *In non-IMS mode: if REG-ROUTE is present then use primary REGISTRAR
             *otherwise select active registrar and send request to this registrar
             */
            if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ims_oprn_flag) || 
                ((ICF_FALSE == p_ssa_pdb->p_glb_cfg_data->ims_oprn_flag) &&
                 (ICF_CFG_LINE_DATA_REG_ROUTE_ADDR_RECD & 
                   p_ssa_pdb->p_line_data->line_data_received)))
            {
                /* Copy the registrar address in local variables */
                /* for IMS network registrar address is same as proxy address */
                if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                    p_ssa_pdb->p_line_data->registrar_addr.addr.addr_type)
                {
                    icf_port_strcpy(reg_addr,
                        p_ssa_pdb->p_line_data->registrar_addr.addr.addr.domain.str);
                }
                else
                {
                    /* No need to check return value of 
                    * icf_ssa_convert_to_IP_addr. Always
                    * returns SUCCESS */
                    icf_ssa_convert_to_IP_addr(
                        &(p_ssa_pdb->p_line_data->registrar_addr),
                        reg_addr);
                }
            }
            /*Now, if its non-IMS mode when REG-ROUTE is not onfigured then find active and
             *secondary registrar addresses*/
          else 
          {   
            if(ICF_NULL == p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active) 
            {
                /*SPR18392 This function was onvoked twice in E164 call 
                  another call was from send_reg_request function which
                  created memory leak. The function should only be invoked 
                  if the p_rem_addr_active is null.*/
                   ret_val = icf_ssa_find_registrar_address_list(p_ssa_pdb);
            }
            if(ICF_SUCCESS == ret_val)
            {   
                icf_transport_address_st    *p_transport = ICF_NULL;

                if (p_ssa_pdb->common_bitmask & ICF_SSA_USE_REM_SERVER_INACTIVE)
                {
                    p_transport = p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive;
                }
                else
                {
                    p_transport = p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active;
                }
                if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                    p_transport->addr.addr_type)
                {
                    icf_port_strcpy(reg_addr,
                       p_transport->addr.addr.domain.str);
                }
                else
                {
                    /* No need to check return value of 
                     * icf_ssa_convert_to_IP_addr. Always
                     * returns SUCCESS */
                     icf_ssa_convert_to_IP_addr(p_transport,
                        reg_addr);
                }
            }/*end of "if" for ret_val success*/   
          }  
            icf_port_strcat(dest_request_uri,(icf_uint8_t*)"@");
            icf_port_strcat(dest_request_uri, reg_addr);
        }
    }

    if(ICF_SUCCESS == ret_val)
    {
        if ( ICF_NULL != 
                p_ssa_pdb->p_line_data->user_name.str_len)
        {
            icf_port_strcpy(display_name, 
                    p_ssa_pdb->p_line_data->user_name.str);
        }
        else
        {
            icf_port_strcpy(display_name, (icf_uint8_t *)"");
        }

        if(Sdf_co_fail == sdf_ivk_uaSetTo(p_ssa_pdb->p_ssa_ctxt->p_call_obj, 
                    (Sdf_ty_s8bit *)display_name,
                    (Sdf_ty_s8bit *)dest_request_uri, 
        /* Merged from 4.3, this port shud be 0 always */
            ICF_NULL,
                    (Sdf_ty_s8bit *)scheme,
                    &sdf_error))
        {
            /*Raise/Set Major Error here:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_set_to_in_callobj
 **
 * DESCRIPTION:     This  routine's purpose is to set the TO header
 *                  for outgoing calls.
 *                  1.For that, we need to get the 
 *                  remote party uri, scheme-sip/tel, remote's port
 *                  number, remote party display name.
 *                  2.Sets the proxy, if it is to be used, in the PreLoaded
 *                  Route set of the profile
 *                  3. Check if Transport is TCP/UDP and transport is preset 
 *                  in user_addr then create transport=tcp/udp parameter
 *                  and insert in TO header
*****************************************************************************/
icf_return_t icf_ssa_set_to_in_callobj(
        INOUT   icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_return_t                 ret_val = ICF_SUCCESS;
    icf_glb_pdb_st               *p_glb_pdb = 
        p_ssa_pdb->p_glb_pdb;

    icf_call_ctx_st              *p_call_ctxt =
        p_glb_pdb->p_call_ctx;

    icf_config_data_st           *p_glb_cfg_data =
        p_ssa_pdb->p_glb_cfg_data;

    icf_address_st               *p_rem_addr = 
        &(p_call_ctxt->remote_party_addr);
    icf_transport_address_st     *p_proxy_addr = ICF_NULL; 

    icf_boolean_t                is_proxy_cfg = ICF_FALSE, 
                                    is_preloaded_req = ICF_FALSE;

    icf_uint8_t  proxy_address[ICF_MAX_STR_LEN],
                 str_count = 0;
#ifdef ICF_SIGCOMP_SUPPORT
    icf_void_t            *p_sigsa_ctxt = ICF_NULL;
#endif

    /*
     * CAUTION: if we modify the size of char array
     * in icf_string_st, we should do the same 
     * here in this local variable
     */

    icf_uint8_t       dest_request_uri[ICF_MAX_STR_LEN] = "\0",
                         dest_request_ip[ICF_MAX_STR_LEN] = "\0",
                         display_name[ICF_MAX_STR_LEN] = "\0",
                         tpt_scheme[ICF_MAX_SIZE_INT_USAGE_STR] = "\0",
                         proxy_addr_str[ICF_MAX_STR_LEN] = "\0";

    icf_uint8_t       *p_temp = ICF_NULL,*p_temp_1 = ICF_NULL;
    icf_uint16_t      dest_port_num = 0,default_port =ICF_NULL;
    Sdf_st_error         sdf_error;
    icf_string_st     param_val;

#ifdef ICF_SIGCOMP_SUPPORT
    icf_transport_address_st     *p_sigcomp_proxy_addr = ICF_NULL;
    icf_error_t      ecode;
    icf_boolean_t    is_to_add_sigcomp_param_in_route = ICF_FALSE;
#endif
    icf_list_st   *p_temp_list_node = ICF_NULL;
    icf_tag_list_st        temp_tag_list = {0, 0};

    ICF_FUNCTION_ENTER(p_glb_pdb)
        
#ifdef ICF_SIGCOMP_SUPPORT
#ifdef ICF_IPSEC_ENABLED
    if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
    {
        icf_rgm_glb_data_st         *p_rgm_glb_data  = ICF_NULL;

        if (ICF_FAILURE == \
                icf_dbm_get_module_glb_data(p_ssa_pdb->p_glb_pdb,\
                ICF_INT_MODULE_REGM, 
                (icf_void_t **)(p_rgm_glb_data),
                p_ssa_pdb->p_ecode))
        {
            /*ICF_SIGSA_TRACE(("\nFailure while getting RGM Global Data in SIGSA\n"));*/
            return ICF_FAILURE;
        }
        p_sigsa_ctxt = p_rgm_glb_data->p_sigsa_ctxt;
    }
    else
    {
        p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
    }
#else
    p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
#endif
#endif

    /* UMR fix */
    icf_port_memset(
        (icf_void_t *)&sdf_error,
        0,
        ICF_PORT_SIZEOF(Sdf_st_error));

    /* Fetch proxy address, SUCCESS will be returned if proxy found */
    if (ICF_SUCCESS == icf_ssa_find_proxy_address_list (p_ssa_pdb))
    {
        is_proxy_cfg = ICF_TRUE;
        if (p_ssa_pdb->common_bitmask & ICF_SSA_USE_REM_SERVER_INACTIVE)
        {
            /*if secondary proxy server is deleted by applicaiton in between
             *the call setup phase then this parameter will be NULL for 
             *attept on secondary proxy address, so mark proxy_cfg as FALSE
             *to initiate call clear*/
            if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive)
            {
                p_proxy_addr = p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive;
                p_ssa_pdb->p_ssa_ctxt->bitmask_1 |= ICF_SSA_SEC_SERVER_ADDRESS_IS_USED;
                p_ssa_pdb->p_ssa_ctxt->rem_servers_tried = p_ssa_pdb->rem_srv_cnt;
            }
            else
            {
                is_proxy_cfg = ICF_FALSE;

                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            }
        }
        else
        {
            p_proxy_addr = p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active;
        }
    }

#ifdef ICF_SIGCOMP_SUPPORT
    if((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) &&
       (ICF_NULL != p_sigsa_ctxt) &&
       (ICF_SUCCESS == icf_sigsa_get_sigcomp_proxy_addrs_from_ctxt
                        (p_sigsa_ctxt,
                        &p_sigcomp_proxy_addr,
                        &is_to_add_sigcomp_param_in_route,&ecode)))
    {
        if(ICF_NULL != p_sigcomp_proxy_addr)
        {
            p_proxy_addr = p_sigcomp_proxy_addr;
        }
    }
#endif

    if (ICF_TRUE == is_proxy_cfg)
    {
        if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_proxy_addr->addr.addr_type)
        {
            icf_port_strcpy(proxy_addr_str,
                    p_proxy_addr->addr.addr.domain.str);
        } /* p_proxy_addr->addr.a... */
        else
        {
            /* No need to check return value of 
             * icf_ssa_convert_to_IP_addr. Always
             * returns SUCCESS */
             icf_ssa_convert_to_IP_addr(p_proxy_addr,
                    proxy_addr_str);
        }
    }

    /*Get the scheme type sip/tel)*/
    if ( ICF_ADDRESS_PLAN_TEL_URI ==
            p_rem_addr->addr_type)
    {
        icf_port_strcpy(tpt_scheme, (icf_uint8_t *)"tel");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    else if ( ICF_ADDRESS_PLAN_SIPS_URI ==
            p_rem_addr->addr_type)
    {
        icf_port_strcpy(tpt_scheme, (icf_uint8_t *)"sips");
        default_port = ICF_DEFAULT_SIPS_SERVER_PORT;
    }
    else
    {   
        icf_port_strcpy(tpt_scheme, (icf_uint8_t *)"sip");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    
    /*
     * Copy the received address string in dest request uri
     * Whatever type it is, it will be the first part of dest req uri
     */

    icf_port_strcpy(
            dest_request_uri,
            p_rem_addr->addr_val.str);

    /* Removing any params from address. These will be
       inserted once to is formed earlier we were doing
       this only for TEL uri*/

    str_count=0;

    while( (str_count < ICF_MAX_STR_LEN) && ('\0' != dest_request_uri[str_count]) )
    {
        if(';' == dest_request_uri[str_count])
            break;
        str_count++;
    }

    if (str_count < ICF_MAX_STR_LEN) 
	{ 
		dest_request_uri[str_count] = '\0';
	}


    if ( (ICF_ADDRESS_PLAN_E164  == p_rem_addr->addr_type ) ||
            (ICF_ADDRESS_PLAN_TEL_URI == p_rem_addr->addr_type ))
    {
        if ( ICF_TRUE == is_proxy_cfg )
        {
            dest_port_num = p_proxy_addr->port_num;
            is_preloaded_req = ICF_TRUE;
            
           if ( ICF_ADDRESS_PLAN_E164  == p_rem_addr->addr_type )
            {
                /*Form the request URI*/
                icf_port_strcat(
                        dest_request_uri,(icf_uint8_t *)"@");
                icf_port_strcat(
                        dest_request_uri,
                        proxy_addr_str);
            }
        }
        else
        {
            /* Set the call clear reson */
            p_call_ctxt->release_cause = 
                ICF_CALL_CLEAR_REASON_PROXY_ADDRESS_NOT_CONFIGURED;
            ret_val = ICF_FAILURE;
        }
    }
    else if ((ICF_ADDRESS_PLAN_SIP_URI == p_rem_addr->addr_type ) ||
                (ICF_ADDRESS_PLAN_SIPS_URI == p_rem_addr->addr_type))
    {
        icf_uint8_t       str[ICF_MAX_STR_LEN];
        /* Now we will attempt to get the port number*/
#ifdef ICF_IPV6_ENABLED
        p_temp = icf_port_strchr(dest_request_uri,']');
    /*if p_temp is Null then dest_request_uri is IPv4 format*/
    if(ICF_NULL == p_temp)
    {
#endif 
            p_temp = dest_request_uri;
#ifdef ICF_IPV6_ENABLED
    }
#endif
        p_temp_1 = icf_port_strchr(p_temp,':');

        if ( ICF_NULL == p_temp_1 )
        {
            if (ICF_ADDRESS_PLAN_SIPS_URI == p_rem_addr->addr_type )
            {
                dest_port_num = ICF_DEFAULT_SIPS_SERVER_PORT;
            }
            else
            {
                dest_port_num = ICF_DEFAULT_SIP_SERVER_PORT;
            }
        }
        else
        {
            dest_port_num = (icf_uint16_t)icf_port_atoi((const icf_int8_t *)(p_temp_1+1));
        }
        icf_port_strcpy(str, dest_request_uri);
#ifdef ICF_IPV6_ENABLED
            p_temp = icf_port_strchr(dest_request_uri,']');
            if(ICF_NULL == p_temp)
#endif        
            {
                p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)str,":");
                if(ICF_NULL != p_temp)
                {
                    icf_port_strcpy(dest_request_uri,p_temp);
                }
            }
#ifdef ICF_IPV6_ENABLED
            
            else{
                p_temp = icf_port_strtok(str,"]");
                if(ICF_NULL != temp)
                {
                    icf_port_strcpy(dest_request_uri,p_temp);
                    icf_port_strcat(dest_request_uri,"]");
                }
            }
#endif

        /*
         * Here onwards, we are sure that dest_request_uri does
         * not has :portnum
         */

        if ( ICF_NULL != (ICF_CFG_CC_CALL_THRU_SIP_PROXY & 
                    p_glb_cfg_data->default_settings))
        {
            /*Not a Direct Call, proxy routed one*/
            if (ICF_NULL == is_proxy_cfg)
            {
                /* Set the call clear reson */
                p_call_ctxt->release_cause = 
                    ICF_CALL_CLEAR_REASON_PROXY_ADDRESS_NOT_CONFIGURED;
                ret_val = ICF_FAILURE;
            }
            else
            {
                /*The sip request URI has been already copied
                 * into the dest_req_uri at the start of the routine
                 * Implicitly ensured that is_preloaded_req is set
                 * only if is_proxy_cfg is set
                 */
                is_preloaded_req = ICF_TRUE;
            }
        }
        else
        {
            /*Direct Call*/
            icf_uint8_t      *p_temp = ICF_NULL, 
            userid[ICF_MAX_SIZE_INT_USAGE_STR];

            icf_port_strcpy(userid, (icf_uint8_t *)"");
            p_temp = icf_port_strchr(dest_request_uri,'@');

            if ( ICF_NULL == p_temp)
            {
                ret_val = ICF_FAILURE;
            }
#ifndef ICF_DNS_LOOKUP_ENABLED            
            else if (! icf_ssa_check_if_ip(p_temp + 1))
            {
                /*Hostname is not IP*/
                /* In case of a direct-routed call, the called party address 
                 * should not be replaced by the proxy address. Why was the 
                 * below written code added ?? This might be required if DNS 
                 * is not enabled, but when DNS is supported we can definitely 
                 * attempt DNS query to the called party address in direct call.
				 *
                 */
                if ( ICF_TRUE == is_proxy_cfg)
                {
                    icf_port_strcpy(str, dest_request_uri);
                    p_temp = icf_port_strtok(str,"@");
                    if(ICF_NULL == p_temp)
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else
                    {
                    icf_port_strcpy(userid, p_temp);
                    /*Here we overwrite the dest_request_uri
                     * which was initially set to the remote add
                     * string and then append it with proxy address*/
                    icf_port_strcpy(dest_request_uri, userid);
                    icf_port_strcat(dest_request_uri,"@");
                    icf_port_strcat(
                            dest_request_uri,
                            proxy_addr_str);
                    dest_port_num = p_proxy_addr->port_num;
                    is_preloaded_req = ICF_TRUE;
                    }
                }
                else
                {
                    /*Since the hostname was not an IP address, and the
                     * proxy is also not configured, we do not know
                     * where to send the call and hence we fail it*/
                    /* Set the call clear reson */
                    p_call_ctxt->release_cause = 
                        ICF_CALL_CLEAR_REASON_PROXY_ADDRESS_NOT_CONFIGURED;
                    ret_val = ICF_FAILURE;
                }
            }
#endif /* NOT(ICF_DNS_LOOKUP_ENABLED) */
            /*This is needed for TCP calls*/
            else
            {
                icf_port_strcpy(dest_request_ip, (p_temp + 1));
            }
            /*Hostname is not an IP, so we will use the complete URI as
             * the dest_req_uri while setting the TO header, no pre-loaded
             * route will be set and the message will be sent by UATK
             * to the peer directly*/
        }
    }

    if ( ICF_TRUE == is_preloaded_req)
    {
        if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_proxy_addr->addr.addr_type)
        {
            icf_port_strcpy(proxy_address,
                p_proxy_addr->addr.addr.domain.str);
        }
        else
        {
            /* No need to check return value of 
             * icf_ssa_convert_to_IP_addr. Always
             * returns SUCCESS */
             icf_ssa_convert_to_IP_addr(
               p_proxy_addr,
               proxy_address);

        }
    }
    if ( ICF_SUCCESS == ret_val)
    {
         /* 
         * The proxy port should not be appended in case 
         * the called party is an E164 number and
         * phone-context field is present
         */
        icf_uint16_t      port_num = 0;
        /* SPR 19590 : Adding a node in the tag list of 
           call ctx list of tags */
        ret_val =  icf_cmn_fetch_curr_tag_list_node_from_call_ctx(
                      p_glb_pdb,
                      &p_temp_list_node);
        if((ICF_NULL != p_temp_list_node) && (ICF_NULL !=
                p_temp_list_node->p_data))
        {
            temp_tag_list =
                ((icf_tag_link_list_st*)(p_temp_list_node->p_data))->tag_list;
        }
        /* SPR 19590 : End */
        if ((ICF_ADDRESS_PLAN_E164  == p_rem_addr->addr_type) &&
               (ICF_FALSE == icf_cmn_check_if_param_present(
                &(p_rem_addr->addr_val), (icf_uint8_t *)"phone-context", param_val.str,
                (icf_uint8_t *)"To", &(temp_tag_list))))
        {
            port_num = 0;
        }
        else
        {
            port_num = dest_port_num;
        }
        
        if ( ICF_REMOTE_NAME_PRESENT & 
                p_call_ctxt->common_bitmask)
        {
            icf_port_strcpy(display_name,
                    p_call_ctxt->remote_party_name.str);
        }
        else
        {
            icf_port_strcpy(display_name,(icf_uint8_t *)"");
        }

       if(Sdf_co_fail == sdf_ivk_uaSetTo(p_ssa_pdb->p_ssa_ctxt->p_call_obj, 
                    (Sdf_ty_s8bit *)display_name,
                    (Sdf_ty_s8bit *)dest_request_uri, 
                    /* fix - default port should not go in header */
                    ((dest_port_num == default_port)?ICF_NULL:dest_port_num), 
                    (Sdf_ty_s8bit *)tpt_scheme,
                    &sdf_error))
        {
            /*Raise/Set Major Error here:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
/*#if 0*/
    /* 
         * After creating TO header check if transport mode is TCP/UDP not both
         * then create transport parameter and insert it in TO header
         */
        else
        {
            icf_uint8_t    param_val[4]; 
            SipHeader         *p_to = 
                p_ssa_pdb->p_ssa_ctxt->p_call_obj->pCommonInfo->pTo;
            
            if (ICF_TRUE == p_ssa_pdb->send_trans_param)
            {
                
                if (ICF_TRANSPORT_TYPE_UDP == 
                    p_ssa_pdb->p_ssa_ctxt->transport)
                {
                    icf_port_strcpy(param_val, (icf_uint8_t *)"udp");
                }
                else if (ICF_TRANSPORT_TYPE_TCP == 
                    p_ssa_pdb->p_ssa_ctxt->transport)
                {
                    icf_port_strcpy(param_val, (icf_uint8_t *)"tcp");
                }
                else if (ICF_TRANSPORT_TYPE_TLS == 
                    p_ssa_pdb->p_ssa_ctxt->transport)
                {
                    icf_port_strcpy(param_val, (icf_uint8_t *)"tls");
                }
                
                /* 
                * Create and insert transport parameter only if 
                * transport mode is TCP or UDP
                */
                if ((ICF_TRANSPORT_TYPE_UDP == 
                    p_ssa_pdb->p_ssa_ctxt->transport)
                    ||(ICF_TRANSPORT_TYPE_TCP ==
                    p_ssa_pdb->p_ssa_ctxt->transport)
                    ||(ICF_TRANSPORT_TYPE_TLS ==
                    p_ssa_pdb->p_ssa_ctxt->transport))
                {
                    if (ICF_FAILURE == 
                        icf_ssa_insert_param_in_addr_spec(
                        p_ssa_pdb,
                        ((SipToHeader*)p_to->pHeader)->pAddrSpec,
                        (icf_uint8_t *)"transport",param_val,&sdf_error))
                    {
                        ret_val = ICF_FAILURE;
                    }
                }
            }
        /*
         * Insert params (like phone-context and user
         * into the addr spec of the To header
         */
            if (ICF_FAILURE != ret_val)
            {
                if (ICF_FAILURE ==
                    icf_ssa_insert_params_frm_address_st(
                    p_ssa_pdb,
                    ((SipToHeader*)p_to->pHeader)->pAddrSpec,
                    p_rem_addr))
                {
                    ret_val = ICF_FAILURE;
                }
            }
        }/*END OF CODE LEG USED FOR INSERTING TRANSPORT PARAM INOUT to HEADER*/
/*#endif*/
    }
    if ((ICF_FAILURE != ret_val) && ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_ssa_ctxt->transport) || 
            (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)))
    {
            if ( ICF_TRUE == is_preloaded_req)
            {
                icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->dest_ip, (icf_uint8_t *)proxy_address);
                p_ssa_pdb->dest_port = p_proxy_addr->port_num;
            }
            else
            {
                icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->dest_ip, (icf_uint8_t *)dest_request_ip);
                p_ssa_pdb->dest_port = dest_port_num;
            }  
    }

    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_set_to_in_sic_callobj
 **
 ** DESCRIPTION:        This  routine's purpose is to set the TO header
 **                     for outgoing call.For that, we need to get the 
 **                     remote party uri, scheme-sip/tel, remote's port
 **                     number, remote party display name.
 **                     Sets the proxy, if it is to be used, in the PreLoaded
 **                         Route set of the profile
*****************************************************************************/
icf_return_t icf_ssa_set_to_in_sic_callobj(
      
        INOUT   icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT        icf_uint8_t           *p_proto)
{
    icf_return_t                 ret_val = ICF_SUCCESS;
    icf_glb_pdb_st               *p_glb_pdb = 
        p_ssa_pdb->p_glb_pdb;

    icf_sic_ctx_st              *p_sic_ctx = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt;

    icf_line_data_st             *p_line_data =
        p_ssa_pdb->p_line_data;

    icf_config_data_st           *p_glb_cfg_data =
        p_ssa_pdb->p_glb_cfg_data;

    icf_address_st               *p_rem_addr = 
        &(p_sic_ctx->dest_addr);
    icf_transport_address_st     *p_proxy_addr = 
                                       &(p_line_data->proxy_addr);

    icf_boolean_t                is_proxy_cfg = ICF_FALSE, 
                                    is_preloaded_req = ICF_FALSE;

    icf_uint8_t  proxy_address[ICF_MAX_STR_LEN];

    /*
     * CAUTION: if we modify the size of char array
     * in icf_string_st, we should do the same 
     * here in this local variable
     */

    icf_uint8_t       dest_request_uri[ICF_MAX_STR_LEN] = "\0",
                         dest_request_ip[ICF_MAX_STR_LEN] = "\0",
                         display_name[ICF_MAX_STR_LEN] = "\0",
                         tpt_scheme[ICF_MAX_SIZE_INT_USAGE_STR] = "\0",
                         proxy_addr_str[ICF_MAX_STR_LEN] = "\0";

    icf_uint8_t       *p_temp = ICF_NULL;
    icf_uint16_t      dest_port_num = 0,default_port = ICF_NULL;
    Sdf_st_error         sdf_error;
#ifdef ICF_SIGCOMP_SUPPORT
    icf_transport_address_st     *p_sigcomp_proxy_addr = ICF_NULL;
    icf_error_t      ecode;
    icf_boolean_t    is_to_add_sigcomp_param_in_route = ICF_FALSE;
#endif

    
    if(ICF_NULL == p_glb_pdb)
    {
       return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_glb_pdb)
        
    ICF_ASSERT(p_glb_pdb, p_line_data)

#ifdef ICF_SIGCOMP_SUPPORT
#ifdef ICF_IPSEC_ENABLED
    if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
    {
        icf_rgm_glb_data_st         *p_rgm_glb_data  = ICF_NULL;

        if (ICF_FAILURE == \
                icf_dbm_get_module_glb_data(p_ssa_pdb->p_glb_pdb,\
                ICF_INT_MODULE_REGM, 
                (icf_void_t **)(&p_rgm_glb_data),
                p_ssa_pdb->p_ecode))
        {
            /*ICF_SIGSA_TRACE(("\nFailure while getting RGM Global Data in SIGSA\n"));*/
            return ICF_FAILURE;
        }
        p_sigsa_ctxt = p_rgm_glb_data->p_sigsa_ctxt;
    }
    else
    {
        p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
    }
#else
    p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
#endif
#endif


    /* UMR fix */
    icf_port_memset(
        (icf_void_t *)&sdf_error,
        0,
        ICF_PORT_SIZEOF(Sdf_st_error));

    /* Fetch proxy address, SUCCESS will be returned if proxy found */
    if (ICF_SUCCESS == icf_ssa_find_proxy_address_list (p_ssa_pdb))
    {
        is_proxy_cfg = ICF_TRUE;
        if (p_ssa_pdb->common_bitmask & ICF_SSA_USE_REM_SERVER_INACTIVE)
        {
            /*if secondary proxy server is deleted by applicaiton in between
             *the call setup phase then this parameter will be NULL for 
             *attept on secondary proxy address, so mark proxy_cfg as FALSE
             *to initiate call clear*/
            if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive)
            {
                p_proxy_addr = p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive;
                p_ssa_pdb->p_ssa_ctxt->bitmask_1 |= ICF_SSA_SEC_SERVER_ADDRESS_IS_USED;
                p_ssa_pdb->p_ssa_ctxt->rem_servers_tried = p_ssa_pdb->rem_srv_cnt;
            }
            else
            {
                is_proxy_cfg = ICF_FALSE;

                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            }
        }
        else
        {
            p_proxy_addr = p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active;
        }
    }
    /*is_proxy_cfg = (ICF_CFG_LINE_DATA_PROXY_RECD &
            p_line_data->line_data_received)?
    ICF_TRUE:ICF_FALSE; */
#ifdef ICF_SIGCOMP_SUPPORT
    if((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) &&
       (ICF_NULL != p_sigsa_ctxt) &&
       (ICF_SUCCESS == icf_sigsa_get_sigcomp_proxy_addrs_from_ctxt
                        (p_sigsa_ctxt,
                        &p_sigcomp_proxy_addr,
                        &is_to_add_sigcomp_param_in_route,&ecode)))
    {
        if(ICF_NULL != p_sigcomp_proxy_addr)
        {
            p_proxy_addr = p_sigcomp_proxy_addr;
        }
    }

#endif
    if (ICF_TRUE == is_proxy_cfg)
    {
        if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_proxy_addr->addr.addr_type)
        {
            icf_port_strcpy(proxy_addr_str,
                    p_proxy_addr->addr.addr.domain.str);
        } /* p_proxy_addr->addr.a... */
        else
        {
            icf_ssa_convert_to_IP_addr(p_proxy_addr,
                    proxy_addr_str);
        }
    }

    /*Get the scheme type sip/tel)*/
    if ( ICF_ADDRESS_PLAN_TEL_URI ==
               p_rem_addr->addr_type)
    {
        icf_port_strcpy(tpt_scheme, (icf_uint8_t *)"tel");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    else if ( ICF_ADDRESS_PLAN_SIPS_URI ==
               p_rem_addr->addr_type)
    {
        icf_port_strcpy(tpt_scheme, (icf_uint8_t *)"sips");
        default_port = ICF_DEFAULT_SIPS_SERVER_PORT;
    }
    else
    {
        icf_port_strcpy(tpt_scheme, (icf_uint8_t *)"sip");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    
    /*
     * Copy the received address string in dest request uri
     * Whatever type it is, it will be the first part of dest req uri
     */
    icf_port_strcpy(
            dest_request_uri,
            p_rem_addr->addr_val.str);

    if ( (ICF_ADDRESS_PLAN_E164  == p_rem_addr->addr_type ) ||
            (ICF_ADDRESS_PLAN_TEL_URI == p_rem_addr->addr_type ))
    {
        if ( ICF_TRUE == is_proxy_cfg )
        {
            dest_port_num = p_proxy_addr->port_num;
            is_preloaded_req = ICF_TRUE;
            if ( ICF_ADDRESS_PLAN_E164  == p_rem_addr->addr_type )
            {
                /*Form the request URI*/
                icf_port_strcat(
                        dest_request_uri,(icf_uint8_t *)"@");
                icf_port_strcat(
                        dest_request_uri,
                        proxy_addr_str);
            }
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
    }
    else if ((ICF_ADDRESS_PLAN_SIP_URI == p_rem_addr->addr_type ) ||
                (ICF_ADDRESS_PLAN_SIPS_URI == p_rem_addr->addr_type ))
    {
        icf_uint8_t       str[ICF_MAX_STR_LEN];

        /* Now we will attempt to get the port number*/
        p_temp = icf_port_strchr(dest_request_uri,':');
        if ( ICF_NULL == p_temp )
        {
            if (ICF_ADDRESS_PLAN_SIPS_URI == p_rem_addr->addr_type )
            {
                dest_port_num = ICF_DEFAULT_SIPS_SERVER_PORT;
            }
            else
            {
                dest_port_num = ICF_DEFAULT_SIP_SERVER_PORT;
            }
        }
        else
        {
            dest_port_num = (icf_uint16_t )icf_port_atoi((const icf_int8_t *)p_temp+1);

            icf_port_strcpy(str, dest_request_uri);
            p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)str,":");
            if(ICF_NULL != p_temp)
                icf_port_strcpy(dest_request_uri,p_temp);
        }
        /*
         * Here onwards, we are sure that dest_request_uri does
         * not has :portnum
         */

        if ( ICF_NULL != (ICF_CFG_CC_CALL_THRU_SIP_PROXY & 
                    p_glb_cfg_data->default_settings))
        {
            /*Not a Direct Call, proxy routed one*/
            if (ICF_NULL == is_proxy_cfg)
            {
                /* Set the call clear reson */
            /*    p_call_ctxt->release_cause = */
            /*        ICF_CALL_CLEAR_REASON_PROXY_ADDRESS_NOT_CONFIGURED;*/
                ret_val = ICF_FAILURE;
            }
            else
            {
                /*The sip request URI has been already copied
                 * into the dest_req_uri at the start of the routine
                 * Implicitly ensured that is_preloaded_req is set
                 * only if is_proxy_cfg is set
                 */
                is_preloaded_req = ICF_TRUE;
            }
        }
        /* This might be required if DNS is not enabled, but when DNS is 
         * supported we can definitely attempt DNS query to the remote addr 
         */
#ifndef ICF_DNS_LOOKUP_ENABLED
        else
        {
            /*Direct Call*/
            icf_uint8_t      *p_temp = ICF_NULL, 
            userid[ICF_MAX_SIZE_INT_USAGE_STR];

            icf_port_strcpy(userid, "");
            p_temp = icf_port_strchr(dest_request_uri,'@');

            if ( ICF_NULL == p_temp)
            {
                ret_val = ICF_FAILURE;
            }
            else if (! icf_ssa_check_if_ip(p_temp + 1))
            {
                /*Hostname is not IP*/
                if ( ICF_TRUE == is_proxy_cfg)
                {
                    icf_port_strcpy(str, dest_request_uri);
                    p_temp = icf_port_strtok(str,"@");
                    if(ICF_NULL != p_temp)
                    {
                    icf_port_strcpy(userid, p_temp);
                    /*Here we overwrite the dest_request_uri
                     * which was initially set to the remote add
                     * string and then append it with proxy address*/
                    icf_port_strcpy(dest_request_uri, userid);
                    icf_port_strcat(dest_request_uri,"@");
                    icf_port_strcat(
                            dest_request_uri,
                            proxy_addr_str);
                    dest_port_num = p_proxy_addr->port_num;
                    is_preloaded_req = ICF_TRUE;
                    }
                    else
                    {
                        ret_val = ICF_FAILURE;
                    }
                }
                else
                {
                    /*Since the hostname was not an IP address, and the
                     * proxy is also not configured, we do not know
                     * where to send the call and hence we fail it*/
                    /* Set the call clear reson */
        /*            p_call_ctxt->release_cause = */
          /*              ICF_CALL_CLEAR_REASON_PROXY_ADDRESS_NOT_CONFIGURED;*/
                    ret_val = ICF_FAILURE;
                }
            }
            /*Hostname is not an IP, so we will use the complete URI as
             * the dest_req_uri while setting the TO header, no pre-loaded
             * route will be set and the message will be sent by UATK
             * to the peer directly*/
        }
#endif
    }

    if ( ICF_TRUE == is_preloaded_req)
    {
        if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_proxy_addr->addr.addr_type)
        {
            icf_port_strcpy(proxy_address,
                p_proxy_addr->addr.addr.domain.str);
        }
        else
        {
            icf_ssa_convert_to_IP_addr(
               p_proxy_addr,
               proxy_address);

        }
    }
    if ( ICF_SUCCESS == ret_val)
    {
        icf_port_strcpy(display_name,(icf_uint8_t *)"");
        

        if(Sdf_co_fail == sdf_ivk_uaSetTo(p_ssa_pdb->p_ssa_ctxt->p_call_obj, 
                    (Sdf_ty_s8bit *)display_name,
                    (Sdf_ty_s8bit *)dest_request_uri, 
                    /* fix - default port should not go in header */
                    ((dest_port_num == default_port)?ICF_NULL:dest_port_num), 
                    (Sdf_ty_s8bit *)tpt_scheme,
                    &sdf_error))
        {
            /*Raise/Set Major Error here:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
    else
    {
        icf_uint8_t    param_val[4]; 
        SipHeader         *p_to = 
            p_ssa_pdb->p_ssa_ctxt->p_call_obj->pCommonInfo->pTo;

        if (ICF_TRANSPORT_TYPE_UDP == 
                p_ssa_pdb->p_ssa_ctxt->transport)
        {
            icf_port_strcpy(param_val, (icf_uint8_t *)"udp");
        }
        else if (ICF_TRANSPORT_TYPE_TCP == 
                p_ssa_pdb->p_ssa_ctxt->transport)
        {
            icf_port_strcpy(param_val, (icf_uint8_t *)"tcp");
        }
        else if (ICF_TRANSPORT_TYPE_TLS == 
                p_ssa_pdb->p_ssa_ctxt->transport)
        {
            icf_port_strcpy(param_val,(icf_uint8_t *) "tls");
        }

        /* 
         * Create and insert transport parameter only if 
         * transport mode is TCP or UDP
         */
        if ((ICF_TRANSPORT_TYPE_UDP == 
                    p_ssa_pdb->p_ssa_ctxt->transport)
                ||(ICF_TRANSPORT_TYPE_TCP ==
                    p_ssa_pdb->p_ssa_ctxt->transport)
                ||(ICF_TRANSPORT_TYPE_TLS ==
                    p_ssa_pdb->p_ssa_ctxt->transport))
        {
            if (ICF_FAILURE == 
                    icf_ssa_insert_param_in_addr_spec(
                        p_ssa_pdb,
                        ((SipToHeader*)p_to->pHeader)->pAddrSpec,
                        (icf_uint8_t *)"transport",param_val,&sdf_error))
            {
                ret_val = ICF_FAILURE;
            }
                        /* Insert the transport parameter into the Conatct header also */
            else 
                        {
                icf_uint8_t    transport_param[15]="\0";
                icf_port_strcpy(transport_param,(icf_uint8_t *)"transport=");
                icf_port_strcat(transport_param,param_val);

                if(ICF_FAILURE ==
                        icf_ssa_AddParamToContactHdrList
                        (&(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData->slContact),
                         transport_param,
                         &sdf_error))
                {
                    /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                     * major ERROR*/
                    ret_val = ICF_FAILURE;
                }
            }
        }
    }/*END OF CODE LEG USED FOR INSERTING TRANSPORT PARAM INOUT to HEADER*/
    }
    if ((ICF_FAILURE != ret_val) &&
            ((0 == icf_port_strcmp(p_proto,(icf_uint8_t *)"TCP"))
             || (0 == icf_port_strcmp(p_proto,(icf_uint8_t *)"TLS"))))
    {
        /* the con db node will be allocated from inside the ssa_send_to_peer function when 
           icf_ssa_attempt_out_of_uatk_connect is invoked*/
        if ( ICF_TRUE == is_preloaded_req)
        {
            icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->dest_ip,(icf_uint8_t *)proxy_address);
            p_ssa_pdb->dest_port = p_proxy_addr->port_num;
        }
        else
        {
            /*get the destination IP address and port from
             * destination address*/
            icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->dest_ip, (icf_uint8_t *)dest_request_ip);
        p_ssa_pdb->dest_port = dest_port_num;
    }

    if (0 == icf_port_strcmp(p_proto,(icf_uint8_t *)"TLS"))
    {
        p_ssa_pdb->p_ssa_ctxt->bitmask |= ICF_SSA_TLS_TRANSPORT;
    }
    else
    {
            p_ssa_pdb->p_ssa_ctxt->bitmask |= ICF_SSA_TCP_TRANSPORT;
        }
    }
    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}


/*****************************************************************************
 ** FUNCTION:           icf_ssa_map_sip_resp_code
 **
 ** DESCRIPTION:        This function maps the SIP response codes to
 **                     CC specific reason codes
 **
 *****************************************************************************/
icf_return_t icf_ssa_map_sip_resp_code(
        Sdf_ty_u16bit dRespCode,
        icf_ssa_reason_t *p_reason_code)
{
    icf_return_t             ret_val = ICF_SUCCESS;

    switch(dRespCode)
    {
        case 300 :
        case 301 :
        case 410 :
        case 480 :
        case 485 :
        case 604 :
        case 404 :        
            *p_reason_code = ICF_CALL_CLEAR_REASON_USER_NOT_FOUND;
            break;

        case 305 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_CORRECT_PROXY_REQD;
            break;

        case 380 :
        case 400 :
        case 413 :
        case 414 :
        case 416 :
        case 482 :
        case 483 :
        case 484 :
        case 493 :
        case 500 :
        case 501 :
        case 502 :
        case 503 :
        case 504 :
        case 505 :
        case 513 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_NW_ERROR;
            break;
        case 481 :
            /*CSR1-5413721 change*/
	        *p_reason_code = ICF_CALL_CLEAR_REASON_CALL_LEG_DELETED_AT_REMOTE;
            break;
        case 401 :
        case 407 :
          *p_reason_code = ICF_CALL_CLEAR_REASON_AUTH_FAILURE;
            break;
        case 403 :
        case 420 :
        case 421 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_NW_REJECTED;
            break;

        case 402 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_PAYMENT_REQD;
            break;

        case 405 :
        case 406 :
        case 603 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_REMOTE_REJECTED;
            break;
        /* SPR 17993 Merge */
        case 415 : 
            *p_reason_code = ICF_CALL_CLEAR_REASON_UNSUPPORTED_MEDIA; 
            break;

        case 408 :
            *p_reason_code = ICF_CALL_CLEAR_REMOTE_UNREACHABLE;
            break;

        case 423 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_UNDEFINED;
            break;

        case 486 :
        case 600 :
            *p_reason_code = ICF_CALL_CLEAR_REMOTE_BUSY;
            break;

        case 488 :
        /* SPR 17399 : response code 606 is Not Acceptable Here and is send for
         * media mismatch.
         */
        case 606 :
            *p_reason_code = ICF_CALL_CLEAR_MEDIA_MISMATCH;
            break;

            /*Filling it here since in case of 487 we are not
             * indicating an error as it will come for a CANCELLED
             * txn, if not then we need to have some valid value here
             */
        case 487 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_INVALID;
            break;

        case 491 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_REQUEST_PENDING;
            break;

#ifdef ICF_QOS_SUPPORT
        case 580 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_PRECONDITIONS_FAILURE;
            break;
#endif

        case 508 :
            *p_reason_code = ICF_CALL_CLEAR_REASON_REMOTE_MEDIA_NOT_RECEIVED ;
            break;

        default :
	    if((400 < dRespCode) && (600 > dRespCode))
	    {
		*p_reason_code = ICF_CALL_CLEAR_REASON_NW_ERROR;
  	    }
	    else if((601 < dRespCode) && (700 > dRespCode))
	    {
		*p_reason_code = ICF_CALL_CLEAR_REMOTE_BUSY;
  	    }
	    else
	    {
                *p_reason_code = ICF_CALL_CLEAR_REASON_UNDEFINED;
	    }
            break;
    }
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:        icf_ssa_form_sip_uri_frm_e164
 ** 
 ** DESCRIPTION:    This function takes a string (E164 user ID), an instance
 **                 of icf_transport_address_st ( proxy address, self address)
 **                 address of a variable to return port number if any.
 **                 Based on the type of address in the instance of
 **                 icf_transport_address_st, it appends appropriate string
 **                 to the received user ID to return the comeplte SIP uri
 *****************************************************************************/
icf_return_t icf_ssa_form_sip_uri_frm_e164(
        icf_ssa_pdb_st               *p_ssa_pdb,
        icf_uint8_t                  *p_address_str,
        icf_transport_address_st     *p_transport_addr,
        icf_uint16_t                 *p_port_num)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    icf_glb_pdb_st       *p_glb_pdb = 
        p_ssa_pdb->p_glb_pdb;

    ICF_FUNCTION_ENTER(p_glb_pdb)
    p_glb_pdb = p_glb_pdb;

    icf_port_strcat(p_address_str,(icf_uint8_t *)"@");   

    if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
            p_transport_addr->addr.addr_type)
    {
        icf_port_strcat(p_address_str,
                p_transport_addr->
                addr.addr.domain.str);
        *p_port_num = p_transport_addr->port_num;
    }
    else/*Assumption that it will be IPV4*/
    {
        icf_uint8_t remote_ip[16];

        if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                    p_transport_addr, remote_ip))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            icf_port_strcat(p_address_str, remote_ip);
        }
        *p_port_num = p_transport_addr->port_num;
    }

    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_clone_profile_data
 ** DESCRIPTION:  This function is a cut down version of the Clone
 *                Init Data API.  It is used to copy selected information
 *                from the global profile to the call object specific profile
 *                Currently we only copy default transport
 ***************************************************************************/
icf_return_t    icf_ssa_clone_profile_data(
        INOUT    icf_glb_pdb_st       *p_glb_pdb,
        INOUT      Sdf_st_initData         *p_dest_profile,
        INOUT      Sdf_st_initData          *p_source_profile,
        OUT     icf_error_t           *p_ecode)
{
    icf_return_t         ret_val = ICF_SUCCESS;

    Sdf_st_error            sdf_error;
    Sdf_st_listIterator     dListIterator;

    p_ecode = p_ecode;
    p_glb_pdb = p_glb_pdb;

    ICF_FUNCTION_ENTER(p_glb_pdb)

    /* UMR fix */
    icf_port_memset(
        (icf_void_t *)&sdf_error,
        0,
        ICF_PORT_SIZEOF(Sdf_st_error));

    if ( Sdf_co_fail == 
            sdf_ivk_uaCloneTransportInfo(p_dest_profile->pTransport,
                p_source_profile->pTransport, &sdf_error))
    {
        /*Raise Alarm/Error-Major UATK PROCESSING FAILURE*/
        /*Raise Trace : Failure in CloneTransportInfo-MINOR*/
        ret_val = ICF_FAILURE;
    }

    else
    {
        /* 
         * Clone list of extra headers
         */
        sdf_listDeleteAll(&(p_dest_profile->slExtraHeadersList), &sdf_error);

        sdf_listInitIterator(&(p_source_profile->slExtraHeadersList), \
                &dListIterator, &sdf_error);

        while (dListIterator.pCurrentElement != Sdf_co_null)
        {
            Sdf_st_configExtraHeaders *p_extra_hdrs = ICF_NULL;
            Sdf_st_configExtraHeaders *p_cloned_extra_hdrs = ICF_NULL;

            p_extra_hdrs =\
            (Sdf_st_configExtraHeaders*)(dListIterator.pCurrentElement->pData);

            if(Sdf_co_fail == 
                    sdf_ivk_uaInitConfigExtraHeaders(&p_cloned_extra_hdrs,\
                        &sdf_error))
            {
                ret_val = ICF_FAILURE;
            }
            else if(Sdf_co_fail == 
                    sdf_ivk_uaCloneConfigExtraHeaders(p_cloned_extra_hdrs, 
                        p_extra_hdrs, &sdf_error))
            {
                ret_val = ICF_FAILURE;
            }
            else if(Sdf_co_fail == 
                    sdf_listAppend(&(p_dest_profile->slExtraHeadersList), 
                        (Sdf_ty_pvoid)p_cloned_extra_hdrs, &sdf_error))
            {
                ret_val = ICF_FAILURE;
            }
            /*Klocwork warning removal*/
            ICF_KLOCWORK_FALSE_POSITIVE(p_glb_pdb,p_cloned_extra_hdrs)
            
            if(ICF_FAILURE == ret_val)
            {
               sdf_ivk_uaFreeConfigExtraHeaders(p_cloned_extra_hdrs);
               break;
            }
            sdf_listNext(&dListIterator, &sdf_error);
        }
    }

    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_send_to_peer
 * DESCRIPTION:  1.This function internally calls sdf_ivk_uaSendCallToPeer
 *               after initialising an Event Context and setting the 
 *               SSA ctxt into it.
 *               2.In the case of TCP as transport,
 *               we are populating the current transactions' SockFd
 *               with the one in the ConnDb,  if there is one,if not
 *               we reset it to an invalid value so that UATK attempts a 
 *               connect by itself
 ***************************************************************************/
icf_return_t icf_ssa_send_to_peer(
        icf_ssa_pdb_st *p_ssa_pdb,
        Sdf_st_callObject *p_call_obj,
        SipMessage *p_sip_msg,
        SipOptions *p_options,
        Sdf_st_error *p_sdf_error)
{
    icf_return_t ret_val = ICF_SUCCESS;
    icf_return_t dummy_ret_val = ICF_SUCCESS;
    icf_uint32_t count = 0;
    icf_ssa_ctxt_st  *p_ssa_ctxt = ICF_NULL;
    icf_error_t      local_ecode = 0;
#ifdef ICF_SIGCOMP_SUPPORT
    icf_boolean_t    should_msg_compress = ICF_FALSE;
        icf_void_t                      *p_sigsa_ctxt = ICF_NULL;
#endif

    SipError                SipErr;
    en_SipMessageType    dMsgType = SipMessageAny;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /*Start SPR18846 */
    if((Sdf_co_null != p_call_obj) &&
       (Sdf_co_null != p_call_obj->pAppData) &&
       (Sdf_co_null != p_call_obj->pAppData->pData))
    {   
       p_ssa_ctxt = (icf_ssa_ctxt_st*)(p_call_obj->pAppData->pData);
    }
    else
    {
        return ICF_FAILURE;
    }/*End SPR 18846 */
    p_ssa_ctxt->p_ssa_pdb = (struct icf_ssa_pdb_st*)p_ssa_pdb;
    p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;
    p_options = p_options;

#ifdef ICF_SIGCOMP_SUPPORT
        if (sip_getMessageType(p_sip_msg,
                &dReqRespType, (SipError*)\
                &(SipErr)) ==  SipFail)
        {
                return ICF_FAILURE;
        }

#endif

#ifdef ICF_SIGCOMP_SUPPORT
#ifdef ICF_IPSEC_ENABLED
        if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
        {
                icf_rgm_glb_data_st              *p_rgm_glb_data  = ICF_NULL;

                if (ICF_FAILURE == \
                                icf_dbm_get_module_glb_data(p_ssa_pdb->p_glb_pdb,\
                                ICF_INT_MODULE_REGM,
                                (icf_void_t **)(&p_rgm_glb_data),
                                p_ssa_pdb->p_ecode))
                {
                        /*ICF_SIGSA_TRACE(("\nFailure while getting RGM Global Data in SIGSA\n"));*/
                        return ICF_FAILURE;
                }
                p_sigsa_ctxt = p_rgm_glb_data->p_sigsa_ctxt;
        }
        else
        {
                p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
        }
#else
    p_sigsa_ctxt = p_ssa_ctxt->p_sigsa_ctxt;
#endif
#endif

#ifdef ICF_SIGCOMP_SUPPORT
        /* fix for stray msg crash */
        /* this will only avoid the problem when sigcomp is OFF, but it will still
         * crash when sigcomp is runtime enabled */
        if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->sigcomp_required)
        {
                if(ICF_SSA_SIP_MSG_SHOULD_BE_COMPRESSED !=
                        ICF_SSA_GET_COMMON_BITMASK(p_ssa_ctxt->bitmask,
                        ICF_SSA_SIP_MSG_SHOULD_BE_COMPRESSED))
                {
        /* For Failure Case of the below function we will 
                 * send the Uncompressed Message.So No Check required for the Failure
                 * leg*/

                        if(ICF_SUCCESS == icf_ssa_checkForSigCompParam(
                                p_call_obj,p_sip_msg,&should_msg_compress,
                                &local_ecode))
                        {
                                ICF_SSA_SET_COMMON_BITMASK(p_ssa_ctxt->bitmask,
                                        ICF_SSA_SIP_MSG_SHOULD_BE_COMPRESSED);
                        }
                }

                /* Add Comp=sigcomp param in the via header if it is a request
                * Message only if the sigsa context stored in the ssa context
                * is not null(secure connection is up)
                */

                if(ICF_NULL != p_sigsa_ctxt)
                {
                    if (dReqRespType == SipMessageRequest)
                        {

                                icf_tag_st            sigcomptag;
                                /* Make the local tag for adding comp=sigcomp
                                * parameter in the list 
                                */
                                icf_port_strcpy((icf_uint8_t*)&sigcomptag.hdr_name.str,"Via");
                                sigcomptag.hdr_name.str_len = icf_port_strlen("Via");

                                icf_port_strcpy((icf_uint8_t*)&sigcomptag.tag_value.str,"comp=sigcomp");
                                sigcomptag.tag_value.str_len = icf_port_strlen("comp=sigcomp");
                                sigcomptag.tag_type = ICF_TAG_TYPE_HDR_PARAM;

                                if(ICF_FAILURE ==
                                        icf_append_tag_params_to_hdr(p_ssa_pdb,&sigcomptag,p_sip_msg))
                                {
                                        ret_val = ICF_FAILURE;
                                }
                        }
                }
        }/* end if(sigcomp_required) */
#endif


    if(ICF_FAILURE == ret_val)
    {
    }
    /*  check for presence of allow header and populate it with only the methods
        which the application supports */
    else if (SipFail == sip_getHeaderCount(p_sip_msg, SipHdrTypeAllow, &count, \
        &SipErr) )
    {
        /*ICF_SSA_TRACE(("\nFailed to get Header Count "))*/
        ret_val = ICF_FAILURE;
    }
    /* Allow header present */
    else if(0 < count )
    {
        SipHeader               *p_allow_hdr = ICF_NULL;
        icf_uint8_t *p_method=ICF_NULL;
        icf_uint32_t index;

        if ((ICF_NULL == p_ssa_pdb->p_app_conf) &&
            ((ICF_SSA_USER_ADDR_FRM_SIC & p_ssa_pdb->common_bitmask) ||
             (
              (ICF_NULL != p_ssa_ctxt->p_sic_ctxt) &&
              (ICF_DUMMY_APP_ID == p_ssa_ctxt->p_sic_ctxt->app_id)
             )
            )
           )
        {
            /* Internal Subscribe */
            if(ICF_FAILURE == icf_ssa_make_allow_hdr_for_int_subscribe(p_ssa_pdb,&p_allow_hdr))
            {
                ret_val = ICF_FAILURE;
            }
        }
        else if(ICF_FAILURE == sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg,
                        (Sdf_ty_s8bit**)&p_method,p_sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
        else if((0 == icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER")) &&
                (ICF_NULL != p_ssa_ctxt->p_rgm_ctxt))
        {
            if(ICF_FAILURE == icf_ssa_make_allow_hdr_for_reg(p_ssa_pdb,&p_allow_hdr))
            {
                /*Klocwork warning removal*/
                sip_freeSipHeader(p_allow_hdr);
                ret_val = ICF_FAILURE;
            }
        }
        /* Fix for CSR_1-5316323(ETSI conformance case SIP_MG_TE_V_006.
         * The NULL check of p_ssa_pdb->p_app_conf has been removed since
         * the function being called here does the same checking.
         */
        else if(ICF_FAILURE == icf_ssa_make_allow_hdr_from_app_profile(p_ssa_pdb,&p_allow_hdr))
        {
            ret_val = ICF_FAILURE;
        }
        /*
         * This else block has been removed as per the above mentioned fix.If the above
         * called function returns success,405 sent out will not contain the Allow header 
         * as the following check would make it NULL.Hence it has been commented.
         */

        /*
        else
            p_allow_hdr = ICF_NULL;
        */
            
        /* Set new Allow header */
        if(ICF_FAILURE != ret_val)
        {
            /* Delete all allow headers */
            for(index = 0; index < count; index++)
            {
                if(SipFail == sip_deleteHeaderAtIndex (p_sip_msg,SipHdrTypeAllow, 0, &SipErr))
                {
                    ret_val = ICF_FAILURE;
                    break;
                }
            }
            if(ICF_FAILURE == ret_val)
            {
            }
            else if(ICF_NULL != p_allow_hdr)
            {
                /* Insert header in sip message */
                if(SipFail == sip_insertHeaderAtIndex (p_sip_msg, p_allow_hdr, 0, &SipErr))
                {
                    ret_val = ICF_FAILURE;
                }
            }
        }
        /*Klocwork Warning removal*/
        sip_freeSipHeader(p_allow_hdr);
        if(ICF_NULL != p_allow_hdr)
        {
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
        }
    }

    if (ICF_SSA_FAILURE_RESP_CODE_488 == (p_ssa_pdb->p_ssa_ctxt->failure_bitmask 
                                          & ICF_SSA_FAILURE_RESP_CODE_488))
    {
         /* SPR 18814: Insert warning header in a response message only. This code
         * leg can be hit even in the time of sending request messages so the check
         * for message type as response is added.
         */
         sip_getMessageType(p_sip_msg, &dMsgType, &SipErr);

         if(SipMessageResponse == dMsgType)
         {
            ret_val = icf_ssa_form_and_insert_warning_hdr(p_ssa_pdb,p_sip_msg);    
         }
    }
    
    if ( ICF_FAILURE != ret_val)
    {
        Sdf_st_eventContext *p_event_context = Sdf_co_null;
        if (Sdf_co_fail ==
                sdf_ivk_uaInitEventContext(&p_event_context, p_sdf_error))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInInitEventCtxt in SSASendToPeer"));
            ret_val = ICF_FAILURE;
        }
        else
        {
            Sdf_st_transaction          *p_txn = Sdf_co_null;
            Sdf_st_overlapTransInfo     *p_overlap_txn = Sdf_co_null;

            p_event_context->pData = p_call_obj->pAppData->pData;
           
#ifdef ICF_DNS_LOOKUP_ENABLED
#if 0

            /* DNS-Buffer code starts here-- this code is for making the retries
        configurable */ 
            if(ICF_FAILURE == icf_dbm_get_module_glb_data(
                        p_ssa_pdb->p_glb_pdb,
                        (icf_int_module_id_t)ICF_INT_MODULE_CFG,
                        (icf_void_t *)&p_config_data, p_ssa_pdb->p_ecode))
            {
                /* didn't get the config data can't make the retry to be configurable
                   raise the error */
            }
            else if(ICF_NULL != p_config_data)
            {

                p_event_context->dTimerOption |= SIP_OPT_TIMER_T1;
                p_event_context->dTimerOption |= SIP_OPT_TIMER_F;
                p_event_context->dTimerOption |= SIP_OPT_TIMER_B;
                    p_event_context->dTimeoutValues.dT1= 500; /* default value */
                /* for NON-Invite x-saction */    
                p_event_context->dTimeoutValues.dTimerF_T3=  
                (icf_ssa_dns_2_pow (p_config_data->sip_req_retry)) * p_event_context->dTimeoutValues.dT1; 
                /* for INvite X-saction */
                p_event_context->dTimeoutValues.dTimerB= 
               (icf_ssa_dns_2_pow (p_config_data->sip_req_retry))* p_event_context->dTimeoutValues.dT1;
            } 
            else
            {
                /* configuration data is null raise the error */
               ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_config_data));
            }
        /* end of DNS-buffer code */
#endif
#endif

            if (Sdf_co_fail == sdf_ivk_uaGetTransactionForSipMsg(
                        p_call_obj, p_sip_msg,
                        &p_txn, &p_overlap_txn, p_sdf_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Can'tGetTxnFromMsg!!!"));
                ret_val = ICF_FAILURE;
            }
#ifdef ICF_DNS_LOOKUP_ENABLED
#ifdef ICF_RUNTIME_NAMESERVER_CONFIG
            /* DNS Lookup is not required while sending:
             * - De/REGSITER with credentials on getting challenge from 
             * Registrar
             */
            if(ICF_NULL != 
                    (p_ssa_pdb->common_bitmask & ICF_SSA_NO_NAMESERVER_REFRESH))
            {
			    p_ssa_ctxt->refresh_nameserver = ICF_FALSE;
            }
            else
            {
    			p_ssa_ctxt->refresh_nameserver = ICF_TRUE;
            }
			if (ICF_FAILURE == ret_val)
			{
				ret_val = ICF_FAILURE; /* effective no-op */
			}
#endif
            else if ( Sdf_co_fail == sdf_ivk_uaHandleLookup(p_call_obj,
                        p_overlap_txn, p_sip_msg,
                        p_event_context,p_sdf_error) &&
                    ( Sdf_en_dnsInvState != p_sdf_error->errCode))
            {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureIn HandleLookUp API"));
                    ret_val = ICF_FAILURE;
            }
            else if ((Sdf_co_false == sdf_ivk_uaIsDnsQueryState(p_call_obj,
                        p_overlap_txn, p_sdf_error)) || ICF_NULL == (p_ssa_ctxt->bitmask & 
                                                        ICF_SSA_DNS_FQDN_PRESENT ))
            {
#endif
                if (ICF_FAILURE != ret_val)
                {
                    /*this flag is used to identify whether a connection
                      has been made fully or not. Tjus is it to be used for
                      TCP/TLS cases only*/
                    icf_boolean_t    ready_to_send = ICF_TRUE;
#ifdef ICF_DNS_LOOKUP_ENABLED
                    p_ssa_pdb->p_event_ctxt = p_event_context;
#endif
                    if (ICF_NULL != 
                            (ICF_SSA_EXPLICIT_CONNECT_REQ & p_ssa_ctxt->bitmask))
                    {
                        if (ICF_FAILURE == icf_ssa_attempt_out_of_uatk_connect(
                                    p_ssa_pdb, p_call_obj, p_txn, 
                                    p_overlap_txn, &ready_to_send))
                        {
                            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureFrom AttemptOutOfDlgConnect"));
                            ret_val = ICF_FAILURE;
                        }
                    }/*out of UATK connect*/
#ifdef ICF_SECURE_SUPPORT
                    /*Add alias parameter in Via in case of persistent TLS*/
                    if ((ICF_SUCCESS == ret_val) &&
                        (ICF_FAILURE == icf_ssa_insert_alias_params_in_via(p_ssa_pdb,
                                                   p_sip_msg)))
                    {
                        ret_val = ICF_FAILURE;
                    }
#endif

                    
#ifdef ICF_NAT_RPORT_SUPPORT
                    /*Add rport parameter in Via in case of NAT support*/
                    if ((ICF_SUCCESS == ret_val) && 
                        (ICF_FAILURE == icf_ssa_insert_rport_params_in_via(p_ssa_pdb,
                                                   p_sip_msg)))
                    {
                        ret_val = ICF_FAILURE;
                    }
#endif

                   /*Fix for CSR 1-9012191 : SPR 20697*/
                   /*If EGT receive transport param and default port(5060) in Contact header
                    *of 200 OK then removing this transport param and default port(5060)  
                    *from Request URI of all further outgoing request.
                    */
                   /*Knowing Message Type Either Request or Response*/
                    if(ICF_FAILURE != ret_val)
                    {    
                        sip_getMessageType(p_sip_msg, &dMsgType, &SipErr);
                    }    
                    
                   /*If SIP Message is a request type : This Block will Execute */  
                    if((SipMessageRequest == dMsgType) && (ICF_FAILURE != ret_val)) 
                    {   
                        /* Fetching line_data if not present */
                        if((ICF_NULL == p_ssa_pdb->p_line_data) && 
                              (ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                              p_ssa_pdb->p_glb_pdb, p_ssa_ctxt->line_id,
                              &(p_ssa_pdb->p_line_data), p_ssa_pdb->p_ecode)))
                        {   
                            ret_val = ICF_FAILURE;
                        }
                        /*If strip_req_uri_param is set as TRUE Than Execute This blog */   
                        else if(ICF_TRUE == p_ssa_pdb->p_line_data->strip_req_uri_param)
                        {      
                            /*deleting the transport parameter from Request Line in the sip message*/
                            if(ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
                                   p_sip_msg->u.pRequest->pRequestLine->pAddrSpec,
                                   (icf_uint8_t *)"transport"))
                            {        
                                ICF_PRINT(((icf_uint8_t *)
                                "[SSA]:Failure In Deleting Parameter from Request Line\n"));
                                ret_val = ICF_FAILURE;
                            }
                      
                            /*deleting transport parameter from Common Info*/
                            /*deleting the transport parameter from Request Line in Common Info*/
                            else if((ICF_NULL != p_call_obj->pCommonInfo->pRequestUri) &&
                                    (ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
                                    p_call_obj->pCommonInfo->pRequestUri,(icf_uint8_t *)"transport")))
                            {   
                                ICF_PRINT(((icf_uint8_t *)
                                "[SSA]:Failure In Deleting Parameter from Request Line\n"));
                                ret_val = ICF_FAILURE;
                            }

                            /*deleting default port(5060) from Request Line in the sip Message*/
                            /* NULL Check Condition for dPort */
                            else if(ICF_NULL != p_sip_msg->u.pRequest->pRequestLine->
                                          pAddrSpec->u.pSipUrl->dPort)
                            {    
                                if(ICF_DEFAULT_SIP_SERVER_PORT ==
                                *(p_sip_msg->u.pRequest->pRequestLine->pAddrSpec->u.pSipUrl->dPort))
                                {    
                                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)
                                    (&p_sip_msg->u.pRequest->pRequestLine->pAddrSpec->u.pSipUrl->dPort),
                                    p_sdf_error);
                                }
                            }
                        }                         
                    }
                   /* Fix End for CSR 1-9012191 : SPR 20697*/
                    
                    if ((ICF_TRUE == ready_to_send) && (ICF_FAILURE != ret_val) && 
						    (Sdf_co_fail == 
						     icf_ssa_initiate_dispatch_sequence(
							     p_ssa_pdb, p_call_obj,
							     p_txn, p_overlap_txn, p_event_context,
							     &local_ecode)))
				    {
					    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in InitiateDispatchSeq!!!"));
					    ret_val = ICF_FAILURE;
				    }
#ifdef ICF_TRACE_ENABLE
                    else
                    {
						if(Sdf_co_success == sdf_ivk_uaIsSdpBodyPresent(
                                        p_sip_msg, p_sdf_error))
                        {
                             p_ssa_pdb->sdp_present = ICF_TRUE;
                        }
                        else
                        {
                              p_ssa_pdb->sdp_present = ICF_FALSE;
                        }
                        icf_ssa_capture_trace(
						       p_ssa_pdb,p_sip_msg, 0);
                    }
#endif
			    }/*retval FIALURE check*/
#ifdef ICF_DNS_LOOKUP_ENABLED
            }/*If the query state indicated that no query was sent
               i.e IP is already present in txn structure*/
            else
            {
                /* SPR 18872: In case to send a mesasge, DNS query has been 
                 * issued then set the bitmask so that no other message should be
                 * send in the same context as long as the DNS query is not complete 
                 * and the address for peer entity is not resolved.
                 */  
                p_ssa_ctxt->bitmask_1 |= ICF_SSA_DNS_QUERY_ONGOING;
            }
#endif
        if ( Sdf_co_null != p_txn)
        {
            sdf_ivk_uaFreeTransaction(p_txn);
        }
        if ( Sdf_co_null != p_overlap_txn)
        {
            sdf_ivk_uaFreeOverlapTransInfo(p_overlap_txn);
        }
        }/*InitEventContext Success leg*/
        sdf_ivk_uaFreeEventContext(p_event_context);
    }/*ret_val != FAILURE*/

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_check_if_ip
 ** DESCRIPTION:  This function checks if the string passed is an IP address
 **               
 **
 ***************************************************************************/
icf_return_t icf_ssa_check_if_ip(icf_uint8_t *p_ip_address)
{
    return icf_port_check_if_ip(p_ip_address);
}

#ifdef ICF_TRACE_ENABLE


/*****************************************************************************
 ** FUNCTION:        icf_ssa_capture_trace
 **
 ** DESCRIPTION:    This function captures the traces at ssa
 **
 **
*****************************************************************************/

icf_void_t
icf_ssa_capture_trace(
          icf_ssa_pdb_st *p_ssa_pdb,
           SipMessage     *p_sip_msg,
           icf_uint8_t    call_dir)
{
                 icf_return_t    ret_val = ICF_SUCCESS;
        en_SipMessageType    dReqRespType;
        Sdf_ty_s8bit         *p_method = Sdf_co_null;
        Sdf_ty_u16bit        dRespCode = 0;
        SipError        sip_error;
                Sdf_st_error    sdf_error;

	   if ((ICF_NULL == p_sip_msg) ||
              (SipFail == sip_getMessageType(p_sip_msg, &dReqRespType,&sip_error))
              || (Sdf_co_fail ==sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg, &p_method,
                  &sdf_error)))
                {
                 ret_val = ICF_FAILURE;
                }/* end of if */
                else
                {
                        p_ssa_pdb->p_method = (icf_uint8_t *)p_method;

                if(dReqRespType == SipMessageRequest)
                {
                if(0 == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"INVITE"))
                {
                        if(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->common_bitmask &
                                        ICF_CALL_CONNECT_DONE)
                        {
                                if(call_dir == 0)
                       			ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_REINVITE_SENT)
                		else if(call_dir == 1)
                       			ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_REINVITE_RECVD)

                	}/* end of if */
			else
                	{
                		if(call_dir == 0)
                   			ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_INVITE_SENT)
                		else if(call_dir == 1)
                    			ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_INVITE_RECVD)
                	}/* end of else */

		}/* end of if */
        	else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"INFO"))
        	{
                	if(call_dir == 0)
                 		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_OTG_INFO)
                	else if(call_dir == 1)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_INC_INFO)
        	} 
        	else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"PRACK"))
        	{
                        if(call_dir == 0)
                        	ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_PRACK_SENT)
                	else if(call_dir == 1)
                        	ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_PRACK_RECVD)
        	}
        	else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"UPDATE"))
        	{
                	if(call_dir == 0)
                        	ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_UPDATE_SENT)
                	else if(call_dir == 1)
                        	ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_UPDATE_RECVD)
        	}
        	else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"BYE"))
        	{
                        if(call_dir == 0)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_BYE_SENT)
                	else if(call_dir == 1)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_BYE_RECVD)
        	}      
        	else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"ACK"))
        	{
                        if(call_dir == 0)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_ACK_SENT)
                	else if(call_dir == 1)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_ACK_RECVD)
        	}      
        	else if(0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"CANCEL"))
        	{
                        if(call_dir == 0)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_CANCEL_SENT)
                	else if(call_dir == 1)
                		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_CANCEL_RECVD)
        	}
                /* If OPTIONS is sent on network then handle it and no traces should be printed */
                /* Fix for SPR 17649 */
            else if((0 == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"OPTIONS"))
                   ||(0 == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"REFER")))
                {
                }           

 		else if((0 != icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"REGISTER")) &&
                        (0 != icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"SUBSCRIBE")))
        	{
                	if(call_dir == 0)
                 		ICF_SSA_APP_TRACE(p_ssa_pdb,
                                                ICF_TRACE_OUT_OF_DIALOG_MESSAGE_SENT)
                	else if(call_dir == 1)
                        	ICF_SSA_APP_TRACE(p_ssa_pdb,
                                                ICF_TRACE_OUT_OF_DIALOG_MESSAGE_RECVD)
        	}
        	}/* end of if */

        	else if(dReqRespType ==  SipMessageResponse)
        	{
        	if (Sdf_co_fail == sdf_ivk_uaGetRespCodeFromSipMessage(
                        p_sip_msg, &dRespCode, &sdf_error))
        	{
            		ret_val = Sdf_co_fail;
        	}/* end of if */
        	else
        	{
                        p_ssa_pdb->resp_code = dRespCode;
                	switch (dRespCode)
                	{
            			case 100:
                 			if(call_dir == 0)
                      				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_100_SENT)
               				else if(call_dir == 1)
                  				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_100_RECVD)
                     			break;    

            			case 180:
                       			p_ssa_pdb->sdp_present = 1;

               				if(call_dir == 0)
               	      				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_180_SENT)
               				else if(call_dir == 1)
                      				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_180_RECVD)
               	     			break;

            			case 183:
                               		 p_ssa_pdb->sdp_present = 1;
               				if(call_dir == 0)
                      				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_183_SENT)
               				else if(call_dir == 1)
                      				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_183_RECVD)
               	    			break;
	   			case 200:
              				if(call_dir == 0)
                     				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_200_SENT)
              				else if(call_dir == 1)
                    				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_200_RECVD)
                     			 break;

             			case 202:
                       			if(call_dir == 0)
                    				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_202_SENT)
               				else if(call_dir == 1)
                    				ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_202_RECVD)
              	 			break;

             			default:
                        	
                        		if (dRespCode >100 && dRespCode <= 199)
            				{
               					if(call_dir == 0)
                                			ICF_SSA_APP_TRACE(p_ssa_pdb,
                                                		ICF_TRACE_PROVISIONAL_RESP_SENT)
               					else if(call_dir == 1)
                                    			ICF_SSA_APP_TRACE(p_ssa_pdb,
                                                		ICF_TRACE_PROVISIONAL_RESP_RECVD)
            				}/* end of if */

                        		else if (dRespCode >=300 && dRespCode <= 399)
            				{
                				if(call_dir == 0)
                     					ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_302_SENT)
                				else if(call_dir == 1)
                     					ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_302_RECVD)
            				}/* end of else if */

                    			else if (dRespCode >=400 && dRespCode <= 699)
            				{
                 				if(call_dir == 0)
                      					ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_FAILURE_RESP_SENT)
                 				else if(call_dir == 1)
                               				ICF_SSA_APP_TRACE(p_ssa_pdb,ICF_TRACE_FAILURE_RESP_RECVD)
            				}/* end of else if */
            				else
                 				ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Response code not valid."))
                         		
					break;
                        	
          }/* end of switch */
       }/* end of else */
     }/* end of else if */
    else
               ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Neither a Sip Request/Response Message"));
   }/* end of else */

}/* end of function */

#endif
/*******************************************************************************
 * 
 * FUNCTION:        icf_ssa_send_register_req
 *
 * DESCRIPTION:     This function constructs and sends REGISTER req on network.
 *                  1.Update the profile of the call object and set the 
 *                  transport scheme(TCP/UDP) in the transaction.
 *                  2.Set the To header and then invoke the API 
 *                  sdf_ivk_uaSetDefaultRegistrar which sets the registrar
 *                  address on the basis of the registrar addr configured on
 *                  that line.
 *                  3.All the contact addresses for which a binding needs
 *                  to be added are as stored in the contact address
 *                  list stored in the call object profile.
 *                  4.This contact addr list is cloned and passed as a
 *                  parameter to the sdf_ivk_uaMakeRegister API if this
 *                  is an initial registn request,else invoke the
 *                  sdf_ivk_uaDeleteRegistration API to make the appr.
 *                  de-registration request.
 *                  5.If the transport type is TCP,fetch a new connection
 *                  DB node and populate it with the requisite information
 *                  (registrar addr,sock fd etc)
 *                  6.If there is a failure in sending the message on TCP,
 *                  call utility function icf_ssa_revert_to_udp which sends
 *                  the message on UDP.
 *
 ******************************************************************************/
 icf_return_t icf_ssa_send_register_req(
     INOUT    icf_ssa_pdb_st       *p_ssa_pdb)
 {
     icf_return_t             ret_val = ICF_SUCCESS;
     icf_ssa_ctxt_st          *p_ssa_ctxt = ICF_NULL;
     Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;
     Sdf_st_error                sdf_error;
     Sdf_ty_s8bit                proto[ICF_MAX_SIZE_INT_USAGE_STR];
     Sdf_ty_s8bit                duration[ICF_MAX_SIZE_INT_USAGE_STR];
#ifdef SDF_THREAD_SAFE
    Sdf_ty_slist         contact_addr_list = {0,0,'\0','\0',{PTHREAD_MUTEX_INITIALIZER,0,0},0};
#else
    Sdf_ty_slist         contact_addr_list = {0,0,'\0','\0',0};  
#endif
     SipOptions                  sip_options;
     icf_uint8_t                 reg_addr[ICF_MAX_STR_LEN] = "";
     
     icf_uint16_t                reg_port = 0,default_port=ICF_NULL;
     icf_boolean_t               contact_list_valid = ICF_TRUE;

     icf_uint8_t                 *p_content_type = ICF_NULL;
     icf_transport_mode_t        effective_self_mode = 0; /*Parameter to store self_mode*/
     icf_line_id_t               line_index = 0;
     

#ifdef ICF_IPSEC_ENABLED
     icf_config_data_st  *p_cfg_data = p_ssa_pdb->p_glb_cfg_data;
     icf_uint16_t        port_num = ICF_NULL;
     icf_uint8_t         *p_value = ICF_NULL;
     SipMessage             *p_otg_sip_msg = ICF_NULL;
#endif
      ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
 
      /* UMR fix */
      icf_port_memset(
          (icf_void_t *)&sdf_error,
          0,
          ICF_PORT_SIZEOF(Sdf_st_error));

      /* Copy the ssa ctxt pointer locally */
      p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
      
      /* Null check added for ssa context*/
      if(ICF_NULL == p_ssa_ctxt)
      {
          ret_val = ICF_FAILURE;
          ICF_PRINT(((icf_uint8_t *)("\n[SSA] p_ssa_ctxt is NULL\n.")))
          ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
          return ICF_FAILURE;          
      }      
      
      p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;       

      /* If the line data in ssa pdb is NULL try to fetch the same from regm
       * context; If the regm context is also NULL return failure from the
       * function.*/
      if(ICF_NULL == p_ssa_pdb->p_line_data)
      {
          if(ICF_NULL != p_ssa_ctxt->p_rgm_ctxt)
          {
              line_index = p_ssa_ctxt->p_rgm_ctxt->line_id;
              if((line_index < ICF_MAX_NUM_OF_LINES) && 
                      (ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                                        p_ssa_pdb->p_glb_pdb,
                                        line_index,
                                        &(p_ssa_pdb->p_line_data),
                                        p_ssa_pdb->p_ecode)))
              {
                  ret_val = ICF_FAILURE;
                  ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                  return ret_val;
              }
          }
          else
          {
              ret_val = ICF_FAILURE;
              ICF_PRINT(((icf_uint8_t *)("\n[SSA] Not able to populate line data\n.")))
              ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
              return ICF_FAILURE;                
          }
      }
      /* Klockwork Warning Resolved*/  
      if(ICF_NULL == p_ssa_pdb->p_line_data)
      {
          ret_val = ICF_FAILURE;
          ICF_PRINT(((icf_uint8_t *)("\n[SSA] Not able to fetch line data\n.")))
          ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
          return ret_val;
      }
      
      if (ICF_NULL == p_ssa_pdb->p_glb_cfg_data)
      {
          /* Request the DBM for getting pointer to config data structure */
          ret_val = icf_dbm_get_module_glb_data(
                  p_ssa_pdb->p_glb_pdb,
                  (icf_int_module_id_t)(ICF_INT_MODULE_CFG),
                  (icf_void_t **)(&(p_ssa_pdb->p_glb_cfg_data)),
                  p_ssa_pdb->p_ecode);     

          ICF_ASSERT(
                  p_ssa_pdb->p_glb_pdb,
                  (ICF_NULL != p_ssa_pdb->p_glb_cfg_data))
      }/* get pointer to global cfg data if NULL already */

        /* Set the transport mode in local variable */
    if (((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_ssa_ctxt->transport) ||
            (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_ssa_ctxt->transport))
        && (ICF_NULL == (p_ssa_ctxt->bitmask & 
                               ICF_SSA_RGM_PREV_TRANS_TYPE_UDP)))
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP"); 
        icf_port_strcpy(p_ssa_pdb->trans_param, (icf_uint8_t *)"TCP");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport) 
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
        icf_port_strcpy(p_ssa_pdb->trans_param, (icf_uint8_t*)"TLS"); 
        default_port = ICF_DEFAULT_SIPS_SERVER_PORT;
    }
    else if (ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->p_ssa_ctxt->transport)
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
        default_port = ICF_DEFAULT_SIP_SERVER_PORT;
    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)proto,(icf_uint8_t *)"");
    }

    /*In IMS MODE: Use primary registrar always
     *In non-IMS mode: if REG-ROUTE is present then use primary REGISTRAR
     *otherwise select active registrar and send request to this registrar
     */
    if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ims_oprn_flag) || 
        ((ICF_FALSE == p_ssa_pdb->p_glb_cfg_data->ims_oprn_flag) &&
         (ICF_CFG_LINE_DATA_REG_ROUTE_ADDR_RECD & 
           p_ssa_pdb->p_line_data->line_data_received)))
    {
        /* Copy the registrar address in local variables */
        /* for IMS network registrar address is same as proxy address */
        if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
            p_ssa_pdb->p_line_data->registrar_addr.addr.addr_type)
        {
            icf_port_strcpy(reg_addr,
                p_ssa_pdb->p_line_data->registrar_addr.addr.addr.domain.str);
        }
        else
        {
             icf_ssa_convert_to_IP_addr(
                &(p_ssa_pdb->p_line_data->registrar_addr),
                reg_addr);
        }
        reg_port = p_ssa_pdb->p_line_data->registrar_addr.port_num;
    }
    /*Now, if its non-IMS mode when REG-ROUTE is not onfigured then find active and
     *secondary registrar addresses*/
    else if (ICF_SUCCESS == icf_ssa_find_registrar_address_list(p_ssa_pdb))
    {
        icf_transport_address_st    *p_transport = ICF_NULL;

        if (p_ssa_pdb->common_bitmask & ICF_SSA_USE_REM_SERVER_INACTIVE)
        {
            /*if secondary proxy server is deleted by applicaiton in between
             *the call setup phase then this parameter will be NULL for 
             *attept on secondary proxy address, so mark proxy_cfg as FALSE
             *to initiate call clear*/
            if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive)
            {
                p_transport = p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive;
                p_ssa_pdb->p_ssa_ctxt->bitmask_1 |= ICF_SSA_SEC_SERVER_ADDRESS_IS_USED;
                p_ssa_pdb->p_ssa_ctxt->rem_servers_tried = p_ssa_pdb->rem_srv_cnt;
            }
            else
            {
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
                ret_val = ICF_FAILURE;
            }
        }
        else
        {
            p_transport = p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active;
        }
        if (ICF_SUCCESS == ret_val)
        {
            if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_transport->addr.addr_type)
            {
                icf_port_strcpy(reg_addr,
                   p_transport->addr.addr.domain.str);
            }
            else
            {
                 icf_ssa_convert_to_IP_addr(p_transport,
                    reg_addr);
            }
            reg_port = p_transport->port_num;
        }
    }
    else
    {
         ret_val = ICF_FAILURE;
    }

#ifdef ICF_IPSEC_ENABLED
        if (ICF_TRUE == p_cfg_data->ipsec_enabled )
        {
            /* extract the reg ctxt and the relevant SA and save in 
             * the ssa_pdb. These parameters are required to update 
             * the protected server ports in VIA and Contact. Also 
             * required to increase the transaction count after sending 
             * out the message */
            p_ssa_pdb->p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;

            if ((((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context != ICF_NULL) &&
            (((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->is_active == 
                ICF_TRUE))
            {
                p_ssa_pdb->p_sa_context = 
                    ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
            }
            else if (((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context != NULL)
            {
                p_ssa_pdb->p_sa_context = 
                        ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context;
            }
            if (ICF_NULL == p_ssa_pdb->p_sa_context)
            {
                port_num = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_security_client_params->port_s;
                /*reg_port = p_ssa_pdb->p_rgm_context->p_security_client_params->port_s;*/
            }
            else
            {
                port_num = p_ssa_pdb->p_sa_context->p_ue_security_params->port_s;
                reg_port = p_ssa_pdb->p_sa_context->p_proxy_security_params->port_s;
            }

            p_ssa_ctxt->ssa_sa_context.p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;
            p_ssa_ctxt->ssa_sa_context.p_sa_context = 
                    ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;

            p_ssa_pdb->p_sa_context = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
            p_ssa_pdb->p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;

        }
#endif
        /*Fetch self mode from line data when self transport is configured per line
         *otherwise fetch self mode from config_data*/
        if (ICF_CFG_SELF_ADDR_PER_LINE ==
                         p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
        {
             effective_self_mode = p_ssa_pdb->p_line_data->self_mode;
        }
        else
        {
             /*When self address is system_wide then get mode from config_data*/
             effective_self_mode = p_ssa_pdb->p_glb_cfg_data->self_mode;
        }
        
         if (ICF_FAILURE == ret_val)
         {
             /*Do Nothing*/
         }
         else if (Sdf_co_fail == sdf_listInit(
             &contact_addr_list,
             __sdf_fn_uaFreeCompleteHeader,
             Sdf_co_false,
             &sdf_error))
         {
             /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
             sdf_ivk_uaClearTransaction(
                 p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                 p_overlap_trans_info,
                 "REGISTER",
                 Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
             contact_list_valid = ICF_FALSE;
         }
         else if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
             p_ssa_pdb->p_ssa_ctxt->p_call_obj,
             &p_overlap_trans_info,
             "REGISTER",
             &sdf_error))
         {
             /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
             ret_val = ICF_FAILURE;
         }
         /* this only updates the protocol in the call Obj */
         else if (Sdf_co_fail == sdf_ivk_uaSetTransportSchemeInTransaction(
             p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction,
             p_overlap_trans_info,
             proto,
             &sdf_error))
         {
             /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
             sdf_ivk_uaClearTransaction(
                 p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                 p_overlap_trans_info,
                 "REGISTER",
                 Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
         }
         else if(ICF_FAILURE ==
                     icf_ssa_update_callobj_for_profile(p_ssa_pdb))
         {
             /* incase if IPsec is enabled, the ports for Contact and Via will
              * be updated to the protected server port at UE. */ 
             sdf_ivk_uaClearTransaction(
                 p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                 p_overlap_trans_info,
                 "REGISTER",
                 Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
         }
         /* Add profile headers now */
         else if(ICF_FAILURE == icf_ssa_make_profile_for_reg(
             p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,            
             p_ssa_pdb))
         {
             /* incase if IPsec is enabled, the ports for Contact and Via will
              * be updated to the protected server port at UE. */ 
             sdf_ivk_uaClearTransaction(
                 p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                 p_overlap_trans_info,
                 "REGISTER",
                 Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
         }


         /* To header will be set only at the first time */    
        else if ((ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask) &&
                (ICF_FAILURE == icf_ssa_set_to_in_reg_callobj(p_ssa_pdb)))
        {
             sdf_ivk_uaClearTransaction(
                 p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                 p_overlap_trans_info,
                 "REGISTER",
                 Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
         }
         else if (Sdf_co_fail == sdf_ivk_uaSetDefaultRegistrar(
             p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
             (Sdf_ty_s8bit *)reg_addr,
             /* SPR: 19999: Merged (CSR 1-7413863 : SPR-19883)*/
             /* fix - default port 5060 should not go in header */
             ((reg_port == default_port)?ICF_NULL:reg_port),
             &sdf_error))
         {
             sdf_ivk_uaClearTransaction(
                 p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                 p_overlap_trans_info,
                 "REGISTER",
                 Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
         }
#ifdef ICF_SECURE_SUPPORT
     /*When self mode is TLS then fetch self port from tls data
      *configured through icf.cfg*/
     else if (ICF_TRANSPORT_TYPE_TLS == effective_self_mode)
     {
         if (ICF_NULL != p_ssa_pdb->p_glb_cfg_data->p_tls_init_data)
         {
             p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData->pTransport->dPort =
                 p_ssa_pdb->p_glb_cfg_data->p_tls_init_data->tls_sip_serv_port_num;
         }
         else
         {
             ICF_PRINT(((icf_uint8_t *)"\n Error : TLS data not configured"));
             ret_val = ICF_FAILURE;
         }
     }    
#endif
    
        /* Changes done for CSR 1-7413863 is applicable to NON-IMS mode only,In
         * IMS mode IPTK always insert proxy as route in REGISTER request.*/     
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_FALSE)
        /* SPR: 19999:  Merged (CSR 1-7413863:SPR-19883)*/
        /* Add the route header specifying the configured registrar address if
         * registrar port is Default port(5060, in case of TLS transport
         * default port will be 5061) and reg route header is not configured by
         * application.
         */
         if ((ICF_SUCCESS == ret_val) &&
             (reg_port == default_port) && 
             (ICF_NULL == (ICF_CFG_LINE_DATA_REG_ROUTE_ADDR_RECD & 
              p_ssa_pdb->p_line_data->line_data_received)))
         {
             if (Sdf_co_fail == sdf_ivk_uaAddDefaultPreLoadedRoute(
                         p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                         Sdf_co_null,
                         (icf_int8_t *)reg_addr,
                         reg_port,
                         "lr",/*pParam*/
                         ((ICF_TRANSPORT_TYPE_TLS == 
                           p_ssa_pdb->p_line_data->reg_mode)?"sips":"sip"),
                         &sdf_error))
             {

                 ret_val = ICF_FAILURE;
             }
             /* Set bimask_1 with ICF_SSA_REGISTRAR_ADDR_PRESENT_IN_ROUTE_HEADER
              * so that the route header (containing registrar address) can be 
              * removed by stack before sending the REGISTER request on network.
              */  
             else
             {
                 p_ssa_pdb->p_ssa_ctxt->bitmask_1 |= 
                     ICF_SSA_REGISTRAR_ADDR_PRESENT_IN_ROUTE_HEADER;
             }
         } /* send Route header in REGISTER */
ICF_CHECK_IMS_END
     
         if ((ICF_SUCCESS == ret_val) && 
                 (!(ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask)))
         {
             /* Register request which is not the initial one should 
              * not contain the to tag : So remove the to tag
              */
            Sdf_ty_u32bit dCount = 0;

            if(sip_getTagCountFromToHdr(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pCommonInfo->pTo,&dCount,\
                        (SipError *)&(sdf_error.stkErrCode))==SipFail)
            {
                ret_val = ICF_FAILURE;
            }
            if (dCount != 0)
            {
                Sdf_ty_u32bit dIndex=0;
                for(dIndex=0;dIndex<dCount;dIndex++)
                {
                    if(sip_deleteTagAtIndexInToHdr(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pCommonInfo->pTo,
                                dIndex,\
                                (SipError *)&(sdf_error.stkErrCode))==SipFail)
                    {
                        ret_val = ICF_FAILURE;
                        break;
                    }
                }
            }

         }
         if ((ICF_SUCCESS == ret_val) && 
             (ICF_SSA_RGM_REQ_TYPE & p_ssa_pdb->common_bitmask))
     {
         /* Make the Register Request */ 
         if(ICF_FAILURE == icf_ssa_make_contact_list_for_reg(
                     p_ssa_pdb,
                     &contact_addr_list))
         {
             /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
             sdf_ivk_uaClearTransaction(
                     p_ssa_ctxt->p_call_obj,
                     p_overlap_trans_info,
                     "REGISTER",
                     Sdf_en_uacTransaction);
             ret_val = ICF_FAILURE;
         }
         else
         {

             sdf_fn_uaSprintf(duration,"%lu",
                     p_ssa_ctxt->p_rgm_ctxt->rgm_duration/1000);
             if (Sdf_co_fail == sdf_ivk_uaMakeRegister(
                         p_ssa_ctxt->p_call_obj,
                         duration,
                         &contact_addr_list,
                         p_overlap_trans_info,
                         &sdf_error))
             {
                 sdf_ivk_uaClearTransaction(
                         p_ssa_ctxt->p_call_obj,
                         p_overlap_trans_info,
                         "REGISTER",
                         Sdf_en_uacTransaction);
                 ret_val = ICF_FAILURE;
             }
         }
     }
         if ((ICF_SUCCESS == ret_val) && 
             (!(ICF_SSA_RGM_REQ_TYPE & p_ssa_pdb->common_bitmask)))
         {
             /* Make the DE-Register Request */
              if(ICF_TRUE == p_ssa_ctxt->p_rgm_ctxt->dereg_specific_contact)
			 {
                 if(ICF_FAILURE == icf_ssa_make_contact_list_for_reg(
                             p_ssa_pdb,
                             &contact_addr_list))
                 {
                     ret_val = Sdf_co_fail;
                 }
                 if(ICF_FAILURE != ret_val)                  
                 {
                     if (Sdf_co_fail == sdf_ivk_uaDeleteRegistration(
                                 p_ssa_ctxt->p_call_obj,
                                 &contact_addr_list,
                                 p_overlap_trans_info,
                                 &sdf_error))
                     {
                         sdf_ivk_uaClearTransaction(
                                 p_ssa_ctxt->p_call_obj,
                                 p_overlap_trans_info,
                                 "REGISTER",
                                 Sdf_en_uacTransaction);
                         ret_val = ICF_FAILURE;
                     }
                 }
             }
             else
             {                 
             if (Sdf_co_fail == sdf_ivk_uaDeleteRegistration(
                 p_ssa_ctxt->p_call_obj,
                 Sdf_co_null,
                 p_overlap_trans_info,
                 &sdf_error))
             {
                 sdf_ivk_uaClearTransaction(
                     p_ssa_ctxt->p_call_obj,
                     p_overlap_trans_info,
                     "REGISTER",
                     Sdf_en_uacTransaction);
                 ret_val = ICF_FAILURE;
             }
         }
                            

         }
                            
         if (ICF_SUCCESS == ret_val)
         {
             /* ret_val SUCCESS begins */
             /* We will not insert Authorization header in the initial register
              * request.
              */
             if(!(ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask) &&
                (ICF_CHALLENGE_ALGO_AKA == p_ssa_ctxt->p_rgm_ctxt->challenge_algo))
             {
                 /* Make the authorization header for AKA scenario */
                 if (ICF_FAILURE == icf_ssa_make_aka_auth_hdr(p_ssa_pdb,
                             p_overlap_trans_info->pSipMsg))
        
                 {
                     sdf_ivk_uaClearTransaction(
                                 p_ssa_ctxt->p_call_obj,
                                 p_overlap_trans_info,
                                 "REGISTER",
                                 Sdf_en_uacTransaction);
                     ret_val = ICF_FAILURE;
                 }
             }/* AKA option ends for authorization header */

             if(ICF_SUCCESS == ret_val)
             {

             /* To add the P-Access-Network Info header to the SipMsg */
             if (ICF_FAILURE == icf_ssa_form_and_insert_access_nw_info_hdr(
                 p_ssa_pdb,p_overlap_trans_info->pSipMsg))
             {
                 ret_val = ICF_FAILURE;
             }
            /* To add security association headers*/
             else if(ICF_FAILURE == 
                      icf_ssa_form_and_insert_security_agreement_hdrs(
                           p_ssa_pdb,(icf_uint8_t *)"REGISTER",
                           p_overlap_trans_info->pSipMsg))
             {
                 ret_val = ICF_FAILURE;  
             } 
 
              /* To add the additional tags/headers/msg_body to REGISTER 
             * as received from the application data */
             if ((ICF_FAILURE == ret_val)||
                 (ICF_FAILURE == icf_ssa_add_rgm_app_data(
                 p_ssa_pdb,p_overlap_trans_info)))
             {
                 /* Error during addition of app_data tags/hdrs/msg bodies */
                 ret_val = ICF_FAILURE;
                 
             }
             /*Message body header changes Start*/

             /* Get the Content Type from the Message Body List to be used to 
          * fill in the SIP general Content-Type Header.
          */
             icf_get_content_type_from_msg_body(p_ssa_pdb,&p_content_type);
             
             /* To move the added message bodies onto the SIP message */
             if (ICF_FAILURE == icf_ssa_SetAllMsgBody(Sdf_co_null,
                 p_overlap_trans_info,(icf_int8_t *)p_content_type,&sdf_error))
             {
                 ret_val = ICF_FAILURE;
             }

             }
         }/* ret_val SUCCESS ends */
    /*Message body header changes Ends*/
    
    if(ICF_TRUE == contact_list_valid)
        sdf_listDeleteAll(&contact_addr_list, &sdf_error);
    
    sip_options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;
    
    if (ICF_SUCCESS == ret_val)
    {
        if (ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask)
        {
            icf_ssa_add_callid_callobj_map(
                p_ssa_pdb,
                p_ssa_ctxt,
                p_ssa_pdb->p_ecode);
        }
        
#ifdef ICF_IPSEC_ENABLED
        /* now insert the security header information in the UA Callobj. This 
         * header will go as unknown header in the message */

        /* derive the SIP message from the OverlapTransaction on which we have 
         * invoked the Start Transaction UATK function */
        p_otg_sip_msg = p_overlap_trans_info->pSipMsg;
        if (ICF_TRUE == p_cfg_data->ipsec_enabled)
        {
            /* insert Security Client Header */
            if (ICF_NULL != 
                ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_security_client_params)
            {
                if (ICF_FAILURE == icf_ssa_get_sec_client_string(
                                        p_ssa_pdb,
                                        &p_value, 
                                        ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_security_client_params))
                {
                    ret_val = ICF_FAILURE;
                }
                else if (ICF_FAILURE ==     
                    icf_ssa_insert_unknown_hdr_in_sip_msg (p_ssa_pdb,
                    (icf_uint8_t*)"Security-Client",
                    p_value, p_overlap_trans_info->pSipMsg ))
                {
                    ICF_PRINT(("\nFailed to insert unknown header \
                        (Security-Client)"));
                    ret_val = ICF_FAILURE;
                }

                if (ICF_SUCCESS == ret_val )
                {
                    ICF_PRINT(("\nSecurity Client Header inserted to \
                                    outgoing Register "));
                }

                if (ICF_NULL != p_value)
                {
                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_value,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                }

            }

            /* set the sa_ctxt and rgm_ctxt in p_ssa_sa_ctxt in p_ssa_ctxt */
            /* used for setting the prot port in VIA and contact */
            p_ssa_ctxt->ssa_sa_context.p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;
            p_ssa_ctxt->ssa_sa_context.p_sa_context = 
                    ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;

            p_ssa_pdb->p_sa_context = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
            p_ssa_pdb->p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;
        }
#endif
        /* ------------------------------------------------------------------ */
        /* Send request to peer */
        /*TCPM Additions*/
        
        if ((0 == icf_port_strcmp((icf_uint8_t *)proto, (icf_uint8_t *)"TCP")) ||
            (0 == icf_port_strcmp((icf_uint8_t *)proto, (icf_uint8_t *)"TLS")))
        {
            icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->dest_ip,(icf_uint8_t *)reg_addr);

            p_ssa_pdb->dest_port = reg_port;

            if ( Sdf_co_fail == 
                sdf_ivk_uaSetTransportSchemeInTransaction(
                    p_ssa_ctxt->p_call_obj->pUacTransaction, 
                    p_overlap_trans_info, 
                    proto,
                    &sdf_error))
        {
            ret_val = ICF_FAILURE;
        }

        if (ICF_TRANSPORT_TYPE_TLS == 
                p_ssa_ctxt->transport)
        {
            p_ssa_ctxt->bitmask |= ICF_SSA_TLS_TRANSPORT;
        }
        else
        {
            p_ssa_ctxt->bitmask |= ICF_SSA_TCP_TRANSPORT;
        }

        if (ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask)
        {
            ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                    ICF_SSA_EXPLICIT_CONNECT_REQ)
        }
        }
    /*If transport is INVALID then also set EXPLICIT CONNECT as 
     *mode will be decided from NAPTR response later*/
    if (ICF_TRANSPORT_TYPE_INVALID == p_ssa_ctxt->transport)
    {
        ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                ICF_SSA_EXPLICIT_CONNECT_REQ)
    }
    if (ICF_SUCCESS == ret_val)
    {
        p_ssa_pdb->p_ssa_ctxt->p_overlap_transaction = p_overlap_trans_info;

        if ( ICF_FAILURE == icf_ssa_send_to_peer(
                    p_ssa_pdb,
                    p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info->pSipMsg,
                    &sip_options,
                    &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                    p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == sdf_ivk_uaEndTransaction(
                    p_ssa_ctxt->p_call_obj,
                    Sdf_co_null,
                    "REGISTER",
                    &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                    p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
            ret_val = ICF_FAILURE;
        }
        }
    }
    /*Klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_overlap_trans_info)

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} /* End of icf_ssa_send_register_req() */

/*******************************************************************************
 * 
 * FUNCTION:        icf_ssa_send_register_req_with_auth
 *
 *                  Authentication info on network.Only DIGEST scheme is
 *                  supported.
 *                  1.Initialize the UAC auth info list 
 *                  2.Iterate through the authorization params list
 *                  stored in the SSA ctxt.This list was returned when
 *                  the REGISTRAR challenged us with 401/407 response 
 *                  asking for authorization parameters.
 *                  3.If the scheme present in the elements of this list
 *                  is "Digest",populate the authorization parameters from
 *                  that configured on the line and append the same to the
 *                  UAC auth info list initialized earlier. 
 *                  4. Set the transport scheme in transaction and invoke
 *                  sdf_ivk_uaFormRequestWithAuthorization with the
 *                  authorization paramters and send the request to peer.
*
 ******************************************************************************/
icf_return_t icf_ssa_send_register_req_with_auth(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb)

{
    icf_return_t                     ret_val = ICF_SUCCESS,
                                     dummy_ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;
    Sdf_st_overlapTransInfo             *p_overlap_trans_info = Sdf_co_null;
    Sdf_st_error                        sdf_error, *pErr = &sdf_error;
    Sdf_ty_s8bit                        proto[ICF_MAX_SIZE_INT_USAGE_STR];
    SipOptions                          sip_options;
    Sdf_ty_slist                        *p_uac_auth_info_list = Sdf_co_null;
    Sdf_ty_u32bit                       index = 0;
    
#ifdef ICF_IPSEC_ENABLED
    icf_transport_address_st     *p_transport_address = ICF_NULL;
    icf_uint8_t                  p_transp_addr_str[ICF_MAX_STR_LEN]= "";
    icf_uint16_t                 reg_port = ICF_NULL, port_us = ICF_NULL;
    icf_uint8_t                  reg_addr[ICF_MAX_STR_LEN] = "";
    icf_uint16_t                 proxy_port = ICF_NULL;
    icf_uint8_t                  proxy_addr[ICF_MAX_STR_LEN] = "";
#endif

    Sdf_st_error                sdf_err;

     Sdf_ty_slist               contact_addr_list;

    SipHeader                           *p_exp_hdr = SIP_NULL;
    icf_uint32_t                        tVal = 0;
    SipError                            sip_err;
    icf_error_t                         ecode;
#ifdef ICF_IPSEC_ENABLED
    icf_config_data_st                  *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
#endif
    icf_uint8_t                         *p_content_type = ICF_NULL;
    icf_transport_address_st            self_addr ;
    
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    ICF_SSA_INIT_TRANS_ADDR(&self_addr)

    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))

    if(ICF_NULL == p_ssa_ctxt)
    {
        return ICF_FAILURE;
    }
    p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;
    /* DNS Lookup is not required while sending:
     * - De/REGSITER with credentials on getting challenge from 
     * Registrar
     */
    /* Set the bit indicating that this request is being sent on receiving 
     * 401/407. This will be used to make sure there is no name server refetch
     * needed.
     */
    ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->common_bitmask, ICF_SSA_NO_NAMESERVER_REFRESH)
    tVal = p_ssa_ctxt->p_rgm_ctxt->rgm_duration/1000;

        if (ICF_NULL == p_ssa_pdb->p_glb_cfg_data)
        {
            /* Request the DBM for getting pointer to config data structure */
            ret_val = icf_dbm_get_module_glb_data(
                p_ssa_pdb->p_glb_pdb,
                (icf_int_module_id_t)(ICF_INT_MODULE_CFG),
                (icf_void_t **)(&(p_ssa_pdb->p_glb_cfg_data)),
                p_ssa_pdb->p_ecode);     
            
            ICF_ASSERT(
                p_ssa_pdb->p_glb_pdb,
                (ICF_NULL != p_ssa_pdb->p_glb_cfg_data))
        }/* get pointer to global cfg data if NULL already */

   /*If per line self transport then copy address from line_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE ==
        p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                        sizeof(icf_transport_address_st));
    }
    else
    {
        icf_port_memcpy(&self_addr,
                        &(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                        sizeof(icf_transport_address_st));
    }
    

    /* Initialize the uac auth info list */
    ICF_MEMGET(
        p_ssa_pdb->p_glb_pdb,
    ICF_PORT_SIZEOF(Sdf_ty_slist),
    ICF_MEM_COMMON,
    p_uac_auth_info_list,
    ICF_RET_ON_FAILURE,
    p_ssa_pdb->p_ecode,
    ret_val)

    if (Sdf_co_fail == sdf_listInit(
                            p_uac_auth_info_list,
                            __sdf_fn_uaFreeUacAuthInfo,
                            Sdf_co_false,
                            &sdf_error))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {/* outermost else begins */
        for (index = 0; index < p_ssa_ctxt->auth_params_list_size; index++)
        {
            Sdf_st_authenticationParams     *p_auth_params = Sdf_co_null;
            Sdf_st_uacAuthInfo              *p_uac_auth_info = Sdf_co_null;
           
            /* get the auth param list element */ 
            if (Sdf_co_fail == sdf_listGetAt(
                                    p_ssa_ctxt->p_auth_params_list,
                                    index,
                                    (Sdf_ty_pvoid *)&p_auth_params,
                                    &sdf_error))
            {
                sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_uac_auth_info_list,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
                ret_val = ICF_FAILURE;
                /*Klocwork Warning resolved*/
                ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                return ret_val;
            }
            else if ((ICF_SUCCESS == ret_val) && 
                    (0 == Sdf_mc_strcasecmp((Sdf_ty_s8bit*)p_auth_params->pScheme,
                                            (Sdf_ty_s8bit*) "Digest")))
            {/* scheme supported: begins */

                /* initialize uac auth info list element */
                if (Sdf_co_fail == 
                        sdf_ivk_uaInitUacAuthInfo(&p_uac_auth_info,pErr))
                {
                    sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_uac_auth_info_list,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                    ret_val = ICF_FAILURE;
                   /*Klocwork Warning Removal*/
                    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                        p_uac_auth_info)
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                    return ret_val;
                }
                if (ICF_FAILURE == icf_ssa_fill_uac_auth(p_ssa_pdb,
                                        p_uac_auth_info))
                {
                    sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_uac_auth_info_list,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                    ret_val = ICF_FAILURE;
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                    return ret_val;
                    
                }
                
            /* add the uac info element to list */
                if (Sdf_co_fail == sdf_listAppend(
                            p_uac_auth_info_list,
                            (Sdf_ty_pvoid)p_uac_auth_info,
                            pErr))
                {
                    sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_uac_auth_info_list,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                    ret_val = ICF_FAILURE;
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                    return ret_val;
                }
            } /* End if(p_auth_params->pScheme) */
        } /* End for(index) */

        /*
         * Now form a request with authorization. The list of
         * authentication params and uac auth info structures
         * are passed to this API
         */
        /* Set the transport mode in local variable */
        if (((ICF_TRANSPORT_TYPE_TCP == 
        p_ssa_pdb->p_ssa_ctxt->transport) ||
             (ICF_TRANSPORT_MODE_BOTH == 
                    p_ssa_pdb->p_ssa_ctxt->transport)) &&
              (ICF_NULL == (p_ssa_ctxt->bitmask & 
                               ICF_SSA_RGM_PREV_TRANS_TYPE_UDP)))
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
            icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->trans_param, (icf_uint8_t *)"TCP");
        }
        else if( ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->p_ssa_ctxt->transport)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
        }
        else if( ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)

        {
            icf_port_strcpy((icf_uint8_t *)proto,(icf_uint8_t *)"TLS");
        }


        if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                                p_ssa_ctxt->p_call_obj,
                                &p_overlap_trans_info,
                                "REGISTER",
                                &sdf_error))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/ 
            sdf_listDeleteAll(p_uac_auth_info_list, pErr);
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_uac_auth_info_list,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            ret_val = ICF_FAILURE;
            /*Klocwork Warning resolved*/
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return ret_val;
        }
        else if (Sdf_co_fail == sdf_ivk_uaSetTransportSchemeInTransaction(
                                    p_ssa_ctxt->p_call_obj->pUacTransaction,
                                    p_overlap_trans_info,
                                    proto,
                                    &sdf_error))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            sdf_listDeleteAll(p_uac_auth_info_list, pErr);
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_uac_auth_info_list,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            sdf_ivk_uaClearTransaction(
                    p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
            ret_val = ICF_FAILURE;
            /*Klocwork Warning resolved*/
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return ret_val;
        }
#ifdef ICF_IPSEC_ENABLED
        /* If IPSec is enabled, set the port in Via and Contact headers to 
         * be the UE protected server port, for subsequent protected 
         * messages */
        else if ((ICF_TRUE == p_glb_cfg_data->ipsec_enabled) &&
            (ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context))
        {
        /* For Registration message, rgm ctxt would have been already 
        * copied in ssa pdb from ssa ctxt. 
            */
            if (ICF_NULL != 
                ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
                p_ue_security_params)
            {
                /* set the SA context in the SSA context */
                p_ssa_ctxt->ssa_sa_context.p_sa_context = 
                            ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
                p_ssa_ctxt->ssa_sa_context.p_rgm_context = 
                            p_ssa_ctxt->p_rgm_ctxt ;

                /* this means an SA exists */
                port_us = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
                    p_ue_security_params->port_s;
                
                    /* this code for getting p_transp_addr_str has been copied 
                    * from the function icf_ssa_process_open_nw_servers()
                */
                
                p_transport_address = &(self_addr);
                if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                    p_transport_address->addr.addr_type)
                {
                    icf_port_strcpy(p_transp_addr_str, 
                        p_transport_address->addr.addr.domain.str);
                }
                else if (ICF_TRANSPORT_ADDRESS_IPV4_ADDR == 
                    p_transport_address->addr.addr_type)
                {
                    icf_ssa_convert_to_IP_addr(p_transport_address,
                        p_transp_addr_str);
                }
#ifdef ICF_IPV6_ENABLED
                else if(ICF_TRANSPORT_ADDRESS_IPV6_ADDR == 
                    p_transport_address->addr.addr_type)
                {
                    icf_ssa_convert_to_IP_addr(p_transport_address,
                        p_transp_addr_str);
                    if( (0 == icf_port_strcmp("",p_transp_addr_str)) ||
                        (0 == icf_port_strcmp("::",p_transp_addr_str)))
                    {
                        ret_val = icf_ssa_get_and_populate_self_ip(
                            p_ssa_pdb,
                            p_transport_address,
                            p_transp_addr_str);
                    }
                }
#endif
                else
                {
                    /*Raise A Major Error here-SDF PROCESSING FAILURE*/
                    sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_uac_auth_info_list,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                        sdf_ivk_uaClearTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                    ret_val = ICF_FAILURE;
                }
                
                if (ICF_FAILURE != ret_val)
                {
                    Sdf_st_initData *pInitData = ICF_NULL;
                    sdf_ivk_uaGetInitDataFromCallObject(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj, 
                        &pInitData,
                        pErr);
                    
                    /* change the Via header in the default profile */
                    if (Sdf_co_fail == sdf_ivk_uaSetDefaultTransport(
                        pInitData,     
                        (Sdf_ty_s8bit *)p_transp_addr_str,
                        port_us,
                        &sdf_error))
                    {
                        /*Raise A Major Error here-SDF PROCESSING FAILURE*/
                        sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                        ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_uac_auth_info_list,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                            sdf_ivk_uaClearTransaction(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            p_overlap_trans_info,
                            "REGISTER",
                            Sdf_en_uacTransaction);
                        ret_val = ICF_FAILURE;
                    }
                    /* change the registrar IP and port also */
                  
                    reg_port = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
                        p_proxy_security_params->port_s;

                    /* copy the Registrar address locally */
                    if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                        p_ssa_pdb->p_line_data->registrar_addr.addr.addr_type)
                    {
                        icf_port_strcpy(reg_addr,
                            p_ssa_pdb->p_line_data->registrar_addr.addr.addr.domain.str);
                    }
                    else
                    {
                        icf_ssa_convert_to_IP_addr(
                            &(p_ssa_pdb->p_line_data->registrar_addr),
                            reg_addr);
                    }

                    proxy_port = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
                        p_proxy_security_params->port_s;

                    /* copy the Proxy address locally */
                    if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                        p_ssa_pdb->p_line_data->proxy_addr.addr.addr_type)
                    {
                        icf_port_strcpy(proxy_addr,
                            p_ssa_pdb->p_line_data->proxy_addr.addr.addr.domain.str);
                    }
                    else
                    {
                        icf_ssa_convert_to_IP_addr(
                            &(p_ssa_pdb->p_line_data->proxy_addr),
                            proxy_addr);
                    }

                    if (Sdf_co_fail == sdf_ivk_uaSetDefaultRegistrar(
                        pInitData,
                        reg_addr,
#ifndef ICF_DNS_LOOKUP_ENABLED
                        /* fix - default port 5060 should not go in header */
                        ((reg_port == 5060)?ICF_NULL:reg_port),
#else
                        reg_port,
#endif
                        &sdf_error))
                    {
                        sdf_listDeleteAll(p_uac_auth_info_list, pErr);
                        ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_uac_auth_info_list,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                            sdf_ivk_uaClearTransaction(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            p_overlap_trans_info,
                            "REGISTER",
                            Sdf_en_uacTransaction);

                        sdf_ivk_uaClearTransaction(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            p_overlap_trans_info,
                            "REGISTER",
                            Sdf_en_uacTransaction);
                        ret_val = ICF_FAILURE;
                    }    
                    
                    
                    /* need to set the pre-loaded route set, so that
                     * subsequent Register goes to the peer protected
                     * server port. Thus we need to first delete the 
                     * existing route header value and then add the 
                     * desired route header in the otg Register
                     */
                    icf_ssa_checkNdeleteRouteHdr(p_ssa_pdb->p_ssa_ctxt->p_call_obj);

#ifdef ICF_SIGCOMP_SUPPORT
                    if(ICF_PEER_SUPPORTS_SIGCOMP == 
                        p_ssa_pdb->p_line_data->sigcomp_support_by_proxy)
                    {
                        if ( Sdf_co_fail == 
                            sdf_ivk_uaAddDefaultPreLoadedRoute(
                            pInitData,
                            Sdf_co_null,
                            proxy_addr,
                            proxy_port,
                            "lr;comp=sigcomp",/*pParam*/
                            ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)?"sips":"sip"),
                            &sdf_error))
                        {
                            /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                            ret_val = ICF_FAILURE;
                        }
                    }
                    else
                    {
                        if ( Sdf_co_fail == 
                            sdf_ivk_uaAddDefaultPreLoadedRoute(
                            pInitData,
                            Sdf_co_null,
                            proxy_addr,
                            proxy_port,
                            "lr",/*pParam*/
                            ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)?"sips":"sip"),
                            &sdf_error))
                        {
                            /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                            ret_val = ICF_FAILURE;
                        }
                        
                    }
#else
                    if(ICF_FAILURE == ret_val)
                    {
                        /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                        
                    }
                    else if ( Sdf_co_fail == 
                        sdf_ivk_uaAddDefaultPreLoadedRoute(
                        pInitData,
                        Sdf_co_null,
                        proxy_addr,
                        proxy_port,
                        "lr",/*pParam*/
                        "sip",
                        &sdf_error))
                    {
                        /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                        ret_val = ICF_FAILURE;
                    }
#endif
                    /* Free the local reference */
                    sdf_ivk_uaFreeInitData(pInitData);
                }
            }
        } /* End if(ipsec_enabled) */
#endif
        if ((ICF_SUCCESS == ret_val) && 
            (!(ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask)))
        {
        /* Register request which is not the initial one should 
        * not contain the to tag : So remove the to tag
            */
            Sdf_ty_u32bit dCount = 0;
            
            if(sip_getTagCountFromToHdr(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pCommonInfo->pTo,&dCount,\
                (SipError *)&(sdf_error.stkErrCode))==SipFail)
            {
                ret_val = ICF_FAILURE;
            }
            if (dCount != 0)
            {
                Sdf_ty_u32bit dIndex=0;
                for(dIndex=0;dIndex<dCount;dIndex++)
                {
                    if(sip_deleteTagAtIndexInToHdr(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pCommonInfo->pTo,
                        dIndex,\
                        (SipError *)&(sdf_error.stkErrCode))==SipFail)
                    {
                        ret_val = ICF_FAILURE;
                        break;
                    }
                }
            }
            
        }
    if ( ICF_FAILURE == ret_val)
    {
    }
    else if (ICF_FAILURE == icf_ssa_make_profile_for_reg(
             p_ssa_ctxt->p_call_obj->pInitData,            
             p_ssa_pdb))
         {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                sdf_ivk_uaClearTransaction(
                        p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
         }
        else if(sdf_ivk_uaAddExtraHeaders(p_ssa_ctxt->p_call_obj,
            p_overlap_trans_info,"REGISTER", \
            pErr) == Sdf_co_fail)
        {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                sdf_ivk_uaClearTransaction(
                        p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
            ret_val = ICF_FAILURE;
        }

        else if ((ICF_SUCCESS == ret_val) && 
            (Sdf_co_fail == sdf_ivk_uaFormRequestWithAuthorization(
                                    p_ssa_ctxt->p_call_obj,
                                    p_overlap_trans_info,
                                    "REGISTER",
                                    Sdf_co_false,
                                    p_ssa_ctxt->p_auth_params_list,
                                    p_uac_auth_info_list,
                                    pErr)))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE == icf_ssa_chk_n_append_auts(p_ssa_pdb,
                        p_overlap_trans_info->pSipMsg))
        {/* If AUTS appending fails: end transaction */
            ret_val = ICF_FAILURE;
        }/* For IMS: AUTS added if present in auth_data_sent of rgm_context */    
        else
        {

           /*
            * The list of pAuthenticationParams and pUacAuthInfo are no longer
            * required and can be freed at this stage.
            */
            /*sdf_listDeleteAll(p_ssa_ctxt->p_auth_params_list, pErr);*/
            sdf_listDeleteAll(p_uac_auth_info_list, pErr);
            
            /* this should be freed in sdf_ivk_ua_FreeApplicationData */

            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_uac_auth_info_list,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
                
        }

        if (ret_val == ICF_FAILURE)
        {
            if (p_uac_auth_info_list) sdf_listDeleteAll(p_uac_auth_info_list, pErr);
            
            if ( p_uac_auth_info_list )  
			{	ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_uac_auth_info_list,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
            }
            sdf_ivk_uaClearTransaction(
                p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "REGISTER",
                Sdf_en_uacTransaction);
            
            return ret_val;
        }

        else
        {
          /* ret_val : SUCCESS : Begins */

         /* Expire header addition */
                            
            if (ICF_FAILURE == sip_initSipHeader(
                        &p_exp_hdr, SipHdrTypeExpiresSec, &sip_err))
            {
                        sdf_ivk_uaClearTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                        ret_val = ICF_FAILURE;

                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                                        ICF_MEM_COMMON, &ecode, ret_val)
                        ret_val = ICF_FAILURE;
            }

            else if (ICF_FAILURE == sip_setSecondsInExpiresHdr(
                            p_exp_hdr, tVal, &sip_err))
            {
                        sdf_ivk_uaClearTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                        ret_val = ICF_FAILURE;

                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                                        ICF_MEM_COMMON, &ecode, ret_val)
                        sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
                        ret_val = ICF_FAILURE;
           }
           else if (ICF_FAILURE == sip_setHeader(
                          p_overlap_trans_info->pSipMsg, 
                          p_exp_hdr, &sip_err))
           {
                        sdf_ivk_uaClearTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                        ret_val = ICF_FAILURE;

                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                                        ICF_MEM_COMMON, &ecode, ret_val)
                        ret_val = ICF_FAILURE;
           }
           sip_freeSipHeader(p_exp_hdr);
           ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_exp_hdr,\
                                      ICF_MEM_COMMON, &ecode, ret_val)
        }

        if ( ICF_FAILURE == ret_val)
    {
    }
#ifndef MSTC_DISABLE_PRACK
    else if(0 == tVal)
        {
            /* This is the case of sending 
             * Authenticated deregister request */
            Sdf_ty_s8bit dContact[] = "Contact: *";
            
            if(sip_insertHeaderFromStringAtIndex(p_overlap_trans_info->pSipMsg,\
                SipHdrTypeContactWildCard,dContact,(Sdf_ty_u32bit)0,\
                (SipError *)&(pErr->stkErrCode))==SipFail)
            {
                ret_val = Sdf_co_fail;
            }    
        }
#endif		
        else
        {
            
            if(ICF_FAILURE == ret_val)
            {
                
            }
            else if (Sdf_co_fail == sdf_listInit(
                &contact_addr_list,
                __sdf_fn_uaFreeCompleteHeader,
                Sdf_co_false,
                &sdf_error))
            {
                /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
                sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
                
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                    ICF_MEM_COMMON, &ecode, ret_val)
                    ret_val = ICF_FAILURE;
            }
            
            else if(ICF_FAILURE == icf_ssa_make_contact_list_for_reg(
                p_ssa_pdb,
                &contact_addr_list))
            {
                sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
                
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                    ICF_MEM_COMMON, &ecode, ret_val)
                    ret_val = ICF_FAILURE;
            }
            
            
            else if(ICF_FAILURE == 
                icf_ssa_add_ContactHeaderToSipMsg(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,&contact_addr_list,p_overlap_trans_info,&sdf_err))
            {
                sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "REGISTER",
                    Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
                
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt,\
                    ICF_MEM_COMMON, &ecode, ret_val)
                   ret_val = ICF_FAILURE;
            }
            sdf_listDeleteAll(&contact_addr_list, pErr);

        }/* If Tval is not 0 make the contact address */
        
        if ((ICF_FAILURE == ret_val)||
            (ICF_FAILURE == icf_ssa_add_rgm_app_data(
            p_ssa_pdb,p_overlap_trans_info)))
        {
            /* Error during addition of app_data tags/hdrs/msg bodies */
            ret_val = ICF_FAILURE;
            
        }
        /* To add the P-Access-Network Info header to the SipMsg */
        else if ((ICF_FAILURE == ret_val)||
            (ICF_FAILURE == icf_ssa_form_and_insert_access_nw_info_hdr(
            p_ssa_pdb,p_overlap_trans_info->pSipMsg)))
        {
            /* Error during addition of P-Access-Info Header */
            ret_val = ICF_FAILURE;
        }
        /* To add security association headers*/
        else if(ICF_FAILURE ==
                 icf_ssa_form_and_insert_security_agreement_hdrs(
                        p_ssa_pdb,(icf_uint8_t *)"REGISTER",
                        p_overlap_trans_info->pSipMsg))
        {
                ret_val = ICF_FAILURE;
        }

        /* To move the added message bodies onto the SIP message */
       else
       {
        /*Message body header changes Start*/
        icf_get_content_type_from_msg_body(p_ssa_pdb,&p_content_type);    
              if ((ICF_FAILURE == ret_val)||\
            (ICF_FAILURE == icf_ssa_SetAllMsgBody(Sdf_co_null,\
             p_overlap_trans_info,(icf_int8_t *)p_content_type,&sdf_err)))
        {
            ret_val = ICF_FAILURE;
        }
        /*Message body header changes Ends*/
       }   
        
#ifdef ICF_IPSEC_ENABLED

    /* SSA needs to insert Security-Verify header in all REG requests except for
     * initial REG request */
    if ((!(ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask)) ||
        ((ICF_SSA_RGM_INITIAL_REQ & p_ssa_pdb->common_bitmask) && 
         (ICF_RGM_ONCE_REGISTERED & p_ssa_pdb->p_rgm_context->indicator)))
    {
    /* if SA exists, all messages will go protected */
    if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled) &&
        /* if SA exits */
        (ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context))
    {
        icf_uint8_t            *p_value = ICF_NULL;

        /* insert Security Client Header */
        if (ICF_NULL != 
            ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_security_client_params)
        {
            if (ICF_FAILURE == icf_ssa_get_sec_client_string(
                                    p_ssa_pdb,
                                    &p_value, 
                                    ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_security_client_params))
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_FAILURE ==     
                icf_ssa_insert_unknown_hdr_in_sip_msg (p_ssa_pdb,
                (icf_uint8_t*)"Security-Client",
                p_value, 
                p_overlap_trans_info->pSipMsg ))
            {
                ICF_PRINT(("\nFailed to insert unknown header \
                    (Security-Client)"));
                ret_val = ICF_FAILURE;
            }

            if (ICF_SUCCESS == ret_val )
            {
                ICF_PRINT(("\nSecurity Client Header inserted to \
                                outgoing Register "));
            }
            if (ICF_NULL != p_value)
            {
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_value,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            }
        }

        /* insert security-verify header in the otg Register (with Auth) */
        if (ICF_FAILURE == icf_ssa_get_sec_verify_string(
                                p_ssa_pdb,
                                &p_value,
                                ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context))
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE ==     
          icf_ssa_insert_unknown_hdr_in_sip_msg (
              p_ssa_pdb,
              (icf_uint8_t*)"Security-Verify",
              p_value, 
              p_overlap_trans_info->pSipMsg))
        {
            ICF_PRINT(("\nFailed to insert unknown header \
                    (Security-Verify)"));
            ret_val = ICF_FAILURE;
        }
        if (ICF_NULL != p_value)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_value,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        }
        if (ICF_SUCCESS == ret_val )
        {
            ICF_PRINT(("\nSecurity Verify Header inserted to \
                            outgoing REGISTER with Auth "));
        }
    }
    }
#endif
            
        if(p_ssa_ctxt && (ICF_FAILURE != ret_val))
        {
            sip_options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;
            
#ifdef ICF_IPSEC_ENABLED
            p_ssa_pdb->p_sa_context =  ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
            p_ssa_pdb->p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;

            p_ssa_ctxt->ssa_sa_context.p_sa_context = 
                ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
            p_ssa_ctxt->ssa_sa_context.p_rgm_context = 
                p_ssa_ctxt->p_rgm_ctxt;
#endif
            /* Send request to peer */
         if (ICF_FAILURE == icf_ssa_send_to_peer(p_ssa_pdb,
                                        p_ssa_ctxt->p_call_obj,
                                        p_overlap_trans_info->pSipMsg,
                                        &sip_options,
                                        &sdf_error))
            {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                sdf_ivk_uaClearTransaction(
                        p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
            }
            else if (Sdf_co_fail == sdf_ivk_uaEndTransaction(
                        p_ssa_ctxt->p_call_obj,
                        Sdf_co_null,
                        "REGISTER",
                        &sdf_error))
            {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                sdf_ivk_uaClearTransaction(
                        p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "REGISTER",
                        Sdf_en_uacTransaction);
                ret_val = ICF_FAILURE;
            }
        } /* End if */
    } /* outermost else  Ends  */
    /*Klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_overlap_trans_info)

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;

} /* End of icf_ssa_send_register_req_with_auth() */

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_status_frm_notify
 * DESCRIPTION:     This function checks the given SipMessage for Fragmented
 *                  Sip body and then checks it for the response code
 *                  It returns TRUE if a 200 OK is found, FALSE if any non 2xx
 *                  is found or no message body is found at all
 ******************************************************************************/
icf_return_t icf_ssa_get_status_frm_notify(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT      SipMessage              *p_sip_message,
              OUT     icf_boolean_t        *p_status,
                OUT     icf_boolean_t        *p_indicate_service)

{
    icf_return_t         ret_val = ICF_SUCCESS;

    Sdf_st_error            sdf_error;
    SIP_U32bit              counter = 0,body_count = 0;


    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /*
     * Here I am setting the status as success, in the code below i will
     * check for presence of a non 2xx response in the sip message body.
     * if it is there then this status is changed to false.
     * In allother cases, that is when there is no sip message body ( there
     * could be otehr bodies), or the sip message body is there with 200 OK
     * we do not modify the status
     */
    *p_status = ICF_TRUE;

    /*This is a flag that will decide whether service is to be indicated of
     *this notify or not. This will be set to FALSE when the sip frag body
     *contains a provisional response*/

    *p_indicate_service=ICF_TRUE;

    if (SipFail == sip_getMsgBodyCount(p_sip_message, &body_count, 
                (SipError*)&(sdf_error.errCode)))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sip_getMsgBodyCount"));
        ret_val = ICF_FAILURE;
        *p_status = ICF_FALSE;
    }
    else
    {
        /*
         * If message body is absent,SSA sets the status as FALSE
         */
        if (ICF_NULL == body_count)
        {
            *p_status = ICF_FALSE;
        }
        for (counter = 0; counter < body_count; counter++)
        {
            /*Loop pver all the message bodies looking for sip fragmen body
             * Once that is found, extract the sip frag message, then get the
             * response code from sip frag message ad decide the status code 
             * value to be returned*/
            en_SipMsgBodyType  msg_body_type;
            if (SipFail == sip_getMsgBodyTypeAtIndex(p_sip_message,
                        &msg_body_type, counter,
                        (SipError*)&(sdf_error.errCode)))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sip_getMsgBodyTypeAtIndex"));
                ret_val = ICF_FAILURE;
                *p_status = ICF_FALSE;
                break;
            }
            else if (SipAppSipBody == msg_body_type)/*for SIP fragment*/
            {
                SipMsgBody      *p_sip_msg_body = SIP_NULL;
                SipMessage      *p_sip_frag_message = SIP_NULL;
                Sdf_ty_u16bit   frag_resp_code;
                /*
                 * Retreive the message  body so as to get access to 
                 * SipFragMessage in it
                 */
                if (SipFail == sip_getMsgBodyAtIndex(
                            p_sip_message, &p_sip_msg_body,
                            counter, (SipError*)&(sdf_error.errCode)))
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sip_getMsgBodyAtIndex"));
                    ret_val = ICF_FAILURE;
                    *p_status = ICF_FALSE;
                    break;
                }
                /*Now get the SipMessage Fragment from the SipMessageBody*/
                else if (SipFail == sip_getSipMessageFromMsgBody(p_sip_msg_body,
                            &p_sip_frag_message,
                            (SipError*)&(sdf_error.errCode)))
                {
                    sip_freeSipMsgBody(p_sip_msg_body);
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sip_getSipMessageFromMsgBody"));
                    ret_val = ICF_FAILURE;
                    *p_status = ICF_FALSE;
                    break;
                }
                /*Now get the response code from SipMessage Fragment*/
                else if (Sdf_co_fail == sdf_ivk_uaGetRespCodeFromSipMessage(
                            p_sip_frag_message,&frag_resp_code,&sdf_error))
                {
                    sip_freeSipMessage(p_sip_msg_body->u.pAppSipMessage);
                    sip_freeSipMsgBody(p_sip_msg_body);
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sdf_ivk_uaGetRespCodeFromSipMessage"));
                    ret_val = ICF_FAILURE;
                    *p_status = ICF_FALSE;
                    break;
                }
                else
                {
					/* CSR 1-6240518: Update the response code in ssa pdb */
					p_ssa_pdb->resp_code = frag_resp_code;                    
                    sip_freeSipMessage(p_sip_msg_body->u.pAppSipMessage);
                    sip_freeSipMsgBody(p_sip_msg_body);
                    if ((100 <= frag_resp_code)&&(199 >= frag_resp_code))
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:provisional response code in SipMessageFragment"));
                        *p_indicate_service = ICF_FALSE;
                    }

                    /*2XX should be treated as 200 OK*/
                    if (( 200 > frag_resp_code)||(299 < frag_resp_code))
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Non200 response code in SipMessageFragment"));
                        *p_status = ICF_FALSE;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }/*End of block for SipAppSipBody*/
    }/*End of for loop for traversing the message bodies*/

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/**********************************************************************
 * FUNCTION:        icf_ssa_get_div_count
 * DESCRIPTION:     This routine traverses the Route header structure 
 * slParam and looks for diversion counter. If it is not there
 * it set the default value from configuration into it
 **********************************************************************/
icf_return_t icf_ssa_get_div_count(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT      SipRouteHeader          *p_route_hdr,
        OUT     icf_diversion_info_st  *p_div_info)
{
    icf_return_t             ret_val = ICF_SUCCESS;

    Sdf_ty_u32bit           param_list_size = 0, count = 0;
    Sdf_st_error            sdf_error;
    SipParam                *p_sip_param = SIP_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (Sdf_co_fail == sip_listSizeOf(
                &(p_route_hdr->slParam),&param_list_size,\
                (SipError*)&(sdf_error.stkErrCode)))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureListSizeOf of Param in DivHdr"));
        return ICF_FAILURE;
    }
    for ( count = 0; count < param_list_size; count++)
    {
        if (Sdf_co_fail == sip_listGetAt(
                    &(p_route_hdr->slParam),
                    count,(Sdf_ty_pvoid *)&p_sip_param,\
                    (SipError*)&(sdf_error.stkErrCode)))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureListGetAt in Param for DivHdr"));
            ret_val = ICF_FAILURE;
        }
        else
        {
            if ( ICF_NULL ==
                    icf_port_strcmp((icf_uint8_t *)p_sip_param->pName,(icf_uint8_t *)"counter"))
            {/*Now we have to get the value string for counter
               and convert it to string. The values are also
               as a List of S8bit.  We will index into the list
               to get the first value ( index )*/
                SIP_S8bit       *p_counter_val = SIP_NULL;
                if (Sdf_co_fail == sip_listGetAt(
                            &(p_sip_param->slValue),0,
                            (Sdf_ty_pvoid *)&p_counter_val,\
                            (SipError*)&(sdf_error.stkErrCode)))
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureListGetAt for CounterVal"));
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    p_div_info->no_of_hops =
                        (icf_uint8_t )icf_port_atoi(p_counter_val);
                    break;
                }
            }
        }
        if ( ICF_FAILURE == ret_val)
        {
            break;
        }
    }
    if ((ICF_FAILURE != ret_val) &&
        param_list_size == count)
    {
        p_div_info->no_of_hops = 
            p_ssa_pdb->p_glb_cfg_data->max_num_of_call_forwarding_hops;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/**********************************************************************
 * FUNCTION:        icf_ssa_populate_div_hdr
 * DESCRIPTION:     This routine traverses the list of unknown headers
 *                  and extracts the diversion header(s) and populates 
 *                  the p_diversion_header_list field of the call context
 *                  on the basis of the diversion headers.
 *                  1.The diversion header(s) are parsed similarly to
 *                  the From header as the syntax of both are the same.
 *                  2. If there are multiple diversion headers,they are
 *                  appended to the p_diversion_header_list 
 *                  of call context.
 **********************************************************************/
icf_return_t icf_ssa_populate_div_hdr(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT    SipMessage              *p_sip_msg)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_diversion_info_st    *p_div_info = ICF_NULL;
    icf_diversion_data_st    *p_div_data = ICF_NULL;

    Sdf_st_error            sdf_error;
    Sdf_ty_u32bit           unp_hdr_list_size = 0, count = 0;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (Sdf_co_fail == sip_listSizeOf(
                &(p_sip_msg->
                    pGeneralHdr->slUnknownHdr),&unp_hdr_list_size,
                (SipError*)&(sdf_error.stkErrCode)))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Failure in getting size of UnknownHdrList"));
        return ICF_FAILURE;
    }
    for ( count = 0 ; count < unp_hdr_list_size; count++)
    {
        SipUnknownHeader    *p_unknown_hdr = SIP_NULL;
        if (Sdf_co_fail == sip_listGetAt(
                    &(p_sip_msg->
                        pGeneralHdr->slUnknownHdr),
                    count,(Sdf_ty_pvoid *)&p_unknown_hdr,
                    (SipError*)&(sdf_error.stkErrCode)))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Failure in getting the pHeader from list"));
            ret_val = ICF_FAILURE;
            break;
        }
        else if ( ICF_NULL ==
#ifdef ICF_WITH_MUATK_2_2
                icf_port_strcmp((icf_uint8_t *)p_unknown_hdr->pStr1, (icf_uint8_t *)"Diversion"))
#else
                icf_port_strcmp(p_unknown_hdr->pName, "Diversion"))
#endif
        {
            /*We will invoke the parseFromHeader API to get the Name, 
             * pAddrSpec and the parameter list*/
#ifdef ICF_WITH_MUATK_2_2
            SIP_S8bit       *p_start = p_unknown_hdr->pStr2;
#else
            SIP_S8bit       *p_start = p_unknown_hdr->pBody;
#endif
            SipError        sip_error;
            SipHeader  *p_route_hdr = SIP_NULL;


            if ( SipFail == 
                    sip_initSipHeader( 
                        &p_route_hdr, SipHdrTypeRoute, &sip_error))
            {
                sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Failure in Init of Sip Route Header"));
                ret_val = ICF_FAILURE;
                break;
            }
            else if (SIP_NULL == p_route_hdr)
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Failure in Init of Sip Route Header"));
                ret_val = ICF_FAILURE;
                break;
            }
            else
            {
                SipAddrSpec     *p_addr_spec = SIP_NULL;
                en_AddrType     addr_type;
                Sdf_ty_u32bit   buf_count = 0;
				icf_uint16_t    tmp_size = 0;
#ifdef ICF_WITH_MUATK_2_2
                buf_count=icf_port_strlen((icf_uint8_t *)p_unknown_hdr->pStr2);
#else
                buf_count=icf_port_strlen(p_unknown_hdr->pBody);
#endif
                if( 0 == buf_count)
                {
                    /* Fix for SPR 19924 */
                    /* If the diversion header is malformed 
                     * reject the request with 400 response.
                     */
                    ICF_SSA_SET_COMMON_BITMASK(
                            p_ssa_pdb->p_ssa_ctxt->failure_bitmask, 
                            ICF_SSA_FAILURE_RESP_CODE_400)    
                    sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_route_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE;
                    break;

                }
                if (SipFail == sip_parseFromHeader(
                            p_start, p_start+buf_count-1, p_route_hdr,
                            SipHdrTypeRoute, &sip_error))
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]: FailureInit of SipRouteHeader"));
                    sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_route_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE;
                    break;
                }
                else if(SipFail == sip_getAddrSpecFromRouteHdr(
                            p_route_hdr,&p_addr_spec, &sip_error))
                {
                    sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_route_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE;
                    break;
                }
                else if ( SipFail == sip_getAddrTypeFromAddrSpec(
                            p_addr_spec, &addr_type, &sip_error))
                {
                    sip_freeSipAddrSpec(p_addr_spec);
                    sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_route_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE;
                    break;
                }
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        ICF_PORT_SIZEOF(icf_diversion_data_st),
                        ICF_MEM_COMMON,
                        p_div_data,
                        ICF_DONOT_RET_ON_FAILURE,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                /*klocwork warning removal*/
                ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_div_data);
                                                 
                if (ICF_FAILURE == ret_val || ICF_NULL == p_div_data)
                {
                    sip_freeSipAddrSpec(p_addr_spec);
                    sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_route_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE;
                    break;
                }
                p_div_data->bitmask = ICF_NULL;
                p_div_data->p_next = ICF_NULL;

				/* SPR 19927: The string names are initialised. Also all the
				 * instances of strncpy are updated with calculating the
			     * remaining lenght before calling the fn icf_port_strcpy. This 
				 * is to avoid potential ABRs / ABWs in case of buffer overflow 
				 * as reported by klocworks.
			     */	 
				p_div_data->diverted_frm_name.str[0] = '\0'; 
				p_div_data->diverted_frm_addr.addr_val.str[0] = '\0'; 

                if (SIP_NULL != 
#ifdef ICF_WITH_MUATK_2_2
                        ((SipRouteHeader*)(p_route_hdr->pHeader))->pStr1)
#else
                        ((SipRouteHeader*)(p_route_hdr->pHeader))->pDispName)
#endif
                {
                    /* Fix for SPR: 19886 (Merged SPR:19839)*/
                    icf_port_strncpy((icf_int8_t *)p_div_data->diverted_frm_name.str, 
#ifdef ICF_WITH_MUATK_2_2
                            (const icf_int8_t *)((SipRouteHeader*)(p_route_hdr->pHeader))->pStr1,
                            (ICF_MAX_STR_LEN-2));
#else
                            (const icf_int8_t *)((SipRouteHeader*)(p_route_hdr->pHeader))->pDispName,
                            (ICF_MAX_STR_LEN-2));
#endif
                    p_div_data->diverted_frm_name.str[ICF_MAX_STR_LEN - 1] = '\0';

                    p_div_data->diverted_frm_name.str_len = 
                        (icf_uint16_t)icf_port_strlen(p_div_data->
                                diverted_frm_name.str);

                    p_div_data->bitmask|=ICF_DIVERTERD_NAME_PRESENT;      
                }
                if(SipAddrSipUri == addr_type)
                {
                    SipUrl          *p_sip_url = SIP_NULL;
                    if(SipFail == sip_getUrlFromAddrSpec(
                                p_addr_spec, &p_sip_url, &sip_error))
                    {
                        sip_freeSipAddrSpec(p_addr_spec);
                        sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_route_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_div_data,ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                            ret_val = ICF_FAILURE;
                        break;
                    }
                    else
                    {
                        p_div_data->diverted_frm_addr.addr_type =
                            ICF_ADDRESS_PLAN_SIP_URI;
                        if(ICF_NULL != p_sip_url->pUser)
						{
							/* Fix for SPR: 19886 (Merged SPR:19839)*/
							icf_port_strncpy((icf_int8_t *)p_div_data->
									diverted_frm_addr.addr_val.str,
									(const icf_int8_t *)(p_sip_url->pUser),(ICF_MAX_STR_LEN-3));


							icf_port_strcat((icf_uint8_t *)p_div_data->
									diverted_frm_addr.addr_val.str,(icf_uint8_t *)"@");
						}
						
						tmp_size = icf_port_strlen(p_div_data->diverted_frm_addr.addr_val.str);

						if((tmp_size + icf_port_strlen((icf_uint8_t *)p_sip_url->pHost)) < (ICF_MAX_STR_LEN - 2))
						{
                           icf_port_strcat(p_div_data->diverted_frm_addr.
                                addr_val.str,(icf_uint8_t *)p_sip_url->pHost);
						   tmp_size = icf_port_strlen(p_div_data->diverted_frm_addr.addr_val.str);
						}


                        if ( ICF_NULL != p_sip_url->dPort)
                        {
                            icf_uint8_t  p_div_hdr_port[6] = "\0";
                            icf_port_strcat((icf_uint8_t *)p_div_data->
                                diverted_frm_addr.addr_val.str,(icf_uint8_t *)":");
                            
                            icf_port_snprintf(
                                    (icf_uint8_t *)p_div_hdr_port,
                                    ICF_PORT_SIZEOF(p_div_hdr_port),(const icf_uint8_t*)"%d",
                                    *(p_sip_url->dPort));

							if((tmp_size + icf_port_strlen(p_div_hdr_port)) < (ICF_MAX_STR_LEN - 2))
						    {
                               icf_port_strcat(
                                    p_div_data->diverted_frm_addr.addr_val.str,
                                    p_div_hdr_port);
						       tmp_size = icf_port_strlen(p_div_data->diverted_frm_addr.addr_val.str);
							}
                        }
                        p_div_data->diverted_frm_addr.addr_val.str_len = tmp_size;
                        
                        sip_freeSipUrl(p_sip_url);
                    }
                }
                else
                    /*Assuming Tel URI*/
                {
                    SIP_S8bit   *p_sip_uri = SIP_NULL;
                    if (SipFail == sip_getUriFromAddrSpec (
                                p_addr_spec, &p_sip_uri, &sip_error))
                    {
                        sip_freeSipAddrSpec(p_addr_spec);
                        sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_route_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_div_data,ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                            ret_val = ICF_FAILURE;
                        break;
                    }
                    else
                    {
                        icf_uint8_t  *p_temp= ICF_NULL, 
                                        p_temp2[ICF_MAX_STR_LEN] = "\0",
                                        str[ICF_MAX_STR_LEN] = "\0";
                                        
                        p_div_data->diverted_frm_addr.addr_type =
                            ICF_ADDRESS_PLAN_TEL_URI;

                        icf_port_strncpy((icf_int8_t *)str,(const icf_int8_t *)p_sip_uri,
                                (ICF_MAX_STR_LEN-2));
                        str[ICF_MAX_STR_LEN - 1] = '\0';

                        p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)str,":");
                        if(ICF_NULL != p_temp)
                        {
                            p_temp = (icf_uint8_t *)icf_port_strtok(0,":");
                            if (ICF_NULL != p_temp)
                            {
                                icf_port_strncpy((icf_int8_t *)p_temp2,
										(const icf_int8_t *)p_temp,(ICF_MAX_STR_LEN-2));
                                p_temp2[ICF_MAX_STR_LEN - 1] = '\0'; 

                                if (' ' == p_temp2[0])
                                {
                                    p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)p_temp2, " ");
                                }

                                if(ICF_NULL != p_temp)
                                    icf_port_strncpy(
                                        (icf_int8_t *)p_div_data->diverted_frm_addr.addr_val.str,
                                        (const icf_int8_t *)p_temp,(ICF_MAX_STR_LEN-2));
                                p_div_data->diverted_frm_addr.addr_val.str[ICF_MAX_STR_LEN - 1] = '\0';
                            }
                            else
                            {
                                icf_port_strncpy(
                                    (icf_int8_t *)p_div_data->diverted_frm_addr.addr_val.str,
                                    (const icf_int8_t *)str,(ICF_MAX_STR_LEN-2));
                                p_div_data->diverted_frm_addr.addr_val.str[ICF_MAX_STR_LEN - 1] = '\0';
                            }
                            p_div_data->diverted_frm_addr.addr_val.str_len = 
                           (icf_uint16_t)icf_port_strlen(p_div_data->
                                    diverted_frm_addr.addr_val.str);
                        }
                    }
                }
                /* Reaching this point means that we have successfully
                 * retreived one diversion header, allocated memory
                 * for it, and populated it with SipPdu info*/
                /*Now we allocate the diversion information struct for Cctxt*/

                if ( ICF_NULL == 
                        p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list)
                {
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                            ICF_PORT_SIZEOF(icf_diversion_info_st),
                            ICF_MEM_COMMON, p_div_info,
                            ICF_DONOT_RET_ON_FAILURE,
                            p_ssa_pdb->p_ecode, ret_val);
                    if ( ICF_FAILURE == ret_val || ICF_NULL == p_div_info)
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:MemgetFailure for Div hdr"));
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_div_data,ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                        sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                        if(ICF_NULL != p_route_hdr)
                        {
                             ICF_MEMFREE(
                                     p_ssa_pdb->p_glb_pdb,
                                     p_route_hdr,
                                     ICF_MEM_COMMON,
                                     p_ssa_pdb->p_ecode,
                                     ret_val)
                         }
                         ret_val = ICF_FAILURE;
                         break;
                    }
                    p_div_info->no_of_diversion_data = 0;
                    p_div_info->no_of_hops = 0;
                    p_div_info->p_contact_addr = ICF_NULL;
                    p_div_info->p_contact_name = ICF_NULL;
                    p_div_info->p_diversion_data = ICF_NULL;
                    p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list = 
                        p_div_info;

                    if(ICF_FAILURE == 
                            icf_ssa_get_div_count( p_ssa_pdb,
                                (SipRouteHeader*)(p_route_hdr->pHeader),p_div_info))
                    {
                        sip_freeSipAddrSpec(p_addr_spec);
                        sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_route_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_div_data,ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                            ret_val = ICF_FAILURE;
                        break;
                    }
                }
                if (ICF_SUCCESS == ret_val)
                {
                    sip_freeSipAddrSpec(p_addr_spec);
                    sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_route_hdr,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                }

                if (ICF_NULL != p_div_info)
                {
                    ICF_SSA_ADD_DIV_DATA_TO_DIV_INFO(p_div_info, p_div_data)
                }
                /* Klocwork warning removal.*/ 
                else
                {
                   ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_div_data,ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                   sip_freeSipHeader((SIP_Pvoid)p_route_hdr);
                   if(ICF_NULL != p_route_hdr)
                   {
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_route_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                    }
                   ret_val = ICF_FAILURE;
                   break;                     
                }                
            }
        }/*Handling of unknonw header for "Diversion"*/
    }/*end of loop block for all the SipUnknownHeaders*/
    if ((ICF_FAILURE == ret_val) &&
            (ICF_NULL != 
             p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list) &&
         (ICF_NULL != p_div_info))
    {
        ICF_SSA_FREE_DIV_DATA_LIST(p_ssa_pdb, p_div_info)
        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_div_info,ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        ret_val = ICF_FAILURE;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_hostname_str_frm_trans_addr
 * DESCRIPTION:    This function returns the host name string corresponding
 *                 to the transport address passed to it. 
 ******************************************************************************/
icf_return_t icf_ssa_get_hostname_str_frm_trans_addr(
        icf_ssa_pdb_st       *p_ssa_pdb,
        icf_transport_address_st     *p_transp_addr,
        icf_uint8_t          *p_hostname)
{
    icf_return_t             ret_val = ICF_SUCCESS;

    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }
    
    p_ssa_pdb=p_ssa_pdb;
        
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)


    if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
            p_transp_addr->addr.addr_type)
    {
        icf_port_strcpy(p_hostname,
                p_transp_addr->addr.addr.domain.str);
    }
    else/*Assumption that it will be IPV4*/
    {
        icf_uint8_t remote_ip[16];

        if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                    p_transp_addr, remote_ip))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            icf_port_strcpy(p_hostname, remote_ip);
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_form_and_insert_div_hdr
 * DESCRIPTION:     This function forms and insert the diversion header
 *                  in the SIP message passed to it on the basis of the
 *                  p_diversion_header_list field of the call context.
 *                  1. One diversion header is added for every entry in 
 *                  the p_diversion_header_list.
 *                  2. These headers are added as Unknown headers as the
 *                  micro SIP stack doesn't recognize them.
 ******************************************************************************/
icf_return_t icf_ssa_form_and_insert_div_hdr(
        icf_ssa_pdb_st   *p_ssa_pdb,
        SipMessage      *p_otg_sip_msg)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_diversion_info_st            *p_div_info =
        p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list;
    icf_diversion_data_st            *p_div_data = ICF_NULL;
     icf_uint16_t            port_num=0;
    icf_uint8_t                      div_counter = 0,
                            addr_str[ICF_MAX_STR_LEN] = "\0", 
                                scheme[ICF_MAX_SIZE_INT_USAGE_STR] = "\0";

    SipHeader  *p_sip_header = SIP_NULL;
    SipUnknownHeader  *p_unknown_header = SIP_NULL;
    SipError        sip_error;
    icf_transport_address_st     self_addr ;
    
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /* Fix for SPR: 19886 (Merged CSR 1-7444867)*/    
    /* Fix For SPR:19788*/
    if (ICF_NULL == p_div_info)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Diversion Info is not present"));
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;           
    }        
    ICF_SSA_INIT_TRANS_ADDR(&self_addr)

    div_counter = p_div_info->no_of_hops;

    p_div_data = p_div_info->p_diversion_data;

    /*If per line self transport then copy address from line_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE == 
        p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                        sizeof(icf_transport_address_st));
    }
    else
    {
        icf_port_memcpy(&self_addr, 
                        &(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                        sizeof(icf_transport_address_st));
    }
    
    while ((ICF_NULL != p_div_data) && (ICF_SUCCESS == ret_val))
    {
        /* copy the display name */
        icf_port_strcpy(addr_str, (icf_uint8_t *)"\0");
        /* Check if bitmask for diversion name is present */
        if (ICF_DIVERTERD_NAME_PRESENT == 
           (ICF_DIVERTERD_NAME_PRESENT & p_div_data->bitmask))
        {
            icf_port_strcat(addr_str,p_div_data->diverted_frm_name.str);
        }           

        if (ICF_ADDRESS_PLAN_E164 == p_div_data->diverted_frm_addr.addr_type)
        {
            icf_uint8_t      hostname[ICF_MAX_STR_LEN];
            
            icf_port_strcat(addr_str, (icf_uint8_t *)"<sip:");
            icf_port_strcat(
                    addr_str, p_div_data->diverted_frm_addr.addr_val.str);
            
            if ( ICF_FAILURE == 
                    icf_ssa_get_hostname_str_frm_trans_addr(p_ssa_pdb, 
                        &(self_addr),
                        hostname))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in address conversion"));
                ret_val = ICF_FAILURE; 
            }
            else
            {
                if ( ICF_NULL != icf_port_strcmp(hostname,(icf_uint8_t *) "0.0.0.0"))
                {
                    icf_port_strcat(addr_str, (icf_uint8_t *)"@");
                    icf_port_strcat(addr_str, hostname);
                    port_num = self_addr.port_num;
                    icf_port_strcpy(scheme, (icf_uint8_t *)"sip");
                }
                else
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Self IP not configured"));
                    ret_val = ICF_FAILURE; 
                }
            }
        }/*E164 handling ends*/
        else if (ICF_ADDRESS_PLAN_SIP_URI == 
                p_div_data->diverted_frm_addr.addr_type)
        {
            icf_uint8_t      *p_temp= ICF_NULL, 
                                host_name[ICF_MAX_STR_LEN] = "\0",
                                str[ICF_MAX_STR_LEN] = "\0",
                                user_name[ICF_MAX_STR_LEN] = "\0";

            icf_port_strcat(addr_str, (icf_uint8_t *)"<sip:");
            icf_port_strcpy(str, p_div_data->diverted_frm_addr.addr_val.str);
            p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)str,"@");
            if(ICF_NULL != p_temp)
            {
                icf_port_strcpy(user_name, p_temp);
                p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)0,":");
                if ( ICF_NULL == p_temp)
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:InvalidDivertedFromAddress"));
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    icf_port_strcpy(host_name, p_temp);
                        p_temp = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)0,":");
                    if (ICF_NULL != p_temp)
                    {
                        port_num = (icf_uint16_t)icf_port_atoi((const icf_int8_t *)p_temp);
                    }
                    icf_port_strcat(addr_str, user_name);
                    icf_port_strcat(addr_str, (icf_uint8_t *)"@");
                    icf_port_strcat(addr_str, host_name);
                    icf_port_strcpy(scheme, (icf_uint8_t *)"sip");
                    }
            }
            else
            {
                ret_val = ICF_FAILURE;
            }
        }
        else if (ICF_ADDRESS_PLAN_TEL_URI == 
                p_div_data->diverted_frm_addr.addr_type)
        {
            icf_port_strcat(addr_str, (icf_uint8_t *)"<tel:");
            icf_port_strcat(
                    addr_str, p_div_data->diverted_frm_addr.addr_val.str);
            icf_port_strcpy(scheme, (icf_uint8_t *)"tel");
            port_num = 0;
        }
        else
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Invalid Address type for DiversionInfo"));
            return ICF_FAILURE;
        }

        /*Data from IPPHONE DB collated, now we fill the SIP UATK
         * constructs*/
        if ( ICF_FAILURE != ret_val)
        {
            if(SipFail == 
                    sip_initSipHeader(
                        &p_sip_header, SipHdrTypeUnknown, &sip_error))
            {
                sip_freeSipHeader(p_sip_header);
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failed to init unknown Sip header"));
                return ICF_FAILURE;
            }
            else if (ICF_NULL == p_sip_header)
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failed to init unknown Sip header"));
                return ICF_FAILURE;
            }
            else
            {
                icf_uint8_t      size;
                p_unknown_header = (SipUnknownHeader*)(p_sip_header->pHeader);
                /*Get the memory for "Diversion" string.
                 * This will be assigned to the pName pointer
                 * in the Unknown header body.  The memory will
                 * be freed when the header is freed on invocationof
                 * freeSipHeader API*/
#ifdef ICF_WITH_MUATK_2_2
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        10,/*size of "Diversion" +1 */
                        ICF_MEM_COMMON,
                        p_unknown_header->pStr1,
                        ICF_DONOT_RET_ON_FAILURE,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                /*klocwork warning removal*/
                ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                  p_unknown_header->pStr1)
#else
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        10,/*size of "Diversion" +1 */
                        ICF_MEM_COMMON,
                        (icf_void_t *)
                        p_unknown_header->pName,
                        ICF_DONOT_RET_ON_FAILURE,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                /*klocwork warning removal*/
                ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                  p_unknown_header->pName)
#endif
                if ( ICF_FAILURE == ret_val)
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Memget failure for Diversion"));
                    sip_freeSipHeader(p_sip_header);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_sip_header,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    icf_uint8_t  counter_str[4] = "\0";

                    /* SPR 19121: Populate the counter string first and calculate the
                     * size of diversion header string using the lenght of counter_str
                     */
                    icf_port_sprintf((icf_int8_t *)counter_str,"%d",div_counter);

                    icf_port_strcat(addr_str, (icf_uint8_t *)">");
#ifdef ICF_WITH_MUATK_2_2
                    icf_port_strcpy( (icf_uint8_t *)p_unknown_header->pStr1,(icf_uint8_t *)"Diversion");
#else
                    icf_port_strcpy( p_unknown_header->pName,"Diversion");
#endif

                    /* SPR 19121 : The magic number 13 was used with the assumption that
                     * the hop counter will be of single digit. Since there is no such
                     * restriction, therfore strlen of counter_str is used to caluculate
                     * the size of diversion header value.
                     */ 
                    size = (icf_uint8_t)(icf_port_strlen(addr_str) + 
                           icf_port_strlen(counter_str) +
                           12)/* ";counter:<1spce><2bytes>,1byte for newline*/;
                    if ( ICF_MAX_STR_LEN < size)
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:max diversion str size exceeded!!"));
                        sip_freeSipHeader(p_sip_header);
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_sip_header,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                        ret_val = ICF_FAILURE;
                    }
                    else
                    {
#ifdef ICF_WITH_MUATK_2_2
                        ICF_MEMGET(p_ssa_pdb->p_glb_pdb,size,
                                ICF_MEM_COMMON,
                                p_unknown_header->pStr2,
                                ICF_DONOT_RET_ON_FAILURE,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                       /*klocwork warning removal*/
                       ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                    p_unknown_header->pStr2);
#else
                        ICF_MEMGET(p_ssa_pdb->p_glb_pdb,size,
                                ICF_MEM_COMMON,
                                (icf_void_t *)(p_unknown_header->pBody),
                                ICF_DONOT_RET_ON_FAILURE,
                                p_ssa_pdb->p_ecode,
                                ret_val)
#endif
                        if ( ICF_FAILURE == ret_val)
                        {
                            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Memget failure for Diversion"));
                            sip_freeSipHeader(p_sip_header);
                            ICF_MEMFREE(
                                    p_ssa_pdb->p_glb_pdb,
                                    p_sip_header,
                                    ICF_MEM_COMMON,
                                    p_ssa_pdb->p_ecode,
                                    ret_val)
                            ret_val = ICF_FAILURE;
                        }
                        else
                        {
                            SIP_U32bit  hdr_index = 0;

#ifdef ICF_WITH_MUATK_2_2
                            icf_port_memset(
                                    (icf_void_t *)(p_unknown_header->pStr2),
                                    0, size);
                            
                            icf_port_strcat((icf_uint8_t *)p_unknown_header->pStr2,
                                    (icf_uint8_t *)addr_str);
                            icf_port_strcat((icf_uint8_t *)p_unknown_header->pStr2,
                                    (icf_uint8_t *)";counter=");
                            icf_port_strcat((icf_uint8_t *)p_unknown_header->pStr2,
                                    (icf_uint8_t *)counter_str);
                            p_unknown_header->pStr2[size-1]='\n';
#else
                            icf_port_memset(
                                    (icf_void_t *)(p_unknown_header->pBody),
                                    0, size);
                            
                            icf_port_strcat(p_unknown_header->pBody,
                                    addr_str);
                            icf_port_strcat(p_unknown_header->pBody,
                                    ";counter=");
                            icf_port_strcat(p_unknown_header->pBody,
                                    counter_str);
                            p_unknown_header->pBody[size-1]='\n';
#endif                
                            sip_getHeaderCount(
                                        p_otg_sip_msg,
                                        SipHdrTypeUnknown,
                                        &hdr_index,&sip_error);
                            
                            if (SipFail == sip_insertHeaderAtIndex(
                                        p_otg_sip_msg,p_sip_header,
                                        hdr_index,&sip_error))
                            {
                                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure Diversion Header List Append"));
                                sip_freeSipHeader(p_sip_header);
                                ICF_MEMFREE(
                                        p_ssa_pdb->p_glb_pdb,
                                        p_sip_header,
                                        ICF_MEM_COMMON,
                                        p_ssa_pdb->p_ecode,
                                        ret_val)
                                ret_val = ICF_FAILURE;
                            }
                            else
                            {
                                sip_freeSipHeader(p_sip_header);
                                ICF_MEMFREE(
                                        p_ssa_pdb->p_glb_pdb,
                                        p_sip_header,
                                        ICF_MEM_COMMON,
                                        p_ssa_pdb->p_ecode,
                                        ret_val)
                            }
                        }
                    }/*memget for unknown jdr body successful*/
                }
            }/*Instance of Unknown Header Init successfully*/
        }
        p_div_data = p_div_data->p_next;
        div_counter--;
    }/*loop for the different Diversion Data instances*/
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_populate_address_from_sip_addr_spec
 ** DESCRIPTION:  This function populates the icf_address_st structure
 **               from the SipAddrSpec structure passed to it
 **               
 **
 ***************************************************************************/
icf_return_t icf_ssa_populate_address_from_sip_addr_spec(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT SipAddrSpec            *p_sip_addr_spec,
        INOUT  icf_address_st   *p_addr)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    SipError                            sip_error;
    icf_uint16_t                     addr_val_len = 0;    
    Sdf_ty_s8bit                     dHexConvertedName1[Sdf_co_smallBufferSize] = {'\0'};
    /* Rel 8.2 Klocworks fix end */ 
    icf_string_st                    temp_str = {0,"\0"};

    /* Fix for CSR 1-6967056 */
    /* Address spec may exceed 128 bytes. So generate this in a local string &
     * then copy 128 bytes from local string into p_addr.
     */
    icf_uint8_t    addr_str[ICF_SIP_MAX_HEADER_VALUE_LEN] = "\0";

    /* Rel 8.2 Klocworks fix end */
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb);
/* Patch taken for BUG-947 CERT */    
  	if(ICF_NULL == p_sip_addr_spec)
	{
		ret_val = ICF_FAILURE;
    	ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
	    return ret_val;
	}
    icf_port_strcpy(p_addr->addr_val.str,(icf_uint8_t *)"");

    if ((p_sip_addr_spec->dType == SipAddrSipUri) || \
        (p_sip_addr_spec->dType == SipAddrSipSUri))
    /* Address is a SIP Uri, so more dissection */
    {
        SipUrl *pSipUrl = p_sip_addr_spec->u.pSipUrl;

        if (p_sip_addr_spec->dType == SipAddrSipUri)
        {
            /* Populate the addr type */
            p_addr->addr_type = 
                ICF_ADDRESS_PLAN_SIP_URI ;
        }
        else
        {

                      if(ICF_NULL == p_ssa_pdb->p_glb_cfg_data->p_tls_init_data)
                       {
                             p_ssa_pdb->p_ssa_ctxt->failure_bitmask |=
                                    ICF_SSA_FAILURE_RESP_CODE_416;
                             ret_val = ICF_FAILURE;
                       }
                       else    
                       {
                /* Populate the addr type */
                p_addr->addr_type = 
                    ICF_ADDRESS_PLAN_SIPS_URI ;
               }
        }
                              
		/* ARICENT_BLR fix for CERT bug 945 to avoid overflow in strcat  -start */
		if(ICF_NULL != pSipUrl->pUser)
                	addr_val_len = (icf_uint16_t)(addr_val_len + icf_port_strlen((icf_uint8_t *)pSipUrl->pUser) +1);
		if(SIP_NULL != pSipUrl->pPassword)
			addr_val_len = (icf_uint16_t)(addr_val_len + icf_port_strlen((icf_uint8_t *)pSipUrl->pPassword) +1);
		if(ICF_NULL != pSipUrl->pHost)
			addr_val_len  = (icf_uint16_t)(addr_val_len + icf_port_strlen((icf_uint8_t *)pSipUrl->pHost));
		if(SIP_NULL != pSipUrl->dPort)
			addr_val_len += 7;
                if (ICF_FALSE == p_ssa_pdb->addr_param_not_reqd)
                 {
                     if(SIP_NULL != pSipUrl->pHeader)
                         addr_val_len = (icf_uint16_t )(addr_val_len + icf_port_strlen((icf_uint8_t *)pSipUrl->pHeader) +1);
                 } 





        if(addr_val_len >= ICF_SIP_MAX_HEADER_VALUE_LEN)
      	{
                p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= ICF_SSA_FAILURE_RESP_CODE_414;
   	        ret_val = ICF_FAILURE;
           	ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
           	return ret_val;
       	}
		else
		{
			
			/* 
			 * Check if the parameters present in the URL do not cause the length to 
			 * exceed.
			 */
			SIP_U32bit	listIter = 0;
			SIP_U32bit	listSize = 0;

			(void)sip_listSizeOf(&pSipUrl->slParam, &listSize, &sip_error);
			listIter = 0;
			while (listIter < listSize)
			{
				SipParam		*pParam;
				SIP_U32bit		valueSize;
				SIP_S8bit		*value;
				SIP_U32bit		valueIter=0;

				(void)sip_listGetAt(&pSipUrl->slParam, listIter, (SIP_Pvoid *)&pParam, &sip_error);
				if (listIter!=0)
					addr_val_len += 1;
		
				addr_val_len = (icf_uint16_t)(addr_val_len + icf_port_strlen((icf_uint8_t *)pParam->pName));
				sip_listSizeOf( &(pParam->slValue), &valueSize, &sip_error);

				if (valueSize >= 1)
				{
					(void)sip_listGetAt(&(pParam->slValue), valueIter, \
					(SIP_Pvoid *) &value, &sip_error);
					if (value != SIP_NULL)
					{
						addr_val_len += 1;
						while (valueIter < valueSize)
						{
							if (valueIter > 0)
								addr_val_len += 1;
							(void)sip_listGetAt(&(pParam->slValue), valueIter, \
							(SIP_Pvoid *) &value, &sip_error);
							addr_val_len = (icf_uint16_t)(addr_val_len + icf_port_strlen((icf_uint8_t *)value));
							valueIter++;
						}
					}
				}
				listIter++;
		        if(addr_val_len >= ICF_SIP_MAX_HEADER_VALUE_LEN)
		      	{
		   	        p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= ICF_SSA_FAILURE_RESP_CODE_414;  
                                ret_val = ICF_FAILURE;
		           	ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
		           	return ret_val;
		       	}
			} /* while */
		} /* else */
        /* ARICENT_BLR fix for CERT bug 945 -end */

        if( ICF_NULL != pSipUrl->pUser)
        {
             /* SPR 19805 :Check added for the return value of  sdf_fn_uaConvertHexEncodedString 
             *  after merging UATK CSR:1-7574892 
             */ 
            if (Sdf_co_fail == sdf_fn_uaConvertHexEncodedString(pSipUrl->pUser, dHexConvertedName1,\
                   Sdf_co_smallBufferSize))
            {
                p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= ICF_SSA_FAILURE_RESP_CODE_400;
                ret_val = ICF_FAILURE;
                ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                return ret_val;
            }

            icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)addr_str,
                (icf_uint8_t *)dHexConvertedName1);

            if (pSipUrl->pPassword != SIP_NULL)
            {
                icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)addr_str,
                        (icf_uint8_t *)(SIP_S8bit*)":");
                icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)addr_str,
                        (icf_uint8_t *)pSipUrl->pPassword);
            }

            icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)addr_str,
                    (icf_uint8_t *)(SIP_S8bit*)"@");
        }

        if (pSipUrl->pHost) icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)addr_str,
                (icf_uint8_t *)pSipUrl->pHost);

        /* see if its pHost or pHost:dPort */
        if (pSipUrl->dPort != SIP_NULL)
        {
            SIP_S8bit porttext[6]={0}; /* max val of dPort = 65535 */
            porttext[0]='\0';
            icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)addr_str,
                    (icf_uint8_t *)(SIP_S8bit*)":");
            sip_snprintf((SIP_S8bit *)porttext, 6, "%u", *(pSipUrl->dPort) );
            porttext[5]='\0';
            icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)addr_str,(icf_uint8_t *)porttext);
        }

        /*FormSipParam list into local string and then covert any hex character 
         *in it first then append to p_addr*/
        sip_formSipParamList(
                /* SPR 19218 : UATK CSR_1-6613911 Change Start */SIP_NULL,
                /* SPR 19218 : UATK CSR_1-6613911 Change End */
                (SIP_S8bit *)temp_str.str, &(pSipUrl->slParam), \
                (SIP_S8bit *)";",1, &sip_error);
        (void)sdf_fn_uaConvertHexEncodedString((Sdf_ty_s8bit*)temp_str.str, dHexConvertedName1,\
                   Sdf_co_smallBufferSize);
        icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)addr_str,
                         (icf_uint8_t *)dHexConvertedName1);
        temp_str.str[0] = '\0';

       if (ICF_FALSE == p_ssa_pdb->addr_param_not_reqd)
        {
            /* Now parse Header */
            if (pSipUrl->pHeader !=SIP_NULL)
            {
                icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)addr_str,
                        (icf_uint8_t *)(SIP_S8bit*)"?");

                /*Copy address parameters after coverting any hex character present in the string*/
                icf_port_strcpy(temp_str.str, (icf_uint8_t *)pSipUrl->pHeader);

                (void)sdf_fn_uaConvertHexEncodedString((Sdf_ty_s8bit*)temp_str.str, dHexConvertedName1,\
                   Sdf_co_smallBufferSize);

                icf_port_strcat((icf_uint8_t *)(SIP_S8bit *)addr_str,
                         (icf_uint8_t *)dHexConvertedName1);
            }
        }
        p_ssa_pdb->addr_param_not_reqd = ICF_FALSE;
       
    } /*End of if (ch->pAddrSpec->dType == SipAddrSipUri/SipAddrSipSUri) */
    else
    {
        /* Check whether addr type is TEL */
        if(SipFail != sip_isTelUrl(
                    p_sip_addr_spec,&sip_error))
        {
            icf_uint8_t *p_tel_uri =
                            (icf_uint8_t *)(p_sip_addr_spec->u.pUri+icf_port_strlen((icf_uint8_t *)"tel:"));
        
            /* Populate the addr type */
            p_addr->addr_type = 
                ICF_ADDRESS_PLAN_TEL_URI;

            /* Fix for CSR 1-7436288 : SPR-19778*/

            /*Length of the tel-uri received + 1 character for '\0'*/
            addr_val_len = (icf_uint16_t )(1 + icf_port_strlen(p_tel_uri));

            /* Check if the address length is greater than ICF_MAX_STR_LEN
             * send 414 response code to peer.
             */  
            if(addr_val_len >= ICF_MAX_STR_LEN)
            {
                p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= ICF_SSA_FAILURE_RESP_CODE_414;
                ret_val = ICF_FAILURE;
                ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                return ret_val;
            }
            /* Copy the entire URI after tel:*/
            icf_port_strcpy(
                addr_str,p_tel_uri);
        }
        else
        {
            /*Address Type cannot be identified here */
            /* Populate the addr type */
            p_addr->addr_type = 
                ICF_ADDRESS_PLAN_UNDEFINED;
            /* Copy the entire URI */
            
            /*CERT Fix for SPR : 18429*/ 
            /*String Copy should not exceed ICF_MAX_STR_LEN value, so strcpy
             * is replaced with strncpy. This will take care of scenario in which 
             * we receive INVITE from remote with from header having string value 
             * greater than ICF_MAX_STR_LEN(128 bytes).*/
            icf_port_strncpy(
                    (icf_int8_t *)addr_str,
                    (const icf_int8_t *)p_sip_addr_spec->u.pUri,(ICF_SIP_MAX_HEADER_VALUE_LEN -1));
            addr_str[ICF_SIP_MAX_HEADER_VALUE_LEN - 1] = '\0';
        }
    }

     icf_port_strncpy((icf_int8_t*)p_addr->addr_val.str, (const icf_int8_t *)addr_str, ICF_MAX_STR_LEN - 2);
     p_addr->addr_val.str[ICF_MAX_STR_LEN - 1] = '\0';
     p_addr->addr_val.str_len =
                (icf_uint16_t )icf_port_strlen(
                p_addr->addr_val.str);

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_form_and_insert_ref_by_hdr
 ** DESCRIPTION:  This function forms and inserts a referred by header 
 **               in the SipMsg passed to it
 **
 ***************************************************************************/

icf_return_t icf_ssa_form_and_insert_ref_by_hdr(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  SipMessage          *p_sip_msg)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_address_st           *p_icf_address = ICF_NULL;
    icf_uint8_t              ref_by_addr_str[ICF_MAX_STR_LEN];
    icf_config_data_st       *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    icf_call_ctx_st          *p_call_ctxt = 
                                    p_ssa_pdb->p_glb_pdb->p_call_ctx;
    icf_transport_address_st    *p_icf_trans_addr = ICF_NULL;

    Sdf_ty_u16bit               port_num_to_be_set = 0;
    SipHeader                   *p_referred_by_hdr = SIP_NULL;
    SipError                    sip_error;
    Sdf_ty_s8bit                tpt_scheme[ICF_MAX_STR_LEN];
    SipAddrSpec                 *p_addr_spec = SIP_NULL;
    Sdf_st_error                sdf_error;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Get the pointer to referred by party addr */
    p_icf_address = p_call_ctxt->p_referred_party_addr;
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
            (ICF_NULL != p_icf_address))

    icf_port_strcpy(ref_by_addr_str,
            p_call_ctxt->p_referred_party_addr->addr_val.str);

    if ( (ICF_ADDRESS_PLAN_SIP_URI == 
                p_icf_address->addr_type) ||
            (ICF_ADDRESS_PLAN_E164 ==
             p_icf_address->addr_type))
    {
        icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"sip");
    }
    else if (ICF_ADDRESS_PLAN_TEL_URI == 
            p_icf_address->addr_type)
    {
        icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"tel");
    }

    /*
     * If referred by party addr_type is E164,
     * append the self ip adress 
     * to make it a SIP URI
     */
    if ( ICF_ADDRESS_PLAN_E164 == p_icf_address->addr_type)
    {
       /*If per line self transport then copy address from line_data*/
       if (ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
       {
           p_icf_trans_addr = &(p_ssa_pdb->p_line_data->self_addr);
       }
       else
       {    
           p_icf_trans_addr = &(p_glb_cfg_data->self_ip_address);
       }
        if ( ICF_FAILURE == 
                icf_ssa_form_sip_uri_frm_e164(
                    p_ssa_pdb, ref_by_addr_str, 
                    p_icf_trans_addr,&port_num_to_be_set))
        {
            ret_val = ICF_FAILURE;
        }
    }/*Formation of SIP URI from E164 ends here*/

    /* Set reffered by header */
    if (Sdf_co_fail == sdf_ivk_uaMakeAddrSpecFromConstituents(
                &p_addr_spec,
                (Sdf_ty_s8bit *)ref_by_addr_str,
                port_num_to_be_set,
                (Sdf_ty_s8bit *)tpt_scheme,
                &sdf_error))
    {
        /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
    else if(SipFail == sip_initSipHeader(
                (SipHeader**)(&p_referred_by_hdr),
                SipHdrTypeReferredBy,\
                (SipError*)(&sip_error)))
    {
        /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
    else if ( SipFail == sip_setReferrerInReferredByHdr(
                p_referred_by_hdr,
                p_addr_spec, (SipError *)(&sip_error)))
    {
        /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
    /*
     * As there is no bitmask to identify the presence of
     * refered by party name,we are checking whether
     * the pointer is NULL
     */
    if ( (ICF_FAILURE != ret_val) &&
            (ICF_NULL != p_call_ctxt->p_referred_party_name))
    {
        if (SipFail == sip_setDispNameInReferredByHdr(
                    p_referred_by_hdr,
                    Sdf_mc_strdupCT((const icf_int8_t *)p_call_ctxt->p_referred_party_name->str),
                    (SipError *)(&sip_error)))
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
            /*we are not freeing the header here as that is done
             * while exiting this routine. So no direct return calls
             * are to be added in this code.*/
        }
    }
    /*This Free is to be hit whether some opeartion above succeeded
     * or failed*/
    if (SipFail == sip_insertHeaderAtIndex(
                p_sip_msg,p_referred_by_hdr,
                0,&sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure Referred By Header List Append"));
        ret_val = ICF_FAILURE;
    }
    /* Now free the header and the addr spec memory */
    sip_freeSipAddrSpec(p_addr_spec);
    /*
     * The SipHeader structure contains 2 fields,one being the
     * type of header and second being a void pointer
     * The call to sip_freeSipHeader fress the memory corresponding
     * to the specific header according to the type but
     * doesn't free the top level structure.
     * Hence,invoke a memfree on the top level structure
     */
    if (SIP_NULL != p_referred_by_hdr)
    {
        sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_referred_by_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_form_and_insert_replaces_hdr
 * DESCRIPTION:  This function forms and inserts a Replaces header 
 *               in the SipMsg passed to it
 *               1. Invoke the sdf_ivk_uaFormReplacesHeader header
 *               with replaces callid,from tag and to tag stored in 
 *               call context.
 *               2. Insert the header into the SIP message
 ***************************************************************************/

icf_return_t icf_ssa_form_and_insert_replaces_hdr(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  SipMessage          *p_sip_msg)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_return_t             dummy_ret_val = ICF_SUCCESS;
    icf_call_ctx_st          *p_call_ctxt = 
                                     p_ssa_pdb->p_glb_pdb->p_call_ctx;

    SipHeader                   *p_replaces_hdr = SIP_NULL;
    SipError                    sip_error;
    Sdf_st_error                sdf_error;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
            (ICF_NULL != p_call_ctxt->p_replaces_header))

    /*
     * Invoke sdf_ivk_uaFormReplacesHeader with
     * call object pointer as NULL as we want to form
     * the Replaces header with the call id ,from tag and
     * to tag stored in the call context
     */
    if (Sdf_co_fail ==sdf_ivk_uaFormReplacesHeader (
                Sdf_co_null,
                Sdf_mc_strdupSdp(
                 (const icf_int8_t *)p_call_ctxt->p_replaces_header->replace_nw_call_id.nw_call_id),
                Sdf_mc_strdupSdp(
            (const icf_int8_t *)p_call_ctxt->p_replaces_header->to_tag.str),
                Sdf_mc_strdupSdp(
                        (const icf_int8_t *)p_call_ctxt->p_replaces_header->from_tag.str),
                &p_replaces_hdr,
                &sdf_error))
    {
        /*Set/RaiseError:UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == sip_insertHeaderAtIndex(
                p_sip_msg,p_replaces_hdr,
                0,&sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure Replaces header Header List Append"));
        ret_val = ICF_FAILURE;
    }
    /*
     * The SipHeader structure contains 2 fields,one being the
     * type of header and second being a void pointer
     * The call to sip_freeSipHeader fress the memory corresponding
     * to the specific header according to the type but
     * doesn't free the top level structure.
     * Hence,invoke a memfree on the top level structure
     */
        sip_freeSipHeader(p_replaces_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_replaces_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_form_and_send_response
 * DESCRIPTION:  This function forms and sends a response to peer
 *               1. The response code is passes as a paramter   
 *               2. If p_overlap_txn is not null, the response is made
 *               on the overlap transaction,else on the UAS transaction
 *               3.Invoke icf_ssa_send_to_peer
 ***************************************************************************/

icf_return_t icf_ssa_form_and_send_response(
        INOUT  icf_ssa_pdb_st         *p_ssa_pdb,
        INOUT    icf_uint16_t           resp_code,
        INOUT  Sdf_st_callObject         *p_call_obj,
        INOUT  Sdf_st_overlapTransInfo   *p_overlap_txn,
        INOUT    Sdf_ty_s8bit              *p_method,
        INOUT    Sdf_ty_bool               rel_resp)
{
    Sdf_st_error            sdf_error;
    SipOptions                dOptions ;
    SipMessage              *p_sip_msg = Sdf_co_null;

    icf_return_t         ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (Sdf_co_fail == sdf_ivk_uaFormResponse(
                resp_code,p_method,p_call_obj,p_overlap_txn,
                rel_resp, &sdf_error))
    {
        ret_val = ICF_FAILURE ;
    }
    else
    {
        if (Sdf_co_null == p_overlap_txn)
        {
            p_sip_msg = p_call_obj->pUasTransaction->pSipMsg;
        } /* if (Sdf_co_null == p_overlap_t... */
        else
        {
            p_sip_msg = p_overlap_txn->pSipMsg;
        }
        /* 
         * Specify the stack options
         * SIP_OPT_CLEN : A Content-Length header with the 
         * correct length is inserted in the message being
         * formed.
         * SIP_OPT_FULLFORM : All header names will appear
         * in full.
         */
        dOptions.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;
        /* 
         * This API is used to send a message to the 
         * peer entity
         */

       /*To add the P-Access-Network Info header to the 
          responses within dialog*/
       /*Check for sic context is added so that response for 
         notify for subscribe should also consists of hdr*/
 
       if((ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx)
              || (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt))
       { 
           if ( ICF_FAILURE == 
                icf_ssa_form_and_insert_access_nw_info_hdr(
                p_ssa_pdb,p_sip_msg))
           {
               ret_val = ICF_FAILURE ;
           }
       }

     if (ICF_FAILURE == icf_ssa_form_and_insert_unknown_hdr(
                    p_ssa_pdb,(icf_uint8_t *)"User-Agent",
                    p_ssa_pdb->p_ssa_glb_data->user_agent_str.str,
                    p_sip_msg))
        {
            ret_val = ICF_FAILURE ;
        }
        else if (ICF_FAILURE == icf_ssa_send_to_peer(p_ssa_pdb,
                    p_call_obj,
                    p_sip_msg,&dOptions,&sdf_error))
        {
            ret_val = ICF_FAILURE ;
        }
#ifdef ICF_STAT_ENABLE        
        /* Async NOTIFY Support */
        else
        {
            /* Increment responses sent for the method received as an
               argument to this function.
            */   
            icf_ssa_resp_stats(p_ssa_pdb,(icf_uint8_t *)p_method,resp_code,1);
        }
#endif

         /* If Notify received was out of dialog then reset the bitmask in ssa ctxt
         * and invoke API for freeing call object.
         */  
        if (p_ssa_pdb->p_ssa_ctxt->bitmask_1 & ICF_MSG_RECVD_OUT_OF_DIALOG)
        {
           /*dRefCount will be one when out-of-dialog message is received and
            *transport is TCP/TLS in this case set common_bitmask as TRACE_REQUIRED
            *and call object already freed. This is required because FreeCallObject will
            *free call object in this case and these bitmask will prevent its use after
            *returning of this function to avoid free memory read*/
#ifdef SDF_THREAD_SAFE
           if (1 == p_call_obj->dRefCount.ref)
#else           
           if (1 == p_call_obj->dRefCount)
#endif
           {
               ICF_SSA_SET_COMMON_BITMASK(
                    p_ssa_pdb->common_bitmask,
                    ICF_SSA_TRACE_REQUIRED)
               ICF_SSA_SET_COMMON_BITMASK(
                    p_ssa_pdb->common_bitmask,
                    ICF_SSA_CALL_OBJ_ALREADY_FREED)
           }
           p_ssa_pdb->p_ssa_ctxt->bitmask_1 &= ~(ICF_MSG_RECVD_OUT_OF_DIALOG);
           sdf_ivk_uaFreeCallObject(&p_call_obj); 
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
       
/*****************************************************************************
 ** FUNCTION:        icf_ssa_formStatusLineMessage
 ** 
 ** DESCRIPTION:    This function forms SipResponseMessage only with StatusLine
 **
 *****************************************************************************/
icf_return_t icf_ssa_formStatusLineMessage(
        INOUT  SipMessage    **p_p_sip_msg,
        INOUT    Sdf_ty_u16bit    resp_code,
        INOUT  Sdf_st_error    *pError)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    
    Sdf_ty_s8bit            *pReason=Sdf_co_null,*pTmpVal=Sdf_co_null;
    SipStatusLine            *pStatLine=Sdf_co_null;

    sdf_fn_uaGetReasonFromTable(resp_code, &pReason, pError);
    pTmpVal = Sdf_mc_strdupCallHandler("SIP/2.0");

    /*got from the global table */
    
    if (SipFail == sip_initSipMessage(
                p_p_sip_msg, SipMessageResponse,
                (SipError *)&(pError->stkErrCode)))
    {
        sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&pReason,pError);
        ret_val = ICF_FAILURE ;
    }
    /* Setting the Status Line */
    else if (SipFail == sip_initSipStatusLine(
                &pStatLine,(SipError *)&(pError->stkErrCode)))
    {
        sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&pReason,pError);
        sip_freeSipMessage(*p_p_sip_msg);
        ret_val = ICF_FAILURE ;
    }
    else if (SipFail == sip_setReasonInStatusLine(
                pStatLine, pReason,
                (SipError *)&(pError->stkErrCode)))
    {
        sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&pReason,pError);
        sip_freeSipMessage(*p_p_sip_msg);
        ret_val = ICF_FAILURE ;
    }    

    else if (SipFail == sip_setVersionInStatusLine(
                pStatLine, pTmpVal,
                (SipError *)&(pError->stkErrCode)))
    {
        sip_freeSipMessage(*p_p_sip_msg);
        ret_val = ICF_FAILURE ;
    }    
    else if (SipFail == sip_setStatusCodeNumInStatusLine(
                pStatLine,resp_code,
                (SipError *)&(pError->stkErrCode)))
    {
        sip_freeSipMessage(*p_p_sip_msg);
        ret_val = ICF_FAILURE ;
    }    
    else if (SipFail == sip_setStatusLineInSipRespMsg (
                *p_p_sip_msg, pStatLine,
                (SipError *)&(pError->stkErrCode)))
    {
        sip_freeSipMessage(*p_p_sip_msg);
        ret_val = ICF_FAILURE ;
    }    
    /* Free the Local Reference */
    sip_freeSipStatusLine(pStatLine);

    return ret_val ;
}

/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_validate_via
 * DESCRIPTION:  This function validates the via header value in an incoming 
 *               request.
 *               1.If the topmost Via header of the incoming request has the
 *                IP/port which is the same as the local IP,
 *                the message should be discarded. Else, this 
 *                user agent would end up sending a response to itself.
 ******************************************************************************/
Sdf_ty_messageValidity icf_ssa_validate_via(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  Sdf_st_callObject   *p_call_obj,
        OUT Sdf_st_error          *pErr)

{
    icf_return_t                     ret_val = ICF_SUCCESS;
    en_SipMessageType                   dReqRespType;
    Sdf_ty_s8bit                        pLocal[30]="\0";
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (SipFail == sip_getMessageType(p_call_obj->pUasTransaction->pSipMsg,
        &dReqRespType, (SipError*)&(pErr->stkErrCode)))
    {
        pErr->errCode=Sdf_en_headerManipulationError;
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return Sdf_en_failed;
    }

    if (dReqRespType == SipMessageRequest)
    {
        SipHeader dTempHeader;
        Sdf_ty_s8bit *pRemoteIp = Sdf_co_null, *pSentBy = Sdf_co_null;
        Sdf_ty_s8bit *pHostAddress = Sdf_co_null, *pHostPort = Sdf_co_null;
        Sdf_ty_s8bit *p_local_ip = Sdf_co_null;
        Sdf_ty_u16bit dPort;
        Sdf_ty_s8bit dTempSentby[Sdf_co_mediumBufferSize]={'\0'};

        /* 
         * If the topmost Via header of the incoming request has the IP/port 
         * set in this profile, the message should be discarded. Else, this 
         * user agent would end up sending a response to itself.
         */
        if (SipFail == sip_getHeaderAtIndex(
                    p_call_obj->pUasTransaction->pSipMsg, SipHdrTypeVia,
                    &dTempHeader, 0, (SipError*)&(pErr->stkErrCode)))
        {
            pErr->errCode=Sdf_en_headerManipulationError;
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return Sdf_en_failed;
        }

        if (SipFail == sip_getSentByFromViaHdr(
                        &dTempHeader, &pSentBy, (SipError*)&(pErr->stkErrCode)))
        {        
            sip_freeSipHeader(&dTempHeader);
            pErr->errCode=Sdf_en_headerManipulationError;
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return Sdf_en_failed;
        }    

        Sdf_mc_strcpy(dTempSentby, pSentBy);

        pHostAddress = Sdf_mc_strtokr(dTempSentby, ":",&pHostPort);

        if (Sdf_co_null == pHostAddress)
        {
            sip_freeSipHeader(&dTempHeader);
            pErr->errCode=Sdf_en_invalidParamError;
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return Sdf_en_failed;            
        }
        /* resolve the hostname into ip addr */
        if (Sdf_co_fail == 
                (sdf_fn_uaGetHostIp(pHostAddress, &pRemoteIp, pErr)))
        {
            sip_freeSipHeader(&dTempHeader);
            pErr->errCode=Sdf_en_invalidParamError;
            sdf_memfree(Sdf_mc_callHandlerMemId, 
                (Sdf_ty_pvoid*)&(pRemoteIp), pErr);
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return Sdf_en_failed;
        }

        /* resolve the local hostname into ip addr */
        if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
        {
            if (Sdf_co_fail == (sdf_fn_uaGetHostIp(
                (Sdf_ty_s8bit *)p_ssa_pdb->p_glb_cfg_data->self_ip_address.
                    addr.addr.domain.str, 
                &p_local_ip, 
                pErr)))
            {
                if (ICF_NULL != p_local_ip)
                {
                   sdf_memfree(Sdf_mc_callHandlerMemId, 
                    (Sdf_ty_pvoid*)&(p_local_ip),pErr);
                }
                sip_freeSipHeader(&dTempHeader);
                sdf_memfree(Sdf_mc_callHandlerMemId,
                              (Sdf_ty_pvoid*)&(pRemoteIp),pErr);
                pErr->errCode=Sdf_en_invalidParamError;
                ret_val = ICF_FAILURE;
                ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
                return Sdf_en_failed;
            }
            if (p_local_ip) icf_port_strcpy((icf_uint8_t *)pLocal, (icf_uint8_t *)p_local_ip);
            sdf_memfree(Sdf_mc_callHandlerMemId, 
                    (Sdf_ty_pvoid*)&(p_local_ip),pErr);
        }
        else 
        {
            icf_ssa_convert_to_IP_addr(
                    &(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                    (icf_uint8_t *)pLocal);
        }

        if (pHostPort != NULL)
            dPort = (icf_uint16_t)icf_port_atoi(pHostPort);
        else
            dPort = 5060;

        /* 
         * If the IP/port in the topmost Via header matches with that in the 
         * user profile's transport information, the message should be 
         * discarded 
         */
        if ( (Sdf_mc_strcmp(pRemoteIp, pLocal) == 0) && 
            (dPort == p_ssa_pdb->p_glb_cfg_data->self_ip_address.port_num) )
        {
            sip_freeSipHeader(&dTempHeader);
            sdf_memfree(Sdf_mc_callHandlerMemId, 
                (Sdf_ty_pvoid*)&(pRemoteIp), pErr);
            pErr->errCode=Sdf_en_invalidParamError;
            
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return Sdf_en_discarded;
        }

        /* Free the local reference */

        sip_freeSipHeader(&dTempHeader);
        sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(pRemoteIp),pErr);

    } /* if (dReqRespType == SipMessage... */

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return Sdf_en_valid;
}

/*******************************************************************************
 * FUNCTION:     icf_ssa_form_and_insert_priv_hdr
 * DESCRIPTION:  This function forms and inserts a privacy header into the SIP
 *               message .
 *               1. Currently we are only sending Privacy header with
 *               the value "id"
 ******************************************************************************/
icf_return_t icf_ssa_form_and_insert_priv_hdr(
        INOUT      icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT    SipMessage          *p_otg_sip_msg)
{
    icf_return_t                     ret_val = ICF_SUCCESS;

    SipHeader  *p_sip_header = SIP_NULL;
    SipUnknownHeader  *p_unknown_header = SIP_NULL;
    SipError        sip_error;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if(SipFail == 
            sip_initSipHeader(
                &p_sip_header, SipHdrTypeUnknown, &sip_error))
    {
        sip_freeSipHeader(p_sip_header);
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failed to init unknown Sip header"));
        return ICF_FAILURE;
    }
    else if (ICF_NULL == p_sip_header)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failed to init unknown Sip header"));
        return ICF_FAILURE;
    }
    else
    {
        icf_uint8_t      size;
        p_unknown_header = (SipUnknownHeader*)(p_sip_header->pHeader);
        /*
         * Get the memory for "Privacy" string.
         * This will be assigned to the pName pointer
         * in the Unknown header body.  The memory will
         * be freed when the header is freed on invocationof
         * freeSipHeader API
         */
#ifdef ICF_WITH_MUATK_2_2
        ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                8,/*size of "Privacy" +1 */
                ICF_MEM_COMMON,
                p_unknown_header->pStr1,
                ICF_DONOT_RET_ON_FAILURE,
                p_ssa_pdb->p_ecode,
                ret_val)
        /*Klocwork Warning Removal*/
        ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                   (p_unknown_header->pStr1))
#else
        ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                8,/*size of "Privacy" +1 */
                ICF_MEM_COMMON,
                (icf_void_t *)
                p_unknown_header->pName,
                ICF_DONOT_RET_ON_FAILURE,
                p_ssa_pdb->p_ecode,
                ret_val)
#endif
        if ( ICF_FAILURE == ret_val)
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Memget failure for Privacy"));
            sip_freeSipHeader(p_sip_header);
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_sip_header,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            ret_val = ICF_FAILURE;
        }
        else
        {
            size = 3;/* 2 bytes for id parameter and 1 newline */ 
#ifdef ICF_WITH_MUATK_2_2
            icf_port_strcpy( (icf_uint8_t *)p_unknown_header->pStr1,(icf_uint8_t *)"Privacy");
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb,size,
                    ICF_MEM_COMMON,
                    p_unknown_header->pStr2,
                    ICF_DONOT_RET_ON_FAILURE,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            /*Klocwork Warning Removal*/
            ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                       (p_unknown_header->pStr2))
#else
            icf_port_strcpy( p_unknown_header->pName,"Privacy");
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb,size,
                    ICF_MEM_COMMON,
                    (icf_void_t *)(p_unknown_header->pBody),
                    ICF_DONOT_RET_ON_FAILURE,
                    p_ssa_pdb->p_ecode,
                    ret_val)
#endif
            if ( ICF_FAILURE == ret_val)
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Memget failure for privacy hdr body"));
                sip_freeSipHeader(p_sip_header);
                ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_sip_header,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                ret_val = ICF_FAILURE;
            }
            else
            {
                SIP_U32bit  hdr_index = 0;
#ifdef ICF_WITH_MUATK_2_2
                icf_port_memset(
                        (icf_void_t *)(p_unknown_header->pStr2),
                        0, size);
                icf_port_strcat((icf_uint8_t *)p_unknown_header->pStr2,
                        (icf_uint8_t *)"id");
#else
                icf_port_memset(
                        (icf_void_t *)(p_unknown_header->pBody),
                        0, size);
                icf_port_strcat(p_unknown_header->pBody,
                        "id");
#endif
                sip_getHeaderCount(
                        p_otg_sip_msg,
                        SipHdrTypeUnknown,
                        &hdr_index,&sip_error);
                if (SipFail == sip_insertHeaderAtIndex(
                            p_otg_sip_msg,p_sip_header,
                            hdr_index,&sip_error))
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure Privacy Hdr List Append"));
                    ret_val = ICF_FAILURE;
                }
                sip_freeSipHeader(p_sip_header);
                ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_sip_header,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
             }
        }
    }/*Instance of Unknown Header Init successfully*/
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_parse_privacy_header
 ** DESCRIPTION:  This function iterates through all the unknown headers
 **               If it doesn't find privacy header,it returns
 **               failure.
 **               Otherwise,if the privacy hdr is present,SSA
 **               will parse it like an unknown header.If privacy header
 **               contains the value "id",then return SUCCESS.
 **               In all other cases failure is returned.In case UATK failure
 **               occurs,ecode is set as ICF_ERROR_UATK_FAILURE
 **
 ***************************************************************************/

icf_return_t icf_ssa_parse_privacy_header(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  Sdf_st_callObject   *p_call_obj)

{
    icf_return_t         ret_val = ICF_FAILURE;

    Sdf_ty_u32bit           iterator=0,count=0;
    SipError                err;
    SipHeader               dHeader;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* get the unknown header count */
    if(SipFail == sip_getHeaderCount(
                p_call_obj->pUasTransaction->pSipMsg,
                SipHdrTypeUnknown,&count,
                &err))
    {
        *(p_ssa_pdb->p_ecode) = ICF_ERROR_UATK_FAILURE ;
        ret_val = ICF_FAILURE ;
    }
    /* Iterate through all the unknown headers*/
    for(iterator=0 ; iterator<count ; iterator++)
    {
        SIP_S8bit           *pUnkHdrName = SIP_NULL,
                            *pBuffer = SIP_NULL ;

        if(SipFail == sip_getHeaderAtIndex(
                    p_call_obj->pUasTransaction->pSipMsg,
                    SipHdrTypeUnknown, &dHeader,
                    iterator,&err))
        {
            /*In this case we continue to try to fetch other unknown headers*/
            continue;
        }
        if(SipFail == sip_getNameFromUnknownHdr(
                    &dHeader,&pUnkHdrName,&err))
        {
            /*In this case we continue to try to fetch other unknown headers*/
            sip_freeSipHeader(&dHeader);
            continue;
        }
        /* Check for the P-Asserted-Identity header */
        if(0 == sip_strcasecmp(pUnkHdrName,"Privacy"))
        {
            icf_uint8_t  seps[] = " ;";
            icf_uint8_t  *token = ICF_NULL;
            /*buf_count=icf_port_strlen(((SipUnknownHeader *)
                        (dHeader.pHeader))->pBody); */
#ifdef ICF_WITH_MUATK_2_2

            /* Fix for SPR : 19312*/    
            /* If the value of Privacy header is null it means, header is
             * received by IPTK with no value.Free the memory for
             * the dHeader and break from the loop*/
            if (ICF_NULL == (((SipUnknownHeader *)(dHeader.pHeader))->pStr2))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:icf_ssa_parse_privacy_header():Header Value is not present"));
                sip_freeSipHeader(&dHeader);
                ret_val = ICF_FAILURE ;
                break;
            }     
            else
            {
                pBuffer = (((SipUnknownHeader *)(dHeader.pHeader))->pStr2);
            }
#else
            /* Fix for SPR : 19312*/   
            /* If the value of Privacy header is null it means, header is
             * received by IPTK with no value.Free the memory for
             * the dHeader and break from the loop*/
            if (ICF_NULL == (((SipUnknownHeader *)(dHeader.pHeader))->pBody))
            {
                ICF_PRINT(("\n[SSA]:icf_ssa_parse_privacy_header():Header Value is not present"));
                sip_freeSipHeader(&dHeader);
                ret_val = ICF_FAILURE ;
                break;
            }          
            else
            {
                pBuffer = (((SipUnknownHeader *)(dHeader.pHeader))->pBody);
            }
#endif

            token = (icf_uint8_t *)icf_port_strtok(pBuffer,(const icf_int8_t *)seps);
            while(ICF_NULL != token)
            {
                /* On encountering an id parameter we return SUCCESS */
                if (ICF_NULL == icf_port_strcmp(
                            token,(icf_uint8_t *)"id"))
                {
                    sip_freeSipHeader(&dHeader);
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                    return ICF_SUCCESS;
                }
                /* Get next token */
                token = (icf_uint8_t *)icf_port_strtok(ICF_NULL,(const icf_int8_t *)seps);
            }
        }
        sip_freeSipHeader(&dHeader);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/*
 * Following routines are used for addition/deletion of PDU nodes from 
 * the link list maintained in the TCP conn SM blocks.
 * PDUs are inserted at the end of the list and are removed from the 
 * start of the list when they have to be sent on the network.
 */
/*******************************************************************************
 * FUNCTION:        icf_ssa_add_to_pdu_array
 * DESCRIPTION:    This routine adds the given pdu at the end of array
 ******************************************************************************/
icf_return_t icf_ssa_add_to_pdu_array(
        INOUT    icf_ssa_pdb_st   *p_ssa_pdb,
        OUT     icf_uint8_t      *p_pdu)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st     *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    icf_uint8_t      counter = 0;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    while ( counter < ICF_MAX_PENDING_PDU_PER_CONN)
    {
        if (ICF_NULL != p_ssa_ctxt->p_pending_pdu[counter])
        {
            counter++;
        }
        else
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FreeLocation found in pdu ptr array"));
            p_ssa_ctxt->p_pending_pdu[counter] = p_pdu;
            p_ssa_ctxt->no_of_pending_pdu++;
            break;
        }
    }
    if ( ICF_MAX_PENDING_PDU_PER_CONN == counter)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:NoFreeLocation found in pdu ptr array"));
        ret_val = ICF_FAILURE;
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


/*******************************************************************************
 * FUNCTION:        icf_ssa_revert_to_udp
 * DESCRIPTION:   This function is used to revert the callobject from TCP
 *          to UDP. Don;t Know if a clear transaction is required prior to the
 *          second the MakeCal ( in this call)
 ******************************************************************************/
icf_return_t icf_ssa_revert_to_udp(
        INOUT    icf_ssa_pdb_st   *p_ssa_pdb,
        Sdf_st_callObject   *p_call_obj, 
        Sdf_st_overlapTransInfo     **p_p_overlap_txn,
        icf_uint8_t      *p_method,
        Sdf_st_error                *p_error)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st  *p_ssa_ctxt = 
        (icf_ssa_ctxt_st*)(p_call_obj->pAppData->pData);
    SipMessage          *p_sip_msg = Sdf_co_null;
    Sdf_ty_messageType  msg_type;
    SipError            sip_error;
    icf_uint8_t  proto[5]="UDP";
    SipList             contact_hdr_list_in_SipMsg;
    Sdf_ty_slist        contact_hdr_list_in_CommonInfo;    


    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }   
    p_ssa_pdb=p_ssa_pdb;    
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /*ICF_SSA_TRACE((p_ssa_pdb,ICF_TRACE_TRANS_MODE_REVERT_TO_UDP));*/

#ifdef ICF_P_CSCF_DISCOVERY_ENABLED
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
/* We will net the transport mode to none for P-CSCF Discovery */
    proto[0]='\0';
ICF_CHECK_IMS_END
#endif
#endif
    if ( Sdf_co_fail == 
            sdf_ivk_uaSetTransportSchemeInTransaction(
                p_call_obj->pUacTransaction, 
                *p_p_overlap_txn, (Sdf_ty_s8bit *)proto, p_error))
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:FailureInSettingTransportToUdp\n"));
        ret_val = ICF_FAILURE;
    }
    if (ret_val == ICF_SUCCESS)
    {
        /* Fix for SPR: 19886 (Merged CSR 1-7329950)*/
        /* If the transport mode is successfully updated as UDP in Transaction
         * reflect the same in tranport field of ssa context.This is done for
         * handling of following scenario:
         * Application configure transport mode as BOTH and initiate outgoing
         * call.
         * 1. INVITE ---------->on TCP and set the transport as TCP in  field of
         *    ssa context.
         * 2. Connection failure; IPTK revert to UDP from this function
         * 3. Successfull call connect on UDP.Now application send terminate
         *    call request. As transport field of ssa context is still TCP in
         *    function "icf_ssa_process_call_terminate" based on transport
         *    field of ssa context IPTK set TCP protocol in Transaction and
         *    try to send BYE on TCP.As remote party is listening on UDP IPTK
         *    is unable to send the BYE request.
         * As a fix of reported problem as soon as we are reverting to UDP
         * reflect the same in transport field of ssa context.*/
        p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
        
        sdf_fn_uaGetMethodNameAsEnum((const Sdf_ty_s8bit *)p_method, &msg_type, p_error);
        switch (msg_type)
        {
        case Sdf_en_invite:
            p_sip_msg = p_call_obj->pUacTransaction->pSipMsg;
            break;
        case Sdf_en_register:
            p_sip_msg = (*p_p_overlap_txn)->pSipMsg;
            p_ssa_ctxt->bitmask |= ICF_SSA_RGM_PREV_TRANS_TYPE_UDP;
            break;
        case Sdf_en_subscribe:
        case Sdf_en_refer:
        case Sdf_en_message:
        case Sdf_en_options:
            p_sip_msg = (*p_p_overlap_txn)->pSipMsg;
            break;
        default:
            if (0 == (icf_port_strcmp((icf_uint8_t *)"PUBLISH", p_method)))
            {
                p_sip_msg = (*p_p_overlap_txn)->pSipMsg;
            }
            else
            {
                ICF_PRINT(((icf_uint8_t *)"[SSA]:NoValidMethodToBeReverted!!"));
                ret_val = ICF_FAILURE;
            }
            break;
        }
    }
    /*as per UATK team*/
    /*delete the old via header which contains the failed transport scheme*/
    if ( ICF_FAILURE != ret_val)
    {
        if(SipFail == sip_deleteHeaderAtIndex(
                    p_sip_msg, SipHdrTypeVia,0, &sip_error))
        {
            ICF_PRINT(((icf_uint8_t *)"[SSA]:FailureInDeletingSipViaHeader\n"));
            ret_val = ICF_FAILURE;
        }

        /*generate the new via header to reflect the new 
         * transport scheme selected*/
        else if(Sdf_co_fail == sdf_fn_uaFormViaHeader(p_call_obj,
                    *p_p_overlap_txn,msg_type,p_sip_msg, p_error))
        {
            ICF_PRINT(((icf_uint8_t *)"[SSA]:FailureInMakingNewViaHeader\n"));
            ret_val = ICF_FAILURE;
        }

    }

    if (ICF_NULL == p_sip_msg)
    {
       return ICF_FAILURE;
    }

    /*deleting the transport parameter from To header in the sip message*/
    if(ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
           p_sip_msg->pGeneralHdr->pToHdr->pAddrSpec,(icf_uint8_t *)"transport"))
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Parameter from To header\n"));
        ret_val = ICF_FAILURE;
    }

    /*Iterating and deleting the transport parameter from Contact header(s) in the sip message*/
    if(0 != p_sip_msg->pGeneralHdr->slContactHdr.size)
    {
        contact_hdr_list_in_SipMsg = p_sip_msg->pGeneralHdr->slContactHdr;
        /*iterating through the list and passing each list element's pAddrSpec for deletion*/ 
        while(contact_hdr_list_in_SipMsg.head)
        {
            if(ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
               ((SipCommonHeader*)contact_hdr_list_in_SipMsg.head->pData)->pAddrSpec,(icf_uint8_t *)"transport"))
            {
                ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Parameter from Contact header\n"));
                ret_val = ICF_FAILURE;
            }
            contact_hdr_list_in_SipMsg.head = contact_hdr_list_in_SipMsg.head->next;
        }
    }
    else
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:Empty contact list in Sip Message\n"));
    }

    /*deleting the transport parameter from Request Line in the sip message*/
    if(ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
           p_sip_msg->u.pRequest->pRequestLine->pAddrSpec,(icf_uint8_t *)"transport"))
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Parameter from Request Line\n"));
        ret_val = ICF_FAILURE;
    }
  
    /* deleting transport parameter from Common Info*/

    /*deleting the transport parameter from Request Line in Common Info*/
    if((ICF_NULL != p_call_obj->pCommonInfo->pRequestUri) &&
       (ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
           p_call_obj->pCommonInfo->pRequestUri,(icf_uint8_t *)"transport")))
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Parameter from Request Line\n"));
        ret_val = ICF_FAILURE;
    }

    /*Iterating and deleting the transport parameter from Contact header(s) in the Common Info*/
    if(0 != p_call_obj->pCommonInfo->slContact.size)
    {
        contact_hdr_list_in_CommonInfo = p_call_obj->pCommonInfo->slContact;
        /*iterating through the list and passing each list element's pAddrSpec for deletion*/
        while(contact_hdr_list_in_CommonInfo.head)
        {
            if(ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
               ((SipCommonHeader*)contact_hdr_list_in_CommonInfo.head->pData)->pAddrSpec,(icf_uint8_t *)"transport"))
            {
                ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Parameter from Contact header\n"));
                ret_val = ICF_FAILURE;
            }
            contact_hdr_list_in_CommonInfo.head = contact_hdr_list_in_CommonInfo.head->next;
        }
    }
    else
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:Empty contact list in Common Info\n"));
    }
  
    /*deleting the transport parameter from To header in the Common Info*/
    if(ICF_FAILURE ==  icf_ssa_delete_param_from_addr_spec(
           ((SipCommonHeader *)p_call_obj->pCommonInfo->pTo->pHeader)->pAddrSpec,(icf_uint8_t *)"transport"))
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Parameter from To header\n"));
        ret_val = ICF_FAILURE;
    }
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_send_dialog_initiator_msg
 * DESCRIPTION:   
 ******************************************************************************/
icf_return_t icf_ssa_send_dialog_initiator_msg(
        INOUT    icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_ssa_tcpm_conn_data_st  *p_conn_db_node = 
        p_ssa_pdb->p_conn_table_entry;
    icf_uint8_t      method[ICF_MAX_SIZE_INT_USAGE_STR];

    Sdf_st_callObject           *p_call_obj = 
        p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;
    Sdf_st_transaction         *p_txn = Sdf_co_null;
/* p_sip_msg is not being used in this function, but value to it is
 * being assigned from p_overlap_trans_info that is resulting in klocwork
 * error, so i am removing it.
 */ 
/*    SipMessage                  *p_sip_msg = SIP_NULL;*/
    Sdf_st_error                sdf_error;
    SipOptions                  options;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb);


    options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

   if (ICF_SSA_INVITE_PENDING == (ICF_SSA_INVITE_PENDING & 
                p_ssa_pdb->p_ssa_ctxt->bitmask))
   {
        icf_port_strcpy(method,(icf_uint8_t *)"INVITE");
        p_txn = p_call_obj->pUacTransaction;
   }
   else
   {
       icf_ssa_get_method_name(p_ssa_pdb->p_ssa_ctxt->bitmask,
               method);         
       if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_pending_txn)
       {
           p_overlap_trans_info = (Sdf_st_overlapTransInfo*)
              (p_ssa_pdb->p_ssa_ctxt->p_pending_txn);
       }
#if 0       
       if (ICF_SSA_SUBS_PENDING & p_ssa_pdb->p_ssa_ctxt->bitmask)
       {
           p_ssa_pdb->p_ssa_ctxt->bitmask &= ~ICF_SSA_SUBS_PENDING;
       }
       else if (ICF_SSA_REG_PENDING & p_ssa_pdb->p_ssa_ctxt->bitmask)
       {
           p_ssa_pdb->p_ssa_ctxt->bitmask &= ~ICF_SSA_REG_PENDING;
       }
       else if (ICF_SSA_REFER_PENDING & p_ssa_pdb->p_ssa_ctxt->bitmask)
       {
           p_ssa_pdb->p_ssa_ctxt->bitmask &= ~ICF_SSA_REFER_PENDING;
       }
       else if (ICF_SSA_OPTION_PENDING & p_ssa_pdb->p_ssa_ctxt->bitmask)
       {
           p_ssa_pdb->p_ssa_ctxt->bitmask &= ~ICF_SSA_OPTION_PENDING;
       }
#endif       
   }
   
    if ( ICF_NULL == 
       (ICF_SSA_TCP_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask))
    {
            
        if (ICF_TRUE == p_ssa_pdb->p_ssa_ctxt->revert_mode)
        {
            /*p_overlap_trans_info =  p_conn_db_node->p_ssa_ctxt->p_pending_txn;*/

            /*Indicates that a TCP connect attempt failed here.
             * So going for UDP transport to start the transaction*/
            if ( ICF_FAILURE == icf_ssa_revert_to_udp(
                        p_ssa_pdb, p_call_obj, &p_overlap_trans_info,
                        method, &sdf_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInRevertingToUdp\n"));
                ret_val = ICF_FAILURE;
            }
            /* this is to tell that for subsequent requests
             * we will not change the transport mode 
             */
            p_ssa_pdb->p_ssa_ctxt->trans_mode_reverted = ICF_TRUE;
          }
        else
        {
            ret_val = ICF_FAILURE;
        }

    }
    else
    {
        /*If connection is established then update call_obj*/
       p_call_obj->pUacTransaction->dSocket.dSockfd =
            p_conn_db_node->conn_fd;
#ifdef ICF_SECURE_SUPPORT                
       if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)
       {
            p_call_obj->pUacTransaction->dSocket.dProtocol
                = Sdf_en_protoTls;
       }
       else
       {
#endif       
            p_call_obj->pUacTransaction->dSocket.dProtocol
                = Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
       }
#endif 
    }

    if ( ICF_FAILURE != ret_val)
    {
        Sdf_st_eventContext *p_event_context = Sdf_co_null;
        if (Sdf_co_fail ==
                sdf_ivk_uaInitEventContext(&p_event_context, &sdf_error))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInInitEventCtxt in SendDialogInitiator"));
            ret_val = ICF_FAILURE;
        }
        else if (ICF_NULL == p_event_context)
        {
            ICF_PRINT(((icf_uint8_t *)"(icf_uint8_t *)\n[SSA]:FailureInInitEventCtxt in SendDialogInitiator"));
            ret_val = ICF_FAILURE;
        }
        else
        {
            p_event_context->pData = p_ssa_pdb->p_ssa_ctxt;
            if (ICF_FAILURE == icf_ssa_initiate_dispatch_sequence(
                         p_ssa_pdb, p_call_obj,
                         p_txn, p_overlap_trans_info,
                         p_event_context,
                         p_ssa_pdb->p_ecode))
            {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                    sdf_ivk_uaClearTransaction(p_call_obj, 
                        p_overlap_trans_info,(const Sdf_ty_s8bit *)method, 
                        Sdf_en_uacTransaction);
                /*Not freeing CallObject here as a failure from
                 * this routine will trigger Generic call clear
                 * or clear reg object from app mode*/
                 ret_val = ICF_FAILURE;
            }
            else if ( Sdf_co_fail ==
                        sdf_ivk_uaEndTransaction(p_call_obj,
                        p_overlap_trans_info, (const Sdf_ty_s8bit *)method, &sdf_error))
            {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                   sdf_ivk_uaClearTransaction(p_call_obj, 
                        p_overlap_trans_info,(const Sdf_ty_s8bit *)method, 
                        Sdf_en_uacTransaction);
                /*Not freeing CallObject here as a failure from
                 * this routine will trigger Generic call clear
                 * or clear reg object from app mode*/
                 ret_val = ICF_FAILURE;
             }
         }
       if  ( Sdf_co_null != p_event_context)
       {
           sdf_ivk_uaFreeEventContext(p_event_context);
       }
    }
    /*Resetting the bitmask in success case .The changes is done while 
     *Merging the CSR_1_5397601 for sending the failure response to 
     *application */
    if(ICF_SUCCESS == ret_val)
    {
       if (ICF_SSA_SUBS_PENDING & p_ssa_pdb->p_ssa_ctxt->bitmask)
       {
           p_ssa_pdb->p_ssa_ctxt->bitmask &= ~ICF_SSA_SUBS_PENDING;
       }
       else if (ICF_SSA_REG_PENDING & p_ssa_pdb->p_ssa_ctxt->bitmask)
       {
           p_ssa_pdb->p_ssa_ctxt->bitmask &= ~ICF_SSA_REG_PENDING;
       }
       else if (ICF_SSA_REFER_PENDING & p_ssa_pdb->p_ssa_ctxt->bitmask)
       {
           p_ssa_pdb->p_ssa_ctxt->bitmask &= ~ICF_SSA_REFER_PENDING;
       }
       else if (ICF_SSA_OPTION_PENDING & p_ssa_pdb->p_ssa_ctxt->bitmask)
       {
           p_ssa_pdb->p_ssa_ctxt->bitmask &= ~ICF_SSA_OPTION_PENDING;
       }

    }
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
    return ret_val;
}
/*******************************************************************************
 * FUNCTION:        icf_ssa_dispatch_pdu_to_es
 * DESCRIPTION:    The ppdu memory is allocated to this function
 * by athe calling routine and then it frees it.
 ******************************************************************************/
icf_return_t icf_ssa_dispatch_pdu_to_es(
        INOUT icf_glb_pdb_st   *p_glb_pdb,
        INOUT icf_ssa_ctxt_st  *p_ssa_ctxt,
        INOUT SipTranspAddr    *pTranspaddr,
        INOUT Sdf_ty_protocol  dTransptype,
        INOUT icf_uint8_t      *p_pdu,
        INOUT icf_uint32_t     pdu_len,
        INOUT icf_line_id_t    line_id,
        OUT   icf_error_t      *p_ecode)
{
    icf_return_t     ret_val = ICF_FAILURE;
    icf_return_t     return_val = ICF_SUCCESS;
    icf_return_t     dummy_ret_val = ICF_SUCCESS;
    icf_uint32_t     outgoing_msg_len = 0;
    icf_msg_st       *p_outgoing_msg = ICF_NULL;
    icf_nw_interface_info_st *p_nw_interface_info = ICF_NULL;
    icf_config_data_st   *p_config_data = ICF_NULL;
    icf_line_data_st     *p_line_data = ICF_NULL;
    icf_uint16_t         server_index = 0;
    #ifdef ICF_TRACE_ENABLE
    icf_global_port_info_st  *p_glb_port_data = ICF_NULL;
    #endif
    /* To remove warnings */
    p_ssa_ctxt=p_ssa_ctxt;

        if (ICF_NULL == p_glb_pdb)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]: p_glb_pdb is NULL"));

        return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_glb_pdb)

    ICF_CHECK_IF_ANY_OF_TWO_VAR_IS_NULL(p_glb_pdb,
                             p_glb_pdb->p_glb_data,
                             pTranspaddr,
                             return_val)
    if(ICF_FAILURE == return_val)
    {
        ICF_MEMFREE(p_glb_pdb, p_pdu, ICF_MEM_COMMON,\
                p_ecode, ret_val)
        ret_val = ICF_FAILURE;

        ICF_FUNCTION_EXIT(p_glb_pdb)
        return ret_val;    
    }
#ifdef ICF_TRACE_ENABLE
    p_glb_port_data = (icf_global_port_info_st *)p_glb_pdb->p_glb_data->p_glb_port_info;
#endif

   /* get the pointer to CFG data: to check for GPRS state */
    ret_val = icf_dbm_get_module_glb_data(
                p_glb_pdb,
                (icf_int_module_id_t)(ICF_INT_MODULE_CFG),
                (icf_void_t **)(&(p_config_data)),
                p_ecode);     

    ICF_CHECK_IF_VAR_IS_NULL(p_glb_pdb,
                             p_config_data,
                             return_val)
    if (ICF_FAILURE == return_val)
    {
        ICF_MEMFREE(p_glb_pdb, p_pdu, ICF_MEM_COMMON,\
                p_ecode, ret_val)
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_glb_pdb)
        return ret_val;
    }

    /* Fix for CSR 1-8678911: SPR 20428 */
    if (ICF_CFG_SELF_ADDR_PER_LINE == p_config_data->self_addr_per_line)
    {
        /* If the line id is set to INVALID i.e(A common scenario for sending
         * the 404 response to incoming request in case self address is
         * configured as per line); fetched the most appropriate line for
         * sending the 404 response(Best effort). We will traverse the all
         * configured lines in EGT and the first line which is initialized in
         * system is used for sending the reponse.
         */
        if (ICF_INVALID_LINE_ID == line_id)
        {
            icf_uint32_t          line_count = 0, count = 0;
            icf_line_data_st      *p_line_blk = ICF_NULL;

            line_count = p_config_data->max_lines;
            for(count = 0; count < line_count; count++)
            {
                if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                                        p_glb_pdb,(icf_line_id_t const)(count),
                                        &p_line_blk,p_ecode))
                {
                    continue;
                }
                else if((ICF_TRUE == p_line_blk->line_data_init_complete))
    {
                    /* Update the line id variable. This will be further used
                     * to identify the server index.*/
                    line_id = p_line_blk->line_id;
                    break;
                }
            }
        }
        if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(p_glb_pdb, line_id,
                &p_line_data, p_ecode))
        {
            /*Fix for SPR : 19188 (Rel 7.1.2 SPR merging for SPR 18885)*/
            /*  Fix for spr 18885 */
            ICF_MEMFREE(p_glb_pdb, p_pdu, ICF_MEM_COMMON,\
                p_ecode, ret_val)            
            return ICF_FAILURE;
        }
        ICF_CHECK_IF_VAR_IS_NULL(p_glb_pdb,
                                 p_line_data,
                                 return_val)
        if (ICF_FAILURE == return_val)
        {
            ICF_MEMFREE(p_glb_pdb, p_pdu, ICF_MEM_COMMON,\
                p_ecode, ret_val)
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_glb_pdb)
            return ret_val;
        }
        server_index = p_line_data->server_index[ICF_WIN_UDP_SIP_SERVER];
    }
    else
    {
        server_index = p_config_data->server_index[ICF_WIN_UDP_SIP_SERVER];
    }       

/* Start for SIP DSCP parameter */
 if (ICF_SUCCESS == ret_val)
 {
   if (ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk( p_glb_pdb,
                                                    line_id,
                                                    (&p_line_data),
                                                    p_ecode ) )
    {
      ret_val = ICF_FAILURE;
    }
 }   
 /* End for SIP DSCP parameter */
#ifdef ICF_NW_ACTIVATE 
    if (ICF_TRUE == p_config_data->gprs_suspended)
    {
        ICF_MEMFREE(p_glb_pdb, p_pdu, ICF_MEM_COMMON,\
                p_ecode, ret_val)
        return ICF_SUCCESS;
    }
#endif

#ifdef ICF_TRACE_ENABLE
    ICF_CHECK_IF_VAR_IS_NULL(p_glb_pdb,
                             p_ssa_ctxt,
                             return_val)
    if (ICF_FAILURE == return_val)
    {
        ICF_MEMFREE(p_glb_pdb, p_pdu, ICF_MEM_COMMON,\
                p_ecode, ret_val)
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_glb_pdb)
        return ret_val; 
    }
    if (ICF_NULL != p_ssa_ctxt->p_ssa_pdb)
    {

        p_ssa_ctxt->p_ssa_pdb->p_buf = p_pdu;
        p_ssa_ctxt->p_ssa_pdb->len = pdu_len;
        p_ssa_ctxt->p_ssa_pdb->p_glb_pdb=p_glb_pdb;
      /* SPR 17555 Fix: Call Direction send to app trace
       * function to be used to send to application
       */

	    p_ssa_ctxt->p_ssa_pdb->call_direction = ICF_CALL_DIRECTION_OUTGOING;

        /* SPR 18795: assign the ssa context within the SSA pdb before
         * invokation of traces, this was getting currupt when SIP request
         * retransmission were happening and IPTK was sending the resposnes
         */
        p_ssa_ctxt->p_ssa_pdb->p_ssa_ctxt =  p_ssa_ctxt;

        ICF_SSA_APP_TRACE(p_ssa_ctxt->p_ssa_pdb , ICF_TRACE_SIP_PDU)
    }
#endif 
	icf_print_pdu(p_glb_pdb, (icf_uint8_t *)p_pdu, (icf_uint8_t *)pTranspaddr->pHost, 
		          pTranspaddr->dPort, pdu_len);

    outgoing_msg_len = ICF_PORT_SIZEOF(icf_msg_st) + 
        ICF_PORT_SIZEOF(icf_nw_interface_info_st) - 1;

    ICF_MEMGET(p_glb_pdb, outgoing_msg_len, ICF_MEM_COMMON,\
            p_outgoing_msg,ICF_DONOT_RET_ON_FAILURE,\
            p_ecode, ret_val)

    /*Fix for SPR : 19188 (Rel 7.1.2 SPR merging for SPR 18885)*/    
    if (ICF_FAILURE == ret_val)
    {
        /*  Fix for spr 18885 */
        ICF_MEMFREE(p_glb_pdb, p_pdu, ICF_MEM_COMMON,\
            p_ecode, ret_val)
         return ret_val;
    }          

    p_outgoing_msg->hdr.api_id = 0;
    p_outgoing_msg->hdr.app_id = 0;
    p_outgoing_msg->hdr.call_id = 0;
    p_outgoing_msg->hdr.source_id = ICF_MODULE_ICF;
    p_outgoing_msg->hdr.destination_id = ICF_MODULE_SIP_NW;
    p_outgoing_msg->hdr.api_length = (icf_uint16_t)(pdu_len + 
        ICF_PORT_SIZEOF(icf_nw_interface_info_st));

    p_nw_interface_info = (icf_nw_interface_info_st*)
        p_outgoing_msg->payload;

    p_nw_interface_info->p_sip_msg = p_pdu;
    p_nw_interface_info->pdu_len = (icf_uint16_t) pdu_len;
    if(ICF_NULL != p_line_data)
    p_nw_interface_info->sip_dscp = p_line_data->sip_dscp;
    if (dTransptype == Sdf_en_protoUdp)
    {
        p_nw_interface_info->bitmap = ICF_INTF_INFO_PROTOCOL_UDP;
        p_nw_interface_info->remote_port_num = pTranspaddr->dPort;
        /*  Fix for SPR 19522 */
        /*  remote_ip_addr is an array of size ICF_MAX_IPV4_ADDRESS_LENGTH
         *  that is why copying that much value.
         */
        icf_port_strncpy((icf_int8_t *)p_nw_interface_info->remote_ip_addr, 
                ((const icf_int8_t *)pTranspaddr->pHost),
				(ICF_MAX_IPV4_ADDRESS_LENGTH - 1));
		p_nw_interface_info->remote_ip_addr[ICF_MAX_IPV4_ADDRESS_LENGTH - 1] = '\0';
        p_nw_interface_info->curr_server_index = server_index;
	
    }
#ifdef ICF_SECURE_SUPPORT                
    else if(dTransptype == Sdf_en_protoTls)
    {
        p_nw_interface_info->bitmap = ICF_INTF_INFO_PROTOCOL_TLS;
        p_nw_interface_info->receiver_fd = pTranspaddr->dSockFd;
    }
#endif
    else
    {
        p_nw_interface_info->bitmap = ICF_INTF_INFO_PROTOCOL_TCP;
        p_nw_interface_info->receiver_fd = pTranspaddr->dSockFd;
    }

    ICF_SEND(p_glb_pdb, p_outgoing_msg, ret_val, p_ecode);
#ifdef ICF_TRACE_ENABLE
    if( ICF_FAILURE == ret_val)
    {
        ICF_CHECK_IF_VAR_IS_NULL(p_glb_pdb,
                                 p_glb_port_data,
                                 return_val)
        if (ICF_FAILURE == return_val)
        {
            /*  Do  Nothing */ 
        }
        else
        {
            /*  The macro for CHECK varables does not set the return_val
                SUCCESS if pointer is not Null, This same return val can be
                used later so it must be set to success so that when next time
                macro will be called the correct value of return_val should be 
                sent to macro */
            return_val = ICF_SUCCESS;
	        if( dTransptype == Sdf_en_protoUdp )
	        {
                p_glb_port_data->icf_trace_ipc_info.self_mode = ICF_TRANSPORT_TYPE_UDP;
                p_glb_port_data->icf_trace_ipc_info.remote_port = pTranspaddr->dPort;
                icf_port_strcpy(p_glb_port_data->icf_trace_ipc_info.remote_ip,
                                                p_nw_interface_info->remote_ip_addr);
                /* fix for csr-5286119*/
                ICF_CMN_APP_TRACE(p_glb_pdb, ICF_TRACE_UDP_SEND_ERROR,p_outgoing_msg)

	        }
#ifdef ICF_SECURE_SUPPORT
	        else if( dTransptype == Sdf_en_protoTls )
	        {
        	    p_glb_port_data->icf_trace_ipc_info.self_mode = ICF_TRANSPORT_TYPE_TLS;
	            ICF_CMN_APP_TRACE(p_glb_pdb, ICF_TRACE_TLS_SEND_ERROR, p_outgoing_msg)
	        }
#endif /*#ifdef ICF_SECURE_SUPPORT*/
	        else
            {
               p_glb_port_data->icf_trace_ipc_info.self_mode = ICF_TRANSPORT_TYPE_TCP;
	           ICF_CMN_APP_TRACE(p_glb_pdb, ICF_TRACE_TCP_SEND_ERROR, p_outgoing_msg)
            }
        }
    }
#endif /*#ifdef ICF_TRACE_ENABLE*/

    ICF_MEMFREE(p_glb_pdb, p_pdu, ICF_MEM_COMMON,\
                p_ecode, dummy_ret_val)
    ICF_MEMFREE(p_glb_pdb, p_outgoing_msg, ICF_MEM_COMMON,\
                    p_ecode, dummy_ret_val)
     
    /*Code for stat collection*/

    if( ret_val == ICF_FAILURE)
    {
        ICF_CHECK_IF_VAR_IS_NULL(p_glb_pdb,
                                 p_glb_pdb->p_stats_info,
                                 return_val)
        if (ICF_SUCCESS == return_val)
        {
            if(dTransptype == Sdf_en_protoUdp)
            {
                ICF_STATS(p_glb_pdb->p_stats_info->
                    stat_udp_connections.stats_send_failures)
            }
#ifdef ICF_SECURE_SUPPORT
            else if(dTransptype == Sdf_en_protoTls)
            {
                ICF_STATS(p_glb_pdb->p_stats_info->
                                stat_tls_connections.stats_send_failures)
            }
#endif
            else
            {
                ICF_STATS(p_glb_pdb->p_stats_info->
                            stat_tcp_connections.stats_send_failures)
            }
        }
     }

    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}
/*******************************************************************************
 * FUNCTION:        icf_ssa_send_failure_to_app_module
 * DESCRIPTION:    This routine is invoked in case there is a failure either in
 * the handling of a successful open conn resp or there is a failure response
 * for a pending open connection request.  The routine forms and sends appr.
 * failure message to the module whose request resulted in a tcp conn attempt 
 ******************************************************************************/
icf_return_t icf_ssa_send_failure_to_app_module(
        icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t     ret_val = ICF_FAILURE;
    icf_ssa_intrnl_intf_ut   internal_msg_payload;

    icf_ssa_ctxt_st  *p_ssa_ctxt = ICF_NULL;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* As message is coming from MRM, there should not be anything
     * in the payload part of the internal message, so we are over-
     * writing the pointer here.
     */

    p_ssa_pdb->p_internal_msg->p_msg_data  = (icf_uint8_t*)
    (&internal_msg_payload);
    p_ssa_pdb->p_internal_msg->msg_hdr.payload_length  = 
        ICF_PORT_SIZEOF(icf_ssa_intrnl_intf_ut);

    p_ssa_pdb->p_internal_msg->msg_hdr.p_glb_pdb = p_ssa_pdb->p_glb_pdb;
#if 0
    p_root =  icf_dbm_fetch_all_ssa_ctxt_from_hash_table(p_ssa_pdb->p_glb_pdb);
    for (p_temp = p_root; ICF_NULL != p_temp; p_temp = p_temp->p_next)
    {
        for (p_ssa_list = (icf_ssa_ctxt_list_st *)p_temp->p_data; ICF_NULL != p_ssa_list ;
                p_ssa_list = p_ssa_list->p_next)
        {
            p_ssa_ctxt = p_ssa_list->p_ssa_ctxt;
            if ((p_ssa_ctxt->p_conn_table_req_entry == p_conn_db_node) ||
                    (p_ssa_ctxt->p_conn_table_resp_entry == p_conn_db_node))
            {
                break;
            }
            else
                p_ssa_ctxt = ICF_NULL;
        }
    }
   icf_ssa_free_list(p_ssa_pdb, p_root);
#endif
   p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
   if (ICF_NULL == p_ssa_ctxt )
   {
       ICF_PRINT(((icf_uint8_t *)"No ssa context for this connection found. Returning\n"))
       ret_val = ICF_FAILURE;
   }
   else if(ICF_SSA_INVITE_PENDING == 
       (ICF_SSA_INVITE_PENDING & p_ssa_ctxt->bitmask))
    {
        p_ssa_pdb->p_internal_msg->p_msg_data = ICF_NULL;/*no payload*/
        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = 
            ICF_GENERIC_CALL_CLEAR;
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 0;
        p_ssa_pdb->p_internal_msg->msg_hdr.p_glb_pdb->p_call_ctx = 
            p_ssa_ctxt->p_call_ctxt;
        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CM;
    /*Send the message to original module*/
        icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);
        p_ssa_ctxt->bitmask &= ~ICF_SSA_INVITE_PENDING;
    }
    else if(ICF_SSA_REG_PENDING == 
    (ICF_SSA_REG_PENDING & p_ssa_ctxt->bitmask))
    {
        icf_rgm_nw_resp_st*      p_rgm_msg = ICF_NULL;

        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = ICF_NW_INC_REG_RESP;
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 
            ICF_PORT_SIZEOF(icf_rgm_nw_resp_st);

        /* Populate the internal message payload */
        p_rgm_msg = (icf_rgm_nw_resp_st *)
            (p_ssa_pdb->p_internal_msg->p_msg_data);

        p_rgm_msg->p_rgm_context = p_ssa_ctxt->p_rgm_ctxt;

        p_rgm_msg->status = ICF_RGM_SSA_NW_FAILURE;

        p_rgm_msg->ecode = ICF_RGM_SSA_FAIL_REATTEMPT;


        /* SPR 19535: Set the response code as 0 so that it does not result into 
         * UMR while being accessed at REGM module
         */
        p_rgm_msg->response_code = 0;

        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CFG;
        /* Send the message to original module */
        icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);
    }
    /*If TCP connect request was for SUBSCRIBE then send failure SUBSCRIBE response
     *to SIC module*/
    else if(ICF_SSA_SUBS_PENDING == 
    (ICF_SSA_SUBS_PENDING & p_ssa_ctxt->bitmask))
    {
        icf_nw_inc_subs_resp_st * p_subs_resp = ICF_NULL;

        if (ICF_NULL != p_ssa_ctxt->p_sic_ctxt)
        {
            p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = ICF_NW_INC_SUBSCRIBE_RESP;
            p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 
            ICF_PORT_SIZEOF(icf_nw_inc_subs_resp_st);

            /* Populate the internal message payload */
            p_subs_resp = (icf_nw_inc_subs_resp_st *)p_ssa_pdb->p_internal_msg->p_msg_data;

            p_subs_resp->bitmask = 0;
            p_subs_resp->response = ICF_NW_INC_SUBS_RESP_NO_RETRY;
            p_subs_resp->resp_code=0;
            p_subs_resp->p_sic_ctx = p_ssa_ctxt->p_sic_ctxt;
            p_subs_resp->p_sic_ctx->error_code = *(p_ssa_pdb->p_ecode);
            p_ssa_pdb->dest_module_id = ICF_INT_MODULE_SIC;
            ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_subs_resp->p_sic_ctx))
        }
        p_ssa_ctxt->bitmask &= ~ICF_SSA_SUBS_PENDING;
        icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);
    }
    else if (ICF_SSA_REFER_PENDING & p_ssa_ctxt->bitmask)
    {
        p_ssa_ctxt->bitmask &= ~ICF_SSA_REFER_PENDING;
    }
    /*If TCP connect request was for OPTIONS then send failure OPTIONS response
     *to SIC module*/
    else if (ICF_SSA_OPTION_PENDING & p_ssa_ctxt->bitmask)
    {
        icf_nw_inc_opt_resp_st * p_opt_resp = ICF_NULL;
				
        /* Populate the internal message header */
        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = ICF_SIC_OPTION_STATUS;
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 
                ICF_PORT_SIZEOF(icf_nw_inc_opt_resp_st);

        /* Populate the internal message payload */
        p_opt_resp = (icf_nw_inc_opt_resp_st *)p_ssa_pdb->p_internal_msg->p_msg_data;

        p_opt_resp->response = 0;
        p_opt_resp->p_sic_ctx = p_ssa_ctxt->p_sic_ctxt;
        if (ICF_NULL != p_opt_resp->p_sic_ctx)
        {
                p_opt_resp->p_sic_ctx->error_code = *(p_ssa_pdb->p_ecode);
        }
        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_SIC;
        p_ssa_ctxt->bitmask &= ~ICF_SSA_OPTION_PENDING;
        icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);
    }
    /*If TCP connect request was for PUBLISH then send failure PUBLISH response
     *to SIC module*/
    else if (ICF_SSA_PUBLISH_PENDING & p_ssa_ctxt->bitmask)
    {
        icf_nw_inc_publish_resp_st  *p_publish_resp = ICF_NULL;
				
        /* Populate the internal message header */
	p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = ICF_SIC_PUBLISH_STATUS;
	p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 
		ICF_PORT_SIZEOF(icf_nw_inc_publish_resp_st);

	/* Populate the internal message payload */
	p_publish_resp = (icf_nw_inc_publish_resp_st *)p_ssa_pdb->p_internal_msg->p_msg_data;

	p_publish_resp->response = 0;
	p_publish_resp->duration = 0;
	p_publish_resp->p_sic_ctx = p_ssa_ctxt->p_sic_ctxt;
       if (ICF_NULL != p_publish_resp->p_sic_ctx)
       {
           p_publish_resp->p_sic_ctx->error_code = *(p_ssa_pdb->p_ecode);
       }
       p_ssa_pdb->dest_module_id = ICF_INT_MODULE_SIC;
       p_ssa_ctxt->bitmask &= ~ICF_SSA_PUBLISH_PENDING;
       icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);
    }
    /*If TCP connect request was for MESSAGE then send failure message response
     *to SIC module*/
    else if (ICF_SSA_MESSAGE_PENDING & p_ssa_ctxt->bitmask)
    {
        icf_nw_inc_msg_resp_st * p_msg_resp = ICF_NULL;
				
        /* Populate the internal message header */
	p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = ICF_SIC_MESSAGE_STATUS;
	p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 
		ICF_PORT_SIZEOF(icf_nw_inc_msg_resp_st);

	/* Populate the internal message payload */
	p_msg_resp = (icf_nw_inc_msg_resp_st *)p_ssa_pdb->p_internal_msg->p_msg_data;

	p_msg_resp->response = 0;
	p_msg_resp->p_sic_ctx = p_ssa_ctxt->p_sic_ctxt;
       if (ICF_NULL != p_msg_resp->p_sic_ctx)
       {
           p_msg_resp->p_sic_ctx->error_code = *(p_ssa_pdb->p_ecode);
       }
       p_ssa_pdb->dest_module_id = ICF_INT_MODULE_SIC;
       p_ssa_ctxt->bitmask &= ~ICF_SSA_MESSAGE_PENDING;
       icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);
    }
    else
    {    
#if 0
    p_ssa_pdb->p_internal_msg->p_msg_data = ICF_NULL;/*no payload*/
        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = 
            ICF_GENERIC_CALL_CLEAR;
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 0;
        p_ssa_pdb->p_internal_msg->msg_hdr.p_glb_pdb->p_call_ctx = 
            p_conn_db_node->p_ssa_ctxt->p_call_ctxt;
        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CM;
#endif
        ICF_SSA_DEBUG(("[SSA]:InvalidMarkForPendingMsg!!\n"));
        ret_val = ICF_FAILURE;
    }
    /*Send the message to original module*/
/*    icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);*/
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/*******************************************************************************
 * FUNCTION:        icf_ssa_start_purge_timer
 * DESCRIPTION:    This routine is used for starting the purge timer
 ******************************************************************************/
icf_return_t icf_ssa_start_purge_timer(
        INOUT  icf_ssa_pdb_st*    p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_timer_id_t           timer_id = ICF_TIMER_ID_INVALID;
    icf_timer_data_st        *p_timer_data = ICF_NULL;

    icf_return_t return_val = ICF_SUCCESS;

    /* SPR 18880 : Added Null checks */
    if((ICF_NULL == p_ssa_pdb) ||
       (ICF_NULL == p_ssa_pdb->p_glb_pdb))
    {
        ICF_PRINT(((icf_uint8_t *)("[SSA]: p_ssa_pdb or p_glb_pdb is NULL.\n")))
        return ICF_FAILURE;
    }

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                             p_ssa_pdb->p_ssa_glb_data,
                             return_val)
    if(ICF_FAILURE == return_val)
    {
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ICF_FAILURE;
    }

    if ( ICF_FAILURE == icf_dbm_get_mem_from_pool(
                p_ssa_pdb->p_glb_pdb, ICF_MEM_TIMER,
                (icf_void_t **)&(p_ssa_pdb->p_ssa_glb_data->p_purge_timer), 
                p_ssa_pdb->p_ecode))
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA]:FailureInAllocatingTimerBlockForPurgeTimer\n"));
        ret_val = ICF_FAILURE;
    }
    else if(ICF_NULL != p_ssa_pdb->p_ssa_glb_data->p_purge_timer)
    {
        /* fill the timer data structure */
        p_timer_data = p_ssa_pdb->p_ssa_glb_data->p_purge_timer;
        p_timer_data->timer_type = ICF_SSA_PURGE_TIMER_TYPE;
        p_timer_data->module_id = ICF_INT_MODULE_SSA;

        /*In case of timer expiry, eshell will pass the p_timer_data
         * to SSA.SSA will then get the p_ssa_timer_data and invoke
         * UATK callback
         */
        p_timer_data->p_timer_buffer = 
            (icf_void_t*)p_ssa_pdb->p_ssa_glb_data;
        p_timer_data->p_glb_pdb = p_ssa_pdb->p_glb_pdb;
        /*If the purge timer duration is 0 start a default purge timer 
          (ICF_DEFAULT_PURGE_TIMER_DURATION)define in icf_port.h
          (in common module) 
        */
        if( 0!= ICF_PURGE_TIMER_DURATION)
        {
            ICF_START_TIMER(p_ssa_pdb->p_glb_pdb, 
                    p_timer_data, timer_id,
                    ICF_PURGE_TIMER_DURATION, 
                    p_ssa_pdb->p_ecode, ret_val)
        }
        else
        {
            ICF_START_TIMER(p_ssa_pdb->p_glb_pdb, 
                    p_timer_data, timer_id,
                    ICF_DEFAULT_PURGE_TIMER_DURATION, 
                    p_ssa_pdb->p_ecode, ret_val)
        } 
        if ( ICF_FAILURE == ret_val)
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure!!InStartingPurgeTimer"));
            /*Free the allocated timer block here*/
            ret_val = icf_dbm_ret_mem_to_pool(p_ssa_pdb->p_glb_pdb, 
                          ICF_MEM_TIMER,
                          p_timer_data, p_ssa_pdb->p_ecode);
            if(ICF_SUCCESS == ret_val)
            {
                p_ssa_pdb->p_ssa_glb_data->purge_timer_id = ICF_NULL;
                p_ssa_pdb->p_ssa_glb_data->p_purge_timer = ICF_NULL;
                p_timer_data = ICF_NULL;
            }
            /* Timer block freeing failure. Raise a alarm and proceed. */
            else
            {
                ICF_PRINT(((icf_uint8_t *)"[SSA]: Failure in freeing timer block.\n"))
            }
            /* restore ret_val to ICF_FAILURE */
            ret_val = ICF_FAILURE;
        }
        else
        {
            p_ssa_pdb->p_ssa_glb_data->purge_timer_id =
                timer_id;
        }
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

#ifdef IMS_CLIENT

/*****************************************************************************
 ** FUNCTION:           headerListFreeFunction
 **
 ** DESCRIPTION:        This function free memeory allocated for SIP Header.
 **
 *****************************************************************************/
void headerListFreeFunction(void *pData)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_error_t                ecode;
    sip_freeSipHeader((SipHeader *)pData);
    ICF_MEMFREE(p_persistent_glb_pdb,pData,ICF_MEM_COMMON, &ecode, ret_val)
}


/*****************************************************************************
 ** FUNCTION:        icf_ssa_get_reg_body
 ** 
 ** DESCRIPTION:    This function gets the non-SDP/ISUP buffers and returns
 **                    "application/reginfo+xml" message body.
 **
 *****************************************************************************/
icf_return_t icf_ssa_get_reg_body (
            INOUT        SipMessage               *pMessage,
             OUT        Sdf_ty_s8bit             **pp_Buffer,
            OUT        Sdf_ty_u32bit             *pBufLength,
            INOUT     icf_error_t           *p_ecode)
{
  Sdf_st_error              Err;
  SipError                  error;
  Sdf_ty_u32bit             i, dCount = 0;
  SipHeader                    dHeader;
  
  ICF_PRINT(("\nExtracting Unknown Message Body"));
  /* To remove warning */
 p_ecode=p_ecode;

  if (pMessage == ICF_NULL)
  {
    ICF_PRINT(("\nInvalid SipMessage passed to function"));
    return ICF_FAILURE;
  }

  if (sip_getMsgBodyCount(pMessage, &dCount, &error) == SipFail)
  {
    ICF_PRINT(("\nFailed to get MsgBodyCount from SipMessage"));
    return ICF_FAILURE;
  }
  for (i = 0; i < dCount; i++)
  {

    if(sdf_ivk_uaGetUnknownBodyFromSipMessage(pMessage, i, \
          pp_Buffer, pBufLength, &Err) == Sdf_co_success)
    {
      /*
       * Retrieved an non-SDP/ISUP body. Add the body to the temporary
       * array and update the mgc_tunnel_element_st structure with
       * remaining parameters. 
       */
      Sdf_ty_s8bit *pMediaType = ICF_NULL;
      Sdf_ty_u32bit    BufLength = *pBufLength;
      
      Sdf_ty_s8bit *pLastChar=(Sdf_ty_s8bit *)(*pp_Buffer)+BufLength -1 ;
      if(*pLastChar == '\n') *pLastChar = '\0';
      
      /*if(*pp_Buffer[*pBufLength-1] == '\n')
        *pp_Buffer[*pBufLength-1] = '\0';
        */

       /*
       * Set the msg_type of the buffer_info element depending
       * on the type of the message body
       */

        

        if (sip_getHeader(pMessage, SipHdrTypeContentType, \
              &dHeader, &error) == SipFail)
        {
          ICF_PRINT(("\nFailed to get Content-Type Header"));
          return ICF_FAILURE;
        }
        if (sip_getMediaTypeFromContentTypeHdr(&dHeader, &pMediaType,\
              &error) == SipFail)
        {
          ICF_PRINT(("\nFailed to get media-type from "
                "Content-Type Header"));
          sip_freeSipHeader(&dHeader);
          return ICF_FAILURE;
        }
        if (Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pMediaType,
                    (Sdf_ty_s8bit*)"application/reginfo+xml") == 0)
        {
          ICF_PRINT(("\nMedia Type: application/reginfo+xml"));
          sip_freeSipHeader(&dHeader);
          break;
        }
        else
        {
          ICF_PRINT(("\nMessage Type: UNKNOWN"));
        }
        /* Free the local reference */
        sip_freeSipHeader(&dHeader);
  
    }
  }

  return ICF_SUCCESS;
}


/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_set_ValInUnknownHdr
 *
 * DESCRIPTION:     This function creates Unknown header.
 *
 ******************************************************************************/
icf_return_t icf_ssa_set_ValInUnknownHdr(
        INOUT        icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT     SipHeader            *pHeader,
        INOUT      Sdf_ty_s8bit        *pHdr,
        INOUT      Sdf_ty_s8bit        *pVal)
{
    Sdf_ty_s8bit    *pHdrName=ICF_NULL;
    Sdf_ty_s8bit    *pHdrBody=ICF_NULL;
    Sdf_ty_s32bit   HdrBodyLen=0;
    SipError        SipErr;
    Sdf_ty_retVal   ret_val = Sdf_co_success;


    /* Inserting the Header name in the unknown Header */
    Sdf_mc_strdup(pHdrName,pHdr);
    
    if ( ICF_NULL == pHdrName )
    {
        return ICF_FAILURE;
    }

    if (sip_setNameInUnknownHdr(pHeader,pHdrName,&SipErr) == SipFail)
    {
        ICF_PRINT(("\nFailed to Set name"));

            ICF_MEMFREE(
            p_ssa_pdb->p_glb_pdb,
            pHdrName,
            ICF_MEM_COMMON,
            p_ssa_pdb->p_ecode,
            ret_val)

        return ICF_FAILURE;
    }
    /* Calculating the Header Body */
    HdrBodyLen += Sdf_mc_strlen(pVal) + 1;

    ICF_MEMGET(
                   p_ssa_pdb->p_glb_pdb,
                   HdrBodyLen,
                   ICF_MEM_COMMON,
                   pHdrBody,
                   ICF_RET_ON_FAILURE,
                   p_ssa_pdb->p_ecode,
                   ret_val)

    if(ICF_NULL == pHdrBody) 
    {
        sip_freeSipHeader(pHeader);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                pHdrName,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)

        return ICF_FAILURE;
    }
    /* Preparing the Message Body */

    icf_port_strcpy(pHdrBody, pVal);

    if (sip_setBodyInUnknownHdr(pHeader,pHdrBody,&SipErr) == SipFail)
    {
        ICF_PRINT(("\nFailed to set body"));
        return ICF_FAILURE;
    }

    return ICF_SUCCESS;
}
#endif /* #ifdef IMS_CLIENT */


/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_parse_unknown_header_like_from_hdr
 ** DESCRIPTION:  This function iterates through all the unknown headers
 **               If it doesn't find the required header,it returns
 **               success.
 **               Otherwise,if the required header is present,SSA
 **               will parse it like an FROM header and pass it as 
 **               p_p_parsed_hdr.
 **
 ***************************************************************************/
icf_return_t icf_ssa_parse_unknown_header_like_from_hdr(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  SipMessage          *pSipMessage,
        INOUT    Sdf_ty_s8bit        *p_reqd_hdr_name,
        INOUT  SipHeader           **p_p_parsed_hdr)

{
    icf_return_t         ret_val = ICF_SUCCESS;

    Sdf_ty_u32bit           iterator=0,count=0;
    SipError                err;
    SipHeader               dHeader;
    icf_boolean_t        match_found = ICF_FALSE;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* get the unknown header count */
    if(SipFail == sip_getHeaderCount(
                pSipMessage,
                SipHdrTypeUnknown,&count,
                &err))
    {
        /*ICF_SSA_TRACE(("\nFailed to get Header Count "))*/
        ret_val = ICF_FAILURE ;
    }
    /* Iterate through all the unknown headers*/
    for(iterator=0 ; ((iterator<count)&&(ICF_FALSE == match_found)); 
           iterator++)
    {
        SIP_S8bit           *pUnkHdrName = SIP_NULL,
                            *pBuffer = SIP_NULL ;
        Sdf_ty_u32bit         buf_count = 0;

        if(SipFail == sip_getHeaderAtIndex(
                    pSipMessage,
                    SipHdrTypeUnknown, &dHeader,
                    iterator,&err))
        {
            /*In this case we continue to try to fetch other unknown headers*/
            continue;
        }
        if(SipFail == sip_getNameFromUnknownHdr(
                    &dHeader,&pUnkHdrName,&err))
        {
            /*In this case we continue to try to fetch other unknown headers*/
            sip_freeSipHeader(&dHeader);
            continue;
        }
        /* Check for the Required header */
        if(0 == sip_strcasecmp(pUnkHdrName, p_reqd_hdr_name))
        {
            match_found = ICF_TRUE;
            if (SipFail ==sip_initSipHeader(
                        p_p_parsed_hdr,SipHdrTypeFrom,&err))
            {
                sip_freeSipHeader(*p_p_parsed_hdr);
                ret_val = ICF_FAILURE ;
                break;
            }
            else
            {
                /*Klocwork Warning Removal*/
                ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                       *p_p_parsed_hdr)
#ifdef ICF_WITH_MUATK_2_2
                /* Fix for SPR : 19315*/    
                /* If the value of Unknown header is null it means, header is
                 * received by IPTK with no value.Free the memory for
                 * the header and break from the loop*/
                if (ICF_NULL == (icf_uint8_t *)((SipUnknownHeader *)
                            (dHeader.pHeader))->pStr2)
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:icf_ssa_parse_unknown_header_like_from_hdr():Header Value is not present"));
                    sip_freeSipHeader(*p_p_parsed_hdr);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            *p_p_parsed_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)                    
                    sip_freeSipHeader(&dHeader);
                    ret_val = ICF_FAILURE ;
                    break;
                }
                buf_count=icf_port_strlen((icf_uint8_t *)((SipUnknownHeader *)
                        (dHeader.pHeader))->pStr2);
                pBuffer = (((SipUnknownHeader *)
                            (dHeader.pHeader))->pStr2);
#else
                /* Fix for SPR : 19315*/ 
                /* If the value of Unknown header is null it means, header is
                 * received by IPTK with no value.Free the memory for
                 * the header and break from the loop*/
                if (ICF_NULL == ((SipUnknownHeader
                                *)(dHeader.pHeader))->pBody)
                {
                    ICF_PRINT(("\n[SSA]:icf_ssa_parse_unknown_header_like_from_hdr():Header Value is not present"));
                    sip_freeSipHeader(*p_p_parsed_hdr);
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            *p_p_parsed_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)                    
                    sip_freeSipHeader(&dHeader);
                    ret_val = ICF_FAILURE ;
                    break;
                }                
                buf_count=icf_port_strlen(((SipUnknownHeader *)
                        (dHeader.pHeader))->pBody);
                pBuffer = (((SipUnknownHeader *)
                            (dHeader.pHeader))->pBody);
#endif
                /* parse the Required header as per From Header */
                if(SipFail == sip_parseFromHeader(
                            pBuffer,pBuffer+buf_count-1,
                            *p_p_parsed_hdr,
                            SipHdrTypeFrom,&err))
                {
                    sip_freeSipHeader(*p_p_parsed_hdr);
                    /*
                     * The SipHeader structure contains 2 fields,one being the
                     * type of header and second being a void pointer
                     * The call to sip_freeSipHeader fress the memory
                     * corresponding to the specific header according to 
                     * the type but doesn't free the top level structure.
                     * Hence,invoke a memfree on the top level structure
                     */
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            *p_p_parsed_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)
                    ret_val = ICF_FAILURE ;
                    break;
                }
            }
        }
        sip_freeSipHeader(&dHeader);
    }
  
    if(ICF_FAILURE == ret_val)
    {
        *p_p_parsed_hdr = ICF_NULL;
        sip_freeSipHeader(&dHeader);
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_dealloc_call_cntxt_blk
 *
 * DESCRIPTION: The function would free the msgbodylist,tags,headers 
 *                in call context and then frees hash mapping for outgoing call 
 *              and adds the block to free blocks list
 *
 * RETURNS: icf_return_t (SUCCESS)
 *
************************************************************************/  
icf_return_t 
icf_ssa_dealloc_call_cntxt_blk(
       INOUT  icf_glb_pdb_st                    *p_glb_pdb,
       INOUT     icf_call_ctx_st                   *p_call_ctxt,
       OUT   icf_error_t                       *p_ecode)
{
    icf_return_t        ret_val = ICF_SUCCESS;
#ifdef ICF_QOS_SUPPORT
#ifdef IMS_CLIENT
#ifdef ICF_NW_ACTIVATE
    icf_return_t        memfree_retval = ICF_SUCCESS;
#endif
#endif
#endif
    icf_list_st         *p_temp_list_node = ICF_NULL;

    ICF_FUNCTION_ENTER(p_glb_pdb)
    /*SPR 19590 code changes start */
    /*Free the list of header lists in call ctx*/
    p_temp_list_node = p_call_ctxt->p_list_of_header_list;
    while(ICF_NULL != p_temp_list_node)
    {
       if(ICF_NULL !=  p_temp_list_node->p_data)
       {    
          ret_val = icf_cmn_free_header_list(p_glb_pdb,
		 &(((icf_header_link_list_st*)(p_temp_list_node->p_data))->header_list),
		 p_ecode);
       }   
       p_temp_list_node = p_temp_list_node->p_next;
    }   
    if(ICF_NULL != p_call_ctxt->p_list_of_header_list)             
    {
	     ret_val = icf_cmn_delete_list(p_glb_pdb,
			&(p_call_ctxt->p_list_of_header_list),ICF_MEM_COMMON);  
    }
    
    /*Free the lists of tag list in call ctx*/
    p_temp_list_node = p_call_ctxt->p_list_of_tag_list;
    while(ICF_NULL != p_temp_list_node)
    {
       if(ICF_NULL != p_temp_list_node->p_data)
       {    
           ret_val = icf_cmn_free_tag_list(p_glb_pdb,
		       &(((icf_tag_link_list_st*)(p_temp_list_node->p_data))
                 ->tag_list),
		       p_ecode);
       }   
       p_temp_list_node = p_temp_list_node->p_next;
    }   
    if(ICF_NULL != p_call_ctxt->p_list_of_tag_list)             
    {
	   ret_val = icf_cmn_delete_list(p_glb_pdb,
			&(p_call_ctxt->p_list_of_tag_list),ICF_MEM_COMMON);
    }   

    /*Free the lists of body list in call ctx*/
    p_temp_list_node = p_call_ctxt->p_list_of_body_list;
    while(ICF_NULL != p_temp_list_node)
    {
       if(ICF_NULL != p_temp_list_node->p_data)
       {    
           ret_val = icf_cmn_free_msg_body_list(p_glb_pdb,
		       &(((icf_msg_body_link_list_st*)(p_temp_list_node->p_data))
                 ->body_list),
		       p_ecode);
       }   
       p_temp_list_node = p_temp_list_node->p_next;
    }   
    if(ICF_NULL != p_call_ctxt->p_list_of_body_list)             
    {
	   ret_val = icf_cmn_delete_list(p_glb_pdb,
			&(p_call_ctxt->p_list_of_body_list),ICF_MEM_COMMON);  
    }
    p_call_ctxt->last_txn_id = ICF_INVALID_TXN_ID;
    p_call_ctxt->txn_id = ICF_INVALID_TXN_ID;
    /*Free the pending event list in call context*/
    p_temp_list_node = p_call_ctxt->p_pending_event_list;
    while(ICF_NULL != p_temp_list_node)
    {    
        if(ICF_NULL != p_temp_list_node->p_data)
        {
            ICF_MEMFREE(p_glb_pdb,
                 p_temp_list_node->p_data,
                 ICF_MEM_COMMON,
                 p_ecode, ret_val)
        }
        p_temp_list_node = p_temp_list_node->p_next;
    }   
    if(ICF_NULL != p_call_ctxt->p_pending_event_list)             
    {
	   ret_val = icf_cmn_delete_list(p_glb_pdb,
			&(p_call_ctxt->p_pending_event_list),ICF_MEM_COMMON);  
    }
    /*SPR 19590 code changes start */

    /* reset the list of additional streams */
    icf_cmn_free_stream_sdp_info_list(p_glb_pdb, 
                &(p_call_ctxt->p_stream_sdp_info), p_ecode);

#ifdef ICF_QOS_SUPPORT
#ifdef IMS_CLIENT
#ifdef ICF_NW_ACTIVATE
ICF_CHECK_QOS_SUPPORT_START(p_glb_pdb,ICF_TRUE)
ICF_CHECK_IMS_START(p_glb_pdb,ICF_TRUE)
    /* Free memory for P-Media-Authorization header */
    if (ICF_NULL != p_call_ctxt->p_auth_token)
    {
        ICF_MEMFREE(p_glb_pdb, p_call_ctxt->p_auth_token,
            ICF_MEM_COMMON, p_ecode, memfree_retval)

        p_call_ctxt->p_auth_token = ICF_NULL;
    }
ICF_CHECK_IMS_END
ICF_CHECK_QOS_SUPPORT_END
#endif
#endif
#endif

    /* Finally De allocate call context */
     icf_dbm_dealloc_call_cntxt_blk(p_glb_pdb,
                p_call_ctxt->call_id,
                p_ecode);

    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}

#ifdef ICF_QOS_SUPPORT
#ifdef IMS_CLIENT
#ifdef ICF_NW_ACTIVATE
/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_extract_media_authorization_token
 *
 * DESCRIPTION: The function extracts P-Media-Authorization header from
 *                sip message and fills its value in call context.
 *              
 *
 * RETURNS: icf_return_t 
 *
************************************************************************/  
icf_return_t 
icf_ssa_extract_media_authorization_token(
       INOUT  icf_ssa_pdb_st          *p_ssa_pdb,
       INOUT     SipMessage                    *pSipMsg)
{
    en_HeaderType                 dType = SipHdrTypeAny;    
    Sdf_ty_u32bit                dCount = 0;
    icf_uint8_t              header_name[ICF_MAX_STR_LEN] = "P-Media-Authorization"; 
    SipError                    sip_err = 0;
    icf_uint32_t             header_index = ICF_NULL;
    SipUnknownHeader    *p_unknown_hdr = SIP_NULL;
    icf_return_t             ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
     /* Find the header type for the header name */
    icf_ssa_get_hdr_type_from_name(header_name, &dType, &sip_err);
        
    /* There can be multiple hdrs for that type */
    if (SipFail == sip_getHeaderCount(pSipMsg, dType, &dCount,
        (SipError *)&sip_err))
    {
        /*ICF_SSA_TRACE(("\nFailed to get Header Count "))*/
        ret_val  = ICF_FAILURE;
    }
    else if (0 == dCount)
    {
        /*ICF_SSA_TRACE(("\nP-Media-Authorization Header not present "))*/
        ret_val  = ICF_SUCCESS;
    }
    else
    {
        for (header_index = 0; header_index < dCount; header_index++)
        {
            if (Sdf_co_fail == sip_listGetAt(
                &(pSipMsg->
                pGeneralHdr->slUnknownHdr),
                header_index,(Sdf_ty_pvoid *)&p_unknown_hdr,
                &(sip_err)))
            {
                ICF_PRINT(("\n[SSA]: Failure in getting the pHeader from list"));
                ret_val = ICF_FAILURE;
                break;
            }
            else if ( ICF_NULL ==
#ifdef ICF_WITH_MUATK_2_2
                icf_port_strcmp(p_unknown_hdr->pStr1, header_name))
#else
                icf_port_strcmp(p_unknown_hdr->pName, header_name))
#endif
            {

#ifdef ICF_WITH_MUATK_2_2
                icf_uint8_t       *p_value = p_unknown_hdr->pStr2;
#else
                icf_uint8_t       *p_value = p_unknown_hdr->pBody;
#endif
                /* If header is being allocated for the first time */
                if (ICF_NULL == p_ssa_pdb->p_glb_pdb->p_call_ctx->p_auth_token)
                {
                    /* Allocate memory for header value in call context */
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        ICF_PORT_SIZEOF(icf_nm_auth_token_st),
                        ICF_MEM_COMMON, 
                        (icf_void_t*)(p_ssa_pdb->p_glb_pdb->p_call_ctx->p_auth_token),
                        ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)    
                }
                /* Copy authorization token in call context */
                icf_port_strcpy(p_ssa_pdb->p_glb_pdb->p_call_ctx->p_auth_token->octets,
                    p_value);

                p_ssa_pdb->p_glb_pdb->p_call_ctx->p_auth_token->num_of_octets = 
                    icf_port_strlen(p_value);

                ret_val = ICF_SUCCESS;
                break; /* We are taking only first authorization header */
            }
        } /* end of loop on headers */
    } /* End of else */

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
#endif
#endif
#endif

/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_populate_app_specific_hdrs
 *
 * DESCRIPTION: The function populates the application specific headers as  
 *              provided by the application during APP ADD in the call context.
 *              It also provides the contact header list if
 *              contact_list_required filed is configured through
 *              API ICF_REGISTER_REQ.
 *              
 *
 * RETURNS: icf_return_t 
 *
************************************************************************/  
icf_return_t 
icf_ssa_populate_app_specific_hdrs(
       INOUT  icf_ssa_pdb_st                        *p_ssa_pdb,
       INOUT    icf_uint8_t                            module_id,
       INOUT    icf_void_t                            *p_ctx,
       INOUT     SipMessage                                *pSipMsg,       
       OUT   icf_error_t                            *p_ecode)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_app_conf_st*            p_app_conf = ICF_NULL;
    icf_uint32_t                iterator1=0,index=0;
    icf_header_st**            p_p_hdr = ICF_NULL;
    icf_header_list_st*        p_hdr_list = ICF_NULL;
    icf_uint8_t*                p_temp_buff = ICF_NULL;
    icf_header_name_st*        p_name = SIP_NULL;
    en_HeaderType                 dType = SipHdrTypeAny;    
    Sdf_ty_u32bit                dCount = 0;
    icf_uint8_t*                p_token = ICF_NULL;
    icf_int8_t*                p_remainingbuff = ICF_NULL;
    SipError                    sip_err = 0;
    /* This is used as a temporary string for storing header name
     * along with a ":" or any one extra character as FSS sip stack
     * inserts "\0" in place of last character.
     */
    icf_uint8_t              pString[ICF_MAX_STR_LEN + 1] = "";
    icf_app_id_t                app_id = 0;
    icf_return_t             return_val = ICF_SUCCESS;
    icf_header_link_list_st*    p_temp_hdr_list = ICF_NULL;
        
    if ((ICF_NULL == p_ssa_pdb) || (ICF_NULL == p_ssa_pdb->p_glb_pdb))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA] : Either SSA Pdb or GLB Pdb is NULL"));
        return ICF_FAILURE;
    }        
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if ( ICF_INT_MODULE_CC == module_id)
    {
        ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                                            p_ctx,
                                            return_val)
        if (ICF_FAILURE == return_val)
        {
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return ret_val;
        }
        app_id = ((icf_call_ctx_st*)p_ctx)->app_id;
        /*SPR 19590 code changes start */
        /*Allocate memory for the new node*/
        ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
            ICF_PORT_SIZEOF(icf_header_link_list_st),ICF_MEM_COMMON,\
            p_temp_hdr_list,\
            ICF_RET_ON_FAILURE,\
            p_ecode, ret_val);
       
        /*Assign the txn id to the new node*/
        p_hdr_list = &(p_temp_hdr_list->header_list);
        p_temp_hdr_list->txn_id = ((icf_call_ctx_st*)p_ctx)->txn_id;

        /*Add node to call ctx lists of hdr list */
        ret_val = icf_cmn_add_node_to_list(p_ssa_pdb->p_glb_pdb,\
                    &(((icf_call_ctx_st*)p_ctx)->p_list_of_header_list),\
                   p_temp_hdr_list);
        /*SPR 19590 code changes end */
    }
    else if( ICF_INT_MODULE_REGM == module_id )
    {
        icf_uint32_t            loop_app= ICF_NULL;

        ICF_CHECK_IF_ANY_OF_TWO_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                                 p_ssa_pdb->p_glb_cfg_data,
                                 p_ctx,
                                 return_val)
        if (ICF_FAILURE == return_val)
        {
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return ret_val;
 
        }
        
        for (loop_app = 0; loop_app < p_ssa_pdb->p_glb_cfg_data->max_applications;
                            loop_app++)
        {
            ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                                     ((icf_rgm_context_st*)p_ctx)->p_app_data_list+loop_app,
                                     return_val)
            if (ICF_FAILURE == return_val)
            {
                ret_val = ICF_FAILURE;
                ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                return ret_val;

            }
            if (ICF_TRUE == ((icf_rgm_context_st*)p_ctx)->p_app_data_list[loop_app].is_valid)
            {
                /* SPR 19746: The header list is not sent in ICF_REGISTER_STATUS_IND API as 
                 * the check was ICF_REGISTER_CFM specific. Any specific check is removed as
                 * header list should apways be given to application.
                 */ 
                app_id = ((icf_rgm_context_st*)p_ctx)->p_app_data_list[loop_app].app_id;
                p_hdr_list = 
                    &(((icf_rgm_context_st*)p_ctx)->p_app_data_list[loop_app].inc_header_list);

                /*patch*/
                if( p_hdr_list->count)
                {
                    /*free the list*/
                    icf_cmn_free_header_list(p_ssa_pdb->p_glb_pdb,
                            p_hdr_list,
                            p_ssa_pdb->p_ecode);
                }
                break;
            }

        }/* for loop on app_data_list ends */
   
        /* If the below condition is TRUE means do not required to process
         * further since the application have not asked for any header list.
         * The variable p_hdr_list indicates the header list configured
         * app add request and contact_list_required field indicates the 
         * contact list required by application which contains the contact
         * header(s) other than local contact as obtained in the 200 OK
         * response for REGISTER request.
         */    
        if ((ICF_NULL == p_hdr_list) && 
            (ICF_FALSE == ((icf_rgm_context_st*)p_ctx)->contact_list_required))
          return ICF_SUCCESS;
    }


    else if(ICF_INT_MODULE_SIC == module_id)
    {
        ICF_CHECK_IF_ANY_OF_TWO_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                                            p_ctx,
                                            p_ssa_pdb->p_glb_cfg_data,
                                            return_val)
        if(ICF_FAILURE == return_val)
        {
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return ret_val;
        }
        app_id = ((icf_sic_ctx_st*)p_ctx)->app_id;
        p_hdr_list = &(((icf_sic_ctx_st*)p_ctx)->header_list);
    }
    else
    {
        return ICF_SUCCESS;
    }

   /* If the below condition is TRUE, it indicates that the
    * contact_list field in regm_context should be populated with
    * the contact header(s) other than local contact as obtained
    * in the 200 OK response for REGISTER request.
    */
   /*SPR 19476 We need to extract the contact list only if the response
     is 200OK. Therefore added the check for response code when invoking
     icf_ssa_extract_contact_list_from_register_resp. The response code
     gets populated in sdf_cbk_uaTransactionCompleted */
   if((ICF_INT_MODULE_REGM == module_id) &&
      (ICF_TRUE == ((icf_rgm_context_st*)p_ctx)->contact_list_required)&&
      (200 == p_ssa_pdb->resp_code))
   {
      if(ICF_FAILURE == icf_ssa_extract_contact_list_from_register_resp(
                                  p_ssa_pdb,((icf_rgm_context_st*)p_ctx),
                                                       pSipMsg, p_ecode))
      {
          /* Free any node populated in contact_list */
          icf_cmn_free_header_list(
                p_ssa_pdb->p_glb_pdb,
	          	&((icf_rgm_context_st*)p_ctx)->contact_list,
				p_ssa_pdb->p_ecode);
          ret_val = ICF_FAILURE;
          ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
          return ret_val;
      }
   }

    /* Pass the application id to get app specific data from dbm */
    if (ICF_FAILURE == icf_cfg_fetch_app_conf(
        p_ssa_pdb->p_glb_pdb, app_id, &p_app_conf, p_ecode))
    {
/*        ICF_SSA_TRACE(("\nSSA Fetch App Conf Data Func Failed"))*/
            ret_val = ICF_SUCCESS;
    }
    
    /* Assign p_app_conf->call_type to p_call_ctx->call_type if NFS call */
    else if(ICF_NULL != p_app_conf)
    {
        if(( ICF_INT_MODULE_CC == module_id) &&
           ((icf_call_ctx_st*)p_ctx)->call_type == ICF_NULL)
        {
            if(ICF_NULL != p_app_conf->call_type)
            {
            /* Assign default type as specified by app */
            ((icf_call_ctx_st*)p_ctx)->call_type = p_app_conf->call_type;
            }
            else
            {
                ((icf_call_ctx_st*)p_ctx)->call_type = ICF_CALL_TYPE_AUDIO;
            }
        }
        
        /* Take out hdr info, which hdrs are required by application */
        if ((p_app_conf->hdr_list.count != 0) &&
            (ICF_NULL != p_hdr_list))
        {
            /* Assign pointers to start of list */
            p_name = p_app_conf->hdr_list.hdr;
            
            /* Iterate through all the headers */ 
            for (p_p_hdr = &(p_hdr_list->hdr) ,iterator1 = 0; 
            iterator1 < p_app_conf->hdr_list.count; 
            iterator1++,p_name = p_name->next)
            {
                
                /* This is a temporary patch due to incorrect behaviour 
                 * of sip stack we have to insert one extra character in name 
                 * before passing it to sip_getTypeFromName.
                 */

                ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                                         p_name,
                                         return_val)
                if (ICF_FAILURE == return_val)
                {
                   ret_val = ICF_FAILURE;
                   ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                   return ret_val;
                }

                icf_port_strcpy(pString, p_name->hdr_name.str);
                if(0 == Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pString,(Sdf_ty_s8bit *)"req-uri"))
                {
                    /* Initialize the string */
                    /* Rel 8.2 Klocworks fix */
                   	/* Codenomicon fixes: CSR 1-7132323: SPR 19484 */
					/* Req-line should be large string */
                     icf_large_string_st req_line = {0,"\0"};
                    /* Rel 8.2 Klocworks fix end */
                    /* Extract the req-uri */
                    if(ICF_FAILURE == icf_ssa_get_reqline_as_string(pSipMsg, req_line.str))
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else 
                    {
                        if(0 == icf_port_strcmp(req_line.str,(icf_uint8_t *)""))
                        {
                            /* No request uri extracted, continue */
                            continue;
                        }
                        /* allocate memory for first header node and add to List*/
                        ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                            ICF_PORT_SIZEOF(icf_header_st),
                            ICF_MEM_COMMON, 
                            *p_p_hdr,
                            ICF_DONOT_RET_ON_FAILURE, p_ecode, ret_val)
                        
                    }
                    if (ICF_FAILURE == ret_val)
                    {
                        return ICF_FAILURE;
                    }
                    else
                    {
                        (*p_p_hdr)->next = ICF_NULL;
                        /* Increment the node pointer */
                        /* Populate Name/Value for header in call context */                
                        icf_port_strncpy((icf_int8_t *)(*p_p_hdr)->hdr_name.str,
								(const icf_int8_t *)pString, ICF_MAX_STR_LEN - 2);
                        (*p_p_hdr)->hdr_name.str[ICF_MAX_STR_LEN - 1] = '\0';
                        (*p_p_hdr)->hdr_name.str_len = (icf_uint16_t)icf_port_strlen((*p_p_hdr)->hdr_name.str);
                        
                       
                        icf_port_strncpy((icf_int8_t *)(*p_p_hdr)->hdr_value.str,
								(const icf_int8_t *)req_line.str, ICF_MAX_LARGE_STR_LEN - 2);
                        (*p_p_hdr)->hdr_value.str[ICF_MAX_LARGE_STR_LEN - 1] = '\0';
                        (*p_p_hdr)->hdr_value.str_len = (icf_uint16_t)icf_port_strlen((*p_p_hdr)->hdr_value.str);
 
                        p_hdr_list->count++;
                        p_p_hdr = &((*p_p_hdr)->next);
                    }
                    continue;
                }

                /* Find the header type for the header name */
                icf_ssa_get_hdr_type_from_name(pString, &dType, &sip_err);
                
                
                /* There can be multiple hdrs for that type */
                if (sip_getHeaderCount(pSipMsg, dType, &dCount, \
                    &sip_err) == SipFail)
                {
                    ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                                                        pSipMsg,
                                                        return_val)
                    if (ICF_FAILURE == return_val)
                    {
                        ret_val = ICF_FAILURE;
                        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                        return ret_val;
                    }
                    if (SipMessageResponse == pSipMsg->dType 
                        && SipTrue != isSipReqHeader(dType))
                    {
                        /*ICF_SSA_TRACE(("\nFailed to get Header Count "))*/
                        return ICF_FAILURE;
                    }
                    else
                    {
                        dCount = 0;
                    }
                }
                /* Iterate through the list to get all headers of type dType*/
                /* Fix for CSR 1-7160359: SPR 19509 */
				/* Max of 30 headers will be populated because CLIB's unpack logic does not permit
			     * list size beyond 30 (ICF_CLIB_MAX_LIST_NODES).
                 */
                 for(index = 0; (index < dCount) && (ICF_NULL != p_hdr_list)
                         && (ICF_CLIB_MAX_LIST_NODES > p_hdr_list->count)
                        ; index++)
                {
                    /* Construct Header from SipMessage */
                    /* SPR 19218 : Merged CSR 1-6457307 :
                       If the following function returns failure, p_temp_buff
                       will be NULL.In such a case continue without further
                       processing 
                    */  
                    /* Fix for CSR 1-7233780: SPR 19671 */
					/* Use IPTK enhanced sip accesssor API for optimized performance */
					if (SipFail == sip_getIPTKHeaderAsStringAtIndex(
                                                      pSipMsg,dType,
                                                      ((SIP_S8bit **)&p_temp_buff),
                                                      index,
                                                      &sip_err))
                    {
                        continue;
                    }
                    
                    /* Tokenize the : separated string into hdr name/value.*/
                    p_token = (icf_uint8_t *)icf_port_strtokr((icf_int8_t *)p_temp_buff,(const icf_int8_t *)":",&p_remainingbuff); 
                    if (ICF_NULL == p_token)
                    {                    
                        ret_val = ICF_FAILURE;
                    }
                    
                    /* If unknown header compare with the required header.
                    * If matches, allocate memory and store in call ctxt,
                    * else continue with next header from list.
                    */
                    else if ( (dType == SipHdrTypeUnknown) && 
                        (0 != icf_port_strcasecmp((const icf_int8_t *)p_name->hdr_name.str,(const icf_int8_t *)p_token)) )
                    {
                        if (ICF_NULL != p_temp_buff)
                        {
                            /* free the memory allocated for p_temp_buff */
                            fast_memfree(0, p_temp_buff, &sip_err);
                        }
                        continue;
                    }
                    
                    else
                    {
                        /* allocate memory for header node and add to List*/
                        ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                            ICF_PORT_SIZEOF(icf_header_st),
                            ICF_MEM_COMMON, 
                            *p_p_hdr,
                            ICF_DONOT_RET_ON_FAILURE, p_ecode, ret_val)
                    }
                    
                    if (ICF_FAILURE == ret_val)
                    {
                        if (ICF_NULL != p_temp_buff)
                        {
                            /* free the memory allocated for p_temp_buff */
                            fast_memfree(0, p_temp_buff, &sip_err);
                        }
                        return ICF_FAILURE;
                    }
                    
                    
                    /* Increment the header count by one */
                    p_hdr_list->count++;
                    (*p_p_hdr)->next = ICF_NULL;
                    
                    /* Populate Name/Value for header in call context */                
                    icf_port_strncpy((icf_int8_t *)(*p_p_hdr)->hdr_name.str,
							(const icf_int8_t *)p_token,\
                              ICF_MAX_STR_LEN-2);
                    (*p_p_hdr)->hdr_name.str[ICF_MAX_STR_LEN - 1]='\0';
                    (*p_p_hdr)->hdr_name.str_len = (icf_uint16_t )icf_port_strlen((*p_p_hdr)->hdr_name.str);
                    
                    if (p_remainingbuff) 
						icf_port_strncpy((icf_int8_t *)(*p_p_hdr)->hdr_value.str,
								(const icf_int8_t *)p_remainingbuff, ICF_MAX_LARGE_STR_LEN - 2);
                    (*p_p_hdr)->hdr_value.str[ICF_MAX_LARGE_STR_LEN - 1] = '\0';
                    (*p_p_hdr)->hdr_value.str_len = (icf_uint16_t)icf_port_strlen((*p_p_hdr)->hdr_value.str);

                    /* Move pointer to next node */
                    p_p_hdr = &((*p_p_hdr)->next);
                    
                    if (ICF_NULL != p_temp_buff)
                    {
                        /* free the memory allocated for p_temp_buff */
                        fast_memfree(0, p_temp_buff, &sip_err);
                    }
                                    
                }
                /* Move forward in app list */
            } /* for ends */
        } /* if ends */

        /* 
           Asynchronous NOTIFY Support : In case application has enabled
           support of asynchronous NOTIFY, we will also clone the header
           list in SIC context's header_list_backup. This will be used 
           in case we are awaiting NOTIFY confirmation from the 
           application and a response is received to the SUBSCRIBE
           request sent. In such a scenario, the response received 
           will be marked as a pending event. The backup taken here 
           will be used while handling the pending event, after the 
           NOTIFY received has been responded to.
           We will take a backup only if the curent SIC FSM state is 
           ICF_SIC_05_AWAIT_NOTIFY_CFM.
        */
        if((ICF_INT_MODULE_SIC == module_id) &&
           (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->async_notify_support_reqd) &&
           (ICF_SIC_05_AWAIT_NOTIFY_CFM == ((icf_sic_ctx_st*)p_ctx)->sic_state)) 
        {
            /* Free existing list, if any */
            icf_cmn_free_header_list(p_ssa_pdb->p_glb_pdb, 
                &(((icf_sic_ctx_st*)p_ctx)->header_list_backup), 
                p_ecode);
            
            /* clone header_list into header_list_backup */
            icf_cmn_clone_header_list(p_ssa_pdb->p_glb_pdb,
                &(((icf_sic_ctx_st*)p_ctx)->header_list),
                &(((icf_sic_ctx_st*)p_ctx)->header_list_backup),
                p_ecode);
        }
    }
    else if(ICF_NULL == p_app_conf)
    {
        if(( ICF_INT_MODULE_CC == module_id) &&
           ((icf_call_ctx_st*)p_ctx)->call_type == ICF_CALL_TYPE_INVALID)
        {
            /* Assign default type as specified by app */
            ((icf_call_ctx_st*)p_ctx)->call_type = ICF_CALL_TYPE_AUDIO;
        }
    }

    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}





/*****************************************************************************
 * FUNCTION:         icf_ssa_insert_unknown_hdr_in_sip_msg
 *
 * DESCRIPTION:     This function forms and inserts an unknown 
 *                    header into the SIP message passed  to it
 *                    The name of the header and the contents are
 *                    passed to this function.
 * 
 *****************************************************************************/
 icf_return_t icf_ssa_insert_unknown_hdr_in_sip_msg(
         INOUT      icf_ssa_pdb_st   *p_ssa_pdb,
         INOUT      icf_uint8_t      *p_hdr_name,
         INOUT      icf_uint8_t      *p_hdr_contents,
         INOUT    SipMessage          *p_sip_msg)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_return_t memfree_retval;
    SipHeader    *p_sip_header = SIP_NULL;
    SipError    sip_error;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
#ifdef ICF_STRICT_TEST    
    if(ICF_NULL == p_hdr_contents)
    {
        ICF_ALARM(((icf_uint8_t *)" :[SSA]: Invalid Value in unknown header\n"));
        ret_val=ICF_FAILURE;
    }
    else if(ICF_NULL == *p_hdr_contents)
    {
        ICF_ALARM(((icf_uint8_t *)" :[SSA]: Invalid Value in unknown header\n"));
        ret_val = ICF_FAILURE;
    }
    else
#endif
    if (SipFail == sip_initSipHeader(&p_sip_header, SipHdrTypeUnknown, &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to init SIP header"));
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == sip_setNameInUnknownHdr(p_sip_header, sip_strdup((const icf_int8_t *)p_hdr_name, 0), &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to Set name in SIP header"));
        sip_freeSipHeader(p_sip_header);
        ret_val = ICF_FAILURE;
    }
     else if (SipFail == sip_setBodyInUnknownHdr(p_sip_header, sip_strdup((const icf_int8_t *)p_hdr_contents, 0), &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to Set body in SIP header"));
        sip_freeSipHeader(p_sip_header);
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == sip_insertHeaderAtIndex(p_sip_msg, p_sip_header, 0, &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to Set Header at index in SIP header"));
        sip_freeSipHeader(p_sip_header);
        ret_val = ICF_FAILURE;
    }

    sip_freeSipHeader(p_sip_header);
    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, p_sip_header,
        ICF_MEM_COMMON, p_ssa_pdb->p_ecode, memfree_retval)

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;
}







/*****************************************************************************
 * FUNCTION:         icf_ssa_insert_header_list_in_sip_msg
 *
 * DESCRIPTION:         This function inserts the header linked list into a
 *            SIP message passed  to it. The clear_list parameter specifies whether 
 *            the memory associated with this list is to be freed or not
 *            if Set to true the memory is freed.
 * 
 *****************************************************************************/
icf_return_t icf_ssa_insert_header_list_in_sip_msg(
         INOUT      icf_ssa_pdb_st*        p_ssa_pdb,
         INOUT      icf_header_list_st*  p_hdr_list,
         INOUT      icf_boolean_t        clear_list,
         INOUT    SipMessage*             p_sip_msg)
{



    icf_uint16_t list_count    = ICF_NULL;
    icf_header_st* p_hdr = ICF_NULL;
    icf_error_t ecode;
    icf_return_t ret_val = ICF_SUCCESS;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) 

    if (ICF_NULL == p_hdr_list)
    {
        return ICF_SUCCESS;
    }

    list_count = (icf_uint16_t )p_hdr_list->count;
    p_hdr = p_hdr_list->hdr;

    while (list_count > 0 && ICF_NULL != p_hdr) 
    {     
           if(((icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"CSeq"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"Call-ID"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"To"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"From"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"Via"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"Contact"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"Route"))&&
             (icf_port_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str,(const icf_int8_t *)"Content-Length")))&& 
             (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                  p_ssa_pdb, 
                  p_hdr->hdr_name.str,
                  p_hdr->hdr_value.str,
                  p_sip_msg)))
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header"));
                ret_val = ICF_FAILURE;
                break;
        }
        list_count = (icf_uint16_t)(list_count - 1);
        p_hdr = p_hdr->next;
    }

    
    /* Free this list*/
    if((ICF_TRUE == clear_list) && (p_hdr_list->count > 0))
    {
        if ( ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx)
        {
            icf_cmn_free_header_list(p_ssa_pdb->p_glb_pdb, 
                &(p_ssa_pdb->p_glb_pdb->p_call_ctx->persistent_header_list), 
                &ecode);
            
            icf_cmn_clone_header_list(p_ssa_pdb->p_glb_pdb,
                p_hdr_list,
                &(p_ssa_pdb->p_glb_pdb->p_call_ctx->persistent_header_list),
                &ecode);
        }
        /*SPR 19886 Fix for CSR 1-7208970 If the invite is being sent
         do not free the header list as this may be required to send
         redirected INVITE*/
        if((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) &&
           (ICF_FALSE == p_ssa_pdb->p_ssa_ctxt->invite_being_sent))
        {    
           icf_cmn_free_header_list(p_ssa_pdb->p_glb_pdb, p_hdr_list, &ecode);
        }   
        
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;

}








/*****************************************************************************
 * FUNCTION:         icf_ssa_insert_tag_list_in_sip_msg
 *
 * DESCRIPTION:         This function inserts the tag linked list into a
 *            SIP message passed  to it. The clear_list parameter specifies whether 
 *            the memory associated with this list is to be freed or not
 *            if Set to true the memory is freed.
 * 
 *****************************************************************************/

icf_return_t icf_ssa_insert_tag_list_in_sip_msg(
        INOUT      icf_ssa_pdb_st*      p_ssa_pdb,
        INOUT      icf_tag_list_st*     p_tag_list,
        INOUT      icf_boolean_t        clear_list,
        INOUT    SipMessage*                p_sip_msg)
{

    
    icf_uint16_t list_count = ICF_NULL;
    icf_tag_st* p_tag = ICF_NULL;
    icf_error_t ecode;
    icf_return_t ret_val = ICF_SUCCESS;
    icf_uint8_t    *p_method=ICF_NULL;
    Sdf_st_error    SdfError;
    en_HeaderType hdr_type = SipHdrTypeAny;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) 
    
    list_count = (icf_uint16_t)p_tag_list->count;
    p_tag = p_tag_list->tag;

    sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg,((Sdf_ty_s8bit **)&p_method),&SdfError);
    
    while (list_count > 0 && ICF_NULL != p_tag) 
    {
        if(0 == Sdf_mc_strcasecmp((Sdf_ty_s8bit*)p_tag->hdr_name.str,(Sdf_ty_s8bit*)"req-uri"))
        {
            SipReqLine *pReqLine=ICF_NULL;
            SipAddrSpec    *p_addr_spec = SIP_NULL;
            SipError sip_err;
            if (SipFail == sip_getReqLineFromSipReqMsg(p_sip_msg,
                &pReqLine,&sip_err))
            {
                return ICF_FAILURE;
            }
#ifdef ICF_WITH_MUATK_2_2
            p_addr_spec = pReqLine->pAddrSpec;
#else
            p_addr_spec = pReqLine->pRequestUri;
#endif
            if (p_tag->tag_type & ICF_TAG_TYPE_SIP_URI_PARAM)
            {
                icf_ssa_append_sip_uri_param_in_addr_spec(
                    p_ssa_pdb,p_tag->tag_value.str,p_addr_spec);
            }
            else if (p_tag->tag_type & ICF_TAG_TYPE_SIP_URI_HDR_PARAM)
            {
                icf_ssa_append_sip_uri_hdr_param_in_addr_spec(
                    p_ssa_pdb,p_tag->tag_value.str,p_addr_spec);
            }
            else if (p_tag->tag_type & ICF_TAG_TYPE_HDR_PARAM)
            {
                ICF_PRINT(
                    ((icf_uint8_t *)"\n[SSA]: Ignoring Tag-Value=%s,Tag-Type=HDR_PARAM in req-uri\n",
                    p_tag->tag_value.str));
            }
            else
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Ignoring Invalid Tag-Type\n"));
            }
            sip_freeSipReqLine(pReqLine);
        }
        else
        {
            icf_ssa_get_hdr_type_from_name(p_tag->hdr_name.str, &hdr_type,
                (SipError*)&SdfError.stkErrCode);
            
            if( p_method && ((!icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") &&
                ((hdr_type == SipHdrTypeContactNormal)   ||
                (hdr_type == SipHdrTypeContactWildCard) ||
                (hdr_type == SipHdrTypeContactAny)
                )
                )
                ))
            {
            /* We will not append the tag to contact list of
            * Register request as while making the contact 
                * address this thing has taken care of */
            }
            
            else if (ICF_FAILURE == icf_append_tag_params_to_hdr(
                p_ssa_pdb, p_tag, p_sip_msg))
                
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to append tag to header"));
                ret_val = ICF_FAILURE;
                break;
            }
        }
        list_count = (icf_uint16_t )(list_count - 1);
        p_tag = p_tag->next;
    }
  
    /* Free this list*/
    /*SPR 19886 Fix for CSR 1-7208970 If the invite is being sent
      do not free the tag list as this may be required to send
      redirected INVITE*/
     if((ICF_TRUE == clear_list) && (p_tag_list->count > 0) &&
             (ICF_NULL != p_ssa_pdb->p_ssa_ctxt) &&
             (ICF_FALSE == p_ssa_pdb->p_ssa_ctxt->invite_being_sent))
    {
        icf_cmn_free_tag_list(p_ssa_pdb->p_glb_pdb, p_tag_list, &ecode);
    }
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb) 
    return ret_val;  
}


/*****************************************************************************
 * FUNCTION:     icf_ssa_get_hdr_type_from_name
 * DESCRIPTION:  This function gets the Sip Header Type based on the header 
 *               string passed to it
 *****************************************************************************/
icf_void_t icf_ssa_get_hdr_type_from_name
        (icf_uint8_t *pName, en_HeaderType *pType, SipError *pError)
{
    en_HeaderForm     dForm;
    icf_uint8_t       *pTempStr = ICF_NULL;
    icf_uint32_t      dSize = 0;

    if (pName == SIP_NULL)
    {
        *pType = SipHdrTypeUnknown;
        return;
    }

    dSize = sip_strlen((icf_int8_t *)pName);
    pTempStr =(icf_uint8_t *)((char *) fast_memget(ACCESSOR_MEM_ID, dSize+1, SIP_NULL));
    if (pTempStr == SIP_NULL)
    {
        *pType = SipHdrTypeUnknown;
        return;
    }
    sip_strncpy((icf_int8_t *)pTempStr, (icf_int8_t *)pName, dSize);
    pTempStr[dSize]='\0';

    *pType = sip_getHeaderTypeFromString((icf_int8_t *)pTempStr, \
            (icf_int8_t *)(pTempStr + dSize), &dForm);
    
    fast_memfree(0, pTempStr , SIP_NULL);
    *pError = E_NO_ERROR;

}


/*****************************************************************************
 ** FUNCTION:           icf_ssa_validate_sip_uri_param_in_sip_url
 **
 ** DESCRIPTION:        This Function validates uri_parameters 
 **                        in the SipUrl. 
 **
 *****************************************************************************/
icf_return_t icf_ssa_validate_sip_uri_param_in_sip_url(
        icf_ssa_pdb_st    *p_ssa_pdb,
        SipUrl                *p_sip_url,
        icf_uint32_t        dType)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    SipError            dError;
    icf_uint32_t dCount = 0;
    icf_uint32_t index = 0;
    icf_uint8_t  *p_name = ICF_NULL;
    SipParam *p_param = ICF_NULL;
    icf_uint8_t   is_delete_param = ICF_FALSE;

    if(ICF_NULL == p_ssa_pdb)
    {
        return ICF_FAILURE;
    }
    
	p_ssa_pdb=p_ssa_pdb;
	    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    if ( SipFail !=
        sip_getUrlParamCountFromUrl(p_sip_url,&dCount,&dError))
    {
        for ( index = 0; index < dCount;index++)
        {
            /* if a parameter is deleted in previous iteration
             * then number of elements in the parameters List
             * will be reduced by one
             */
            if ( ICF_TRUE == is_delete_param && index != 0)
            {
                index--;
                dCount--;
                is_delete_param = ICF_FALSE;
            }

            if( SipFail !=
                sip_getUrlParamAtIndexFromUrl(p_sip_url,&p_param,index,&dError))
            {
                if( SipFail !=
                    sip_getNameFromSipParam(p_param,((SIP_S8bit **)&p_name),\
                    &dError))
                {
                    if( 0 == icf_port_strcmp((icf_uint8_t *)"ttl",p_name))
                    {
                        if( SipHdrTypeFrom == dType ||
                            SipHdrTypeTo == dType ||
                            SipHdrTypeContactNormal == dType ||
                            SipHdrTypeContactWildCard == dType ||
                            SipHdrTypeContactAny  == dType)
                        {
                            is_delete_param = ICF_TRUE;
                            ICF_ALARM(((icf_uint8_t *)" :[SSA]: ttl not allowed in "
                                "From/To/Contact Headers\n"));
                        }
                    }
                    else if( 0 == icf_port_strcmp((icf_uint8_t *)"maddr",p_name))
                    {
                        if( SipHdrTypeFrom == dType ||
                            SipHdrTypeTo == dType)
                        {
                            is_delete_param = ICF_TRUE;
                            ICF_ALARM(((icf_uint8_t *)"\n[SSA]: maddr not allowed in "
                                "From/To Headers\n"));
                        }
                    }
                    else if( 0 == icf_port_strcmp((icf_uint8_t *)"lr",p_name))
                    {
                        if( SipHdrTypeFrom == dType ||
                            SipHdrTypeTo == dType)
                        {
                            is_delete_param = ICF_TRUE;
                            ICF_ALARM(((icf_uint8_t *)" :[SSA]: lr not allowed in "
                                "From/To Headers\n"));
                        }
                    }
                    else if( 0 == icf_port_strcmp((icf_uint8_t *)"transport",p_name))
                    {
                        if( SipHdrTypeFrom == dType ||
                            SipHdrTypeTo == dType)
                        {
                            is_delete_param = ICF_TRUE;
                            ICF_ALARM(((icf_uint8_t *)" :[SSA]: transport not allowed in "
                                "From/To Headers\n"));
                        }
                    }
                    if ( ICF_TRUE == is_delete_param)
                    {
                        sip_deleteUrlParamAtIndexInUrl(p_sip_url,index,&dError);
                    }
                    sip_freeSipParam(p_param);
                    p_param = ICF_NULL;
                }    
            }
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/*****************************************************************************
 ** FUNCTION:           icf_ssa_append_sip_uri_param_in_sip_hdr
 **
 ** DESCRIPTION:        This Function Appends uri_parameters in the SIP Header
 **
 *****************************************************************************/
icf_return_t icf_ssa_append_sip_uri_param_in_sip_hdr(
        icf_ssa_pdb_st    *p_ssa_pdb,
        icf_uint8_t    *p_sip_uri_param,
        SipHeader        *p_header)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    SipAddrSpec            *p_addr_spec = ICF_NULL;
    SipError            dError;
    SipUrl                *p_sip_url = ICF_NULL;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    switch(p_header->dType)
    {
        case SipHdrTypeFrom:
        case SipHdrTypeRecordRoute:
        case SipHdrTypeReferTo:
        case SipHdrTypeRoute:
        case SipHdrTypeTo:
        case SipHdrTypeContactNormal:
        case SipHdrTypeContactWildCard:
        case SipHdrTypeContactAny:

            if ( SipFail != 
                sip_getAddrSpecFromCommonHdr(p_header,&p_addr_spec,&dError))
            {
                ret_val = icf_ssa_append_sip_uri_param_in_addr_spec(p_ssa_pdb,
                    p_sip_uri_param,p_addr_spec);
                if ( ICF_SUCCESS == ret_val)
                {
                    if ( SipFail != 
                        sip_getUrlFromAddrSpec(p_addr_spec,&p_sip_url,&dError))
                    {
                        icf_ssa_validate_sip_uri_param_in_sip_url(p_ssa_pdb,
                            p_sip_url,p_header->dType);
                        sip_freeSipUrl(p_sip_url);
                    }
                }
                sip_freeSipAddrSpec(p_addr_spec);
            }
            else
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]: SIP_URI paramter Ignored\n"));
                ret_val = ICF_FAILURE;
            }
        break;
        
        default :
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]: SIP_URI paramter Ignored\n"));
            ret_val = ICF_FAILURE;
            break;
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_append_sip_uri_hdr_param
 **
 ** DESCRIPTION:        This Function Appends sip_uri_headers in the SIP Header
 **
 *****************************************************************************/
icf_return_t icf_ssa_append_sip_uri_hdr_param_in_sip_hdr(
        icf_ssa_pdb_st    *p_ssa_pdb,
        icf_uint8_t        *p_sip_uri_hdr_param,
        SipHeader            *p_header)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    SipAddrSpec            *p_addr_spec = ICF_NULL;
    SipError            dError;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    switch(p_header->dType)
    {
        case SipHdrTypeRecordRoute:
        case SipHdrTypeReferTo:
        case SipHdrTypeRoute:
        case SipHdrTypeContactNormal:
        case SipHdrTypeContactWildCard:
        case SipHdrTypeContactAny:

            if ( SipFail != 
                sip_getAddrSpecFromCommonHdr(p_header,&p_addr_spec,&dError))
            {
                ret_val = icf_ssa_append_sip_uri_hdr_param_in_addr_spec(
                    p_ssa_pdb,p_sip_uri_hdr_param,p_addr_spec);
                sip_freeSipAddrSpec(p_addr_spec);
            }
            else
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]: SIP_URI header parameter, Ignored\n"));
                ret_val = ICF_FAILURE;
            }
            break;
        case SipHdrTypeTo:
        case SipHdrTypeFrom:
            ICF_ALARM(((icf_uint8_t *)" :[SSA]: SIP_URI header parameter, not allowed in To/From"));
            break;
        default :
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]: SIP_URI header parameter, Ignored\n"));
            ret_val = ICF_FAILURE;
            break;
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


/*****************************************************************************
 ** FUNCTION:           icf_ssa_append_sip_uri_param_in_addr_spec
 **
 ** DESCRIPTION:        This Function Appends uri_parameters in the addr spec
 **
 *****************************************************************************/
icf_return_t icf_ssa_append_sip_uri_param_in_addr_spec(
        icf_ssa_pdb_st    *p_ssa_pdb,
        icf_uint8_t    *p_sip_uri_param,
        SipAddrSpec        *p_addr_spec)
{
     icf_return_t        ret_val = ICF_SUCCESS;
    SipList                tmpList;
    SipUrl                *p_sip_url = ICF_NULL;
    SipParam            *p_param = ICF_NULL;
    SipError            dError;
    icf_uint32_t        dLength = 0;
    icf_uint32_t        dCount = 0;
    icf_uint32_t        dSize = 0;
    icf_uint32_t        index = 0;

    if(ICF_NULL == p_ssa_pdb)
    {
         return ICF_FAILURE;
    }   
    
	p_ssa_pdb=p_ssa_pdb;    
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /*for pEnd*/
    dLength = icf_port_strlen(p_sip_uri_param);
    dLength--;
    if ( p_addr_spec->dType == SipAddrSipUri ||
         p_addr_spec->dType == SipAddrSipSUri)
    {
        
         /* steps:
          * 1) Get the SipUrl from the Addr-Spec
          * 2) Call sip_parseSipParam to create a SipList
          *    from the tag_value(p_sip_uri_param) passed 
          *    by the application
          * 3) Extract each SipParam from the SipList and 
          *    append into SipUrl's SipList for uri-params
          */
        if ( SipFail !=
            sip_getUrlFromAddrSpec(p_addr_spec,&p_sip_url,&dError))
        {
            sip_listInit(&tmpList, __sip_freeSipParam, &dError);
            
            if( SipFail != sip_parseSipParam(&tmpList,
                (SIP_S8bit*)p_sip_uri_param,
                (SIP_S8bit*)(p_sip_uri_param+dLength),
                SipFalse,(SIP_S8bit)';',&dError))
            {
                sip_listSizeOf(&tmpList,&dSize,&dError);
                
                sip_getUrlParamCountFromUrl(p_sip_url,&dCount,&dError);
                
                for ( index = 0; index < dSize; index++)
                {
                    sip_listGetAt(
                        &tmpList,index,(SIP_Pvoid*)&p_param,&dError);
                    sip_listInsertAt(
                        (SipList*)&(p_sip_url->slParam),index+dCount,
                        (SIP_Pvoid*)p_param,&dError);
                }
                /* sip_listDeleteAll will call freefunc of SipParam and frees the */
                /* SipParam since dRefCount is One.*/
                tmpList.freefunc = ICF_NULL;
                sip_listDeleteAll(&tmpList,&dError);
                
            }
            else
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Tag-Value: %s,Parsing Failed\n",
                    p_sip_uri_param));
                ret_val = ICF_FAILURE;
            }
            sip_freeSipUrl(p_sip_url);
        }
        else
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Tag-Value: %s,Tag-Type=SIP_URI_PARAM,Ignored\n",
                p_sip_uri_param));
            ret_val = ICF_FAILURE;
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
        
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_append_sip_uri_hdr_param_in_addr_spec
 **
 ** DESCRIPTION:        This Function Appends uri_parameters in addr_spec
 **
 *****************************************************************************/
icf_return_t icf_ssa_append_sip_uri_hdr_param_in_addr_spec(
        icf_ssa_pdb_st    *p_ssa_pdb,
        icf_uint8_t    *p_sip_uri_hdr_param,
        SipAddrSpec        *p_addr_spec)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    icf_return_t        dummy_retval = ICF_SUCCESS;
    SipUrl                *p_sip_url = ICF_NULL;
    SipError            dError;
    icf_uint32_t        dHdrLength = 0;
    icf_uint32_t        dLength = 0;
    icf_uint8_t        *p_tmp_hdr = ICF_NULL;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    if ( p_addr_spec->dType == SipAddrSipUri ||
         p_addr_spec->dType == SipAddrSipSUri)
    {

        if ( SipFail !=
            sip_getUrlFromAddrSpec(p_addr_spec,&p_sip_url,&dError))
        {
            /* If p_sip_uri->pHeader is not NULL then
             * Some header params already exist in the SipUrL.
             * So Append & (header seperator) and then 
             * Append new header params. if p_sip_uri->pHeader
             * is NULL then copy the new header contents into 
             * pHeader.
             */
            if ( ICF_NULL != p_sip_url->pHeader)
            {
                dHdrLength = icf_port_strlen((icf_uint8_t *)p_sip_url->pHeader);
                dLength = icf_port_strlen(p_sip_uri_hdr_param);
                dLength += dHdrLength + 2;
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                    dLength,ICF_MEM_COMMON,
                    p_tmp_hdr,
                    ICF_DONOT_RET_ON_FAILURE,
                    p_ssa_pdb->p_ecode,dummy_retval);
            
                if(ICF_NULL != p_tmp_hdr)
                {    
                    icf_port_strcpy((icf_uint8_t *)p_tmp_hdr,(icf_uint8_t *)p_sip_url->pHeader);
                
                    icf_port_strcat(p_tmp_hdr,(icf_uint8_t *)"&");
                
                    icf_port_strcat(p_tmp_hdr,p_sip_uri_hdr_param);
                }

            }
            else
            {
                dLength = icf_port_strlen(p_sip_uri_hdr_param);
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                    dLength+1,ICF_MEM_COMMON, 
                    p_tmp_hdr,ICF_DONOT_RET_ON_FAILURE, 
                    p_ssa_pdb->p_ecode, dummy_retval)

                if(ICF_NULL != p_tmp_hdr)
                {
                    icf_port_strcpy(p_tmp_hdr,p_sip_uri_hdr_param);
                }
            }
            sip_setHeaderInUrl(p_sip_url,(icf_int8_t *)p_tmp_hdr,&dError);
            
            sip_freeSipUrl(p_sip_url);
        }
        else
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Tag-Value: %s,Tag-Type=SIP_URI_HDR_PARAM,Ignored\n",p_sip_uri_hdr_param));
            ret_val = ICF_FAILURE;
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*****************************************************************************
 * FUNCTION:     icf_append_tag_params_to_hdr
 * DESCRIPTION:  This function adds a new tag passed to it to a known header
 *                value, which is also passed as a parameter
 *****************************************************************************/
icf_return_t icf_append_tag_params_to_hdr(
        INOUT     icf_ssa_pdb_st*        p_ssa_pdb,
        INOUT        icf_tag_st*            p_tag_st,
        INOUT     SipMessage*                p_sip_msg)
{

    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_ty_u32bit        count=0;
    SipError                err;
    SipHeader               dHeader;
    Sdf_st_error        Error;

    en_HeaderType hdr_type = 0;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Get the ENUM Type of the Header*/
    icf_ssa_get_hdr_type_from_name(p_tag_st->hdr_name.str, &hdr_type, &err);

     /* get the header count 
     * For future
     */

    if (hdr_type == SipHdrTypeUnknown)
    {
        /* Unknown Header Tag handling is not supported for this Phase */
    }
    else if((hdr_type == SipHdrTypeContactNormal)   ||
            (hdr_type == SipHdrTypeContactWildCard) ||
            (hdr_type == SipHdrTypeContactAny))
    {
        /* Temporary code for inserting param to Contact header
         * has to be verified 
         */
/*        if(Sdf_co_fail == icf_ssa_AddParamToContactHdrList(
            &(p_sip_msg->pGeneralHdr->slContactHdr),
            p_tag_st->tag_value.str,
            &Error))
        {
            ret_val = ICF_FAILURE ;
        }

        return ret_val;
 */
    }

    if(ICF_FAILURE == ret_val)
    {
    }
    else if(SipFail == sip_getHeaderCount(p_sip_msg, hdr_type, &count, &err))
    {
        ret_val = ICF_FAILURE ;
    }
    /* If multiple headers of same type is found, we choose the first header
     * index 0 and insert the tags to that header, currently this is a doubt-
     * ful issue
     */
    else if(SipFail != sip_getHeaderAtIndex(p_sip_msg, hdr_type, &dHeader, 0, &err))
    {

        if ( p_tag_st->tag_type & ICF_TAG_TYPE_SIP_URI_PARAM)
        {
            icf_ssa_append_sip_uri_param_in_sip_hdr(
                            p_ssa_pdb,p_tag_st->tag_value.str,&dHeader);

        }
        else if ( p_tag_st->tag_type & ICF_TAG_TYPE_SIP_URI_HDR_PARAM)
        {
            icf_ssa_append_sip_uri_hdr_param_in_sip_hdr(
                p_ssa_pdb,p_tag_st->tag_value.str,&dHeader);

        }
        else if ( p_tag_st->tag_type & ICF_TAG_TYPE_HDR_PARAM)
        {
            Sdf_ty_slist        sList;
            if(sdf_listInit(&sList, __sdf_fn_uaFreeString, Sdf_co_false, &Error)             
                == Sdf_co_fail)
            {
                ret_val = ICF_FAILURE ;
            }
            /* We are fooling the system here, instead of sending a list of values
             * corresponding to a tag in a list we send the entire tag=value portion
             * as a string to InsertHeaderParam, thus the second argument.
             */

            if (sdf_ivk_uaInsertHeaderParam (&dHeader,  (Sdf_ty_s8bit *)p_tag_st->tag_value.str,  
                &sList, 0, &Error) == Sdf_co_fail)
            {
                ret_val = ICF_FAILURE ;
            }
            sdf_listDeleteAll(&sList, &Error);
        } 
        else 
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Ignoring Invalid Tag Type\n"));
        }
        sip_freeSipHeader(&dHeader);
        
    }
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}




/*****************************************************************************
 * FUNCTION:         icf_ssa_insert_body_list_in_sdf_list
 *
 * DESCRIPTION:         This function inserts the message body linked list into 
 *            a Message body list passed  to it. The clear_list parameter specifies
 *          whether the memory associated with this list is to be freed or not
 *            if Set to true the memory is freed.
 * 
 *****************************************************************************/
icf_return_t icf_ssa_insert_body_list_in_sdf_list(
         INOUT     icf_ssa_pdb_st*          p_ssa_pdb,
         INOUT     icf_msg_body_list_st*    p_body_list,
         INOUT     icf_boolean_t            clear_list,
         INOUT   Sdf_ty_slist*            p_list)
{

 /*Message body header changes  Start */


    icf_uint16_t     list_count = ICF_NULL;

    icf_msg_body_st* p_body = ICF_NULL;

    icf_error_t      ecode;
    icf_return_t     ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) 

    list_count = (icf_uint16_t )p_body_list->count;
    p_body = p_body_list->body;
    
    while (list_count > 0 && ICF_NULL != p_body) 
    {
        if (ICF_FAILURE == icf_add_body_to_list(
            p_ssa_pdb, p_body, p_list))
            
        {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to add body to sip message"));
                ret_val = ICF_FAILURE;
                break;
        }
        list_count = (icf_uint16_t )(list_count - 1);
        p_body = p_body->next;
    }
    
    /* Free this list*/
    /*SPR 19886 Fix for CSR 1-7208970 If the invite is being sent
      do not free the body list as this may be required to send
      redirected INVITE*/
    if((ICF_TRUE == clear_list) && (p_body_list->count > 0) &&
            (ICF_NULL != p_ssa_pdb->p_ssa_ctxt) &&
            (ICF_FALSE == p_ssa_pdb->p_ssa_ctxt->invite_being_sent))
    {
        icf_cmn_free_msg_body_list(p_ssa_pdb->p_glb_pdb, p_body_list, &ecode);
    }
    
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb) 

    return ret_val;  
}


/*****************************************************************************
 * FUNCTION:     icf_add_body_to_list
 * DESCRIPTION:  This function adds a Message body to an Existing Message body
 *                 list.
 *****************************************************************************/
icf_return_t icf_add_body_to_list(
        INOUT     icf_ssa_pdb_st*        p_ssa_pdb,
        INOUT       icf_msg_body_st*       p_body,
        INOUT     Sdf_ty_slist*          p_body_list)
{
    Sdf_ty_u8bit    dAddMimeHeader = Sdf_co_false;
    Sdf_ty_s8bit*   pTextBuf;
    Sdf_st_error    error;
    SipMsgBody      *pMsgBody = NULL;
    icf_uint16_t     body_length;
    icf_return_t     memfree_retval;
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_uint8_t      *p_media_type = ICF_NULL;
    icf_uint8_t      count = 0;
    SipHeader        *pHeader=Sdf_co_null;
    Sdf_ty_s8bit      *p_ctype=Sdf_co_null;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) 
    body_length = (icf_uint16_t)(p_body->length + 1);
    count = (icf_uint8_t)p_body->msg_body_hdr_list.count;
    
    if(ICF_NULL != p_body->value)
    {
        pTextBuf = (char*)sdf_memget(0, body_length, &error);
        if(ICF_NULL == pTextBuf)
        {
            return ICF_FAILURE;
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)pTextBuf, (icf_uint8_t *)p_body->value);
        }
    }
    else
    {
        return ICF_FAILURE;
    }
   
        /* Get the media_type from the Content-Type header */
    if(0 != icf_port_strcmp((icf_uint8_t *)"",p_body->content_type.str))
    {
        Sdf_mc_strdup(p_ctype,(icf_int8_t*)p_body->content_type.str);

        if(ICF_FAILURE == icf_ssa_get_media_type_from_content_type(p_body->\
                    content_type.str,((Sdf_ty_s8bit ** )&p_media_type)))
        {
            ICF_PRINT(((icf_uint8_t *)"Could not get the media type from content-type"\
                        " header from body header\n"));
            /*  THis should be freed here otherwise it would get lost */
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, \
                    p_ctype, ICF_MEM_COMMON, p_ssa_pdb->p_ecode, memfree_retval)

            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, pTextBuf, ICF_MEM_COMMON,\
                    p_ssa_pdb->p_ecode, memfree_retval)
                ret_val = ICF_FAILURE;
        }
    }
    /*  THe processing should be done only if
        ret_val is success */
    if (ICF_FAILURE != ret_val)
    {
        if((Sdf_co_fail == sdf_ivk_uaCreateMessageBodyFromBuffer(&pMsgBody,\
                (Sdf_ty_s8bit *)p_media_type, pTextBuf, p_body->length,\
                dAddMimeHeader,&error)))
        {
            ICF_PRINT(((icf_uint8_t *)"\n Could not add Text Message Body \n"));
             /*  THis should be freed here otherwise it would get lost */
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, \
                    p_ctype, ICF_MEM_COMMON, p_ssa_pdb->p_ecode, memfree_retval)
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, \
                pTextBuf, ICF_MEM_COMMON, p_ssa_pdb->p_ecode, memfree_retval)
    
            ret_val = ICF_FAILURE;
        }
        /* Changes done to remove CRLF : Customer Service Request (CSR) Number :-  1-3571773*/
        else if((0 != count && ICF_NULL != p_body->msg_body_hdr_list.hdr) ||
            (0 != icf_port_strcmp((icf_uint8_t *)"",p_body->content_type.str)))
        {
    
            if(SipFail == sip_bcpt_initSipMimeHeader(&pMsgBody->pMimeHeader,
                        (SipError*)&(error.stkErrCode)))
            {
                 /*  THis should be freed here otherwise it would get lost */
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, \
                p_ctype, ICF_MEM_COMMON, p_ssa_pdb->p_ecode, memfree_retval)
    
                /* Failed to initialize SIP Mime Header */
                ret_val = ICF_FAILURE;
            }

            /* Fill Content-Type header in MIME Header */
            if(0 != icf_port_strcmp((icf_uint8_t *)"",p_body->content_type.str))
            {
                if(sip_initSipHeader(&pHeader,SipHdrTypeContentType,\
                            (SipError*)&(error.stkErrCode))==SipFail)
                {
                     /*  THis should be freed here otherwise it would get lost */
                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, \
                    p_ctype, ICF_MEM_COMMON, p_ssa_pdb->p_ecode, memfree_retval)
                    /*  Code is removed because this function freeSipMsgBody takes care 
                        to free pMsgBody->pMimeHeader */ 
                    sip_freeSipMsgBody(pMsgBody);
                    /*  KlocWorks Fix */
                    sip_freeSipHeader(pHeader);
                    error.errCode=Sdf_en_msgBodyError;
                    ret_val = ICF_FAILURE;
                }         

                else if(sip_setMediaTypeInContentTypeHdr(pHeader, p_ctype,\
                            (SipError*)&(error.stkErrCode))==SipFail)
                {
                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, \
                        p_ctype, ICF_MEM_COMMON, p_ssa_pdb->p_ecode, memfree_retval)
    
                    /*  Code is removed because this function freeSipMsgBody takes care 
                        to free pMsgBody->pMimeHeader */ 
                    sip_freeSipMsgBody(pMsgBody);
                        error.errCode=Sdf_en_msgBodyError;
                    ret_val = ICF_FAILURE;
                }
        
                else if(sip_bcpt_setContentTypeInMimeHdr(pMsgBody->pMimeHeader,pHeader,\
                            (SipError*)&(error.stkErrCode))==SipFail)
                {
                    /*  Code is removed because this function freeSipMsgBody takes care 
                        to free pMsgBody->pMimeHeader */ 
                    sip_freeSipMsgBody(pMsgBody);
                        error.errCode=Sdf_en_msgBodyError;
                    ret_val = ICF_FAILURE;
                }
    
            }
            if (ICF_SUCCESS == ret_val)
            {
                /* If message body header list is present then insert the message body 
                 * headers 
                 */
                if(0 < count && ICF_NULL != p_body->msg_body_hdr_list.hdr)
                {
                    ret_val = icf_ssa_fill_msg_body_hdrs(p_ssa_pdb,&(p_body->
                                msg_body_hdr_list),pMsgBody);
                    if(ICF_FAILURE == ret_val)
                    {
                        ICF_PRINT(((icf_uint8_t *)"Could not insert message body headers in"\
                                        " Sip message\n"));
                         /*THe code is removed because sip_freeSipMsgBody function
                         takes care to free pTextBuf */
                        /*  Code is removed because this function freeSipMsgBody takes care 
                        to free pMsgBody->pMimeHeader */ 
    
                        sip_freeSipMsgBody(pMsgBody);
                        ret_val =  ICF_FAILURE;
                    }
                }
            }
        }/*end of Changes done to remove CRLF*/
    }/*  ret_val = success */
    if(ret_val != ICF_FAILURE && pMsgBody != NULL)
    {
        if (sdf_listAppend(p_body_list, pMsgBody,&error) == SipFail)
        {
            ICF_PRINT(((icf_uint8_t *)"\nUnable to append the msgbody into the callobject's"\
                        " message body list"));
            /*THe code is removed because sip_freeSipMsgBody function
                     takes care to free pTextBuf */
            /*  Code is removed because this function freeSipMsgBody takes care 
                to free pMsgBody->pMimeHeader */ 
            sip_freeSipMsgBody(pMsgBody);
            ret_val = ICF_FAILURE;
        }
    }
    
    /*klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,pMsgBody)

         
    if(pHeader)
    {
        sip_freeSipHeader(pHeader);
        sdf_memfree(Sdf_mc_callHandlerMemId, 
                (Sdf_ty_pvoid*)&pHeader,Sdf_co_null);
    } 
    if(ICF_NULL != p_media_type)
    {
        sdf_memfree(Sdf_mc_callHandlerMemId, 
            (Sdf_ty_pvoid*)&p_media_type,Sdf_co_null);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb) 
    return ret_val;
}
/*Message body header changes Ends*/


/*******************************************************************************
 * FUNCTION:     icf_ssa_form_and_insert_pref_identity_hdr
 * DESCRIPTION:  This function forms and inserts a P-Preferred identity header
 *               into the SIP message .
 ******************************************************************************/
icf_return_t icf_ssa_form_and_insert_pref_identity_hdr(
        INOUT      icf_ssa_pdb_st*    p_ssa_pdb,
        INOUT    SipMessage*            p_otg_sip_msg)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    /* Fix for CSR 1-7436195 */
    /* Coverity bug fix */
    icf_string_st                 addr_val = {0,"\0"};



    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

        if(ICF_NULL == p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity)
        {
            /* Its a incoming call so preferd_identity is null */
            return ICF_SUCCESS;
        }

        if( p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_SIP_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sip:");
            icf_port_strcat( addr_val.str, p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity->addr_val.str );
            icf_port_strcat( addr_val.str, (icf_uint8_t *)">");


        }
        else if( p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_TEL_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"tel:");
            icf_port_strcat( addr_val.str, p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity->addr_val.str );
        }
        else if( p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_SIPS_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sips:");
            icf_port_strcat( addr_val.str, p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity->addr_val.str );
            icf_port_strcat( addr_val.str, (icf_uint8_t *)">");
        }
        else
        {
            icf_port_strcpy( addr_val.str, p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity->addr_val.str );
        }




    if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                p_ssa_pdb, 
                (icf_uint8_t*)"P-Preferred-Identity",
                addr_val.str,
                p_otg_sip_msg))
    {
        ICF_DEBUG_PRINT(("\nFailed to insert unknown header (P-Preferred-Identity)"));
        ret_val = ICF_FAILURE;
    }


    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;

}


/*******************************************************************************
 * FUNCTION:     icf_ssa_form_and_insert_request_disposition_hdr
 * DESCRIPTION:  This function forms and inserts a Request-Disposition header
 *               into the SIP message .
 ******************************************************************************/

icf_return_t icf_ssa_form_and_insert_request_disposition_hdr(
        INOUT      icf_ssa_pdb_st*    p_ssa_pdb,
        INOUT    SipMessage*            p_otg_sip_msg)
{
    icf_return_t                     ret_val = ICF_SUCCESS;

    icf_uint8_t hdr[]="Request-Disposition";


    if(0 != p_ssa_pdb->p_glb_cfg_data->sip_compact_hdrs)
    {
      /* Compact headers is on, use the compact form */
        icf_port_strcpy(hdr,(icf_uint8_t *)"d");
    }

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
        p_ssa_pdb, 
        hdr,
        (icf_uint8_t *)"no-fork", /* for SPR 9864 */
        p_otg_sip_msg))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header (Request-Disposition)"));
        ret_val = ICF_FAILURE;
    }


    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;
}


/*****************************************************************************
 * FUNCTION:     icf_ssa_form_and_insert_access_nw_info_hdr
 * DESCRIPTION:  This function forms and inserts a P-Access-Network-Info 
 *               header into the SIP message.
 *****************************************************************************/
icf_return_t icf_ssa_form_and_insert_access_nw_info_hdr(
        INOUT      icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT    SipMessage          *p_otg_sip_msg)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    /* Rel 8.2 Klocworks fix */
    icf_string_st               addr_val = {0,"\0"}; 
    /* Rel 8.2 Klocworks fix end */
    icf_line_id_t               line_id = ICF_INVALID_LINE_ID;
   if(ICF_NULL != p_ssa_pdb)
   { 
       ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
       /*If line data is not present in the SSA PDB then
         extract line-id for the message and then line-data*/
       if(ICF_NULL == p_ssa_pdb->p_line_data)
       {
          if(ICF_FAILURE == icf_ssa_get_line_id_from_glb_pdb(
                             p_ssa_pdb->p_glb_pdb,
                             p_ssa_pdb->p_ssa_ctxt,
                             &line_id,
                             p_ssa_pdb->p_ecode))
          {
          }
          else if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                               p_ssa_pdb->p_glb_pdb,
                               line_id,
                               &(p_ssa_pdb->p_line_data),
                               p_ssa_pdb->p_ecode))
          {
          }
         else
          {
          }
       }
       
       /*Check if access_network_info has been configured by user
         on line then use per-line configuration else use systemwide*/ 
       if((ICF_NULL != p_ssa_pdb->p_line_data) &&
          (ICF_NULL != p_ssa_pdb->p_line_data->p_access_network_info))
       {
           icf_port_strcpy(addr_val.str,
                 p_ssa_pdb->p_line_data->p_access_network_info->str);
       }
       else if(ICF_NULL != p_ssa_pdb->p_glb_cfg_data->p_access_network_info)
       {
           icf_port_strcpy(addr_val.str,
                 p_ssa_pdb->p_glb_cfg_data->p_access_network_info->str);
       }
       else
       {
       }

       /*P-Hdr Enhancement: If either of per-line or systemwide configuration
         gives the configured access_network_info value then insert it*/
       if(0 != icf_port_strcmp((icf_uint8_t *)addr_val.str,(icf_uint8_t *)""))
       {    
           if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                                  p_ssa_pdb,
                                 (icf_uint8_t*)"P-Access-Network-Info",
                                  addr_val.str,
                                  p_otg_sip_msg))
            {
               ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header (P-Access-Network-Info)"));
               ret_val = ICF_FAILURE;
            }
       }   
       ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
   }/*End of if(ICF_NULL != p_ssa_pdb)*/
   else
   {
        ret_val=ICF_FAILURE;
   } 
   return ret_val;
}

/*****************************************************************************
 * FUNCTION:     icf_insert_header_tag_body_list
 * DESCRIPTION:  This function inserts header/tag/body list collectively
 *               into either a SIP message or SIP transaction.
 *****************************************************************************/
icf_return_t icf_insert_header_tag_body_list(
        INOUT      icf_ssa_pdb_st*          p_ssa_pdb,
        INOUT      icf_boolean_t            clear_list,
        INOUT     Sdf_st_transaction*            p_txn,
        INOUT    Sdf_st_overlapTransInfo*    p_overlap_txn)
{


    SipMessage*           p_sip_msg   = ICF_NULL;
    Sdf_ty_slist*         p_slist = ICF_NULL;   
    icf_header_list_st*   p_hdr_list  = ICF_NULL;
    icf_tag_list_st*      p_tag_list  = ICF_NULL;
    icf_msg_body_list_st* p_body_list = ICF_NULL;
    icf_list_st           *p_temp_list_node = ICF_NULL;
    icf_return_t          ret_val = ICF_SUCCESS;

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    if (ICF_NULL != p_txn)
    {
        p_sip_msg = p_txn->pSipMsg;
        p_slist   = &(p_txn->slMsgBodyList);
    }
    else if (ICF_NULL != p_overlap_txn)
    {
        p_sip_msg = p_overlap_txn->pSipMsg;
        p_slist   = &(p_overlap_txn->slMsgBodyList);
    }

    if (ICF_INVALID_CALL_ID == 
        p_ssa_pdb->p_glb_pdb->p_call_ctx->replace_initiated_call_id)
    {
        /*SPR 19590 change start*/
        /*Fetch the node from the call ctx list of hdr list on basis of 
          current txn id*/
        if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx->p_list_of_header_list)
        {
            ret_val = icf_cmn_fetch_curr_hdr_list_node_from_call_ctx(
                    p_ssa_pdb->p_glb_pdb,
                    &p_temp_list_node);
            if((ICF_NULL != p_temp_list_node) && (ICF_NULL != p_temp_list_node->p_data))
            {    
               p_hdr_list = &(((icf_header_link_list_st*) \
                        (p_temp_list_node->p_data))->header_list);
            }   
        }    
        /*SPR 19590 change end*/

        if ((ICF_NULL != p_hdr_list) && (ICF_NULL < p_hdr_list->count))
        {
            if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
                        p_ssa_pdb, p_hdr_list, clear_list, p_sip_msg))
            {
                ret_val = ICF_FAILURE;
            }
        }
    }
    else
    {
        p_hdr_list = &(p_ssa_pdb->p_glb_pdb->p_call_ctx->persistent_header_list);

        if (ICF_NULL < p_hdr_list->count)
        {
            if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
                        p_ssa_pdb, p_hdr_list, ICF_FALSE, p_sip_msg))
            {
                ret_val = ICF_FAILURE;
            }
        }
    }

    if (ICF_INVALID_CALL_ID == 
           p_ssa_pdb->p_glb_pdb->p_call_ctx->replace_initiated_call_id)
    {
        /*SPR 19590 change start*/
        /*Fetch the node from the call ctx list of tag list on basis of 
          current txn id*/
        if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx->p_list_of_tag_list)
        {
            ret_val = icf_cmn_fetch_curr_tag_list_node_from_call_ctx(
                    p_ssa_pdb->p_glb_pdb,
                    &p_temp_list_node);
            if((ICF_NULL != p_temp_list_node) && (ICF_NULL != p_temp_list_node->p_data))
            {    
                p_tag_list =
                 &(((icf_tag_link_list_st*)(p_temp_list_node->p_data))->tag_list);
            }   
        }
        /*SPR 19590 change end*/
        if ((ICF_NULL != p_tag_list) && (ICF_NULL < p_tag_list->count))
        {
            if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
                p_ssa_pdb, p_tag_list, clear_list, p_sip_msg))
            {
                ret_val = ICF_FAILURE;
            }

        }
        /*SPR 19590 change start*/
        /*Fetch the node from the call ctx list of tag list on basis of 
          current txn id*/
        if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx->p_list_of_body_list)
        {
            ret_val = icf_cmn_fetch_curr_body_list_node_from_call_ctx(
                    p_ssa_pdb->p_glb_pdb,
                    &p_temp_list_node);
            if((ICF_NULL != p_temp_list_node) && (ICF_NULL != p_temp_list_node->p_data))
            {    
                p_body_list =
                 &(((icf_msg_body_link_list_st*)(p_temp_list_node->p_data))->body_list);
            }   
        }
        /*SPR 19590 change end*/
        if((ICF_NULL != p_body_list) && (ICF_NULL < p_body_list->count))
        {
            if ((ICF_NULL != p_slist) && (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
                p_ssa_pdb, p_body_list, clear_list, p_slist)))
            {
                ret_val = ICF_FAILURE;
            }
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;

}


/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_extract_challenge
 *
 * DESCRIPTION: The function extracts the challenge from the auth_params_lis
 *              for the header type sepcified by the calling function.
 *              It also extracts the nonce and stores it in the ssa context
 *              to be used by the function icf_ssa_validate_challenge for
 *              stale parameter processing.
 *              
 * RETURNS: icf_return_t 
 *
************************************************************************/ 
icf_return_t icf_ssa_extract_challenge(
       INOUT  icf_ssa_pdb_st                    *p_ssa_pdb,
       INOUT     icf_uint8_t                          header_type)
       
{
    icf_uint32_t        list_size = ICF_NULL;
    Sdf_st_error        err = {0,0,0,"\0"};
    icf_uint32_t        loop_list = ICF_NULL;
    Sdf_ty_pvoid        p_list_member;
    icf_uint8_t         *p_temp_string = ICF_NULL;        
    icf_return_t        ret_val = ICF_FAILURE, dummy_ret_val = ICF_SUCCESS;
    icf_uint8_t         *p_temp_unq_string = ICF_NULL; /* unquoted string */
    icf_uint32_t        temp_len = 0;
    icf_rgm_context_st  *p_rgm_context = ICF_NULL;
    /* Rel 8.2 Klocworks fix */
    icf_string_st       temp_unq_algo = {0,"\0"},
                        temp_unq_scheme = {0,"\0"},
                        temp_unq_realm = {0,"\0"};
    icf_string_st       temp_unq_opaque = {0,"\0"},
                        temp_unq_qop = {0,"\0"},
                        temp2_unq_realm = {0,"\0"};
    /* Rel 8.2 Klocworks fix end */
    icf_ssa_ctxt_st     *p_ssa_ctxt = ICF_NULL;
    Sdf_ty_slist        *p_auth_params_list = ICF_NULL;
    /* This is to preserve the value of old sequence number as computed
     * in case of AKA challenge by the porting function
     * icf_port_run_aka_procedure.
     */
    icf_uint32_t        sequence_num = 0;

    /* This field is used as a generic pointer which points to
     * either ssa_ctxt->auth_data_recvd or rgm_context->auth_data_recvd
     */
    icf_cmn_auth_data_st *p_auth_data_recvd = ICF_NULL;
    icf_cmn_auth_data_st *p_auth_data_sent = ICF_NULL;
    /*SPR 18769 Start*/ 
    icf_uint8_t          *p_previous_pnonce = ICF_NULL;
    icf_uint32_t          previous_pnonce_len = 0;
    /*SPR 18769 End*/ 
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
         
    /* Copy the ssa ctxt pointer locally */
     p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
     ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))
         
    /* Copy the rgm_context pointer locally */
    p_rgm_context = (icf_rgm_context_st *)(p_ssa_ctxt->p_rgm_ctxt);
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_rgm_context))

    if(ICF_NULL != p_rgm_context)
    {
        p_auth_data_recvd = &(p_rgm_context->auth_data_recd);
        p_auth_data_sent = &(p_rgm_context->auth_data_sent);
        /* resetting the challenge_algo field */
         p_rgm_context->challenge_algo = ICF_CHALLENGE_ALGO_INVALID;
    }
    else
    {
        p_auth_data_recvd = &(p_ssa_ctxt->auth_data_recd);
        p_auth_data_sent = &(p_ssa_ctxt->auth_data_sent);
         /* resetting the challenge_algo field */
        p_ssa_ctxt->challenge_algo = ICF_CHALLENGE_ALGO_INVALID;
    }
    /*Start:SPR 18769: We will store the last recvd nonce in local
      variable so that we can check later in function whether the new recvd
      nonce is same as last one or not.*/
    if(ICF_NULL != p_auth_data_recvd->p_nonce)
    {    
       previous_pnonce_len = icf_port_strlen(p_auth_data_recvd->p_nonce);
       ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
               previous_pnonce_len + 1,
               ICF_MEM_COMMON, 
               (p_previous_pnonce),
               ICF_DONOT_RET_ON_FAILURE, 
               p_ssa_pdb->p_ecode, 
               ret_val)
        if(ICF_SUCCESS == ret_val)
        {   
          icf_port_strcpy(p_previous_pnonce,p_auth_data_recvd->p_nonce);    
        }  
    }/*SPR 18769 End*/  

    /* Assert on auth_params_list */
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
            (ICF_NULL != p_ssa_ctxt->p_auth_params_list))
    p_auth_params_list = p_ssa_ctxt->p_auth_params_list;

    sdf_listSizeOf(p_auth_params_list, &list_size,
                                &err);

    for (loop_list = 0; loop_list < list_size; loop_list++ )
    {
        /* for loop: begin processing */
        if (Sdf_co_fail == sdf_listGetAt (p_auth_params_list,
            loop_list,
            &p_list_member, 
            &err))
        {
            continue;
            
        }
        else
        {
            /* else: auth_params member read safely: processing begins */
            
            if(header_type == ((Sdf_st_authenticationParams *)(p_list_member))->
                dHdrType)
            {
            /* We have found the header type we were looking for:
                * Now copy the challenge and run out of the loop */
                
                if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pNonce) 
                {/* Non null Nonce begins*/

                    /* Clear the contents of old auth_recd in p_rgm_context */

                    /* memfree the nonce string */
                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, 
                                    (p_auth_data_recvd->p_nonce),
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode, dummy_ret_val)
                    
                    if(ICF_NULL != p_auth_data_sent->p_nonce)
                    {
                            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, 
                                    (p_auth_data_sent->p_nonce),
                                    ICF_MEM_COMMON,
                                    p_ssa_pdb->p_ecode, dummy_ret_val)
                    }

                    /* Copy the value of old sequence number before
                     * memsetting the structure.
                     */
                    sequence_num = p_auth_data_recvd->sequence_num;

                    icf_port_memset(
                        (icf_void_t*)(p_auth_data_recvd),
                        (icf_uint8_t)ICF_NULL,
                        (icf_uint32_t) ICF_PORT_SIZEOF(icf_cmn_auth_data_st));   
     
                    /* Start processing the new set of challenge */

                    p_temp_string =  
                        (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pNonce;
                    
                    temp_len = icf_port_strlen(p_temp_string);
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        temp_len+1,
                        ICF_MEM_COMMON, p_temp_unq_string,
                        ICF_DONOT_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                       
                    if (ICF_FAILURE == ret_val) 
                    {
                            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                    p_previous_pnonce, 
                                    ICF_MEM_COMMON, 
                                    p_ssa_pdb->p_ecode, 
                                    ret_val)

                            return ICF_FAILURE;
                    }

                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        temp_len+1,
                        ICF_MEM_COMMON, 
                                (p_auth_data_recvd->p_nonce),
                        ICF_DONOT_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)

                    if (ICF_FAILURE == ret_val) 
                    {
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                    p_temp_unq_string, 
                                    ICF_MEM_COMMON, 
                                    p_ssa_pdb->p_ecode, 
                                    ret_val) 

                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                    p_previous_pnonce, 
                                    ICF_MEM_COMMON, 
                                    p_ssa_pdb->p_ecode, 
                                    ret_val)

                        return ICF_FAILURE;
                    }

                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        temp_len+1,
                        ICF_MEM_COMMON, 
                                (p_auth_data_sent->p_nonce),
                        ICF_DONOT_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)

                    if (ICF_FAILURE == ret_val) 
                    {
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                    p_temp_unq_string, 
                                    ICF_MEM_COMMON, 
                                    p_ssa_pdb->p_ecode, 
                                    ret_val) 
                        
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                    p_auth_data_recvd->p_nonce, 
                                    ICF_MEM_COMMON, 
                                    p_ssa_pdb->p_ecode, 
                                    ret_val) 

                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                    p_previous_pnonce, 
                                    ICF_MEM_COMMON, 
                                    p_ssa_pdb->p_ecode, 
                                    ret_val) 
                        return ICF_FAILURE;
                    }
                    /*Klocwork Warning Removal*/
                   else
                    {
                       ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                   p_auth_data_recvd->p_nonce)
                       ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                   p_auth_data_sent->p_nonce)
                    }     
                    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
                        (ICF_NULL != p_auth_data_recvd->p_nonce))
                
                    if(ICF_NULL!=p_temp_unq_string)
                    {
                        sdf_fn_uaUnq((icf_int8_t *)p_temp_string, (icf_int8_t *)p_temp_unq_string);
                    }
                     /*Start SPR 18769: Compare the last challenge nonce with
                     the one received in the current challenge*/
                     if((ICF_NULL != p_temp_unq_string)&&
                        (ICF_NULL != p_previous_pnonce)) 
                     {
                         if(0 != icf_port_strcmp(p_previous_pnonce, 
                                 p_temp_unq_string))
                          {
                              /*Reset the nonce count in the SSA ctx*/
                               p_ssa_ctxt->nc = 0;
                               if(ICF_NULL != p_rgm_context)
                               {
                                   p_rgm_context->auth_data_sent.nonce_count =
                                       0;
                               }
                          }
                     }/*End SPR18769 */    
                    icf_port_strcpy(p_auth_data_recvd->p_nonce, \
                                p_temp_unq_string);
                    p_auth_data_recvd->nonce_len = temp_len;
                    p_auth_data_recvd->auth_data_present |=
                                                ICF_AUTH_NONCE_PRESENT;

                    /* copying the nonce received in auth_data_sent */
                    icf_port_strcpy(p_auth_data_sent->p_nonce, \
                                p_temp_unq_string);

                    p_auth_data_sent->nonce_len = temp_len;
                    p_auth_data_sent->auth_data_present |=
                                                ICF_AUTH_NONCE_PRESENT;

                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_temp_unq_string, 
                        ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)

                    /* copy other parameters */
                    if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pAlgorithm)
                    {
                        p_temp_string =  
                        (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pAlgorithm;
                        sdf_fn_uaUnq((icf_int8_t *)p_temp_string, (icf_int8_t *)temp_unq_algo.str);
                         /* Codenomicon fixes: CSR 1-7132323: SPR 19484 */
						/* String Copy should not exceed ICF_MAX_STR_LEN value */
                        icf_port_strncpy(
							(icf_int8_t *)p_auth_data_recvd->algo.str, 
							(const icf_int8_t *)temp_unq_algo.str,
							(ICF_MAX_STR_LEN - 1));
						p_auth_data_recvd->algo.str[ICF_MAX_STR_LEN - 1] = '\0';
                        p_auth_data_recvd->algo.str_len = 
                                    (icf_uint16_t)icf_port_strlen(p_auth_data_recvd->algo.str);
                        p_auth_data_recvd->auth_data_present |=
                                                ICF_AUTH_ALGO_PRESENT;
                        /* Now setting the algo received in the challenge_algo
                         * field .
                         */
                        if(0 != icf_port_strcasecmp((const icf_int8_t *)p_auth_data_recvd->algo.str,
                                                "AKAv1-MD5"))
                        {
                            /* set the field challenge algo in
                             * rgm_cxtx/ssa_ctxt */
                            if(ICF_NULL != p_rgm_context)
                            { 
                                p_rgm_context->challenge_algo =
                                    ICF_CHALLENGE_ALGO_MD5;
                            }
                            else
                            {
                                p_ssa_ctxt->challenge_algo =
                                    ICF_CHALLENGE_ALGO_MD5;
                            }
                       }
                       else
                       {
                           /* set the field challenge algo in
                            * rgm_cxtx/ssa_ctxt */
                           if(ICF_NULL != p_rgm_context)
                           { 
                                p_rgm_context->challenge_algo =
                                    ICF_CHALLENGE_ALGO_AKA;
                           }
                           else
                           {
                                p_ssa_ctxt->challenge_algo =
                                    ICF_CHALLENGE_ALGO_AKA;
                           }
                       }
                    }/* Algorithm filled */

                    if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pRealm)
                    {
                        /* SPR 19928 : As per ABNF of the realm parameter, peer can
                           send the same in quotes. As per current design, if the 
                           application has configured realm through ICF_SET_SELF_ID_REQ
                           API, then we compare the received and the configured
                           realm. If it matches, we send a new request with credentials,
                           else the application is indicated and no new request is sent
                           to the peer.
                           
                           However the unqouting of the realm happens only once.
                           Thus the realm comparision fails. As a result, IPTK
                           does not send a new request with credentials.

                           As a fix, in case of REGISTER, unqoute the realm twice
                           and store the final output in p_auth_data_recvd->realm.
                           This will be used in the REGM module for comparision.
                        */

                        p_temp_string = (icf_uint8_t *)((Sdf_st_authenticationParams *)\
                                        (p_list_member))->pRealm;

                        if(ICF_NULL != p_rgm_context)
                        {
                            /* Unqouting first time */
                            sdf_fn_uaUnq((Sdf_ty_s8bit *)p_temp_string,\
                                    (Sdf_ty_s8bit *) temp2_unq_realm.str);
                            
                            /* Unqouting second time */
                            sdf_fn_uaUnq((Sdf_ty_s8bit *)temp2_unq_realm.str,\
                                    (Sdf_ty_s8bit *) temp_unq_realm.str);
                        }
                        else
                        {
                            sdf_fn_uaUnq((Sdf_ty_s8bit *)p_temp_string,\
                                    (Sdf_ty_s8bit *) temp_unq_realm.str);
                        }

                        /* In both the cases, the final unquoted realm 
                           is in temp_unq_realm.str.
                        */

                        /* Codenomicon fixes: CSR 1-7132323: SPR 19484 */
						/* String Copy should not exceed ICF_MAX_STR_LEN value */
                        icf_port_strncpy(
							(icf_int8_t *)p_auth_data_recvd->realm.str, 
							(const icf_int8_t *)temp_unq_realm.str,
							(ICF_MAX_STR_LEN - 1));
						p_auth_data_recvd->realm.str[ICF_MAX_STR_LEN - 1] = '\0';
                        p_auth_data_recvd->realm.str_len = 
                                    (icf_uint16_t)icf_port_strlen(p_auth_data_recvd->realm.str);
                        p_auth_data_recvd->auth_data_present |=
                                                ICF_AUTH_REALM_PRESENT;
                    }/* realm Filled */
                    
                    if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pScheme)
                    {
                        p_temp_string =  
                        (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pScheme;
                        sdf_fn_uaUnq((Sdf_ty_s8bit *)p_temp_string, (Sdf_ty_s8bit *)temp_unq_scheme.str);
                         /* Codenomicon fixes: CSR 1-7132323: SPR 19484 */
						/* String Copy should not exceed ICF_MAX_STR_LEN value */
                        icf_port_strncpy(
							(icf_int8_t *)p_auth_data_recvd->scheme.str, 
							(const icf_int8_t *)temp_unq_scheme.str,
							(ICF_MAX_STR_LEN - 1));
						p_auth_data_recvd->scheme.str[ICF_MAX_STR_LEN - 1] = '\0';
                        p_auth_data_recvd->scheme.str_len = 
                            (icf_uint16_t )icf_port_strlen(p_auth_data_recvd->scheme.str);
                        p_auth_data_recvd->auth_data_present |=
                                                ICF_AUTH_SCHEME_PRESENT;

                    }/* Scheme filled */

                    if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pOpaque)
                    {
                        p_temp_string =  
                        (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pOpaque;
                        sdf_fn_uaUnq((Sdf_ty_s8bit *)p_temp_string, (Sdf_ty_s8bit *)temp_unq_opaque.str);
                        /* Codenomicon fixes: CSR 1-7132323: SPR 19484 */
						/* String Copy should not exceed ICF_MAX_STR_LEN value */
                        icf_port_strncpy(
							(icf_int8_t *)p_auth_data_recvd->opaque.str, 
							(const icf_int8_t *)temp_unq_opaque.str,
							(ICF_MAX_STR_LEN - 1));
						p_auth_data_recvd->opaque.str[ICF_MAX_STR_LEN - 1] = '\0';
                        p_auth_data_recvd->opaque.str_len = 
                            (icf_uint16_t )icf_port_strlen(p_auth_data_recvd->opaque.str);
                        p_auth_data_recvd->auth_data_present |=
                                                ICF_AUTH_OPAQUE_PRESENT;

                    }/* Opaque Filled */

                    if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pQop)
                    {
                        p_temp_string =  
                        (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pQop;
                        sdf_fn_uaUnq((Sdf_ty_s8bit *)p_temp_string, (Sdf_ty_s8bit *)temp_unq_qop.str);
                          /* Codenomicon fixes: CSR 1-7132323: SPR 19484 */
						/* String Copy should not exceed ICF_MAX_STR_LEN value */
                        icf_port_strncpy(
							(icf_int8_t *)p_auth_data_recvd->qop.str, 
							(const icf_int8_t *)temp_unq_qop.str,
							(ICF_MAX_STR_LEN - 1));
						p_auth_data_recvd->qop.str[ICF_MAX_STR_LEN - 1] = '\0';
                        p_auth_data_recvd->qop.str_len = 
                            (icf_uint16_t )icf_port_strlen(p_auth_data_recvd->qop.str);
                        p_auth_data_recvd->auth_data_present |=
                                            ICF_AUTH_QOP_PRESENT;

                    }/* QoP filled */
                    
                    /* restoring the value of the old sequence number */
                    p_auth_data_recvd->sequence_num = sequence_num;

                    ret_val = ICF_SUCCESS;
                    break;
                } 
                else 
                {
                    /* Nonce as NULL received */
                    ret_val = ICF_FAILURE;
                    break;
                }
            }
            else
            {/* hdr type not matched yet: continue */
                continue;
            }
            
            
        }/* else: auth_params member read safely: processing ends */
        
    }/* for loop: ends*/
    /*SPR 18769: Start: Free memory of p_previous_pnonce
      local variable as it is no more required*/
    if(ICF_NULL != p_previous_pnonce)
    {   
        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_previous_pnonce, 
                    ICF_MEM_COMMON, 
                    p_ssa_pdb->p_ecode, 
                    ret_val) 
    }/*SPR 18769 End*/
    return ret_val;/* if not found then FAILURE is returned */
    
}/* Function icf_ssa_extract_challenge() ends here */


#ifdef ICF_SSA_UT_NR_CODE

/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_extract_qop
 *
 * DESCRIPTION: The function extracts the QoP from the auth_params_lis
 *                for the header type sepcified by the calling function.
 *              
 *
 * RETURNS: icf_return_t 
 *
************************************************************************/  
icf_return_t icf_ssa_extract_qop(
       INOUT  icf_ssa_pdb_st                    *p_ssa_pdb,
       INOUT  icf_string_st                      *p_qop,       
       INOUT  Sdf_ty_slist                          *p_auth_params_list,
       INOUT     icf_uint8_t                          header_type,
       OUT   icf_error_t                       *p_ecode)
{
    icf_uint32_t        list_size = ICF_NULL;
    Sdf_st_error            err;
    icf_uint32_t        loop_list = ICF_NULL;
    Sdf_ty_pvoid        p_list_member;
    icf_uint8_t        *p_temp_string = ICF_NULL;        
    icf_return_t        ret_val = ICF_FAILURE;
    icf_uint8_t        *p_temp_unq_string = ICF_NULL; /* unquoted string */
    icf_uint32_t        temp_len = 0;
    

    /* This function is not called on an empty list
     * hence we will not check for the empty ness of the list */
    sdf_listSizeOf(p_auth_params_list, &list_size,
                                &err);

    for (loop_list = 0; loop_list < list_size; loop_list++ )
    {
        /* for loop: begin processing */
        if (Sdf_co_fail == sdf_listGetAt (p_auth_params_list,
            loop_list,
            &p_list_member, 
            &err))
        {
            continue;
            
        }
        else
        {
            /* else: auth_params member read safely: processing begins */
            
            if(header_type == ((Sdf_st_authenticationParams *)(p_list_member))->
                dHdrType)
            {
            /* We have found the header type we were looking for:
                * Now copy the challenge and run out of the loop */
                
                /* Check for presence of qop */
                if (ICF_NULL != 
                    ((Sdf_st_authenticationParams *)(p_list_member))->pQop) 
                {
                    

                    p_temp_string =  
                        ((Sdf_st_authenticationParams *)(p_list_member))->pQop;
                    
                    temp_len = icf_port_strlen(p_temp_string);
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        temp_len+1,
                        ICF_MEM_COMMON, p_temp_unq_string,
                        ICF_RET_ON_FAILURE, p_ecode, ret_val)
                        
                    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
                        (ICF_NULL != p_temp_unq_string))
                                    
                
                    sdf_fn_uaUnq(p_temp_string, p_temp_unq_string);


                    icf_port_strcpy(p_qop->str, p_temp_unq_string);
                        
                    p_qop->str_len = icf_port_strlen(p_qop->str);
                    

                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_temp_unq_string, 
                        ICF_MEM_COMMON, p_ecode, ret_val)

                    ret_val = ICF_SUCCESS;
                    break;
                }/* Non Null qop: Ends here */ 
                else 
                {
                    ret_val = ICF_FAILURE;
                    break;
                }
            }
            else
            {
                continue;
            }
            
            
        }/* else: auth_params member read safely: processing ends */
        
    }/* for loop: ends*/
    
    return ret_val;
    
}/* Function icf_ssa_extract_qop() ends here */
#endif

/************************************************************************
 *
 * FUNCTION NAME: icf_ssa_compute_nc
 *
 * DESCRIPTION: The function computes the nc string from nonce_count
 *              
 *
 * RETURNS: icf_return_t 
 *
************************************************************************/  
icf_return_t icf_ssa_compute_nc(
       INOUT  icf_glb_pdb_st                      *p_glb_pdb,
       INOUT  icf_ssa_ctxt_st                   *p_ssa_ctxt,
       INOUT  icf_string_st                      *p_nc,
       INOUT  icf_uint32_t                      nonce_count,
       OUT   icf_error_t                       *p_ecode)
{
    icf_return_t        ret_val = ICF_SUCCESS;

    icf_uint8_t str[100] = {0}; 
    icf_uint8_t newstr[100] = {0}; 
    icf_uint32_t j; 

    /* To remove warnings */
    p_glb_pdb=p_glb_pdb;
    p_ssa_ctxt=p_ssa_ctxt;
    p_ecode=p_ecode;

    str[0]='\0';
    newstr[0]='\0';

    j = icf_port_sprintf((icf_int8_t *)str, "%x", nonce_count);
    for ( ; 8-(j) > 0 ; j++)
    {
        icf_port_strcat(newstr, (icf_uint8_t *)"0"); 
    }
    icf_port_strcat(newstr, str);
    
    icf_port_strcpy(p_nc->str,newstr);
    p_nc->str_len =
            (icf_uint16_t)icf_port_strlen(p_nc->str);

    /*ICF_PRINT(("newstr = %s [%d]\n", newstr, icf_port_strlen(newstr))); */

    return ret_val;
}/* Function icf_ssa_compute_nc() ends here */

#ifdef ICF_SIGCOMP_SUPPORT
/******************************************************************************
 ** FUNCTION:         icf_ssa_checkForSigCompParam
 **
 ** DESCRIPTION:     This function checks the target address spec for 
 **                 compressing the Outgoing Message.
 **                 For A request Message It checks the TopMost Route
 **                 Header If present or to the Request Uri line whether
 **                 it contains comp=sigcomp parameter or not
 **                 
 **                 For A response message it checks the topmost Via
 **                 header field.If it contains comp_sigcomp then the
 **                 response will be compressed.
 **
 **                 Refer RFC 3486: Section 2:
 **
 **                 ["The presence of the parameter (comp=sigcomp) in a 
 **                  URI indicates that the request has to be compressed 
 **                  using SigComp.The presence of comp=sigcomp in a Via 
 **                  header field indicates that the response has to be 
 **                  compressed using SigComp.]
 **
 **                 Refer RFC 3486: Section 5:
 **
 **                 [If the topmost Via header field contains the 
 **                 parameter comp=sigcomp, the response SHOULD be compressed.
 **                 Otherwise, the response MUST NOT be compressed.]
 **                    
 ******************************************************************************/
static icf_return_t
icf_ssa_checkForSigCompParam(
     INOUT     Sdf_st_callObject              *pObject,
     INOUT     SipMessage                     *pMessage, 
     OUT    icf_boolean_t               *p_isSigcompParamPres,
     OUT    icf_error_t                 *p_ecode)

{
    Sdf_st_error            SdfErr,*pError=&SdfErr;
    SipError                SipErr;
    en_SipMessageType        dType;
    Sdf_st_transaction         *pTransaction=Sdf_co_null;
    Sdf_ty_s8bit               *pTmpVal = Sdf_co_null;
    SipAddrSpec               *pAddrSpec=Sdf_co_null;
    SipAddrSpec                *pRouteAddrSpec = Sdf_co_null;
    SipAddrSpec                *pReqLineAddrSpec = Sdf_co_null;
    Sdf_ty_bool               dIsPresentLr=Sdf_co_false;
    Sdf_ty_u32bit             dCount=0;
    Sdf_ty_s8bit              *pTempHost = Sdf_co_null;
    Sdf_ty_s8bit              *pHost = Sdf_co_null;
       SipReqLine                 *pReqLine = Sdf_co_null;
    en_AddrType                dSchemeType = SipAddrSipUri;
    icf_return_t         ret_val = ICF_FAILURE;

    if (sip_getMessageType(pMessage, &dType, (SipError*)\
        &(SipErr)) ==  SipFail)
     {
        return ret_val ;
    }
    if (dType == SipMessageRequest)
    {
        if (sip_getReqLine(pMessage, &pReqLine, \
                (SipError *)&(SipErr)) == SipFail)
        {
               return ret_val;
           }
            
           if (sip_getAddrSpecFromReqLine(pReqLine, &pReqLineAddrSpec, \
               (SipError *)&(SipErr)) == SipFail)
           {
               sip_freeSipReqLine(pReqLine);
               return ret_val;
           }

           sip_freeSipReqLine(pReqLine);
        dSchemeType = pReqLineAddrSpec->dType;

        sip_getHeaderCount(pMessage,SipHdrTypeRoute, &dCount, \
            (SipError *)&(SipErr));

        if(dCount !=0)
        {
            Sdf_ty_slist     slRouteHeaderList;
            Sdf_st_headerList *pHeaderList = Sdf_co_null;
            SipHeader *pRouteHeader = Sdf_co_null;


            /* Check whether the top most route entry is lr or not */
            
            sdf_ivk_uaGetHeaderListByCorrelation( \
                &(pObject->slPersistentHeaders), \
                (Sdf_ty_s8bit *)"uat-routeset",    &slRouteHeaderList, pError);

            sdf_listGetAt(&slRouteHeaderList, 0, \
                    (Sdf_ty_pvoid *)&pHeaderList, pError);

            sdf_listGetAt(&(pHeaderList->slHeaders), 0, \
                    (Sdf_ty_pvoid *)&pRouteHeader, pError);

            if (sip_getAddrSpecFromRouteHdr(pRouteHeader, &pRouteAddrSpec, \
                    (SipError *)&(SipErr)) == SipFail)
            {
                sdf_listDeleteAll(&slRouteHeaderList, pError);
                   return ret_val;
            }
            sdf_listDeleteAll(&slRouteHeaderList, pError);

            sdf_fn_uaCheckLrParameter(pRouteAddrSpec, &dIsPresentLr,pError);
        }

        if(dIsPresentLr == Sdf_co_true)
        {
            pAddrSpec = pRouteAddrSpec;
            sip_freeSipAddrSpec(pReqLineAddrSpec);
        }
        else
        {
            pAddrSpec = pReqLineAddrSpec;
            sip_freeSipAddrSpec(pRouteAddrSpec);
        }

        if(pAddrSpec->dType != SipAddrReqUri)
        {
            Sdf_ty_u32bit dUrlParamCount = 0;
            SipUrl        *pUrl = Sdf_co_null;

            if(sdf_ivk_uaGetUrlFromAddrSpec(pAddrSpec, &pUrl,\
                        pError) == Sdf_co_fail)
            {
                sip_freeSipAddrSpec(pAddrSpec);
                   return ret_val;
            }
            if (sip_getUrlParamCountFromUrl(pUrl, &dUrlParamCount, \
                (SipError*)&(SipErr)) == SipFail)
            {
                sip_freeSipUrl(pUrl);
                sip_freeSipAddrSpec(pAddrSpec);
                   return ret_val;
            }

            if (dUrlParamCount > 0)
            {
                Sdf_ty_u32bit dIndex;
                for (dIndex = 0; dIndex < dUrlParamCount; dIndex++)
                {
                    SipParam *pUrlParam;
                    Sdf_ty_s8bit *pName;
                    
                    if (sip_getUrlParamAtIndexFromUrl(pUrl, &pUrlParam,\
                        dIndex, (SipError*)&(SipErr)) == SipFail)
                    {
                        sip_freeSipUrl(pUrl);
                        sip_freeSipAddrSpec(pAddrSpec);
                         return ret_val;
                    }

                    if (sip_getNameFromSipParam(pUrlParam, &pName, \
                            (SipError*)&(SipErr)) == SipFail)
                    {
                        sip_freeSipParam(pUrlParam);
                        sip_freeSipUrl(pUrl);
                        sip_freeSipAddrSpec(pAddrSpec);
                         return ret_val;
                    }

                    if (Sdf_mc_strcmp(pName, "comp") == 0)
                    {
                        Sdf_ty_s8bit *pTempCompType = Sdf_co_null;

                        if (sip_getValueAtIndexFromSipParam(pUrlParam, \
                            &pTempCompType, 0, (SipError*) \
                            &(SipErr)) == SipFail)
                        {
                            sip_freeSipParam(pUrlParam);
                            sip_freeSipUrl(pUrl);
                            sip_freeSipAddrSpec(pAddrSpec);
                             return ret_val;
                        }
                        /*
                         * If a Compression parameter exists, check whether
                         * the value is sigcomp or not
                         */
                        if (Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pTempCompType,
                                    (Sdf_ty_s8bit*)"sigcomp") == 0)
                        {
                            *p_isSigcompParamPres = ICF_TRUE;
                            break;
                        }
                    }
                        
                    sip_freeSipParam(pUrlParam);
                } /* End of the for loop */
            }
            /*
             * If any header params are present in the URL, remove that
             * as well (acc. to RFC, method and header params should
             * not be present in Request-URI.
             */
            sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&\
                (pUrl->pHeader),pError);
            /* Free the local reference here. */
            sip_freeSipUrl(pUrl);
       }
       sip_freeSipAddrSpec(pAddrSpec);
    }
    else if (dType == SipMessageResponse)
    {
        SipHeader dTempHeader;
        SipParam     *pViaParam;
        Sdf_ty_u32bit dViaParamCount=0, dIndex=0;

        if (sip_getHeaderAtIndex(pMessage, SipHdrTypeVia, \
            &dTempHeader, 0, (SipError*)&(SipErr)) == SipFail)
        {
            return ret_val;
        }

        if (sip_getViaParamCountFromViaHdr(&dTempHeader, &dViaParamCount, \
            (SipError *)&(SipErr)) == SipFail)
        {
            sip_freeSipHeader(&dTempHeader);
            return ret_val;
        }
        for (dIndex=0; dIndex<dViaParamCount; dIndex++)
        {
            Sdf_ty_s8bit *pParamName  = Sdf_co_null;
            Sdf_ty_s8bit *pParamValue = Sdf_co_null;

            if (sip_getViaParamAtIndexFromViaHdr(&dTempHeader, &pViaParam, \
                (Sdf_ty_u32bit)dIndex, (SipError *)&(SipErr)) \
                == SipFail)
            {
                sip_freeSipHeader(&dTempHeader);
                return ret_val;
            }
            if (sip_getNameFromSipParam(pViaParam, &pParamName, \
                (SipError *)&(SipErr)) == SipFail)
            {
                sip_freeSipHeader(&dTempHeader);
                sip_freeSipParam(pViaParam);
                return ret_val;
            }
            if (sip_getValueAtIndexFromSipParam(pViaParam, &pParamValue, \
                (Sdf_ty_u32bit)0, (SipError *)&(SipErr)) == SipFail)
            {
                sip_freeSipParam(pViaParam);
                if((SipErr != Sdf_en_noExistError) && \
                    (SipErr != Sdf_en_invalidIndexError))
                {
                    sip_freeSipHeader(&dTempHeader);
                    return ret_val;
                }
                else
                {
                    continue;
                }
            }
            if (Sdf_mc_strcmp(pParamName, "comp") == 0)
            {
                /*
                 * If a Compression parameter exists, check whether
                 * the value is sigcomp or not
                 */
                if (Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pParamValue,
                            (Sdf_ty_s8bit*)"sigcomp") == 0)
                {
                    *p_isSigcompParamPres = ICF_TRUE;
                    break;
                }
            }
            sip_freeSipParam(pViaParam);
        }/* End of for Loop */
        
        sip_freeSipHeader(&dTempHeader);
    }
    ret_val = ICF_SUCCESS;
    return ret_val;
}

/******************************************************************************
 ** FUNCTION:         icf_ssa_find_sigsa_ctxt_from_sip_msg
 **
 ** DESCRIPTION:     This function coding the decodes the 
 **                 SIP message and if decode is successfull then
 **                 it fetches the callObject from the map by passing the
 **                 call id,If the CallObject exists then it fetches the actual
 **                 SSA context and sends the SIGSA context stored in it. 
 **                 if the SSA context does not exist then 
 **                    
 ******************************************************************************/
icf_return_t icf_ssa_find_sigsa_ctxt_from_sip_msg(
                              OUT           icf_void_t   **p_p_sigsa_ctxt,
                              INOUT            icf_uint8_t   *pDecompMsg,
                              INOUT            icf_uint32_t  dDecompMsgLen,
                              INOUT            icf_void_t    *p_AppData,
                              OUT           icf_error_t   *p_ecode)
{
    Sdf_st_eventContext       *p_event_ctxt =
                                   (Sdf_st_eventContext*) p_AppData;

    icf_ssa_ctxt_st        *p_ssa_ctxt = 
                                 (icf_ssa_ctxt_st*)p_event_ctxt->pData;

    icf_ssa_pdb_st         *p_ssa_pdb =
                               (icf_ssa_pdb_st*)p_ssa_ctxt->p_ssa_pdb;
    
    icf_ssa_ctxt_st        *p_actual_ssa_ctxt = ICF_NULL;

    Sdf_st_callObject         *p_call_obj = p_ssa_ctxt->p_call_obj;
    icf_uint8_t            *p_current_sip_pdu = pDecompMsg;
    icf_uint8_t            *p_next_msg = ICF_NULL;
    SipOptions                 sip_options ;
    icf_return_t            ret_val = ICF_FAILURE;
    SipError                   SipErr;

    /*
    * Following stops SIP stack from stopping txn timer 
    * on it's own(HSSUA)
    */
    icf_print_pdu(p_ssa_pdb->p_glb_pdb,
        p_current_sip_pdu,p_event_ctxt->pTranspAddr->pHost, 
        p_event_ctxt->pTranspAddr->dPort, dDecompMsgLen);

    sip_options.dOption = SIP_OPT_NOTIMER | SIP_OPT_BADMESSAGE;
   
    p_ssa_pdb->msg_type = sdf_ivk_uaDecodeMessage(
                        p_call_obj, p_current_sip_pdu, \
                        &sip_options, dDecompMsgLen, &p_next_msg,
                        p_event_ctxt,
                        &(p_ssa_pdb->sdf_error));
   if (ICF_NULL != p_next_msg)
   {
       /* Another message is there to be processed.
        * So we invoke ES/port interface to read the processed
        * bytes from the connection and then we set the pointer
        * for current_sip_pdu to the p_next_msg*/
       p_ssa_pdb->processed_bytes =
           icf_port_strlen(p_current_sip_pdu) - 
           icf_port_strlen(p_next_msg);
   }
   else
   {
       p_ssa_pdb->processed_bytes = 
           icf_port_strlen(p_current_sip_pdu);
   }
    
    ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->common_bitmask,\
                ICF_SSA_SIP_MSG_DECODED_BY_UATK);
    *p_p_sigsa_ctxt = ICF_NULL;

    if((ICF_NULL != p_call_obj->pCommonInfo) &&
       (ICF_NULL != p_call_obj->pCommonInfo->pCallid))
    {
        /* Message decoded for fetching ssa_ctxt by the CallId */
        if( ICF_FAILURE != icf_ssa_map_nw_callid(
                    p_ssa_pdb, p_call_obj->pCommonInfo->pCallid,
                    &p_actual_ssa_ctxt,p_ecode))
        {
#ifdef ICF_IPSEC_ENABLED
            if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
            {
                icf_rgm_glb_data_st         *p_rgm_glb_data  = ICF_NULL;

                if (ICF_FAILURE == \
                        icf_dbm_get_module_glb_data(p_ssa_pdb->p_glb_pdb,\
                        ICF_INT_MODULE_REGM, 
                        (icf_void_t **)(p_rgm_glb_data),
                        p_ssa_pdb->p_ecode))
                {
                    /*ICF_SIGSA_TRACE(("\nFailure while getting RGM Global Data in SIGSA\n"));*/
                    return ICF_FAILURE;
                }
                *p_p_sigsa_ctxt = &(p_rgm_glb_data->p_sigsa_ctxt);
            }
            else
            {
                /* Ssa Context Fetched from the Map */
                *p_p_sigsa_ctxt = p_actual_ssa_ctxt->p_sigsa_ctxt;
                /* Set this Sigsa Context to the temporary ssa context */
                p_ssa_ctxt->p_sigsa_ctxt = *p_p_sigsa_ctxt;    
            }
#else
            /* Ssa Context Fetched from the Map */
            *p_p_sigsa_ctxt = p_actual_ssa_ctxt->p_sigsa_ctxt;
            /* Set this Sigsa Context to the temporary ssa context */
            p_ssa_ctxt->p_sigsa_ctxt = *p_p_sigsa_ctxt;
#endif

            if(ICF_NULL != *p_p_sigsa_ctxt)
            {
                /* In crement the reference Counter */
                icf_sigsa_incr_ref_count_to_sigsa_ctxt(*p_p_sigsa_ctxt);
            }


            ret_val = ICF_SUCCESS;

        }
        else
        {
            /* A new call Has been received or a stray response received
             * Where the SSA context has been deleted from the map
             */
            /* Check whether Message has been successfully decoded */
            if((Sdf_en_success == p_ssa_pdb->msg_type) || 
               (Sdf_en_strayMessage == p_ssa_pdb->msg_type))
            {
                SipHeader               *p_called_hdr = SIP_NULL;
                SipToHeader             *pToHeader = SIP_NULL;
                icf_address_st       *p_address = SIP_NULL;
                SipAddrSpec             *p_addr_spec = SIP_NULL;
                icf_rgm_context_st   *p_rgn_cntxt_blk = SIP_NULL;
                SipMessage              *pMessage = SIP_NULL;
                en_SipMessageType        dType;
                /* The Message has been successfully decoded */

                if (ICF_NULL != p_call_obj->pUasTransaction)
                {
                    pMessage = p_call_obj->pUasTransaction->pSipMsg;
                }
                else if (ICF_NULL != p_call_obj->pUacTransaction)
                {
                    pMessage = p_call_obj->pUacTransaction->pSipMsg;
                }

                if(ICF_NULL == pMessage) 
                {
                    /* Failure condition */
                }
                else if(SipFail == sip_getMessageType(pMessage, &dType,
                                   (SipError*)&SipErr))
                {
                     /* Failure condition */

                }
                /* The MessageType has successfully Fetch */
                else if (dType == SipMessageRequest)
                {
                   /* For reuest Type Message
                    * Get the Request Uri from P-Called-Party Header(if present)
                    * else get the Request Uri from the To header */
                    icf_ssa_parse_unknown_header_like_from_hdr(
                        p_ssa_pdb,
                        pMessage,
                        "P-Called-Party-ID",
                        &p_called_hdr);

                    if(ICF_NULL == p_called_hdr)
                    {
                        pToHeader = (SipToHeader *)
                            (p_call_obj->pCommonInfo->pTo->pHeader);
                    }
                    else
                    {
                        pToHeader = (SipToHeader *)(p_called_hdr->pHeader);
                    }
                }
                else if(dType == SipMessageResponse)
                {
                    /* For response Type Message
                     * Get the Request Uri from P-Called-Party Header(if present)
                     * else get the Request Uri from the From header stored */
                    icf_ssa_parse_unknown_header_like_from_hdr(
                        p_ssa_pdb,
                        pMessage,
                        "P-Asserted-Identity",
                        &p_called_hdr);

                    if(ICF_NULL == p_called_hdr)
                    {
                        pToHeader = (SipToHeader *)
                            (p_call_obj->pCommonInfo->pFrom->pHeader);
                    }
                    else
                    {
                        pToHeader = (SipToHeader *)(p_called_hdr->pHeader);
                    }

                }

                if(ICF_NULL != pToHeader)
                {
                   ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        ICF_PORT_SIZEOF(icf_address_st),
                        ICF_MEM_COMMON, (icf_void_t*)p_address,
                        ICF_RET_ON_FAILURE, p_ecode, ret_val)

                    p_addr_spec = ((SipToHeader *)(pToHeader))->pAddrSpec;
                       
                   if ( ICF_FAILURE ==
                       icf_ssa_populate_address_from_sip_addr_spec(
                       p_ssa_pdb,
                       p_addr_spec,
                       p_address))
                   {
                       /*Raise/Set Error:UATK_PROCESSING_FAILURE*/
                   }
                    /* Fetch the Registration Context by giving the Request URI */
                   else if (ICF_FAILURE ==
                               icf_rgm_fetch_ctxt_for_uri(p_ssa_pdb->p_glb_pdb,
                                p_address,&p_rgn_cntxt_blk,
                                p_ecode))
                   {
                   }
                   /* If regisration block fetched successfully */
                   /* then Get SSA context from the Registration Context */
                   /* Return the SIGSA context from the SSA contxt */
                   else 
                   {
#ifdef ICF_IPSEC_ENABLED
                       if (ICF_TRUE == 
                                p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
                       {
                            icf_rgm_glb_data_st         *p_rgm_glb_data  = ICF_NULL;

                            if (ICF_FAILURE == \
                                    icf_dbm_get_module_glb_data(
                                            p_ssa_pdb->p_glb_pdb,\
                                            ICF_INT_MODULE_REGM, 
                                            (icf_void_t **)(p_rgm_glb_data),
                                            p_ssa_pdb->p_ecode))
                            {
                                /*ICF_SIGSA_TRACE(("\nFailure while getting RGM Global Data in SIGSA\n"));    */
                                return ICF_FAILURE;
                            }
                            *p_p_sigsa_ctxt = &(p_rgm_glb_data->p_sigsa_ctxt);
                        }
                        else
                        {
                            *p_p_sigsa_ctxt = ((icf_ssa_ctxt_st*)
                                           (p_rgn_cntxt_blk->p_ssa_ctxt))->
                                                        p_sigsa_ctxt;
                        }
#else
                       *p_p_sigsa_ctxt = ((icf_ssa_ctxt_st*)
                                           (p_rgn_cntxt_blk->p_ssa_ctxt))->
                                                        p_sigsa_ctxt;
                       /* Set this Sigsa Context to the temporary ssa context */
                       p_ssa_ctxt->p_sigsa_ctxt = *p_p_sigsa_ctxt;
#endif

                       if(ICF_NULL != *p_p_sigsa_ctxt)
                       {
                          /* In crement the reference Counter */
                          icf_sigsa_incr_ref_count_to_sigsa_ctxt(*p_p_sigsa_ctxt);
                       }


                       ret_val = ICF_SUCCESS;
                   }
                   
                   if(ICF_NULL != p_address)
                   {

                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_address,
                           ICF_MEM_COMMON, p_ecode, ret_val)
                   }

                }
                /* else return Failure */
            }/* For Successfully decoded message */
        }/* SSA context is not found in the Map */
    }/* Call id is present in the decoded code */
    return ret_val;
}

/****************************************************************************
 * FUNCTION:           icf_ssa_send_create_comp_req_to_sigsa
 *
 * DESCRIPTION:        This routine Sends CREATE_COMP_REQUEST TO
 *                     SIGSA for Creating the compartment for sending
 *                     Compressed Message
 *****************************************************************************/
icf_return_t icf_ssa_send_create_comp_req_to_sigsa(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_internal_msg_st      temp_internal_msg;
    icf_create_comp_req_st   create_comp_req;

    temp_internal_msg.msg_hdr.msg_id = ICF_CREATE_COMP_REQ;
    temp_internal_msg.msg_hdr.p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    temp_internal_msg.msg_hdr.payload_length = 
                                ICF_PORT_SIZEOF(icf_create_comp_req_st);
    temp_internal_msg.msg_hdr.status = 0;
    create_comp_req.p_rgm_ctxt = 
        ((icf_ssa_ctxt_st*)p_ssa_pdb->p_ssa_ctxt)->p_rgm_ctxt;
    
    temp_internal_msg.p_msg_data = (icf_uint8_t*)&create_comp_req;

    ret_val = icf_sigsa_process_mesg(&temp_internal_msg);
    return ret_val;

}


/****************************************************************************
 * FUNCTION:           icf_ssa_send_delete_comp_ind_to_sigsa
 *
 * DESCRIPTION:        This routine Sends ICF_DELETE_COMP_IND TO
 *                     SIGSA for deleting the compartment 
 *****************************************************************************/
icf_return_t icf_ssa_send_delete_comp_ind_to_sigsa(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_internal_msg_st      temp_internal_msg;
    icf_delete_comp_ind_st   delete_comp_ind;

    temp_internal_msg.msg_hdr.msg_id = ICF_DELETE_COMP_IND;
    temp_internal_msg.msg_hdr.p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    temp_internal_msg.msg_hdr.payload_length = 
                                ICF_PORT_SIZEOF(icf_delete_comp_ind_st);
    temp_internal_msg.msg_hdr.status = 0;

    delete_comp_ind.p_rgm_ctxt = 
        ((icf_ssa_ctxt_st*)p_ssa_pdb->p_ssa_ctxt)->p_rgm_ctxt;
    
    temp_internal_msg.p_msg_data = (icf_uint8_t*)&delete_comp_ind;

    ret_val = icf_sigsa_process_mesg(&temp_internal_msg);

    return ret_val;
}
#endif

/****************************************************************************
 * FUNCTION:           icf_ssa_add_param_in_contact_hdr
 *
 * DESCRIPTION:        This routine fetch contact headers from InitData
 *                     Adds comp=sigcomp paramater in contact header
 * 
 *****************************************************************************/
icf_return_t   icf_ssa_AddParamToContactHdrList(
        Sdf_ty_slist             *pContactHdrList,
        icf_uint8_t           *p_param,
        Sdf_st_error *             pError)
{
    icf_return_t       ret_val = ICF_SUCCESS;
    icf_uint32_t        dSize = 0;
    SipHeader             *pContactHeader = Sdf_co_null;
    icf_uint8_t        iterator1 = 0;
    Sdf_ty_s8bit          *pName = ICF_NULL;
    Sdf_ty_s8bit          *p_value = ICF_NULL;
    SipError error;
    Sdf_ty_s8bit *pDupValue = Sdf_co_null;
    Sdf_ty_s8bit          temp_buff[32]={'\0'}; 

    if(ICF_NULL == p_param)
    {
        ret_val = ICF_FAILURE;
    }
    /*Get the Size of Conatact Header List*/
    if(Sdf_co_fail == sdf_listSizeOf(pContactHdrList,&dSize,pError))
    {
        ret_val = ICF_FAILURE;
    }
    /*If list contains elements*/
    else if(dSize !=0)
    {
        if (p_param) icf_port_strcpy((icf_uint8_t *)temp_buff,(icf_uint8_t *)p_param);
        pName = icf_port_strtokr(temp_buff,"=",&p_value);
       /*Fetch all the Contact headers from initdata*/
        for(iterator1=0; iterator1<dSize; iterator1++)
        {
            SipParam *pSipParam                 = SIP_NULL;
            if(Sdf_co_fail == sdf_listGetAt(pContactHdrList,
                iterator1, (Sdf_ty_pvoid *)&pContactHeader,pError))
            {
                ret_val = ICF_FAILURE;
                break;
            }
            else if(SipFail == sip_initSipParam(&pSipParam, &error))
            {      
                /*Klocwork warning removal*/
                ICF_KLOCWORK_FALSE_POSITIVE(p_persistent_glb_pdb,pSipParam)

                ret_val = ICF_FAILURE;
                break;
            }
            else
            {
                SipAddrSpec       *pSipAddrSpec = ICF_NULL;

                /*Klocwork warning removal*/
                ICF_KLOCWORK_FALSE_POSITIVE(p_persistent_glb_pdb,pSipParam)
                                              
                if(SipFail == 
                    sip_getAddrSpecFromContactHdr(pContactHeader,&pSipAddrSpec,
                    (SipError *)&(pError->stkErrCode)))
                {
                    sip_freeSipParam(pSipParam);
                    ret_val = ICF_FAILURE;
                    break;
                }
                else if((SipAddrSipUri == pSipAddrSpec->dType) ||
            (SipAddrSipSUri == pSipAddrSpec->dType))
                {
                    pSipParam->pName = STRDUPACCESSOR(pName);
                    if (p_value != SIP_NULL)
                    {
                        pDupValue = (SIP_S8bit*)STRDUPACCESSOR(p_value);
                        if ( sip_listAppend(&(pSipParam->slValue),
                            pDupValue,
                            (SipError *)&(pError->stkErrCode)) == SipFail )
                        {
                            sip_freeSipParam(pSipParam);
                            sip_freeSipAddrSpec(pSipAddrSpec);
                            ret_val = ICF_FAILURE;
                            break;
                        }
                    }
                    if (sip_listAppend( 
                        &((pSipAddrSpec->u).pSipUrl->slParam),
                        (SIP_Pvoid)pSipParam, 
                        (SipError *)&(pError->stkErrCode)) == SipFail)
                    {
                        sip_freeSipParam(pSipParam);
                        sip_freeSipAddrSpec(pSipAddrSpec);
                        ret_val = ICF_FAILURE;
                        break;
                    }
                }
                sip_freeSipAddrSpec(pSipAddrSpec);
            }
        } /* for(iterator1=0; iterator1<dSi... */
    } /* if(dSize !=0) */
    return ret_val;
} /* icf_ssa_AddParamToContactHdrList */


ICF_SIC_START

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_send_subscribe_req
 *
 * DESCRIPTION:     This function constructs and sends Subscribe req on network.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_subscribe_req(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    Sdf_ty_s8bit                HdrName[] = "Event";
    Sdf_ty_s8bit 
               EventName[ICF_MAX_STR_LEN];
    
     Sdf_ty_s8bit               proto[ICF_MAX_SIZE_INT_USAGE_STR];

    SipOptions                  options;
    Sdf_st_error                sdf_error;
    Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;
    icf_uint32_t                tVal;
    SipError                    sip_err;
    SipHeader                    *p_exp_hdr = SIP_NULL;
    icf_ssa_ctxt_st          *p_ssa_ctx = p_ssa_pdb->p_ssa_ctxt;
    icf_sic_ctx_st          *p_sic_ctx = p_ssa_ctx->p_sic_ctxt;
#ifdef ICF_IPSEC_ENABLED
    icf_uint8_t            *p_value = ICF_NULL;
#endif
  SipHeader                    *p_event_hdr = SIP_NULL;
    
    /* this fix is added here to prevent a failure if the string from the
     * application is received with length including the \0
     */
  icf_uint32_t                strlen_len = ICF_NULL;
  icf_config_data_st       *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
  icf_uint8_t              self_ip[16];
  icf_transport_address_st self_addr = {{0,{{0,"\0"}}},0};

  /* Rel 8.1 : Klokworks warning resolution */
  ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                           p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                           ret_val)
  if(ICF_FAILURE == ret_val)
  {
      ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
      return ret_val;
  }

  if(ICF_NULL != p_sic_ctx->p_preferred_identity)
  {
      if ((ICF_ADDRESS_PLAN_SIP_URI == 
              p_sic_ctx->p_preferred_identity->addr_type) ||
           (ICF_ADDRESS_PLAN_SIPS_URI ==   
              p_sic_ctx->p_preferred_identity->addr_type))
      {
          strlen_len = icf_port_strlen((icf_uint8_t*)
                  (p_sic_ctx->p_preferred_identity->addr_val.str));

          /* adjust the string length filled by the app */
        if (p_sic_ctx->p_preferred_identity->addr_val.str_len == (strlen_len + 1))
        {
            p_sic_ctx->p_preferred_identity->addr_val.str_len = (icf_uint16_t )strlen_len;
        }
    }
    }
    options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

    /*Fetch subscription duration*/
    tVal = p_sic_ctx->app_requested_duration; 
    if(0 != p_ssa_pdb->p_glb_cfg_data->sip_compact_hdrs)
    {
        /* Compact headers is on, use the compact form */
        icf_port_strcpy((icf_uint8_t *)HdrName,(icf_uint8_t *)"o");
    }
  
    /* Set the transport mode in local variable */
     if (ICF_SSA_SIC_INITIAL_REQ & p_ssa_pdb->common_bitmask)
    {
        if (ICF_FAILURE == icf_ssa_check_for_trans_param(p_ssa_pdb,
                    p_ssa_pdb->p_line_data->transport_mode, ICF_NULL, ICF_TRUE))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSettingTransport&Revert Modes"));
            return ICF_FAILURE;
        }
        if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_line_data->transport_mode) ||
                (ICF_TRANSPORT_MODE_BOTH == 
                 p_ssa_pdb->p_line_data->transport_mode))
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
        ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                ICF_SSA_EXPLICIT_CONNECT_REQ)
        }
        else if (ICF_TRANSPORT_TYPE_TLS == 
                p_ssa_pdb->p_line_data->transport_mode)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
        ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                ICF_SSA_EXPLICIT_CONNECT_REQ)
        }
        else if(ICF_TRANSPORT_TYPE_UDP == 
                p_ssa_pdb->p_line_data->transport_mode)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)proto,(icf_uint8_t *) "");
            ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                ICF_SSA_EXPLICIT_CONNECT_REQ)
        }
    }
    else 
    {
        if ((ICF_TRUE == p_ssa_pdb->p_ssa_ctxt->trans_mode_reverted) ||
            (ICF_TRANSPORT_TYPE_UDP == 
            p_ssa_pdb->p_line_data->transport_mode))
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
        }
        else if (ICF_TRANSPORT_TYPE_TLS == 
            p_ssa_pdb->p_line_data->transport_mode)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
        }
        else if ((ICF_TRANSPORT_TYPE_TCP == 
            p_ssa_pdb->p_line_data->transport_mode) ||
                (ICF_TRANSPORT_MODE_BOTH == 
                 p_ssa_pdb->p_line_data->transport_mode))
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)proto,(icf_uint8_t *) "");
        } 
    }

    
    icf_port_strcpy((icf_uint8_t *)EventName,(icf_uint8_t *)p_sic_ctx->event_package.str);

    /*IMP: 
     * Updation needed in update_call_obj for ICF_SSA_USER_ADDR_FRM_SIC*/
    if (ICF_FAILURE == 
                icf_ssa_update_callobj_for_profile(p_ssa_pdb))
    {
    /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        return ICF_FAILURE;
    }
    /*precondition: remove the precondition from supported Hdr list*/
    /* Rel 8.1 : Klokworks warning resolution : Removed NULL
       check for p_ssa_pdb->p_ssa_ctxt->p_call_obj and moved to the 
       beginning of the function.
    */   
    if(Sdf_co_null != p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData)
    {   
        if(ICF_FAILURE == icf_ssa_modify_callobj_profile_for_precondition(
                             p_ssa_pdb,
                             p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                             &sdf_error))
         {
             return ICF_FAILURE;
         }
    }    
    /* IMP: 
     * Updation needed in set_to_in_reg_call_obj for 
     * ICF_SSA_USER_ADDR_FRM_SIC*/
    /* To header will be set */
    if((ICF_SSA_SIC_INITIAL_REQ & p_ssa_pdb->common_bitmask) &&
       (ICF_FAILURE == icf_ssa_set_to_in_sic_callobj(p_ssa_pdb,
                                            (icf_uint8_t *)proto)))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        return ICF_FAILURE;
    }
#if 0
    /*Request URI to be set as destination address*/
    else if (Sdf_co_fail == 
                sdf_ivk_uaMakeAddrSpecFromConstituents(
                    &pAddrSpec, (Sdf_ty_s8bit*)server_addr, 
                    (Sdf_ty_s32bit)server_port,
                    pScheme, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        return ICF_FAILURE;
    }

    else if (Sdf_co_fail == sdf_ivk_uaChangeRequestURI(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                pAddrSpec, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
        return ICF_FAILURE;
    }
#endif

    /*  CSR 1-5685130 Merge */
    if ((ICF_SSA_SIC_INITIAL_REQ & p_ssa_pdb->common_bitmask) && 
        (ICF_FAILURE != ret_val))
    {
        /****************************ICF 8.0************************/
        /* Fill Route Header from Service Route if stored for user-id while 
            registering*/
        if(ICF_FAILURE == 
        icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                p_sic_ctx->p_user_address,
               p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
    }
    if (ICF_FAILURE == ret_val)
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        return ICF_FAILURE;
    }
    else if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                &p_overlap_trans_info,
                "SUBSCRIBE",
                &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
  
        return ICF_FAILURE;
    }

    /* Added null check to resolve Klokworks warning */

    else if ((Sdf_co_null != p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction) &&
             (Sdf_co_fail == 
              sdf_ivk_uaSetTransportSchemeInTransaction(
              p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction, 
              p_overlap_trans_info,
              proto, &sdf_error)))
        {
        
        sdf_ivk_uaClearTransaction(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            p_overlap_trans_info,
            "SUBSCRIBE",
            Sdf_en_uacTransaction);

        return ICF_FAILURE;
    }
    else if (Sdf_co_fail == sdf_ivk_uaMakeTransaction(
                (Sdf_ty_s8bit *)"SUBSCRIBE", 
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);

        return ICF_FAILURE;
    }
    else
    {
        /* Fix for SPR: 19999*/
        /* If application does not want ICF to send expires header*/
        /* Fix for CSR 1-7502322: SPR 19844 */
        /* Expires header should be sent for UnSubscribe irrespective
         * of App setting.
         */
        if ((!(ICF_SIC_EXPIRES_HDR_NOT_TO_BE_SEND & p_sic_ctx->bitmask)) ||
                (ICF_NULL == p_sic_ctx->app_requested_duration))        
        {
            /*Insert Expire header*/
            if (ICF_FAILURE == sip_initSipHeader(
                         &p_exp_hdr, SipHdrTypeExpiresSec, &sip_err))
             {
                 /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

                 sdf_ivk_uaClearTransaction(
                         p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                         p_overlap_trans_info,
                         "SUBSCRIBE",
                         Sdf_en_uacTransaction);

                 sip_freeSipHeader(p_exp_hdr);
                 return ICF_FAILURE;
             }
             else if (ICF_FAILURE == sip_setSecondsInExpiresHdr(
                            p_exp_hdr, p_sic_ctx->app_requested_duration, &sip_err))
             {
                 sdf_ivk_uaClearTransaction(
                         p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                         p_overlap_trans_info,
                         "SUBSCRIBE",
                         Sdf_en_uacTransaction);

                 /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

                 sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
                 sdf_memfree(Sdf_mc_callHandlerMemId, \
                            (Sdf_ty_pvoid *)&p_exp_hdr,\
                                Sdf_co_null);
                 return ICF_FAILURE;
             }
             else if (ICF_FAILURE == sip_setHeader(
                         p_overlap_trans_info->pSipMsg, 
                         p_exp_hdr, &sip_err))
             {
                 sdf_ivk_uaClearTransaction(
                         p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                         p_overlap_trans_info,
                         "SUBSCRIBE",
                         Sdf_en_uacTransaction);

                 /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
                 sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
                 sdf_memfree(Sdf_mc_callHandlerMemId, \
                            (Sdf_ty_pvoid *)&p_exp_hdr,\
                                Sdf_co_null);
                 return ICF_FAILURE;
             }
         }
    }
    /*Insert Event header*/
 /***** fix for event header: ROHIT *********/
    /* Insert Event header as SipHdrTypeEvent instead of SipHdrTypeUnknown */
    if (ICF_FAILURE == ret_val)
    {
        /*Do nothing*/
    }
    else if (ICF_FAILURE == sip_initSipHeader(
                &p_event_hdr, SipHdrTypeEvent, &sip_err))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);
        /*klocwork warning removal*/
        sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
        sdf_memfree(Sdf_mc_callHandlerMemId, \
                   (Sdf_ty_pvoid *)&p_exp_hdr,\
                       Sdf_co_null);

        sip_freeSipHeader(p_event_hdr);
        return ICF_FAILURE;
    }
    else if (ICF_FAILURE == sip_setEventTypeInEventHdr(
                p_event_hdr,Sdf_mc_strdupCT(EventName), &sip_err))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);
        if (ICF_NULL != p_event_hdr->pHeader)
        {
            sip_freeSipEventHeader((SipEventHeader*)p_event_hdr->pHeader);      
        }
        sip_freeSipHeader((SIP_Pvoid)p_event_hdr);
        sdf_memfree(Sdf_mc_callHandlerMemId,
                (Sdf_ty_pvoid *)&p_event_hdr,Sdf_co_null);
        /*klocwork warning removal*/
        sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
        sdf_memfree(Sdf_mc_callHandlerMemId, \
                   (Sdf_ty_pvoid *)&p_exp_hdr,\
                       Sdf_co_null);
        return ICF_FAILURE;
    }
    else if (ICF_FAILURE == sip_setHeader(
                p_overlap_trans_info->pSipMsg, 
                p_event_hdr, &sip_err))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        sip_freeSipEventHeader((SipEventHeader*)p_event_hdr->pHeader);
        sip_freeSipHeader((SIP_Pvoid)p_event_hdr);
        sdf_memfree(Sdf_mc_callHandlerMemId,
                (Sdf_ty_pvoid *)&p_event_hdr,Sdf_co_null);
        /*klocwork warning removal*/
        sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
        sdf_memfree(Sdf_mc_callHandlerMemId, \
                   (Sdf_ty_pvoid *)&p_exp_hdr,\
                       Sdf_co_null);

        return ICF_FAILURE;
    }

    if (ICF_NULL != p_event_hdr)
    {

        sip_freeSipEventHeader((SipEventHeader*)p_event_hdr->pHeader);

        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_event_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)

    }
    sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_exp_hdr,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)

#ifdef ICF_IPSEC_ENABLED
    /* if SA exists, all messages will go protected */
    if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled) &&
        /* if SA exits */
        (ICF_NULL != p_ssa_pdb->p_sa_context))
    {
        /* insert security-verify header in the otg Subscribe */
        if (ICF_FAILURE == icf_ssa_get_sec_verify_string (p_ssa_pdb,&p_value,
            p_ssa_pdb->p_sa_context))
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE ==     
          icf_ssa_insert_unknown_hdr_in_sip_msg (
              p_ssa_pdb,
              (icf_uint8_t*)"Security-Verify",
              p_value, 
              p_overlap_trans_info->pSipMsg))
        {
            ICF_PRINT(("\nFailed to insert unknown header \
                    (Security-Verify)"));
            ret_val = ICF_FAILURE;
        }
        if (ICF_NULL != p_value)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_value,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        }
        if (ICF_SUCCESS == ret_val )
        {
            ICF_PRINT(("\nSecurity Verify Header inserted to \
                            outgoing SUBSCRIBE "));
        }
    }
#endif
   if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
    {
        /* Fix for CSR 1-7436195 */
        /* Coverity bug fix */
        icf_string_st                 addr_val = {0,"\0"};

        if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_SIP_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sip:");
            icf_port_strcat( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                p_preferred_identity->addr_val.str );
            icf_port_strcat( addr_val.str, (icf_uint8_t *)">");


        }
        else if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_TEL_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"tel:");
            icf_port_strcat( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                p_preferred_identity->addr_val.str );
        }
        else if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_E164)
        {
            icf_port_strcpy(addr_val.str,(icf_uint8_t *)"<sip:");

            icf_port_strcat(addr_val.str,
                    p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                    p_preferred_identity->addr_val.str );

            icf_port_strcat(addr_val.str,(icf_uint8_t *)"@");

            /* now appending the self IP/domain */
            /*If per line self transport then copy address from line_data*/
            if(ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
            {
                if(ICF_NULL != p_ssa_pdb->p_line_data)
                {
                    icf_port_memcpy(&self_addr,
                                &(p_ssa_pdb->p_line_data->self_addr),
                                sizeof(icf_transport_address_st));
                }
                else
                {
                    ret_val = ICF_FAILURE;
                }
            }
            else
            {
                icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                                sizeof(icf_transport_address_st));
                }
            if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                           self_addr.addr.addr_type)
            {
                icf_port_strcat(addr_val.str,self_addr.addr.addr.domain.str);
            }
            else/*Assumption that it will be IPV4*/
            {
                if(ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                                      &(self_addr),self_ip))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    icf_port_strcat(addr_val.str,self_ip);
                }
            }
            icf_port_strcat(addr_val.str, (icf_uint8_t *)">");
        }
        else if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_SIPS_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sips:");
            icf_port_strcat( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                p_preferred_identity->addr_val.str );
            icf_port_strcat( addr_val.str, (icf_uint8_t *)">");
        }

        else
        {
            icf_port_strcpy( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->
                p_preferred_identity->addr_val.str );
        }


        if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                p_ssa_pdb, 
                (icf_uint8_t*)"P-Preferred-Identity",
                addr_val.str,
                p_overlap_trans_info->pSipMsg ))
        {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header \
                                    (P-Preferred-Identity)"));
                sdf_ivk_uaClearTransaction(
                                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                                p_overlap_trans_info,
                                "SUBSCRIBE",
                                Sdf_en_uacTransaction);

                /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

                return ICF_FAILURE;
        }
    }


    /* Insert Header/Tag/Body if any given by the application */

    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count)
    {
        if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list),
            ICF_TRUE, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
    }
    
    
    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list.count)
    {
        if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list),
            ICF_FALSE, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
        
    }
    
        if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.count)
    {
        /*Message body header changes Starts*/
        if (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
                    p_ssa_pdb,&(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list) , 
                    ICF_TRUE, &(p_overlap_trans_info->slMsgBodyList)))
        {
            sdf_ivk_uaClearTransaction(\
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                    p_overlap_trans_info, "SUBSCRIBE",\
                    Sdf_en_uacTransaction);

            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                        p_ssa_ctxt->p_call_obj));*/

            return ICF_FAILURE;
        }
        else if ( ICF_FAILURE == icf_ssa_SetAllMsgBody(\
                    Sdf_co_null, p_overlap_trans_info,\
                    (icf_int8_t *)p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.\
                    content_type.str, &sdf_error))
        {
            sdf_ivk_uaClearTransaction(\
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                    p_overlap_trans_info, "SUBSCRIBE",\
                    Sdf_en_uacTransaction);

            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                        p_ssa_ctxt->p_call_obj));*/

            return ICF_FAILURE;
        }
    }/*p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.count*/

    /* To add the P-Access-Network Info header to the SipMsg */
    if ( ICF_FAILURE == 
                icf_ssa_form_and_insert_access_nw_info_hdr(
                p_ssa_pdb, p_overlap_trans_info->pSipMsg))
    {
        ret_val = ICF_FAILURE;
    }
    /* To add security association headers*/
    if(ICF_FAILURE == icf_ssa_form_and_insert_security_agreement_hdrs(
                             p_ssa_pdb,(icf_uint8_t *)"SUBSCRIBE",
                             p_overlap_trans_info->pSipMsg))
    {
        ret_val = ICF_FAILURE;  
    }              
                 

    if (ICF_SUCCESS == ret_val)
    {
        p_ssa_pdb->p_ssa_ctxt->p_overlap_transaction = p_overlap_trans_info;

        if ( ICF_FAILURE == icf_ssa_send_to_peer(
            p_ssa_pdb,
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            p_overlap_trans_info->pSipMsg,
            &options,
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == sdf_ivk_uaEndTransaction(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            Sdf_co_null,
            "SUBSCRIBE",
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "SUBSCRIBE",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
    }
    /*Klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_overlap_trans_info)

    return ret_val;
} /* icf_ssa_send_subscribe_req */



/****************************************************************************
 * FUNCTION:           icf_ssa_init_ssa_context
 *
 * DESCRIPTION:        This routine initializes SSA Context
 * 
 *****************************************************************************/
icf_void_t   icf_ssa_init_ssa_context(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT   icf_ssa_ctxt_st  *p_ssa_ctxt)
{
    icf_uint16_t            i = ICF_NULL;
    icf_uint8_t				index = ICF_NULL;
    if(ICF_NULL == p_ssa_pdb)
    {
       ICF_PRINT(((icf_uint8_t *)"\n[SSA]: PDB is NULL"))
       return;    
    }
    if (ICF_NULL != p_ssa_ctxt)
    {
        icf_port_memset(p_ssa_ctxt,0,sizeof(icf_ssa_ctxt_st));
#ifdef ICF_LOAD_DEBUG
        p_ssa_ctxt->call_id = ICF_INVALID_CALL_ID;
#endif 
        p_ssa_ctxt->callobj_map_index = ICF_SSA_MAX_OPTIONS_CALL_OBJ;        
        p_ssa_ctxt->options_map_index = ICF_SSA_MAX_OPTIONS_CALL_OBJ;
        p_ssa_ctxt->p_conn_table_resp_entry = ICF_NULL;
        p_ssa_ctxt->p_conn_table_req_entry = ICF_NULL;
        p_ssa_ctxt->p_ssa_glb_data = p_ssa_pdb->p_ssa_glb_data;
        p_ssa_ctxt->p_glb_pdb = p_ssa_pdb->p_glb_pdb;
        p_ssa_ctxt->p_hash_key = ICF_NULL;
        p_ssa_ctxt->call_type = ICF_NULL;
        p_ssa_ctxt->bitmask = ICF_NULL;
        p_ssa_ctxt->bitmask_1 = ICF_NULL;
        p_ssa_ctxt->failure_bitmask = ICF_NULL;
        p_ssa_ctxt->p_call_ctxt = ICF_NULL;
        p_ssa_ctxt->p_rgm_ctxt = ICF_NULL;
        p_ssa_ctxt->p_sic_ctxt = ICF_NULL;
        p_ssa_ctxt->p_call_obj = ICF_NULL;
#ifdef ICF_SIGCOMP_SUPPORT
        p_ssa_ctxt->p_sigsa_ctxt = ICF_NULL;
#endif
        p_ssa_ctxt->p_auth_params_list = Sdf_co_null;
        p_ssa_ctxt->auth_params_list_size = 0;
        for (i = 0; i < ICF_MAX_PENDING_PDU_PER_CONN; i++)
        {
            p_ssa_ctxt->p_pending_pdu[i] = ICF_NULL;
        }
        p_ssa_ctxt->no_of_pending_pdu = 0;
        p_ssa_ctxt->no_retrans_req = ICF_FALSE;
#ifdef ICF_SESSION_TIMER
    p_ssa_ctxt->session_timer_expired_refresh = ICF_FALSE;
    p_ssa_ctxt->refresher_method_type    = ICF_SSA_REFRESHER_METHOD_NONE;
    p_ssa_ctxt->num_491_retries_allowed = ICF_SESSION_REFRESH_NUM_491_RETRY_ALWD;
#endif
#ifdef ICF_IPSEC_ENABLED
        p_ssa_ctxt->ssa_sa_context.p_sa_context = ICF_NULL;
        p_ssa_ctxt->ssa_sa_context.p_rgm_context = ICF_NULL;
#endif
        p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;
        p_ssa_ctxt->p_ssa_pdb = p_ssa_pdb;        
        p_ssa_pdb->p_ssa_ctxt->sdp_o_version = ICF_START_SDP_O_VERSION;

        p_ssa_pdb->p_ssa_ctxt->nc = 0;

        p_ssa_pdb->p_ssa_ctxt->timer_count = 0;
#ifdef ICF_NAT_RPORT_SUPPORT
        p_ssa_pdb->p_ssa_ctxt->rport_bitmask = ICF_NULL;
        p_ssa_pdb->p_ssa_ctxt->destination_port = ICF_NULL;
        p_ssa_pdb->p_ssa_ctxt->destination_ip[0] = '\0';
#endif
#ifdef ICF_DNS_LOOKUP_ENABLED
     ICF_CMN_INIT_STRING(p_ssa_pdb->p_ssa_ctxt->fqdn);
     p_ssa_pdb->p_ssa_ctxt->p_transaction = ICF_NULL;
     p_ssa_pdb->p_ssa_ctxt->p_overlap_transaction = ICF_NULL;
     p_ssa_pdb->p_ssa_ctxt->p_dns_ip_addr = ICF_NULL;
     p_ssa_pdb->p_ssa_ctxt->p_dns_resp_timer_data = ICF_NULL;
     p_ssa_pdb->p_ssa_ctxt->dns_resp_timer_id = ICF_TIMER_ID_INVALID;
     p_ssa_pdb->p_ssa_ctxt->ip_fr_req[0] = '\0';
     p_ssa_pdb->p_ssa_ctxt->port_fr_req = 0;
     p_ssa_pdb->p_ssa_ctxt->dns_retrans_timer = 0;
     
    /* Following are the fqdn for SRV and NAPTR record.These are populated
     * in sdf_lookupport.c if any srv or naptr query is performed.Also
     * while adding the A query response in dns buffer same will be
     * populated in dns buffer,so that at dns purge timer expiry same can
     * be removed from DNS Client cache*/     
     ICF_CMN_INIT_STRING(p_ssa_pdb->p_ssa_ctxt->srv_fqdn);
     ICF_CMN_INIT_STRING(p_ssa_pdb->p_ssa_ctxt->naptr_fqdn);
     /* Fix For SPR:20192*/
     ICF_CMN_INIT_STRING(p_ssa_pdb->p_ssa_ctxt->queryA_fqdn);
#endif
#ifdef IMS_CLIENT
     p_ssa_pdb->p_ssa_ctxt->timer_id = ICF_TIMER_ID_INVALID;
     p_ssa_pdb->p_ssa_ctxt->p_timer_data = ICF_NULL;
     p_ssa_pdb->p_ssa_ctxt->p_uac_auth_info_list = ICF_NULL;
     p_ssa_pdb->p_ssa_ctxt->uac_auth_info_list_size = ICF_NULL;
#endif

     p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
     p_ssa_pdb->p_ssa_ctxt->line_id= ICF_INVALID_LINE_ID;
     p_ssa_pdb->p_ssa_ctxt->p_pending_txn = ICF_NULL;
     p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
     p_ssa_pdb->p_ssa_ctxt->trans_mode_reverted = ICF_FALSE;
     p_ssa_pdb->p_ssa_ctxt->p_timer_list = ICF_NULL;
     p_ssa_pdb->p_ssa_ctxt->options_timer_id = ICF_TIMER_ID_INVALID;
     p_ssa_pdb->p_ssa_ctxt->p_options_timer = ICF_NULL;
     p_ssa_pdb->p_ssa_ctxt->context_identifier = ICF_NULL;
     for(index = 0; index < ICF_MAX_STREAM_PER_CALL; index++)
	 {
         ICF_CMN_INIT_STRING(p_ssa_ctxt->rej_stream[index].protocol_name)
         p_ssa_ctxt->rej_stream[index].stream_id =  ICF_STREAM_ID_INVALID;
     }

#ifdef ICF_RUNTIME_NAMESERVER_CONFIG
	 p_ssa_ctxt->refresh_nameserver = ICF_FALSE;
#endif     
     /********** Changes for Forking & Multiple Answer Start (Rel7.0) *********/

      p_ssa_ctxt->forked_resp_counter = ICF_NULL;

     /********** Changes for Forking & Multiple Answer End (Rel7.0) ***********/
    /* Initialise the transport to Invalid */
     p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_INVALID;
     /*Initializing dns_servers_tried to 1 as it is not incremented
      *while doing first query as this is done inside UATK*/
     p_ssa_ctxt->dns_servers_tried = 1;
     p_ssa_ctxt->p_rem_addr_active = ICF_NULL;
     p_ssa_ctxt->p_rem_addr_inactive = ICF_NULL;
     p_ssa_ctxt->rem_servers_tried = ICF_NULL;
     p_ssa_ctxt->p_current_dns_server = ICF_NULL;
     for(index = 0; index < ICF_SSA_MAX_FQDN_ENTRIES; index++)
     {    
         ICF_CMN_INIT_STRING(p_ssa_ctxt->fqdn_list[index])
     }
     icf_cmn_init_reg_auth_data(&(p_ssa_ctxt->auth_data_sent));
     icf_cmn_init_reg_auth_data(&(p_ssa_ctxt->auth_data_recd));
     p_ssa_ctxt->challenge_algo = ICF_NULL;
     p_ssa_ctxt->p_dns_server_data = ICF_NULL;

/*  CSR 1-5385208 Merge */
#ifdef ICF_TRACE_ENABLE
       p_ssa_ctxt->p_criteria_data = ICF_NULL;
#endif
      p_ssa_ctxt->p_old_nonce = ICF_NULL;
      p_ssa_ctxt->internal_msg_id = ICF_NULL;
      p_ssa_ctxt->p_dns_query_internal_msg = ICF_NULL;
      /*Fix For SPR: 19593*/
      p_ssa_ctxt->p_dns_event_context = ICF_NULL;
      /*SPR 19886 Fix for CSR 1-7208970*/
      p_ssa_ctxt->invite_being_sent = ICF_FALSE;
      /*Fix for SPR: 19999 (Merged CSR 1-7586127 : SPR-19988)*/
      p_ssa_ctxt->p_via_hash_key = ICF_NULL;     

      /* Fix for SPR: 19999(Merged CSR 1-7605218: SPR-19997 fixed)*/ 
      icf_cmn_init_address(&(p_ssa_ctxt->req_uri));      
    }
} /* icf_ssa_init_ssa_context */

/*******************************************************************************
 * FUNCTION:        icf_ssa_handle_notify_for_subs
 *
 * DESCRIPTION:     This function parses NOTIFY req received for SUBSCRIPTION
 *
 ******************************************************************************/
icf_return_t   icf_ssa_handle_notify_for_subs(
        icf_ssa_pdb_st              *p_ssa_pdb,
        icf_nw_inc_notify_ind_st    *p_notify_ind,
        Sdf_st_overlapTransInfo     *pOverlapTransInfo,
        SipMessage                  *pSipMsg)
{
    icf_return_t       ret_val = ICF_SUCCESS;
    /* NOTIFY crash fix for p_subs_state = "" */
    SipHeader          subs_header = {SipHdrTypeSubscriptionState, SIP_NULL}, 
                       content_type_hdr = {SipHdrTypeContentType, SIP_NULL};
    Sdf_st_error       sdf_error = {0,0,0,"\0"};
    SipError           sip_error = 0;
    SIP_S8bit          *p_subs_state = SIP_NULL;
    SIP_U32bit         param_count = 0;
    SipError           error = 0;
    SipParam           *p_param_list = ICF_NULL;
    SIP_U32bit         count = 0;
    icf_uint8_t        reason_code[15]="\0", *p_param_val;
    icf_uint16_t       retry_after = 0;
    icf_uint32_t       expires = 0;
    icf_config_data_st *p_glb_cfg_data = ICF_NULL;
    icf_return_t       return_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                             p_ssa_pdb->p_glb_cfg_data,
                             return_val)
    if(ICF_FAILURE == return_val)
    {
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }

    /* Asynchronous NOTIFY support */
    p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;

    /* In case bit ICF_SIC_NOTIFY_PROCESSING_ONGOING is set in SIC context,
       reject this NOTIFY with a 500, else set that bit and continue processing.
       This bit will be reset in function icf_ssa_process_notify_resp after
       sucessfully sending a response to the NOTIFY received.We will set/reset
       this bit only if the application has enabled support of asynchonous NOTIFY.
    */
    if(ICF_TRUE == p_glb_cfg_data->async_notify_support_reqd)
    {
        if(ICF_TRUE == ICF_IS_BIT_SET(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->bitmask,
                                      ICF_SIC_NOTIFY_PROCESSING_ONGOING))
        {
            /* A NOTIFY is already being processed, reject this NOTIFY 
               with a 500.
            */
            ret_val = icf_ssa_form_and_send_response(
                          p_ssa_pdb,
                          500,
                          p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                          pOverlapTransInfo,
                          "NOTIFY",
                          Sdf_co_false);

            /* 
               Set bit ICF_SSA_RESPONSE_SENT_TO_NETWORK in SSA PDB. This is 
               to avoid populating the header list in the SIC context as a 
               response has already been given for the NOTIFY received.
               If this bit is not set, then after returning from this function,
               the calling function will populate the header list in the SIC
               context.However since SIC module is not beng invoked, the 
               header list will remain unused and can be overwritten
               on receipt of another request (thus resulting in memory leaks).
            */
            ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->common_bitmask,
                                       ICF_SSA_RESPONSE_SENT_TO_NETWORK)

            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)    
            return ret_val;
        }
        else
        {
            /* Set bit ICF_SIC_NOTIFY_PROCESSING_ONGOING */
            ICF_SET_BIT(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->bitmask,
                        ICF_SIC_NOTIFY_PROCESSING_ONGOING)
        }
    }

    /* Initializing the members of notify_ind structure. */
    p_notify_ind->bitmask = ICF_NULL;
    p_notify_ind->duration = ICF_NULL;
    p_notify_ind->reason_code = ICF_NULL;
    p_notify_ind->subs_state = ICF_NULL;


    if (ICF_SSA_APP_CTX_DELINKED ==
        (ICF_SSA_APP_CTX_DELINKED & p_ssa_pdb->p_ssa_ctxt->bitmask))
    {
        ret_val = icf_ssa_form_and_send_response(
                      p_ssa_pdb, 200, p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                      pOverlapTransInfo, "NOTIFY", Sdf_co_false);
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }

    
    /*Fetch Subscription-State header*/
    if (SipFail == sip_getHeader(pSipMsg, 
                SipHdrTypeSubscriptionState,&subs_header, 
                (SipError*)&(sdf_error.stkErrCode)))
    {
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == 
            sip_impp_getSubStateFromSubscriptionStateHdr(
                &subs_header,&p_subs_state,
                (SipError*)&(sdf_error.stkErrCode)))
    {
        sip_freeSipHeader(&subs_header);
        return ICF_FAILURE;
    }
    else
    {
        /*Get Parameters in Subscription Header*/
        param_count = 
                              
#ifdef ICF_WITH_MUATK_2_2
            ((SipSubscriptionStateHeader*)(subs_header.pHeader))->slParam.size;
#else
            ((SipSubscriptionStateHeader*)(subs_header.pHeader))->slParams.size;
#endif                
        while (count < param_count)
        {
            if (SipSuccess == 
                    sip_impp_getParamAtIndexFromSubscriptionStateHdr(
                        &subs_header, &p_param_list, count, &error))
            {
                sip_listGetAt(&(p_param_list->slValue), 0, 
                        (SIP_Pvoid *)&p_param_val, &error);
               
                if ( 0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"reason"))
                {
                    icf_port_strcpy(reason_code, p_param_val);
                }
                else if (0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"retry-after"))
                {
                    retry_after = (icf_uint16_t)icf_port_atoi((const icf_int8_t *)p_param_val);
                }
                else  if (0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"expires"))
                {
                    expires = icf_port_atoi((const icf_int8_t *)p_param_val);
                }
                sip_freeSipParam(p_param_list);
            }

            count++;
        } /* while (count < param_count) */
    } /* else */
    /* NOTIFY crash fix for p_subs_state = "" */
	/* In case no Subscription-State header is received in NOTIFY, ICF will
	 * respond with 400 failure response */

	if (ICF_NULL == p_subs_state)
    {
        ICF_PRINT(((icf_uint8_t *)"\nNOTIFY received without Subscription-State header\n"));

        ret_val = icf_ssa_form_and_send_response(
              p_ssa_pdb, 400, p_ssa_pdb->p_ssa_ctxt->p_call_obj,
              pOverlapTransInfo, "NOTIFY", Sdf_co_false);

        /* Free the local reference */
        sip_freeSipHeader(&subs_header);

        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }
        
    /*As discussed while processing the notify received from
     * network the values of the various field in notify body are
     * treated as case insensitive ; so the function call
     * icf_port_strcmp is replaced with icf_port_strcasecmp .*/ 
        
    else if ((0 == icf_port_strcasecmp((const icf_int8_t *)p_subs_state,(const icf_int8_t *) "active")) ||
            (0 == icf_port_strcasecmp((const icf_int8_t *)p_subs_state, (const icf_int8_t *)"pending")))
    {
        /*If subscription-state is active or pending then mark subs_state
         * = ICF_SUBS_STATE_ACTIVE*/
        p_notify_ind->subs_state = ICF_SUBS_STATE_ACTIVE;

        /*If expires parameter is present then copy to duration and mark
         * bitmask as duration_present*/
        if (0 != expires)
        {
            /* Fix for SPR: 19999 (Merged CSR 1-7467002 : SPR 19863)*/
            /* Duration in notify_ind will be equal to the smaller duration
             * between expires duration received in NOTIFY and expires
             * duration sent in SUBSCRIBE request.
             */   
            if((ICF_NULL != p_notify_ind->p_sic_ctx) &&
                    (p_notify_ind->p_sic_ctx->app_requested_duration < expires ))
            {
                p_notify_ind->duration = 
                    p_notify_ind->p_sic_ctx->app_requested_duration * 1000;
            }
            else
            {
                p_notify_ind->duration = expires * 1000;
            }            

            p_notify_ind->bitmask = ICF_NW_INC_SUBS_DURATION_PRESENT;
        }
    } /* (0 == icf_port_strcmp(p_sub... */
    else
    {
        /*Otherwise mark subs_state = ICF_SUBS_STATE_TERMINATED*/
        p_notify_ind->subs_state = ICF_SUBS_STATE_TERMINATED;

        if ((0 == icf_port_strcasecmp((const icf_int8_t *)reason_code,(const icf_int8_t *) "rejected")) ||
                (0 == icf_port_strcasecmp((const icf_int8_t *)reason_code, (const icf_int8_t *)"noresource")))
        {
            p_notify_ind->reason_code = ICF_NW_INC_NOTIFY_NO_RETRY;
                /*ICF_NW_INC_SUBS_RESP_NO_RETRY;*/
        }
        else if (0 == icf_port_strcasecmp((const icf_int8_t *)reason_code,(const icf_int8_t *)"giveup"))
        {
            /* Fix for SPR: 19999 (Merged CSR 1-7615966 : SPR 20030)*/
            /* Do not retry the SUBSCRIPTION if ICF_SIC_SUBS_RETRY_NOT_REQUIRED
             * is set in sic context.
             */
            if ((ICF_NULL != p_notify_ind->p_sic_ctx) &&
                    (ICF_NULL ==(ICF_SIC_SUBS_RETRY_NOT_REQUIRED & 
                                 p_notify_ind->p_sic_ctx->bitmask)) &&
                    (0 != retry_after))            
            {
                p_notify_ind->duration = retry_after;

                p_notify_ind->bitmask = ICF_NW_INC_SUBS_DURATION_PRESENT;

                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_AFTER;
            }
            else if((ICF_NULL != p_notify_ind->p_sic_ctx) &&
                    (ICF_NULL ==(ICF_SIC_SUBS_RETRY_NOT_REQUIRED &
                                 p_notify_ind->p_sic_ctx->bitmask)))            
            {
                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_IMM;
            }
            else
            {
                p_notify_ind->reason_code = ICF_NW_INC_NOTIFY_NO_RETRY;
            }            
        } /* else if (0 == icf_port_strc... */
        else if ((0 == icf_port_strcasecmp((const icf_int8_t *)reason_code, (const icf_int8_t *)"deactivated")) ||
                (0 == icf_port_strcasecmp((const icf_int8_t *)reason_code, (const icf_int8_t *)"timeout")))
        {
            /* Fix for SPR: 19999 (Merged CSR 1-7615966 : SPR 20030)*/
            /* Do not retry the SUBSCRIPTION if ICF_SIC_SUBS_RETRY_NOT_REQUIRED
             * is set in sic context.
             */
            if((ICF_NULL != p_notify_ind->p_sic_ctx) &&
                    (ICF_NULL ==(ICF_SIC_SUBS_RETRY_NOT_REQUIRED &
                                 p_notify_ind->p_sic_ctx->bitmask)))
            {
                p_notify_ind->reason_code = ICF_NW_INC_NOTIFY_RETRY_IMM;
            }
            else
            {
                p_notify_ind->reason_code = ICF_NW_INC_NOTIFY_NO_RETRY;
            }            
        }
        else if (0 == icf_port_strcasecmp((const icf_int8_t * )reason_code, (const icf_int8_t * )"probation"))
        {
            /* Fix for SPR: 19999 (Merged CSR 1-7615966 : SPR 20030)*/
            /* Do not retry the SUBSCRIPTION if ICF_SIC_SUBS_RETRY_NOT_REQUIRED
             * is set in sic context.
             */
            if ((ICF_NULL != p_notify_ind->p_sic_ctx) &&
                    (ICF_NULL ==(ICF_SIC_SUBS_RETRY_NOT_REQUIRED & 
                                 p_notify_ind->p_sic_ctx->bitmask)) &&
                    (0 != retry_after))            
            {
                p_notify_ind->duration = retry_after;
                
                p_notify_ind->bitmask = ICF_NW_INC_SUBS_DURATION_PRESENT;
                
                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_AFTER;
            }
            else  
            {
                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_NO_RETRY;
            }
        }
        else  
        {
            /* kodiak 18 Feb fix for default behavior */
            p_notify_ind->reason_code = 
                ICF_NW_INC_NOTIFY_NO_RETRY;
            
        }
    } /* else */

/*Fix Merge of CSR 1-6179301: Moved the APP_TRACE after the decision making for 
      subs_state*/ 
#ifdef ICF_TRACE_ENABLE
     /* Fix to fetch expires duration so that correct value gets printed 
        for ICF_TRACE_NOTIFY_FOR_SUBS */
     p_ssa_pdb->notify_duration = expires;
     p_ssa_pdb->p_subs_state = p_subs_state;
     ICF_SSA_APP_TRACE(p_ssa_pdb,ICF_TRACE_NOTIFY_FOR_SUBS)
#endif

    /* Free the local reference */
    sip_freeSipHeader(&subs_header);
                
    /*Fetch Content-Type header from SIP message*/
    /*If Content-Type is application/simple-message-summary then
     * fetch message body*/
    if (ICF_SUCCESS == ret_val)
    {
        icf_uint8_t        *p_media_type;
        en_SipMessageType  dReqRespType;
ICF_SIC_START
        Sdf_ty_s8bit        *p_buffer = Sdf_co_null;
        Sdf_ty_u32bit        bufLength = 0;
        Sdf_ty_u32bit       dCount = 0;
        icf_msg_body_st    *p_msg_body = ICF_NULL;
        icf_uint8_t        *p_ContentTypeVal = ICF_NULL;
ICF_SIC_END

        /*Klocwork Warning Resolved*/
        if(ICF_NULL != p_notify_ind->p_sic_ctx)
        {
            
        p_notify_ind->p_sic_ctx->body_list.count=0;

        if (SipFail == sip_getMsgBodyCount(pOverlapTransInfo->pSipMsg, &dCount, &error))
        {
            /*ICF_SSA_TRACE(("\nFailed to get MsgBodyCount from SipMessage"))*/
            return ICF_FAILURE;
        }

        if(dCount)
        {

            if(dCount == 1)
            {

                if (sip_getHeader(pOverlapTransInfo->pSipMsg, 
                            SipHdrTypeContentType,
                            &content_type_hdr, &error) == SipFail)
                {
                    ICF_PRINT(((icf_uint8_t *)"\nFailed to get Content-Type Header"));
                    return ICF_FAILURE;
                }
                else if (sip_getMediaTypeFromContentTypeHdr(&content_type_hdr, 
                            (SIP_S8bit **)&p_media_type,\
                            &error) == SipFail)
                {
                    sip_freeSipHeader(&content_type_hdr);
                    ICF_PRINT(((icf_uint8_t *)"\nFailed to get media-type from "
                                "Content-Type Header"));

                    return ICF_FAILURE;
                }
                /* Free the local reference */
                sip_freeSipHeader(&content_type_hdr);

                if(sdf_ivk_uaGetUnknownBodyFromSipMessage(pOverlapTransInfo->pSipMsg, 0, \
                        &p_buffer, &bufLength, &sdf_error) == Sdf_co_success)
                {                              
            
                    /* allocate memory for a msg body list node and add to List*/
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        ICF_PORT_SIZEOF(icf_msg_body_st),
                        ICF_MEM_COMMON, 
                        p_msg_body,
                        ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                
                     p_notify_ind->p_sic_ctx->body_list.body = p_msg_body;   
            
                    /* Increment the msg body count by one */
                    p_notify_ind->p_sic_ctx->body_list.count++;
                    p_msg_body->next = ICF_NULL;
            
                    /*
                    * Set the content type of the unknown msg body to null
                    * we do not parse unknown msg bodies at present.
                    */               
                    p_msg_body->content_type.str_len = (icf_uint16_t)strlen((const icf_int8_t *)p_media_type);
                    icf_port_strcpy(p_msg_body->content_type.str,p_media_type);

            
                    p_msg_body->length= bufLength;
                    /* Allocate memory for message body value and copy the recvd msg body*/
                    if (ICF_NULL != p_msg_body->length)
                    {
                        ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                            (bufLength + 1),
                            ICF_MEM_COMMON,
                            p_msg_body->value,
                            ICF_RET_ON_FAILURE,
                            p_ssa_pdb->p_ecode, ret_val)
                    
                            icf_port_memcpy(p_msg_body->value,(char*)p_buffer,bufLength);
                            p_msg_body->value[bufLength] = '\0';
                
                    }                 
                }
            }/*if(dCount == 1)*/
            else
            {
                icf_uint8_t     iterator1=0;

                for (iterator1 = 0; iterator1 < (icf_uint16_t)dCount; iterator1++)
                {
        
                    if(sdf_ivk_uaGetUnknownBodyFromSipMessage(pOverlapTransInfo->pSipMsg, iterator1, \
                        &p_buffer, &bufLength, &sdf_error) == Sdf_co_success)
                    { 
                        SipMsgBody        *pTempMsgBody=Sdf_co_null;
                        if (p_notify_ind->p_sic_ctx->body_list.count == 0)
                        {
                            /* allocate memory for a msg body list node and add to List*/
                            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                                ICF_PORT_SIZEOF(icf_msg_body_st),
                                ICF_MEM_COMMON, 
                                p_msg_body,
                                ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                        
                                p_notify_ind->p_sic_ctx->body_list.body = p_msg_body;   
                        }
                        else
                        {
                            /* allocate memory for a msg body list node and add to List*/
                            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                                ICF_PORT_SIZEOF(icf_msg_body_st),
                                ICF_MEM_COMMON, 
                                p_msg_body->next,
                                ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                        
                                p_msg_body = p_msg_body->next;                     
                        }
                        /* Increment the msg body count by one */
                        p_notify_ind->p_sic_ctx->body_list.count++;
                        p_msg_body->next = ICF_NULL;
                
                        /*
                        * Set the content type of the unknown msg body to null
                        * we do not parse unknown msg bodies at present.
                        */               
                        /*p_msg_body->content_type.str_len = 0;*/
                        /*icf_port_strcpy(p_msg_body->content_type.str,"\0");*/

                        
                        sip_listGetAt(
                            &(pOverlapTransInfo->pSipMsg->slMessageBody),\
                            iterator1,(SIP_Pvoid *)&pTempMsgBody,\
                            &sip_error);

                        if(pTempMsgBody)
                        {
                            ret_val =  icf_ssa_get_mime_hdrs_from_sip_msg(\
                                        SipMessageRequest,
                                        p_ssa_pdb,pTempMsgBody,p_msg_body);
                         p_msg_body->content_type.str_len = 
                        (icf_uint16_t)icf_port_strlen(p_msg_body->content_type.str);
                        }
                        else
                        {
                            p_msg_body->content_type.str_len = 0;
                            icf_port_strcpy(p_msg_body->content_type.str,(icf_uint8_t *)"\0");
                        }
                
                        p_msg_body->length= bufLength;
                        /* Allocate memory for message body value and copy the recvd msg body*/
                        if (ICF_NULL != p_msg_body->length)
                        {
                            ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                                bufLength,
                                ICF_MEM_COMMON,
                                p_msg_body->value,
                                ICF_RET_ON_FAILURE,
                                p_ssa_pdb->p_ecode, ret_val)
                        
                                icf_port_memcpy(p_msg_body->value,(char*)p_buffer,bufLength);
                           /*Klocwork Warning Removal*/
                           ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                            p_msg_body->value)
                    
                        }                 
                    }  
                    
                }/*for*/
            }/*if(dCount > 1)*/

             /* Support Fix : Fill the top level Content Type Header in message body.
            */
            
            if (SipFail == sip_getHeader(pOverlapTransInfo->pSipMsg,\
                SipHdrTypeContentType,&content_type_hdr, &sip_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to get Content-Type Header"));
                ret_val = ICF_FAILURE;
            }
            else if (SipFail == sip_getMessageType(pOverlapTransInfo->pSipMsg, 
                    &dReqRespType, &sip_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to get Content-Type Header"));
                ret_val = ICF_FAILURE;
            }
            else if(ICF_FAILURE == icf_ssa_get_content_type_frm_msg(\
                dReqRespType,p_ssa_pdb,&content_type_hdr,\
                &p_ContentTypeVal))
            {
                ICF_PRINT(((icf_uint8_t *)"Failed to get Content-Type Header from SIP"\
                    " message\n"));
                if(ICF_NULL != p_ContentTypeVal)
                {
                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                p_ContentTypeVal,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                }
                /* Free the local reference */
                sip_freeSipHeader(&content_type_hdr);
                ret_val = ICF_FAILURE;
            }
            else
            {
                /* Klocwork warning removal.*/
                if(ICF_NULL != p_ContentTypeVal)
                {            	
                icf_port_strcpy(p_notify_ind->p_sic_ctx->body_list.content_type.str,
                    p_ContentTypeVal);
                p_notify_ind->p_sic_ctx->body_list.content_type.str_len =
                    (icf_uint16_t)icf_port_strlen(p_ContentTypeVal);

                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_ContentTypeVal,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
                }
                sip_freeSipHeader(&content_type_hdr);                
            }
            /* End of Support Fix : Top level Content Type Header.*/
            
            
        }/*if(dCount)*/

        }/*if(ICF_NULL != p_notify_ind->p_sic_ctx)*/
        else
        {
            ICF_PRINT(((icf_uint8_t *)"[SSA]:p_notify_ind->p_sic_ctx is NULL"));
            ret_val = ICF_FAILURE;
        }


ICF_SIC_END

        
        if (ICF_FAILURE != ret_val)
        {
            p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = 
                ICF_NW_INC_NOTIFY_IND;

            p_ssa_pdb->p_internal_msg->msg_hdr.payload_length =
                ICF_PORT_SIZEOF(icf_nw_inc_notify_ind_st);

            p_ssa_pdb->dest_module_id = ICF_INT_MODULE_SIC;
        }
    }

    return ret_val;
} /* icf_ssa_handle_notify_for_subs */

/*******************************************************************************
 * FUNCTION:        icf_ssa_handle_notify_for_refer
 *
 * DESCRIPTION:     This function parses NOTIFY req received for REFER
 *
 ******************************************************************************/
icf_return_t   icf_ssa_handle_notify_for_refer(
        icf_ssa_pdb_st              *p_ssa_pdb,
        icf_nw_inc_notify_ind_st    *p_notify_ind,
        Sdf_st_overlapTransInfo        *pOverlapTransInfo,
        SipMessage                     *pSipMsg)
{
    icf_return_t    ret_val = ICF_SUCCESS;
    SipHeader          subs_header, content_type_hdr;
    Sdf_st_error       sdf_error;
    SIP_S8bit          *p_subs_state = SIP_NULL;
    SIP_U32bit         param_count = 0;
    SipError           error;
    SipParam           *p_param_list = ICF_NULL;
    SIP_U32bit         count = 0;
    icf_uint8_t     reason_code[15]="\0", *p_param_val;
    icf_uint16_t    retry_after = 0;
    icf_uint16_t    expires = 0;
    icf_boolean_t   notification_status = ICF_TRUE;
    SipError           sip_error;
    icf_uint8_t      prov_notify_resp = ICF_FALSE;
    icf_boolean_t   indicate_service = ICF_TRUE;

       
    /*Fetch Subscription-State header*/
    if (SipFail == sip_getHeader(pSipMsg, 
                SipHdrTypeSubscriptionState,&subs_header, 
                (SipError*)&(sdf_error.stkErrCode)))
    {
        ret_val = icf_ssa_form_and_send_response(
                p_ssa_pdb,400,
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                pOverlapTransInfo,
                "NOTIFY", Sdf_co_false);

        return ICF_FAILURE;
    }
    else if (SipFail == 
            sip_impp_getSubStateFromSubscriptionStateHdr(
                &subs_header,&p_subs_state,
                (SipError*)&(sdf_error.stkErrCode)))
    {
        sip_freeSipHeader(&subs_header);
        return ICF_FAILURE;
    }
    else
    {
        /*Get Parameters in Subscription Header*/
        param_count = 
                
#ifdef ICF_WITH_MUATK_2_2
            ((SipSubscriptionStateHeader*)(subs_header.pHeader))->slParam.size;
#else
            ((SipSubscriptionStateHeader*)(subs_header.pHeader))->slParams.size;
#endif                
               
        while (count < param_count)
        {
            if (SipSuccess == 
                    sip_impp_getParamAtIndexFromSubscriptionStateHdr(
                        &subs_header, &p_param_list, count, &error))
            {
                sip_listGetAt(&(p_param_list->slValue), 0, 
                        (SIP_Pvoid *)&p_param_val, &error);
                
                if ( 0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"reason"))
                {
                    icf_port_strcpy(reason_code, p_param_val);
                }
                else if (0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"retry-after"))
                {
                    retry_after = (icf_uint16_t )icf_port_atoi((const icf_int8_t *)p_param_val);
                }
                else  if (0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"expires"))
                {
                    expires = (icf_uint16_t)icf_port_atoi((const icf_int8_t *)p_param_val);
                }
                sip_freeSipParam(p_param_list);
            }

            count++;
        } /* while (count < param_count) */
    } /* else */


    if ((0 == icf_port_strcmp((icf_uint8_t *)p_subs_state, (icf_uint8_t *)"active")) ||
            (0 == icf_port_strcmp((icf_uint8_t *)p_subs_state, (icf_uint8_t *)"pending")))
    {
        /*If subscription-state is active or pending then mark subs_state
         * = ICF_SUBS_STATE_ACTIVE*/
        p_notify_ind->subs_state = ICF_SUBS_STATE_ACTIVE;

        /*If expires parameter is present then copy to duration and mark
         * bitmask as duration_present*/
        if (0 != expires)
        {
            p_notify_ind->duration = expires * 1000;

            p_notify_ind->bitmask = ICF_NW_INC_SUBS_DURATION_PRESENT;
        }
    } /* (0 == icf_port_strcmp(p_sub... */
    else
    {
        /*Otherwise mark subs_state = ICF_SUBS_STATE_TERMINATED*/
        p_notify_ind->subs_state = ICF_SUBS_STATE_TERMINATED;

        if ((0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"rejected")) ||
                (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"noresource")))
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_SUBS_RESP_NO_RETRY;
        }
        else if (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"giveup"))
        {
            if (0 != retry_after)
            {
                p_notify_ind->duration = retry_after;

                p_notify_ind->bitmask = ICF_NW_INC_SUBS_DURATION_PRESENT;

                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_AFTER;
            }
            else
            {
                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_IMM;
            }
        } /* else if (0 == icf_port_strc... */
        else if ((0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"deactivated")) ||
                (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"timeout")))
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_NOTIFY_RETRY_IMM;
        }
        else if (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"probation"))
        {
            if (0 != retry_after)
            {
                p_notify_ind->duration = retry_after;

                p_notify_ind->bitmask = ICF_NW_INC_SUBS_DURATION_PRESENT;
            }

            p_notify_ind->reason_code = 
                ICF_NW_INC_NOTIFY_RETRY_AFTER;
        }
        else  
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_SUBS_RESP_NO_RETRY;
        }
    } /* else */
    /* Free the local reference */
    sip_freeSipHeader(&subs_header);
                
    /*Fetch Content-Type header from SIP message*/
    /*If Content-Type is application/simple-message-summary then
     * fetch message body*/
    if (ICF_SUCCESS == ret_val)
    {
        icf_uint8_t        *p_media_type;
        en_SipMessageType  dReqRespType;
ICF_SIC_START
        Sdf_ty_s8bit        *p_buffer = Sdf_co_null;
        Sdf_ty_u32bit        bufLength = 0;
        Sdf_ty_u32bit       dCount = 0;
        icf_msg_body_st    *p_msg_body = ICF_NULL;
        SipMsgBody            *pTempMsgBody=Sdf_co_null;
        icf_uint8_t         *p_ContentTypeVal = ICF_NULL;
ICF_SIC_END

        if (ICF_NULL != p_notify_ind->p_sic_ctx)
            p_notify_ind->p_sic_ctx->body_list.count=0;

        if (SipFail == sip_getMsgBodyCount(pOverlapTransInfo->pSipMsg, &dCount, &error))
        {
            /*ICF_SSA_TRACE(("\nFailed to get MsgBodyCount from SipMessage"))*/
            return ICF_FAILURE;
        }

        if(dCount)
        {

            if (sip_getHeader(pOverlapTransInfo->pSipMsg, 
                        SipHdrTypeContentType,
                        &content_type_hdr, &error) == SipFail)
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to get Content-Type Header"));
                return ICF_FAILURE;
            }
            else if (sip_getMediaTypeFromContentTypeHdr(&content_type_hdr, 
                        (SIP_S8bit **)&p_media_type,\
                        &error) == SipFail)
            {
                sip_freeSipHeader(&content_type_hdr);
                ICF_PRINT(((icf_uint8_t *)"\nFailed to get media-type from "
                            "Content-Type Header"));

                return ICF_FAILURE;
            }
            /* Support Fix : Fill the top level Content Type Header in message body.
             */
            else if (SipFail == sip_getMessageType(pOverlapTransInfo->pSipMsg, 
                    &dReqRespType, &error))
            {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to get message type"));
                ret_val = ICF_FAILURE;
            }
            else if(ICF_FAILURE == icf_ssa_get_content_type_frm_msg(\
                    dReqRespType,p_ssa_pdb,&content_type_hdr,\
                    &p_ContentTypeVal))
            {
                ICF_PRINT(((icf_uint8_t *)"Failed to get Content-Type Header from SIP"\
                   " message\n"));
                /* Free the local reference */
                sip_freeSipHeader(&content_type_hdr);
                ret_val = ICF_FAILURE;
            }
            else if(ICF_NULL == p_ContentTypeVal)
            {
                 /* Free the local reference */
                 sip_freeSipHeader(&content_type_hdr);
                ret_val = ICF_FAILURE;
                  return ret_val;
            }
            /* End of Support Fix: for top level content type header.*/
            /* Free the local reference */
            sip_freeSipHeader(&content_type_hdr);

  /*If NOTIFY is received for REFER and message body contains
             *sip fragmented body*/
            if (0 == 
                Sdf_mc_strcasecmp((Sdf_ty_s8bit *)p_media_type, 
                (Sdf_ty_s8bit *)"message/sipfrag"))
            {
                if ( ICF_FAILURE == 
                    icf_ssa_get_status_frm_notify(p_ssa_pdb, 
                    pOverlapTransInfo->pSipMsg,
                    &notification_status,
                    &indicate_service))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    /* CSR 1-6240518: Send app trace for notify for refer 
                       irrespective of the status  in message body */
#ifdef ICF_TRACE_ENABLE
                    ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_NOTIFY_FOR_REFER_RECVD)
#endif                    
                    if ((100 <= p_ssa_pdb->resp_code) &&
                            (199 >= p_ssa_pdb->resp_code))
                    {
                        /* Added for sendint traces */
                        prov_notify_resp = ICF_TRUE;
                    }

                    p_notify_ind->status = notification_status;
                }
            }
        
ICF_SIC_START

  else 
  {

    if ((ICF_FAILURE != ret_val) && 
            (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt))
        {
            icf_uint8_t        iterator1=0;
        
            /* Support Fix : Fill the top level content type header in the body list
             */
            if( p_notify_ind->p_sic_ctx && (ICF_NULL != p_ContentTypeVal))
            {
                icf_port_strcpy(p_notify_ind->p_sic_ctx->body_list.content_type.str,
                    p_ContentTypeVal);
                p_notify_ind->p_sic_ctx->body_list.content_type.str_len =
                    (icf_uint16_t)icf_port_strlen(p_ContentTypeVal);  
            }

            /*
            icf_port_strcpy(p_notify_ind->p_sic_ctx->body_list.content_type.str,
                p_media_type);
            p_notify_ind->p_sic_ctx->body_list.content_type.str_len =
                icf_port_strlen(p_media_type);
            */

            for (iterator1 = 0; iterator1 < (icf_uint16_t)dCount; iterator1++)
            {
                /*Changes Start for Message Body Header SPR 10934*/

                SipMimeHeader         *pMime = Sdf_co_null;
                SipHeader             *pContentType = Sdf_co_null;
                Sdf_ty_s8bit          *pMediaType = ICF_NULL;
                
                /* Get Content Type from Message Body
                 */
               sip_listGetAt(
                            &(pOverlapTransInfo->pSipMsg->slMessageBody),
                            iterator1,(SIP_Pvoid *)&pTempMsgBody, &sip_error);

               if(SipFail != sip_bcpt_getMimeHeaderFromMsgBody(pTempMsgBody\
                   ,&pMime,&sip_error))
               {
                 /* Get Content-Type Header from Message Body
                  */
                   
                 if (sip_initSipHeader(&pContentType, SipHdrTypeAny, \
                         (SipError*)&(sdf_error.stkErrCode)) == SipFail)
                 {
                     sip_freeSipHeader(pContentType);
                     return ICF_FAILURE;
                 }
                 else if (sip_bcpt_getContentTypeFromMimeHdr(pMime,\
                      &pContentType, &(sip_error)) \
                     == SipFail)
                 {    
                     sip_freeSipHeader(pContentType);
                     sip_bcpt_freeSipMimeHeader(pMime);
                     ret_val = ICF_FAILURE;
                 }
                  /* Extract the content - type header values from the
                   * Sip message body.
                   */
                   else if (sip_getMediaTypeFromContentTypeHdr(pContentType, &pMediaType,\
                          &error) == SipFail)
                   {
                       ICF_PRINT(((icf_uint8_t *)"\nFailed to get media-type from Content-Type "\
                                "Header"));
                       sip_freeSipHeader(pContentType);
                       sip_bcpt_freeSipMimeHeader(pMime);
                       ret_val = ICF_FAILURE;
                   }
                           
                   else if(0 == Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pMediaType,\
                             (Sdf_ty_s8bit*)"message/sipfrag"))
                   {
                     if ( ICF_FAILURE == 
                               icf_ssa_get_status_frm_notify_from_mime_body(p_ssa_pdb, 
                              pTempMsgBody,&notification_status))
                    {
                          ret_val = ICF_FAILURE;
                          sip_freeSipHeader(pContentType);
                          sdf_memfree(Sdf_mc_callHandlerMemId, \
                            (Sdf_ty_pvoid *)&pMediaType,\
                                Sdf_co_null);
                          sip_bcpt_freeSipMimeHeader(pMime);
                          continue;
                     }
                     else
                     {
                          p_notify_ind->status = notification_status;
                          sip_freeSipHeader(pContentType);
                          sdf_memfree(Sdf_mc_callHandlerMemId, \
                           (Sdf_ty_pvoid *)&pMediaType,\
                                Sdf_co_null);
                          sip_bcpt_freeSipMimeHeader(pMime);
                          continue;
                     }
                   }
                   else
                   {
                       sip_freeSipHeader(pContentType);
                       sdf_memfree(Sdf_mc_callHandlerMemId, \
                           (Sdf_ty_pvoid *)&pMediaType,\
                                Sdf_co_null);
                       sip_bcpt_freeSipMimeHeader(pMime);

                   }
               }
                
                /*Changes Ends for Message Body Header SPR : 10934        */
                
                if((sdf_ivk_uaGetUnknownBodyFromSipMessage(pOverlapTransInfo->pSipMsg,\
                    iterator1, &p_buffer, &bufLength, &sdf_error) == \
                    Sdf_co_success) && p_notify_ind->p_sic_ctx)
                { 
                        if (p_notify_ind->p_sic_ctx->body_list.count == 0)
                        {
                            /* allocate memory for a msg body list node and add to List*/
                            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                                ICF_PORT_SIZEOF(icf_msg_body_st),
                                ICF_MEM_COMMON, 
                                p_msg_body,
                                ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                        
                                p_notify_ind->p_sic_ctx->body_list.body = p_msg_body;   
                            p_msg_body->next = ICF_NULL;
                            p_msg_body->length= bufLength;
                        }
                        else if(ICF_NULL != p_msg_body)
                        {
                            /* allocate memory for a msg body list node and add to List*/
                            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                                ICF_PORT_SIZEOF(icf_msg_body_st),
                                ICF_MEM_COMMON, 
                                p_msg_body->next,
                                ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
                        
                                p_msg_body = p_msg_body->next;                     
                            p_msg_body->next = ICF_NULL;
                            p_msg_body->length= bufLength;
                        }
                        /* Increment the msg body count by one */
                        p_notify_ind->p_sic_ctx->body_list.count++;
                        
                         /* Allocate memory for message body value and copy the recvd msg body*/
                        if ((ICF_NULL != p_msg_body) &&
                                (ICF_NULL != p_msg_body->length))
                        {
                            ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                            bufLength,
                            ICF_MEM_COMMON,
                            p_msg_body->value,
                             ICF_RET_ON_FAILURE,
                             p_ssa_pdb->p_ecode, ret_val)
                    
                            icf_port_memcpy(p_msg_body->value,(char*)p_buffer,bufLength);
                            /*Klocwork Warning Removal*/
                            ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                            p_msg_body->value)
                     
                        }       
                        
                        if(pTempMsgBody)
                        {
                            ret_val = icf_ssa_get_mime_hdrs_from_sip_msg(\
                                /*p_ssa_pdb->p_ssa_ctxt->p_call_obj*/SipMessageRequest,
                                p_ssa_pdb,pTempMsgBody,p_msg_body);

                            
                         if ( p_msg_body) p_msg_body->content_type.str_len = 
                              (icf_uint16_t)icf_port_strlen(p_msg_body->content_type.str);
                         
                        }
            
                }
                
            } /*End of For loop for multiple message bodies*/
            
                         
            }
}
ICF_SIC_END
        }
       if(ICF_NULL != p_ContentTypeVal)
       {
          fast_memfree(0,p_ContentTypeVal,&sip_error);
          p_ContentTypeVal = ICF_NULL; 
        }
    }

    if (ICF_FAILURE != ret_val)
    {
        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = 
            ICF_NW_INC_NOTIFY_IND;
        
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length =
            ICF_PORT_SIZEOF(icf_nw_inc_notify_ind_st);
        
        if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt)
        {   
            p_ssa_pdb->dest_module_id = ICF_INT_MODULE_SIC;
        }
        else
        {
            if ((ICF_SUBS_STATE_TERMINATED != p_notify_ind->subs_state)||
                (ICF_FALSE == indicate_service))

            {
                /*Send a 200 OK*/
                if (ICF_FAILURE == icf_ssa_form_and_send_response(
                            p_ssa_pdb,200,
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                            pOverlapTransInfo,
                            "NOTIFY", Sdf_co_false))
                {
                    ret_val = ICF_FAILURE;
                }
            }
            else
            {
                p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CM;
            }
        }
    }

  


    return ret_val;
} /* icf_ssa_handle_notify_for_refer */

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_send_message_req
 *
 * DESCRIPTION:     This function constructs and sends MESSAGE req on network.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_message_req(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
     icf_return_t             ret_val = ICF_SUCCESS;
     SipOptions                  options;
    Sdf_st_error                sdf_error;
    Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;
    Sdf_ty_s8bit               proto[ICF_MAX_SIZE_INT_USAGE_STR];

    icf_ssa_ctxt_st          *p_ssa_ctx = p_ssa_pdb->p_ssa_ctxt;
    icf_sic_ctx_st          *p_sic_ctx = p_ssa_ctx->p_sic_ctxt;
    /* code change for CSR-1-4816176/SPR 16075 - not tested */
    icf_config_data_st       *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    icf_uint8_t              self_ip[16];
    /*icf_transport_address_st self_addr = {{0,{{0,"\0"}}},0};*/
    icf_transport_address_st self_addr;
    self_addr.addr.addr_type = 0;
    self_addr.port_num = 0;
    
    /* end code change for CSR-1-4816176/SPR 16075 */
#ifdef ICF_IPSEC_ENABLED
    icf_uint8_t              *p_value = ICF_NULL;
#endif
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

    if (ICF_FAILURE == icf_ssa_check_for_trans_param(p_ssa_pdb,
                p_ssa_pdb->p_line_data->transport_mode, ICF_NULL, ICF_TRUE))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSettingTransport&Revert Modes"));
        return ICF_FAILURE;
    }
    if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_line_data->transport_mode) ||
            (ICF_TRANSPORT_MODE_BOTH == 
             p_ssa_pdb->p_line_data->transport_mode))
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
    }
    else if (ICF_TRANSPORT_TYPE_TLS == 
            p_ssa_pdb->p_line_data->transport_mode)
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
    }
    else if(ICF_TRANSPORT_TYPE_UDP == 
           p_ssa_pdb->p_line_data->transport_mode)
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");

    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)""); 
    }

    /*IF transport is not INVALID, then addr_type should be SIPS in case
     *of TLS transport and SIP in case of non-TLS transport, ignore this check
     *when transport is INVALID*/
    if ((ICF_TRANSPORT_TYPE_INVALID != p_ssa_ctx->transport) &&
        (((ICF_ADDRESS_PLAN_SIPS_URI == p_sic_ctx->dest_addr.addr_type) &&
                (ICF_TRANSPORT_TYPE_TLS != p_ssa_ctx->transport)) || 
            ((ICF_ADDRESS_PLAN_SIP_URI == p_sic_ctx->dest_addr.addr_type) &&
             (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctx->transport))))
    {
        ret_val = ICF_FAILURE;
        return ret_val;
    }

    /*IMP: 
     * Updation needed in update_call_obj for ICF_SSA_USER_ADDR_FRM_SIC*/
    if (ICF_FAILURE == 
            icf_ssa_update_callobj_for_profile(p_ssa_pdb))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
    /* IMP: 
     * Updation needed in set_to_in_reg_call_obj for 
     * ICF_SSA_USER_ADDR_FRM_SIC*/
    /* To header will be set */
    else if ((ICF_FAILURE == icf_ssa_set_to_in_sic_callobj(p_ssa_pdb,
                    (icf_uint8_t *)proto)))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj)); */

        ret_val = ICF_FAILURE;
    }
#if 0
    /*Request URI to be set as destination address*/
    else if (Sdf_co_fail == 
            sdf_ivk_uaMakeAddrSpecFromConstituents(
                &pAddrSpec, (Sdf_ty_s8bit*)server_addr, 
                (Sdf_ty_s32bit)server_port,
                pScheme, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj)); */

        ret_val = ICF_FAILURE;
    }

    else if (Sdf_co_fail == sdf_ivk_uaChangeRequestURI(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                pAddrSpec, &sdf_error))
    {
        /* sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj)); */

        ret_val = ICF_FAILURE;
    }
#endif

        if (ICF_FAILURE != ret_val)
        {
            /* Fill Route Header from Service Route if stored for user-id while 
               registering*/
            if(ICF_FAILURE == 
                    icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                        p_sic_ctx->p_user_address,
                        p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
            {
                ret_val = ICF_FAILURE;
            }
        }
        if (ICF_FAILURE == ret_val)
        {
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    &p_overlap_trans_info,
                    "MESSAGE",
                    &sdf_error))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == 
                sdf_ivk_uaSetTransportSchemeInTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction, 
                    p_overlap_trans_info,
                    proto, &sdf_error))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "MESSAGE",
                    Sdf_en_uacTransaction);

            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_ivk_uaMakeTransaction(
                    (Sdf_ty_s8bit *)"MESSAGE", 
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    &sdf_error))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "MESSAGE",
                    Sdf_en_uacTransaction);

            ret_val = ICF_FAILURE;
        }

        else if ( ICF_FAILURE == 
                icf_ssa_form_and_insert_access_nw_info_hdr(
                    p_ssa_pdb, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
        /* To add security association headers*/
        else if(ICF_FAILURE == icf_ssa_form_and_insert_security_agreement_hdrs(
                                   p_ssa_pdb,(icf_uint8_t *)"MESSAGE",
                                   p_overlap_trans_info->pSipMsg))
        {
           ret_val = ICF_FAILURE;  
        }
        /*    sip_freeSipAddrSpec(pAddrSpec);*/

	if(ICF_FAILURE != ret_val)
	{

        if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
        {
            /* Fix for CSR 1-7436195 */
            /* Coverity bug fix */
            icf_string_st                 addr_val = {0,"\0"};
#ifdef ICF_IPSEC_ENABLED
            /* check if SA exists */
            if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
            {
                /* get the corresponding REG context and populate the SSA ctxt and 
                 * SSA pdb with SA ctxt and REGM ctxt structure pointers 
                 */
                ret_val = icf_ssa_set_sa_ctxt_for_otg_req(p_ssa_pdb,
                        p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity);

            }
#endif
            if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_SIP_URI)
            {
                    icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sip:");
                icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
                    icf_port_strcat( addr_val.str, (icf_uint8_t *)">");


            }
            else if( 
                    p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_TEL_URI)
            {
                    icf_port_strcpy( addr_val.str, (icf_uint8_t *)"tel:");
                icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
            }
             /* code change for CSR-1-4816176/SPR 16075 - not tested */

            else if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_E164)
            {
                    icf_port_strcpy(addr_val.str,(icf_uint8_t *)"<sip:");

                icf_port_strcat(addr_val.str,
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );

                    icf_port_strcat(addr_val.str,(icf_uint8_t *)"@");

                /* now appending the self IP/domain */
                /*If per line self transport then copy address from line_data*/
                if(ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
                {
                    if(ICF_NULL != p_ssa_pdb->p_line_data)
                    {
                        icf_port_memcpy(&self_addr,
                                    &(p_ssa_pdb->p_line_data->self_addr),
                                    sizeof(icf_transport_address_st));
                    }
                    else
                    {
                        ret_val = ICF_FAILURE;
                    }
                }
                else
                {
                    icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                                    sizeof(icf_transport_address_st));
                }
		if(ICF_FAILURE != ret_val)
		{
			
                if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                               self_addr.addr.addr_type)
                {
                    icf_port_strcat(addr_val.str,self_addr.addr.addr.domain.str);
                }
                else/*Assumption that it will be IPV4*/
                {
                    if(ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                                          &(self_addr),self_ip))
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else
                    {
                        icf_port_strcat(addr_val.str,self_ip);
                    }
                }
                        icf_port_strcat(addr_val.str, (icf_uint8_t *)">");
            }
	    }
        /* end of code change for CSR-1-4816176/SPR 16075 - not tested */
            else if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_SIPS_URI)
            {
                    icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sips:");
                icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
                    icf_port_strcat( addr_val.str, (icf_uint8_t *)">");
            }

            else
            {
                icf_port_strcpy( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
            }

            /* Klocwork warning removal.*/
			if (ICF_NULL != p_overlap_trans_info)
            { 
            if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                        p_ssa_pdb, 
                        (icf_uint8_t*)"P-Preferred-Identity",
                        addr_val.str,
                        p_overlap_trans_info->pSipMsg ))
            {
                        ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header (P-Preferred-Identity)"));
                sdf_ivk_uaClearTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "MESSAGE",
                        Sdf_en_uacTransaction);

                /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
                /*Klocwork warning removal*/
                ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                   p_overlap_trans_info)
                return ICF_FAILURE;
            }
          }
          else
          {
              /*Klocwork warning removal*/
              ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                 p_overlap_trans_info)
              return ICF_FAILURE;
          }
	  
        }


        /* Insert Header/Tag/Body if any given by the application */

        if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count)
        {
            if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
                        p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list),
                        ICF_TRUE, p_overlap_trans_info->pSipMsg))
            {
                ret_val = ICF_FAILURE;
            }
        }


        if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list.count)
        {
            if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
                        p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list),
                        ICF_TRUE, p_overlap_trans_info->pSipMsg))
            {
                ret_val = ICF_FAILURE;
            }

        }
#ifdef ICF_IPSEC_ENABLED
        /* if SA exists, send the Securiy-Verify Header in the outgoing MESSAGE */
        if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled) &&
                /* if SA exits */
                (ICF_NULL != p_ssa_pdb->p_sa_context))
        {
            /* insert security-verify header in the otg MESSAGE */
            if (ICF_FAILURE == icf_ssa_get_sec_verify_string (p_ssa_pdb,&p_value,
                        p_ssa_pdb->p_sa_context))
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_FAILURE ==     
                    icf_ssa_insert_unknown_hdr_in_sip_msg (
                        p_ssa_pdb,
                        (icf_uint8_t*)"Security-Verify",
                        p_value, 
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg))
            {
                ICF_PRINT(("\nFailed to insert unknown header \
                            (Security-Verify)"));
		
		sdf_ivk_uaClearTransaction(\
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                            p_overlap_trans_info,\
                            "MESSAGE",\
                            Sdf_en_uacTransaction);
		
                return ICF_FAILURE;
            }
            if (ICF_NULL != p_value)
            {
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_value,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
            }
            if (ICF_SUCCESS == ret_val )
            {
                ICF_PRINT(("\nSecurity Verify Header inserted to \
                            outgoing MESSAGE "));
            }
        }
#endif

        if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.count)
        {
            if (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
                        p_ssa_pdb,&(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list) , 
                        ICF_TRUE, &(p_overlap_trans_info->slMsgBodyList)))
            {
                sdf_ivk_uaClearTransaction(\
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                        p_overlap_trans_info,\
                        "MESSAGE",\
                        Sdf_en_uacTransaction);

                /* sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                            p_ssa_ctxt->p_call_obj)); */

                ret_val = ICF_FAILURE;

            }
            /*Message body header changes Start*/
            else if ( ICF_FAILURE == \
                    icf_ssa_SetAllMsgBody(\
                        Sdf_co_null,p_overlap_trans_info,\
                            (icf_int8_t *)p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        body_list.content_type.str,\
                        &sdf_error))
            {

                sdf_ivk_uaClearTransaction(\
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                        p_overlap_trans_info,\
                        "MESSAGE",\
                        Sdf_en_uacTransaction);

                /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                            p_ssa_ctxt->p_call_obj)); */

                ret_val = ICF_FAILURE;
            }
            /*Message body header changes End*/
        }
        if (ICF_SUCCESS == ret_val)
        {
            /*Set EXPLICIT_CONNECT_REQ in case of INVALID transport also, as transport
             *will be determined from DNS-NAPTR in this case*/
            if ((ICF_TRANSPORT_TYPE_INVALID == p_ssa_pdb->p_ssa_ctxt->transport) ||
                (ICF_NULL != (ICF_SSA_TCP_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask)) ||
                (ICF_NULL != (ICF_SSA_TLS_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask)))
            {
                ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                        ICF_SSA_EXPLICIT_CONNECT_REQ);
            }
            p_ssa_pdb->p_ssa_ctxt->p_overlap_transaction = p_overlap_trans_info;
            if ( ICF_FAILURE == icf_ssa_send_to_peer(
                        p_ssa_pdb,
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info->pSipMsg,
                        &options,
                        &sdf_error))
            {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                sdf_ivk_uaClearTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "MESSAGE",
                        Sdf_en_uacTransaction);
                /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
                ret_val = ICF_FAILURE;
            }
            else if ( Sdf_co_fail == sdf_ivk_uaEndTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        Sdf_co_null,
                        "MESSAGE",
                        &sdf_error))
            {
                /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
                sdf_ivk_uaClearTransaction(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                        p_overlap_trans_info,
                        "MESSAGE",
                        Sdf_en_uacTransaction);
                /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
                ret_val = ICF_FAILURE;
            }
        }

	}	
#ifdef ICF_LOAD_STAT
       /* Code added for updating the message requests sent */
        if(ICF_SUCCESS == ret_val)
        {    
          p_ssa_pdb->p_glb_pdb->load_data.otg_message_attempts++;
        }  
#endif
    /*Klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_overlap_trans_info)

        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}


/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_send_refer_req
 *
 * DESCRIPTION:     This function constructs and sends REFER req on network.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_refer_req(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS,
                 dummy_ret_val = ICF_SUCCESS;
    SipOptions                  options;
    Sdf_st_error                sdf_error;
    SipError                    sip_err = ICF_NULL;
    

    Sdf_ty_s8bit               proto[ICF_MAX_SIZE_INT_USAGE_STR] = {0};

    icf_ssa_ctxt_st          *p_ssa_ctx = p_ssa_pdb->p_ssa_ctxt;
    icf_sic_ctx_st          *p_sic_ctx = p_ssa_ctx->p_sic_ctxt;
    SipHeader                *p_refer_to_hdr = SIP_NULL;
    Sdf_st_callObject       *p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;

    Sdf_ty_s8bit            tpt_scheme[ICF_MAX_STR_LEN];
    Sdf_ty_u16bit           port_num_to_be_set = 0;
    Sdf_st_overlapTransInfo *p_overlap_txn = Sdf_co_null;
    icf_glb_pdb_st       *p_glb_pdb = p_ssa_pdb->p_glb_pdb;


    icf_call_ctx_st          *p_call_ctxt = p_glb_pdb->p_call_ctx;
    icf_error_t                *p_ecode = ICF_NULL;

#ifdef ICF_IPSEC_ENABLED
    icf_uint8_t            *p_value = ICF_NULL;
#endif
    icf_address_st           *p_icf_address = ICF_NULL;
    icf_nw_otg_refer_req_st  *p_refer_req = ICF_NULL;
    icf_uint8_t              local_addr_str[ICF_MAX_STR_LEN];    
    icf_transport_address_st *p_icf_trans_addr = ICF_NULL;
    icf_config_data_st       *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    SipAddrSpec                 *p_addr_spec = SIP_NULL;
    SipHeader                   *p_replaces_hdr = SIP_NULL;
    SipHeader                   *p_referred_by_hdr = SIP_NULL;
    Sdf_ty_bool                  is_referred_by = Sdf_co_false;
    icf_list_st              *p_temp_list_node = ICF_NULL;

   /* Do not remove this as this causes warnings */
    proto[0]='\0';

    p_refer_req = 
        (icf_nw_otg_refer_req_st *)(p_ssa_pdb->p_internal_msg->p_msg_data);

    /*Fetch sic context from subs_req*/
    p_sic_ctx = p_refer_req->p_sic_ctx;

    /* crash fix when acccessing p_ecode */
    p_ecode = p_ssa_pdb->p_ecode;
    
    options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

#ifdef ICF_TRACE_ENABLE
    if(p_refer_req->bitmask & ICF_NW_OTG_REFER_RELACE_CALL_ID)
    {
         p_ssa_pdb->replace_header_present=1;
    }
/* CSR 1-6212448: Send refer trace to application even if replace header is 
 * not present*/
    if(ICF_NULL != p_ssa_ctx->p_call_ctxt)
	{
		ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_REFER_SENT)
	}    
#endif

    if (ICF_NULL != p_sic_ctx)
    {
    /* Set the transport mode in local variable */
    if (p_sic_ctx->bitmask & ICF_SIC_REQUEST_WITHIN_DIALOG)
    {
        /*Since request is within dialog, it is assumed that the
        p_ssa_ctxt->transport has been filled earlier and if a revert was
        required or possible, it has been done*/
        if ((ICF_TRUE == p_ssa_pdb->p_ssa_ctxt->trans_mode_reverted) ||
            (ICF_TRANSPORT_TYPE_UDP == 
            p_ssa_pdb->p_line_data->transport_mode))
        {
            icf_port_strcpy((icf_uint8_t *)proto,(icf_uint8_t *) "UDP");
        }
        else if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_ssa_ctxt->transport) ||
                (ICF_TRANSPORT_MODE_BOTH == 
                 p_ssa_pdb->p_ssa_ctxt->transport))
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
        }
        else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
        }
        else
        {
            return ICF_FAILURE;
        }
    }
    else 
    {
        if (ICF_FAILURE == icf_ssa_check_for_trans_param(p_ssa_pdb,
                    p_ssa_pdb->p_line_data->transport_mode, ICF_NULL, ICF_TRUE))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSettingTransport&Revert Modes"));
            return ICF_FAILURE;
        }
        if(ICF_TRANSPORT_TYPE_UDP == 
            p_ssa_pdb->p_line_data->transport_mode)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
        }
        else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_line_data->transport_mode)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
        }
        else if (ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_line_data->transport_mode)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
        }
        else 
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
        }
    }

#ifdef ICF_P_CSCF_DISCOVERY_ENABLED
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)
/* We will net the transport mode to none for P-CSCF Discovery */
    icf_port_strcpy(proto,"");
ICF_CHECK_IMS_END
#endif
#endif
        if (((ICF_ADDRESS_PLAN_SIPS_URI == p_sic_ctx->dest_addr.addr_type) &&
        (ICF_TRANSPORT_TYPE_TLS != p_ssa_ctx->transport)) || 
        ((ICF_ADDRESS_PLAN_SIP_URI == p_sic_ctx->dest_addr.addr_type) &&
        (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctx->transport)))
    {
        ret_val = ICF_FAILURE;
    }
        
    else if(
        !( p_sic_ctx->bitmask & ICF_SIC_REQUEST_WITHIN_DIALOG) &&
        (ICF_FAILURE == icf_ssa_update_callobj_for_profile(p_ssa_pdb))
        )
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            
        ret_val = ICF_FAILURE;
    }
    /* IMP: 
     * Updation needed in set_to_in_reg_call_obj for 
     * ICF_SSA_USER_ADDR_FRM_SIC*/
    /* To header will be set */
    else if (
        !( p_sic_ctx->bitmask & ICF_SIC_REQUEST_WITHIN_DIALOG) &&
        (ICF_FAILURE == icf_ssa_set_to_in_sic_callobj(p_ssa_pdb,
                                (icf_uint8_t *)proto))
        
                )
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_TRUE)
    if (ICF_FAILURE != ret_val)
    {
    /* Fill Route Header from Service Route if stored for user-id while 
        registering*/
        if(ICF_FAILURE == 
        icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                p_sic_ctx->p_preferred_identity,
                p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
    }
ICF_CHECK_IMS_END
#endif
#ifdef NON_IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_FALSE)
    if (ICF_FAILURE != ret_val)
    {
        if(ICF_FAILURE == 
            icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
            ICF_NULL,
            p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
    }
ICF_CHECK_IMS_END
#endif
        if (ICF_FAILURE == ret_val)    
        {
            return ICF_FAILURE;
        }
    }
   /*Check if referred-by header to be sent with refer request*/
    if (ICF_NULL != 
            (ICF_NW_OTG_REFER_REF_BY & p_refer_req->bitmask))
    {
        p_icf_address = &(p_call_ctxt->local_address);
        ICF_ASSERT(p_ssa_pdb->p_glb_pdb, p_icf_address)

        icf_port_strcpy(local_addr_str,
                p_call_ctxt->local_address.addr_val.str);

        is_referred_by = Sdf_co_true;
        /* Start: change for SPR14505 */
        if (ICF_NULL == p_icf_address)
        {
         ret_val = ICF_FAILURE;
        }/* if (ICF_NULL == p_address) */
        else if ((ICF_FAILURE == icf_cmn_validate_sip_addr(p_ssa_pdb->p_glb_pdb,
                    p_icf_address, p_ssa_pdb->p_ecode)))
        {
          ret_val = ICF_FAILURE;
        }
        /* End: change for SPR14505 */
        else
        {
          if ( (ICF_ADDRESS_PLAN_SIP_URI == 
                    p_icf_address->addr_type) ||
                (ICF_ADDRESS_PLAN_E164 ==
                 p_icf_address->addr_type))
          {
              icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"sip");
          }
          else if (ICF_ADDRESS_PLAN_SIPS_URI == 
                  p_icf_address->addr_type)
          {
              icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"sips");
          }
          else if (ICF_ADDRESS_PLAN_TEL_URI == 
                  p_icf_address->addr_type)
          {
              icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"tel");
          }

          if ( ICF_NULL != 
                (ICF_ADDRESS_PLAN_E164 & 
                 p_icf_address->addr_type))
           {/* We need to make the SIP URI using the local address
             * and the self address*/
              if (ICF_CFG_SELF_ADDR_PER_LINE == 
                  p_glb_cfg_data->self_addr_per_line)
               {
                 p_icf_trans_addr = &(p_ssa_pdb->p_line_data->self_addr);
               }
              else
               {
                  p_icf_trans_addr = &(p_glb_cfg_data->self_ip_address);
               }

              if ( ICF_FAILURE == 
                     icf_ssa_form_sip_uri_frm_e164(
                        p_ssa_pdb, local_addr_str, 
                        p_icf_trans_addr,&port_num_to_be_set))
               {
                 ret_val = ICF_FAILURE;
               }
            }/*Formation of SIP URI from E164 ends here*/
        /* Set reffered by header */
        if (Sdf_co_fail == sdf_ivk_uaMakeAddrSpecFromConstituents(
                    &p_addr_spec,
                    (Sdf_ty_s8bit *)local_addr_str,
                    port_num_to_be_set,
                    (Sdf_ty_s8bit *)tpt_scheme,
                    &sdf_error))
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE == 
                 icf_ssa_insert_params_frm_address_st(
                     p_ssa_pdb,p_addr_spec,p_icf_address))
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
        else if(sip_initSipHeader(
                    (SipHeader**)(&p_referred_by_hdr),
                    SipHdrTypeReferredBy,\
                    (SipError*)(&sip_err))==SipFail)
        {
            sip_freeSipHeader(p_referred_by_hdr);
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
        else if ( SipFail == sip_setReferrerInReferredByHdr(
                    p_referred_by_hdr,
                    p_addr_spec, (SipError *)(&sip_err)))
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
      } 
        if ( (ICF_FAILURE != ret_val) &&
                (ICF_NULL != (ICF_LOCAL_NAME_PRESENT &
                                 p_call_ctxt->common_bitmask)))
        {
            if (SipFail == sip_setDispNameInReferredByHdr(
                        p_referred_by_hdr,
                        Sdf_mc_strdupCT((const icf_int8_t *)p_call_ctxt->local_name.str),
                        (SipError *)(&sip_err)))
            {
                /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
                ret_val = ICF_FAILURE;
                /*we are not freeing the header here as that is done
                 * while exiting this routine. So no direct return calls
                 * are to be added in this code.*/
            }
        }
        /*This Free is to be hit whether some opeartion above succeeded
         * or failed*/
        sip_freeSipAddrSpec(p_addr_spec);
    }

    /* Insert Replaces header, if services set the bitmask,
     * this will only be set in case of request received from
     * services*/
    if ( ICF_FAILURE != ret_val)
    {
        if(ICF_NULL != ICF_SSA_GET_COMMON_BITMASK(
                    p_refer_req->bitmask, ICF_NW_OTG_REFER_RELACE_CALL_ID))
        {
            icf_call_ctx_st      *p_replaced_call_ctxt = ICF_NULL ;

            if ( ICF_FAILURE == icf_dbm_find_call_cntxt_blk(
                        p_glb_pdb,
                        p_refer_req->replace_call_id,
                        &p_replaced_call_ctxt,
                        p_ecode))
            {
                /*Set/Raise Error:INVALID_CALL_ID*/
                ret_val = ICF_FAILURE;
            }
            /*
             * Invoke sdf_ivk_uaFormReplacesHeader with
             * pointer to call object stored in the
             * replaced call context.
             */
            else if (Sdf_co_fail ==sdf_ivk_uaFormReplacesHeader (
                        ((icf_ssa_ctxt_st *)
                        p_replaced_call_ctxt->p_sip_ctx)->p_call_obj,
                        Sdf_co_null,Sdf_co_null,Sdf_co_null,
                        &p_replaces_hdr,
                        &sdf_error))
            {
                /*Set/RaiseError:UATK_PROCESSING_FAILURE*/
                ret_val = ICF_FAILURE;
            }
        }
    }
    
    if ( ICF_FAILURE != ret_val)
    {
        icf_uint8_t                refer_to_addr_str[ICF_MAX_STR_LEN + ICF_MAX_LARGE_STR_LEN];
        icf_address_st            *p_icf_address = ICF_NULL;
        icf_transport_address_st    *p_icf_trans_addr = ICF_NULL;
        SipAddrSpec                    *p_addr_spec = SIP_NULL;
      
        if (ICF_NULL != p_sic_ctx)
    {
        icf_port_strcpy(refer_to_addr_str,
                p_sic_ctx->refer_to.addr_val.str);
        p_icf_address = &(p_sic_ctx->refer_to);
    }
    else
    {
        icf_port_strcpy(refer_to_addr_str,
                p_refer_req->p_referred_to->addr_val.str);
        p_icf_address = p_refer_req->p_referred_to;
    }
    /* Start: change for SPR14505 */
    if (ICF_NULL == p_icf_address)
    {
      ret_val = ICF_FAILURE;
    }/* if (ICF_NULL == p_address) */
    else if ((ICF_FAILURE == icf_cmn_validate_sip_addr(
					p_ssa_pdb->p_glb_pdb,
					p_icf_address, p_ssa_pdb->p_ecode)))
    {
      ret_val = ICF_FAILURE;
    }
    else
    {
      /* End: change for SPR14505 */
        if ( (ICF_ADDRESS_PLAN_SIP_URI == 
                    p_icf_address->addr_type) ||
                (ICF_ADDRESS_PLAN_E164 ==
                 p_icf_address->addr_type))
        {
            icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"sip");
        }
        else if (ICF_ADDRESS_PLAN_SIPS_URI == 
                p_icf_address->addr_type)
        {
            icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"sips");
        }
        else if (ICF_ADDRESS_PLAN_TEL_URI == 
                p_icf_address->addr_type)
        {
            icf_port_strcpy((icf_uint8_t *)tpt_scheme, (icf_uint8_t *)"tel");
        }
        else if (ICF_ADDRESS_PLAN_NOT_PRESENT == 
                p_icf_address->addr_type)
        {
            /*Here we need to extract the transport scheme from the address*/
            /*received from application*/
            icf_uint8_t      temp_str[ICF_MAX_STR_LEN];
            icf_int8_t        *p_remaining_str=ICF_NULL;

            icf_port_strcpy(temp_str,refer_to_addr_str );
            icf_port_strtokr((icf_int8_t *)temp_str,":",&p_remaining_str);
            icf_port_strcpy((icf_uint8_t *)tpt_scheme,(icf_uint8_t *)temp_str);
            /* Added the NULL check on p_remaining_str for SPR14505 */
            if(p_remaining_str != ICF_NULL)
              icf_port_strcpy(refer_to_addr_str,(icf_uint8_t *)p_remaining_str);
        }
        /*if ( ICF_NULL != */
        /*        (ICF_ADDRESS_PLAN_E164 & */
        /*         p_icf_address->addr_type))*/
        if (ICF_ADDRESS_PLAN_E164 == 
                p_icf_address->addr_type)
        {/* We need to make the SIP URI using the local address
          * and the self address*/
            
            /* Fix for SPR: 19886 (Merged CSR 1-7297673)*/
            /*  The code was removed from here because sic context will
             *  be null when IPTK would be sending the refer as
             *  this refer is triggered by Services*/
            p_icf_trans_addr = &(p_ssa_pdb->p_line_data->proxy_addr);            

            if ( ICF_FAILURE == 
                    icf_ssa_form_sip_uri_frm_e164(
                        p_ssa_pdb, refer_to_addr_str, 
                        p_icf_trans_addr,&port_num_to_be_set))
            {
                /*Even is referred by was not set, this call will not
                 * result in crash as stack code checks for null value
                 * of the argument*/

                ret_val = ICF_FAILURE;
            }
        }/*Formation of SIP URI from E164 ends here*/
        if(ICF_NULL != port_num_to_be_set)
        {
            icf_uint8_t  temp[6];
            /*Append port to the address*/
            icf_port_strcat(refer_to_addr_str,(icf_uint8_t *)":");
            /* Fix for SPR: 19886 (Merged CSR 1-7297673)*/
            icf_port_itoa(port_num_to_be_set,&temp[0]);
            icf_port_strcat(refer_to_addr_str,temp);            
            port_num_to_be_set = 0;
        }
        if(ICF_REFER_TO_ADDNL_URI_PARAMTR_PRES & p_refer_req->bitmask)
        {
            icf_port_strcat(refer_to_addr_str,(icf_uint8_t *)";");
            icf_port_strcat(refer_to_addr_str,p_refer_req->p_uri_parameter->str);
        }

        if(SipFail == sip_initSipHeader(
                    (SipHeader**)(&p_refer_to_hdr),
                    SipHdrTypeReferTo,\
                    (SipError*)(&sip_err)))
        {
            sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_ivk_uaMakeAddrSpecFromConstituents(
                    &p_addr_spec,
                    (Sdf_ty_s8bit *)refer_to_addr_str,
                    port_num_to_be_set,
                    (Sdf_ty_s8bit *)tpt_scheme,
                    &sdf_error))
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
            ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_refer_to_hdr,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        dummy_ret_val)

            ret_val = ICF_FAILURE;
        }
        else if (ICF_NULL == p_addr_spec)
        {
            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
            ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_refer_to_hdr,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        dummy_ret_val)

            ret_val = ICF_FAILURE;
        }
        else
        { 
          if(p_refer_req->bitmask & ICF_NW_OTG_REFER_METHOD_BYE)
          {
            icf_ssa_insert_param_in_addr_spec(
                    p_ssa_pdb,
                    p_addr_spec,
                     (icf_uint8_t *)"method", (icf_uint8_t *)"BYE", &sdf_error);

          }

          if(SipFail == sip_setAddrSpecInReferToHdr(
                    (SipHeader*)p_refer_to_hdr,
                    p_addr_spec,
                    &sip_err))
          {
            sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
            ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_refer_to_hdr,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        dummy_ret_val)

            /*Raise/Ser Error:UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
          }
        }
        sip_freeSipAddrSpec(p_addr_spec);
      }  
    }

    if ( ICF_FAILURE != ret_val)
    {
        SipOptions          options;
        options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;
        if ( Sdf_co_fail == sdf_ivk_uaStartRegularTransaction(
                    p_call_obj,&p_overlap_txn, "REFER",
                    &sdf_error))
        {   
            /*Raise/Set Error: UATK_PROCESSING_FAILURE*/
            ret_val = ICF_FAILURE;
            p_ssa_pdb->p_internal_msg->msg_hdr.ecode = ICF_ECODE_REFER_PENDING;
        } /* set the transport mode to the outgoing REFER*/
        else if ( Sdf_co_fail == 
                sdf_ivk_uaSetTransportSchemeInTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction, 
                p_overlap_txn,
                proto, &sdf_error))
        {
                ret_val = ICF_FAILURE;
        }
        else
        if( Sdf_co_fail == sdf_ivk_uaMakeRefer (p_call_obj, 
                    p_overlap_txn,
                    (SipHeader*)p_refer_to_hdr,
                    (SipHeader*)p_replaces_hdr,
                    is_referred_by,
                    (SipHeader*)p_referred_by_hdr,
                    &sdf_error))
        {
            /*Set/RaiseError:UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearRegularTransaction(
                    p_call_obj,
                    "REFER",
                    p_overlap_txn);
            /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
            /*klocwork warning removal*/
            sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
            sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
            if(ICF_NULL != p_refer_to_hdr)
            {
                ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_refer_to_hdr,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            dummy_ret_val)
            }
            ret_val = ICF_FAILURE;
        }

    }

       
    if ( ICF_FAILURE != ret_val)
    {
        if (ICF_NULL != p_sic_ctx)
        {
            /* insert Privacy header in BYE request if application requested 
             * it at the time of create_call */
            if ((ICF_NULL != p_sic_ctx->p_call_ctx) && 
                (ICF_PRIVACY_HDR_ALL_REQ & p_sic_ctx->p_call_ctx->common_bitmask))
            {
                if (ICF_FAILURE == icf_ssa_form_and_insert_priv_hdr(
                                        p_ssa_pdb,
                                        p_overlap_txn->pSipMsg))
                {
                    ICF_PRINT(((icf_uint8_t *)"\nFailed to insert Privacy header in BYE request"));
                    sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                    /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                    /*klocwork warning removal*/
                    sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
                    if(ICF_NULL != p_referred_by_hdr)
                    {
                        ICF_MEMFREE(
                                    p_ssa_pdb->p_glb_pdb,
                                    p_referred_by_hdr,
                                    ICF_MEM_COMMON,
                                    p_ssa_pdb->p_ecode,
                                    dummy_ret_val)
                    }
                    sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
                    if(ICF_NULL != p_refer_to_hdr)
                    {
                        ICF_MEMFREE(
                                    p_ssa_pdb->p_glb_pdb,
                                    p_refer_to_hdr,
                                    ICF_MEM_COMMON,
                                    p_ssa_pdb->p_ecode,
                                    dummy_ret_val)
                    }
                    sip_freeSipHeader(p_replaces_hdr);
                    if (SIP_NULL != p_replaces_hdr)
                     {
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_replaces_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                     }
                    ret_val = ICF_FAILURE;
                    return ret_val;
                }         
            }
        }

        if (ICF_FAILURE == ret_val)
        {
            /* do nothing here */
        }
        /* To add the P-Access-Network Info header to the SipMsg */
        else if ( ICF_FAILURE == icf_ssa_form_and_insert_access_nw_info_hdr(
                    p_ssa_pdb, p_overlap_txn->pSipMsg))
        {
              /* klocwork warning removal*/
              sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
              if(ICF_NULL != p_referred_by_hdr)
               {
                   ICF_MEMFREE(
                          p_ssa_pdb->p_glb_pdb,
                          p_refer_to_hdr,
                          ICF_MEM_COMMON,
                          p_ssa_pdb->p_ecode,
                          dummy_ret_val)
               }
              sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
              if(ICF_NULL != p_refer_to_hdr)
              {
                  ICF_MEMFREE(
                          p_ssa_pdb->p_glb_pdb,
                          p_refer_to_hdr,
                          ICF_MEM_COMMON,
                          p_ssa_pdb->p_ecode,
                          dummy_ret_val)
              }
              sip_freeSipHeader(p_replaces_hdr);
              if (SIP_NULL != p_replaces_hdr)
               {
                  ICF_MEMFREE(
                          p_ssa_pdb->p_glb_pdb,
                          p_replaces_hdr,
                          ICF_MEM_COMMON,
                          p_ssa_pdb->p_ecode,
                          ret_val)
               }
              ret_val  = ICF_FAILURE;
        }
        /* To add security association headers*/
        else if(ICF_FAILURE == icf_ssa_form_and_insert_security_agreement_hdrs(
                                      p_ssa_pdb,(icf_uint8_t *)"REFER",
                                      p_overlap_txn->pSipMsg))
        {
              /* Free all the allocated memory to REFER specific
               * headers.
               */ 
              sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
              if(ICF_NULL != p_referred_by_hdr)
              {
                   ICF_MEMFREE(
                          p_ssa_pdb->p_glb_pdb,
                          p_refer_to_hdr,
                          ICF_MEM_COMMON,
                          p_ssa_pdb->p_ecode,
                          dummy_ret_val)
              }
              sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
              if(ICF_NULL != p_refer_to_hdr)
              {
                  ICF_MEMFREE(
                          p_ssa_pdb->p_glb_pdb,
                          p_refer_to_hdr,
                          ICF_MEM_COMMON,
                          p_ssa_pdb->p_ecode,
                          dummy_ret_val)
              }
              sip_freeSipHeader(p_replaces_hdr);
              if (SIP_NULL != p_replaces_hdr)
              {
                  ICF_MEMFREE(
                          p_ssa_pdb->p_glb_pdb,
                          p_replaces_hdr,
                          ICF_MEM_COMMON,
                          p_ssa_pdb->p_ecode,
                          ret_val)
              }
              ret_val = ICF_FAILURE;  
        }
        
#ifdef ICF_IPSEC_ENABLED
        /* Refer needs to go protected if IPSEC is enabled and SA exists */
        if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled) &&
            /* if SA exits */
            (ICF_NULL != p_ssa_pdb->p_sa_context))
        {
            /* insert security-verify header in the otg REFER */
            if (ICF_FAILURE == icf_ssa_get_sec_verify_string (p_ssa_pdb,&p_value,
                p_ssa_pdb->p_sa_context))
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_FAILURE ==     
              icf_ssa_insert_unknown_hdr_in_sip_msg (
                  p_ssa_pdb,
                  (icf_uint8_t*)"Security-Verify",
                  p_value, 
                  p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg))
            {
                ICF_PRINT(("\nFailed to insert unknown header \
                        (Security-Verify)"));
                ret_val = ICF_FAILURE;
            }
            if (ICF_NULL != p_value)
            {
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_value,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            }
            if (ICF_SUCCESS == ret_val )
            {
                ICF_PRINT(("\nSecurity Verify Header inserted to \
                                outgoing Refer "));
            }
        }
#endif
#if 0
        if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
        {
    
            if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                p_ssa_pdb, 
                (icf_uint8_t*)"P-Preferred-Identity",
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_val.str,
                p_overlap_txn->pSipMsg))
            {
                ICF_PRINT(("\nFailed to insert unknown header (P-Preferred-Identity)"));
                sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                ret_val  = ICF_FAILURE;
        
                return ICF_FAILURE;
            }
        }
#endif
        if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt)
        {
            if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
            {
                /* Fix for CSR 1-7436195 */
                /* Coverity bug fix */
                icf_string_st                 addr_val = {0,"\0"};
                
                if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_SIP_URI)
                {
                    icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sip:");
                    icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
                    icf_port_strcat( addr_val.str, (icf_uint8_t *)">");
                    
                    
                }
                else if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_TEL_URI)
                {
                    icf_port_strcpy( addr_val.str, (icf_uint8_t *)"tel:");
                    icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
                }
                else if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_SIPS_URI)
                {
                    icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sips:");
                    icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
                    icf_port_strcat( addr_val.str, (icf_uint8_t *)">");
                }
                else
                {
                    icf_port_strcpy( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
                }
                
                
                if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                    p_ssa_pdb, 
                    (icf_uint8_t*)"P-Preferred-Identity",
                    addr_val.str,
                    p_overlap_txn->pSipMsg ))
                {
                    ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header (P-Preferred-Identity)"));
                    sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        (const Sdf_ty_s8bit *)"REFER",
                        p_overlap_txn);
                    /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                    /* klocwork warning removal*/
                    sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
                    if(ICF_NULL != p_referred_by_hdr)
                     {
                         ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_referred_by_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                dummy_ret_val)
                     }
                    sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
                    if(ICF_NULL != p_refer_to_hdr)
                    {
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_refer_to_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                dummy_ret_val)
                    }
                    sip_freeSipHeader(p_replaces_hdr);
                    if (SIP_NULL != p_replaces_hdr)
                     {
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_replaces_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                     }
                    
                    return ICF_FAILURE;
                }
            }
            
#if 0 /* Remove hard-coded "norefersub" in Require header of REFER request */
            if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->subs_reqd ==0 )
            {
                icf_uint16_t        list_count=p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count;
                icf_boolean_t    require_hdr_present=ICF_FALSE;
                icf_header_st*    p_hdr = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.hdr;
                
                
                /*check if application has already added Require header*/
                
                while (list_count > 0 && ICF_NULL != p_hdr) 
                {
                    if( icf_port_strcmp( p_hdr->hdr_name.str, "Require") == 0)
                    {
                        require_hdr_present = ICF_TRUE;
                        /* Check if 'norefersub' has already been added by application*/
                        if ( ICF_NULL == strstr( p_hdr->hdr_value.str , "norefersub") )
                        {
                            /*We need to append 'norefersub' to it*/
                            icf_port_strcat( p_hdr->hdr_value.str, ",norefersub");
                            
                        }
                    }
                    list_count = list_count - 1;
                    p_hdr = p_hdr->next;
                }
                
                if( require_hdr_present == ICF_FALSE )
                {
                    if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                        p_ssa_pdb, 
                        (icf_uint8_t*)"Require",
                        "norefersub",
                        p_overlap_txn->pSipMsg))
                    {
                        ICF_PRINT(("\nFailed to insert unknown header (P-Preferred-Identity)"));
                        sdf_ivk_uaClearRegularTransaction(
                            p_call_obj,
                            "REFER",
                            p_overlap_txn);
                        /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                        ret_val  = ICF_FAILURE;
                        
                        return ICF_FAILURE;
                    }
                }
            }
#endif /* if 0 for norefersub */
            
            /* Insert Header/Tag/Body if any given by the application */
            
            if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count)
            {
                if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
                    p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list),
                    ICF_TRUE, p_overlap_txn->pSipMsg))
                {
                    ret_val = ICF_FAILURE;
                }
            }
            
            
            if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list.count)
            {
                if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
                    p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list),
                    ICF_TRUE, p_overlap_txn->pSipMsg))
                {
                    ret_val = ICF_FAILURE;
                }
                
            }
            
            if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.count)
            {
                
                               if (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
                    p_ssa_pdb,&(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list) , 
                    ICF_TRUE, &(p_overlap_txn->slMsgBodyList)))
                {
                    sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                    /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                    /* klocwork warning removal*/
                    sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
                    if(ICF_NULL != p_referred_by_hdr)
                     {
                         ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_referred_by_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                dummy_ret_val)
                     }
                    sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
                    if(ICF_NULL != p_refer_to_hdr)
                    {
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_refer_to_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                dummy_ret_val)
                    }
                    sip_freeSipHeader(p_replaces_hdr);
                    if (SIP_NULL != p_replaces_hdr)
                     {
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_replaces_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                     }
                    return ICF_FAILURE;
                    
                }
                
                /*Message body header changes Start*/
                if ( ICF_FAILURE ==icf_ssa_SetAllMsgBody(\
                    Sdf_co_null,p_overlap_txn,\
                    (icf_int8_t *)p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                    body_list.content_type.str,&sdf_error))
                {
                    sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                    /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                    /* klocwork warning removal*/
                    sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
                    if(ICF_NULL != p_referred_by_hdr)
                     {
                         ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_referred_by_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                dummy_ret_val)
                     }
                    sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
                    if(ICF_NULL != p_refer_to_hdr)
                    {
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_refer_to_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                dummy_ret_val)
                    }
                    sip_freeSipHeader(p_replaces_hdr);
                    if (SIP_NULL != p_replaces_hdr)
                     {
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_replaces_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                     }
                    return ICF_FAILURE;
                    
                }
                /*Message body header changes End*/
            }
        }/*end of p_ssa_pdb->p_ssa_ctxt->p_sic_ctx not NULL leg*/ 
        else
        {
            /*SPR 19590 change start*/
            ret_val = icf_cmn_fetch_curr_hdr_list_node_from_call_ctx(
                          p_ssa_pdb->p_glb_pdb,
                          &p_temp_list_node);
            /*SPR 19590 change end*/
			if ((ICF_NULL != p_temp_list_node) &&
                (ICF_NULL != p_temp_list_node->p_data) &&    
                (ICF_NULL <
                  ((icf_header_link_list_st*)(p_temp_list_node->p_data))->header_list.count))
            {
                if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
                    p_ssa_pdb, &(((icf_header_link_list_st*)(p_temp_list_node->p_data))->header_list),
                    ICF_TRUE, p_overlap_txn->pSipMsg))
                {
                    ret_val = ICF_FAILURE;
                }
            }
            
            
            /*SPR 19590 change start*/
            if(ICF_SUCCESS == ret_val)
            {    
                ret_val = icf_cmn_fetch_curr_tag_list_node_from_call_ctx(
                          p_ssa_pdb->p_glb_pdb,
                          &p_temp_list_node);
            }   
            /*SPR 19590 change end*/
			if ((ICF_SUCCESS == ret_val) && (ICF_NULL != p_temp_list_node) &&
                (ICF_NULL != p_temp_list_node->p_data) &&    
			    (ICF_NULL <
                  ((icf_tag_link_list_st*)(p_temp_list_node->p_data))->tag_list.count))
            {
                if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
                    p_ssa_pdb, &(((icf_tag_link_list_st*)(p_temp_list_node->p_data))->tag_list),
                    ICF_TRUE, p_overlap_txn->pSipMsg))
                {
                    ret_val = ICF_FAILURE;
                }
                
            }
            
            /*SPR 19590 change start*/
            if(ICF_SUCCESS == ret_val)
            {    
                ret_val = icf_cmn_fetch_curr_body_list_node_from_call_ctx(
                          p_ssa_pdb->p_glb_pdb,
                          &p_temp_list_node);
            }    
            /*SPR 19590 change end*/
			if((ICF_SUCCESS == ret_val) && (ICF_NULL != p_temp_list_node) &&
                (ICF_NULL != p_temp_list_node->p_data) &&    
			    (ICF_NULL <
                  ((icf_msg_body_link_list_st*)(p_temp_list_node->p_data))->body_list.count))
            {
                
                if(ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(p_ssa_pdb,
                    &(((icf_msg_body_link_list_st*)(p_temp_list_node->p_data))
                        ->body_list), 
                    ICF_TRUE, &(p_overlap_txn->slMsgBodyList)))
                {
                    sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                    /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                    /* klocwork warning removal*/
                    sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
                    if(ICF_NULL != p_referred_by_hdr)
                     {
                         ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_referred_by_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                dummy_ret_val)
                     }
                    sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
                    if(ICF_NULL != p_refer_to_hdr)
                    {
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_refer_to_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                dummy_ret_val)
                    }
                    sip_freeSipHeader(p_replaces_hdr);
                    if (SIP_NULL != p_replaces_hdr)
                     {
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_replaces_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                     }
                    return ICF_FAILURE;
                    
                }
                /*Message body header changes Start*/
                else if(ICF_FAILURE ==icf_ssa_SetAllMsgBody(\
                    Sdf_co_null,p_overlap_txn,\
                    (icf_int8_t *)((icf_msg_body_link_list_st*)\
                        (p_temp_list_node->p_data))->body_list.content_type.str,\
                    &sdf_error))
                {
                    sdf_ivk_uaClearRegularTransaction(
                        p_call_obj,
                        "REFER",
                        p_overlap_txn);
                    /*sdf_ivk_uaFreeCallObject(&p_call_obj);*/
                    /* klocwork warning removal*/
                    sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
                    if(ICF_NULL != p_referred_by_hdr)
                     {
                         ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_referred_by_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                dummy_ret_val)
                     }
                    sip_freeSipHeader((SipHeader*)p_refer_to_hdr);
                    if(ICF_NULL != p_refer_to_hdr)
                    {
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_refer_to_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                dummy_ret_val)
                    }
                    sip_freeSipHeader(p_replaces_hdr);
                    if (SIP_NULL != p_replaces_hdr)
                     {
                        ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_replaces_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                ret_val)
                     }
                    return ICF_FAILURE;
                    
                }
                /*Message body header changes End*/
            }/*p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->body_list.count*/
        }/*end of p_ssa_pdb->p_ssa_ctxt->p_sic_ctx NULL leg*/
    }/*retval SUCCESS leg*/
        /**************************************************/
           /* as per the philosophy, we need to check for mode inversion and
         * attempt opening of a new cnnection only if the message is being 
         * sent  out of context, for message being sent within an ongoing
         * context/dialog, we need not do the following 
         * */
    if ((ICF_SUCCESS == ret_val) &&
        (ICF_NULL != p_sic_ctx) && 
        ((ICF_NULL == icf_port_strcmp((icf_uint8_t *)proto, (icf_uint8_t *)"TCP")) ||
        (ICF_NULL == icf_port_strcmp((icf_uint8_t *)proto, (icf_uint8_t *)"TLS"))))
    {
            /*if within dialog, then we don't need explicit conenct
            and we will not revert if some connect fails*/
        if (!(ICF_SIC_REQUEST_WITHIN_DIALOG & p_sic_ctx->bitmask))
        {
            ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                    ICF_SSA_EXPLICIT_CONNECT_REQ)
        }
    }   
        /* In case of SM failure, the connect_req routine
        * has reset the conn db node*/
    
    if (ICF_SUCCESS == ret_val)
    {
        if ( ICF_FAILURE == icf_ssa_send_to_peer(
            p_ssa_pdb,
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            p_overlap_txn->pSipMsg,
            &options,
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_txn,
                "REFER",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == sdf_ivk_uaEndTransaction(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            Sdf_co_null,
            "REFER",
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_txn,
                "REFER",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
    }
    /*  CSR 1-5685130 Merge. */
    /*Store the ReferredTo as part of Persistent HdrList*/
    if(Sdf_co_fail == icf_ssa_insert_hdr_in_persistent_list_in_call_obj(
			    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
			    p_refer_to_hdr,
			    SipHdrTypeReferTo, 
			    (Sdf_ty_s8bit *)"uat-ReferTo",
			    &sdf_error))
    {
        /* 
         * Ignore the failure response here. In case of failure
         * the header would not be added to persistentList so
         * we would fail to the when we would retreive this.
         */
    }

    /* klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_replaces_hdr)
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_referred_by_hdr)

    if(ICF_FAILURE == ret_val)
     {
        sip_freeSipHeader((SipHeader*)p_referred_by_hdr);
        if(ICF_NULL != p_referred_by_hdr)
         {
             ICF_MEMFREE(
                     p_ssa_pdb->p_glb_pdb,
                     p_referred_by_hdr,
                     ICF_MEM_COMMON,
                     p_ssa_pdb->p_ecode,
                     dummy_ret_val)
          }
      }
     
     /*  CSR 1-5685130 Merge. */
    /*CSR-1-5634729*/ 
    /*Store the ReferredBy as part of Persistent HdrList*/
    if((SIP_NULL != p_referred_by_hdr) && 
		    Sdf_co_fail == 
		    icf_ssa_insert_hdr_in_persistent_list_in_call_obj(
			    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
			    p_referred_by_hdr,
			    SipHdrTypeReferredBy, 
			    (Sdf_ty_s8bit *)"uat-ReferredBy",
			    &sdf_error))
    {
        /* 
         * Ignore the failure response here. In case of failure
         * the header would not be added to persistentList so
         * we would fail to the when we would retreive this.
         */
    }
    if (SIP_NULL != p_replaces_hdr)
    {
        sip_freeSipHeader(p_replaces_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_replaces_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
    }
    /* klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_overlap_txn)
    
    return ret_val;

} /* icf_ssa_send_refer_req */

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_send_publish_req
 *
 * DESCRIPTION:     This function constructs and sends PUBLISH req on network.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_publish_req(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
     icf_return_t             ret_val = ICF_SUCCESS;
     icf_return_t             ret_val1 = ICF_SUCCESS;
    Sdf_ty_s8bit                HdrName[] = "Event";
    Sdf_ty_s8bit                EventName[ICF_MAX_STR_LEN];
    SipOptions                  options;
    Sdf_st_error                sdf_error;
    Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;
    Sdf_ty_s8bit                proto[ICF_MAX_SIZE_INT_USAGE_STR];
    SipError                    sip_err;
    SipHeader                    *p_exp_hdr = SIP_NULL;

    icf_ssa_ctxt_st          *p_ssa_ctx = p_ssa_pdb->p_ssa_ctxt;
    icf_sic_ctx_st           *p_sic_ctx = p_ssa_ctx->p_sic_ctxt;

   /* code change for CSR-1-4816176/SPR 16075 - not tested */
    icf_config_data_st       *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    icf_uint8_t              self_ip[16];
    /*icf_transport_address_st self_addr = {{0,{{0,"\0"}}},0};*/
    icf_transport_address_st self_addr;
    self_addr.addr.addr_type = 0;
    self_addr.port_num = 0;
    /* end code change for CSR-1-4816176/SPR 16075 */

#ifdef ICF_IPSEC_ENABLED
    icf_uint8_t            *p_value = ICF_NULL;
#endif

    options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

    if (ICF_FAILURE == icf_ssa_check_for_trans_param(p_ssa_pdb,
        p_ssa_pdb->p_line_data->transport_mode, ICF_NULL, ICF_TRUE))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSettingTransport&Revert Modes"));
        return ICF_FAILURE;
    }
 
    if(0 != p_ssa_pdb->p_glb_cfg_data->sip_compact_hdrs)
    {
        /* Compact headers is on, use the compact form */
        icf_port_strcpy((icf_uint8_t *)HdrName,(icf_uint8_t *)"o");
    }
     /* Set the transport mode in local variable */
    if ((ICF_TRANSPORT_TYPE_TCP == 
        p_ssa_pdb->p_line_data->transport_mode) ||
       (ICF_TRANSPORT_MODE_BOTH == 
        p_ssa_pdb->p_line_data->transport_mode))
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
    }
    else if (ICF_TRANSPORT_TYPE_TLS ==
        p_ssa_pdb->p_line_data->transport_mode)
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
    }
    else if( ICF_TRANSPORT_TYPE_UDP ==
        p_ssa_pdb->p_line_data->transport_mode)
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"");
    }
    
    /*IF transport is not INVALID, then addr_type should be SIPS in case
     *of TLS transport and SIP in case of non-TLS transport, ignore this check
     *when transport is INVALID*/
    if ((ICF_TRANSPORT_TYPE_INVALID != p_ssa_ctx->transport) &&
        (((ICF_ADDRESS_PLAN_SIPS_URI == p_sic_ctx->dest_addr.addr_type) &&
                (ICF_TRANSPORT_TYPE_TLS != p_ssa_ctx->transport)) ||
            ((ICF_ADDRESS_PLAN_SIP_URI == p_sic_ctx->dest_addr.addr_type) &&
             (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctx->transport))))
    {
        ret_val = ICF_FAILURE;
        return ret_val;
    }
     
    /*Fetch Event from p_sic_ctx*/
    icf_port_strcpy((icf_uint8_t *)EventName,(icf_uint8_t *)p_sic_ctx->event_package.str);
    /*
    switch (p_sic_ctx->event_package)
    {
        case ICF_EVENT_PKG_POC_SETTINGS:
            icf_port_strcpy(EventName,"poc-settings");
           
            break;

        default:
            ret_val = ICF_FAILURE;
    }
    */

    /*IMP: 
     * Updation needed in update_call_obj for ICF_SSA_USER_ADDR_FRM_SIC*/
    if (ICF_FAILURE == 
                icf_ssa_update_callobj_for_profile(p_ssa_pdb))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            
        ret_val = ICF_FAILURE;
    }
    /* IMP: 
     * Updation needed in set_to_in_reg_call_obj for 
     * ICF_SSA_USER_ADDR_FRM_SIC*/
    /* To header will be set */
    else if ((ICF_FAILURE == 
                icf_ssa_set_to_in_sic_callobj(p_ssa_pdb,
                            (icf_uint8_t *)proto)))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
#if 0
    /*Request URI to be set as destination address*/
    else if (Sdf_co_fail == 
                sdf_ivk_uaMakeAddrSpecFromConstituents(
                    &pAddrSpec, (Sdf_ty_s8bit*)server_addr, 
                    (Sdf_ty_s32bit)server_port,
                    pScheme, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }

    else if (Sdf_co_fail == sdf_ivk_uaChangeRequestURI(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                pAddrSpec, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
#endif

    if (ICF_FAILURE != ret_val)
    {
        /* Fill Route Header from Service Route if stored for user-id while 
        registering*/
        if(ICF_FAILURE == 
        icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                p_sic_ctx->p_user_address,
               p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
    }
    if (ICF_FAILURE == ret_val)
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        ret_val = ICF_FAILURE;
    }

    else if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                &p_overlap_trans_info,
                "PUBLISH",
                &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
        ret_val = ICF_FAILURE;
    }
    else if ( Sdf_co_fail == 
                sdf_ivk_uaSetTransportSchemeInTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction, 
                p_overlap_trans_info,
                proto, &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        ret_val = ICF_FAILURE;
    }
    else if (Sdf_co_fail == sdf_ivk_uaMakeTransaction(
                (Sdf_ty_s8bit *)"PUBLISH", 
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        ret_val = ICF_FAILURE;
    }
    /*Insert Expire header*/
    else if (ICF_FAILURE == sip_initSipHeader(
                &p_exp_hdr, SipHdrTypeExpiresSec, &sip_err))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        ret_val = ICF_FAILURE;
    }
    else if (ICF_FAILURE == sip_setSecondsInExpiresHdr(
                p_exp_hdr, p_sic_ctx->duration, &sip_err))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);

        ret_val = ICF_FAILURE;
    }
    else if (ICF_FAILURE == sip_setHeader(
                p_overlap_trans_info->pSipMsg, 
                p_exp_hdr, &sip_err))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
    /*Insert Event header*/
    else if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                p_ssa_pdb, (icf_uint8_t *)HdrName, (icf_uint8_t *)EventName, 
                p_overlap_trans_info->pSipMsg))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
        ret_val = ICF_FAILURE;
    }       
   
    else if ( ICF_FAILURE == 
                icf_ssa_form_and_insert_access_nw_info_hdr(
                p_ssa_pdb, p_overlap_trans_info->pSipMsg))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);
	ret_val = ICF_FAILURE;
	
    }
    /* To add security association headers*/
    else if(ICF_FAILURE == icf_ssa_form_and_insert_security_agreement_hdrs(
                                   p_ssa_pdb,(icf_uint8_t *)"PUBLISH",
                                   p_overlap_trans_info->pSipMsg))
    {
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);
	    ret_val = ICF_FAILURE;
    }

/*    sip_freeSipAddrSpec(pAddrSpec);*/
     sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
     ICF_MEMFREE(
         p_ssa_pdb->p_glb_pdb,
         p_exp_hdr,
         ICF_MEM_COMMON,
         p_ssa_pdb->p_ecode,
         ret_val1)

#ifdef ICF_IPSEC_ENABLED
    if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled) &&
        /* if SA exits */
        (ICF_NULL != p_ssa_pdb->p_sa_context))
    
    {    
        /* insert the SEcurity-Verify Header in the outgoing Publish 
         * Method
         */                
        if (ICF_FAILURE == icf_ssa_get_sec_verify_string (p_ssa_pdb, &p_value,
            p_ssa_pdb->p_sa_context))
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE ==     
          icf_ssa_insert_unknown_hdr_in_sip_msg (
              p_ssa_pdb,
              (icf_uint8_t*)"Security-Verify",
              p_value, 
              p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg))
        {
            ICF_PRINT(("\nFailed to insert unknown header \
                    (Security-Verify)"));
            ret_val = ICF_FAILURE;
        }
        if (ICF_NULL != p_value)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_value,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        }
        if (ICF_SUCCESS == ret_val )
        {
            ICF_PRINT(("\nSecurity Verify Header inserted to \
                            outgoing Publish "));
        }
    }
#endif
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, 
        (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity))
    
#if 0
    if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
    {
        if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
        p_ssa_pdb, 
        (icf_uint8_t*)"P-Preferred-Identity",
        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_val.str,
        p_overlap_trans_info->pSipMsg))
        {
            ICF_PRINT(("\nFailed to insert unknown header (P-Preferred-Identity)"));
            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "PUBLISH",
                    Sdf_en_uacTransaction);

            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
            return ICF_FAILURE;
        }
    }
#endif
    
    if (ICF_FAILURE != ret_val)
    {
    
    if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
    {
         /* Fix for CSR 1-7436195 */
         /* Coverity bug fix */
        icf_string_st                 addr_val = {0,"\0"};

        if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_SIP_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sip:");
            icf_port_strcat( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                p_preferred_identity->addr_val.str );
            icf_port_strcat( addr_val.str,(icf_uint8_t *) ">");


        }
        else if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_TEL_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"tel:");
            icf_port_strcat( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                p_preferred_identity->addr_val.str );
        }
             /* code change for CSR-1-4816176/SPR 16075 - not tested */

        else if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                == ICF_ADDRESS_PLAN_E164)
            {
                icf_port_strcpy(addr_val.str,(icf_uint8_t *)"<sip:");

                icf_port_strcat(addr_val.str,
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );

                icf_port_strcat(addr_val.str,(icf_uint8_t *)"@");

                /* now appending the self IP/domain */
                /*If per line self transport then copy address from line_data*/
                if(ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
                {
                    if(ICF_NULL != p_ssa_pdb->p_line_data)
                    {
                        icf_port_memcpy(&self_addr,
                                    &(p_ssa_pdb->p_line_data->self_addr),
                                    sizeof(icf_transport_address_st));
                    }
                    else
                    {
                        ret_val = ICF_FAILURE;
                    }
                }
                else
                {
                    icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                                    sizeof(icf_transport_address_st));
                }
                if (ICF_FAILURE != ret_val)
                {
			
                if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                               self_addr.addr.addr_type)
                {
                    icf_port_strcat(addr_val.str,self_addr.addr.addr.domain.str);
                }
                else/*Assumption that it will be IPV4*/
                {
                    if(ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                                          &(self_addr),self_ip))
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else
                    {
                        icf_port_strcat(addr_val.str,self_ip);
                    }
                }
                    icf_port_strcat(addr_val.str, (icf_uint8_t *)">");
            }

	    }
        /* end of code change for CSR-1-4816176/SPR 16075 - not tested */
        else if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_SIPS_URI)
        {
            icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sips:");
            icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
            icf_port_strcat( addr_val.str, (icf_uint8_t *)">");
        }
        else
        {
            icf_port_strcpy( addr_val.str, 
                p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                p_preferred_identity->addr_val.str );
        }

        /* Klocwork warning removal.*/
        if (ICF_NULL != p_overlap_trans_info)
        { 
        if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                p_ssa_pdb, 
                (icf_uint8_t*)"P-Preferred-Identity",
                addr_val.str,
                p_overlap_trans_info->pSipMsg ))
        {
                ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header (P-Preferred-Identity)"));
                sdf_ivk_uaClearTransaction(
                                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                                p_overlap_trans_info,
                                "PUBLISH",
                                Sdf_en_uacTransaction);

                /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
                /*Klocwork warning removal*/
                ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                   p_overlap_trans_info)
                return ICF_FAILURE;
        }
        }
        else
        {
            /*Klocwork warning removal*/
            ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                               p_overlap_trans_info)
            return ICF_FAILURE;
        }  
    }

    /* Insert Header/Tag/Body if any given by the application */

    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count)
    {
        if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list),
            ICF_TRUE, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
    }
    
    
    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list.count)
    {
        if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list),
            ICF_TRUE, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
        
    }
    
    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.count)
    {
        if (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
                    p_ssa_pdb,&(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list) , 
                    ICF_TRUE, &(p_overlap_trans_info->slMsgBodyList)))
        {
            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "PUBLISH",
                    Sdf_en_uacTransaction);

            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                        p_ssa_ctxt->p_call_obj));*/

            ret_val = ICF_FAILURE;
        }

        /*Message body header changes Start*/
	else if (ICF_FAILURE == icf_ssa_SetAllMsgBody(\
                    Sdf_co_null, p_overlap_trans_info,\
                    (icf_int8_t *)p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                    body_list.content_type.str,&sdf_error))
        {

            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "PUBLISH",
                    Sdf_en_uacTransaction);

            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                        p_ssa_ctxt->p_call_obj));*/

            ret_val = ICF_FAILURE;
        }
        /*Message body header changes Ends*/
    }
    
    if (ICF_SUCCESS == ret_val)
    {

     #ifdef ICF_LOAD_STAT
         /* Code added for updating the publish requests sent */
         p_ssa_pdb->p_glb_pdb->load_data.otg_publish_attempts++;
     #endif
    /*Set EXPLICIT CONNECT in case of TCP/TLS and INVALID as mode will be decided
     *from NAPTR response later*/
    if ((ICF_TRANSPORT_TYPE_INVALID == p_ssa_pdb->p_ssa_ctxt->transport) ||
        (ICF_NULL != (ICF_SSA_TCP_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask)) ||
        (ICF_NULL != (ICF_SSA_TLS_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask)))
    {
        ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                ICF_SSA_EXPLICIT_CONNECT_REQ);
    }

        p_ssa_pdb->p_ssa_ctxt->p_overlap_transaction = p_overlap_trans_info;

        if ( ICF_FAILURE == icf_ssa_send_to_peer(
            p_ssa_pdb,
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            p_overlap_trans_info->pSipMsg,
            &options,
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == sdf_ivk_uaEndTransaction(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            Sdf_co_null,
            "PUBLISH",
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "PUBLISH",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
    }

    }
   /*Klocwork warning removal*/
   ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_overlap_trans_info)

    return ret_val;
} /* icf_ssa_send_publish_req */

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_send_options_req
 *
 * DESCRIPTION:     This function constructs and sends OPTIONS req on network.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_options_req(
        INOUT   icf_ssa_pdb_st   *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    SipOptions                  options;
    Sdf_st_error                sdf_error;
    Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;


    Sdf_ty_s8bit                proto[ICF_MAX_SIZE_INT_USAGE_STR];

    icf_ssa_ctxt_st          *p_ssa_ctx = p_ssa_pdb->p_ssa_ctxt;
    icf_sic_ctx_st           *p_sic_ctx = p_ssa_ctx->p_sic_ctxt;
    icf_config_data_st       *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    icf_uint8_t              self_ip[16];
    /*icf_transport_address_st self_addr = {{0,{{0,"\0"}}},0};*/
    icf_transport_address_st self_addr;
    self_addr.addr.addr_type = 0;
    self_addr.port_num = 0;


#ifdef ICF_IPSEC_ENABLED
    icf_uint8_t              *p_value = ICF_NULL;
#endif
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

#ifdef ICF_TRACE_ENABLE
         if ( ICF_NULL != p_ssa_ctx->p_call_ctxt) 
         {
                 p_ssa_pdb->dialog_status=1;   /* in dialog */
                 icf_port_strcpy(p_ssa_pdb->remote_addr.addr_val.str,
                       p_sic_ctx->dest_addr.addr_val.str);
                 ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_OTG_OPTIONS);
          }
       else
         {
                 p_ssa_pdb->dialog_status=0;   /* out of dialog */
                 icf_port_strcpy(p_ssa_pdb->remote_addr.addr_val.str,
                           p_sic_ctx->dest_addr.addr_val.str);
                 ICF_SSA_APP_TRACE(p_ssa_pdb, ICF_TRACE_OTG_OPTIONS);
          }
#endif


    options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;
    /* CSR 1-5856190: SPR 18425: If call thru proxy then use proxy mode
 	 * else use self mode*/
    if (ICF_NULL != (ICF_CFG_CC_CALL_THRU_SIP_PROXY &
         p_ssa_pdb->p_glb_cfg_data->default_settings))
     { 
         /*Fetch transport_mode for OPTIONS request*/
         if(ICF_FAILURE == icf_ssa_check_for_trans_param(p_ssa_pdb,
             p_ssa_pdb->p_line_data->transport_mode,ICF_NULL,ICF_TRUE))
         {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSettingTransport&Revert Modes"));
            return ICF_FAILURE;
         }
     } /* p_line_data->line_data_receive... */
    else
     {
         /*Fetch transport_mode for OPTIONS  request*/
         if(ICF_FAILURE == icf_ssa_check_for_trans_param(p_ssa_pdb,
             p_ssa_pdb->p_glb_cfg_data->self_mode,ICF_NULL,ICF_FALSE))
         {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInSettingTransport&Revert Modes"));
            return ICF_FAILURE;
         }
     }
    /* CSR 1-5856190 SPR 18425: Check the transport mode stored in
	 * the ssa context to derive the proto
	 */
    if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_ssa_ctxt->transport) ||
                (ICF_TRANSPORT_MODE_BOTH == 
                 p_ssa_pdb->p_ssa_ctxt->transport))
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
        }
        else if(ICF_TRANSPORT_TYPE_TLS == 
                p_ssa_pdb->p_ssa_ctxt->transport)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
        }
        /*  If Transport mode is UDP then copy the udp in proto */
        else if (ICF_TRANSPORT_TYPE_UDP == 
                p_ssa_pdb->p_ssa_ctxt->transport)
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");

        }
        /*  If transport mode is INVALID then Application wants 
            to do the naptr query for getting the mode 
            So make the proto empty*/
        else
        {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"");
        }
    
    /*IF transport is not INVALID, then addr_type should be SIPS in case
     *of TLS transport and SIP in case of non-TLS transport, ignore this check
     *when transport is INVALID*/
    if ((ICF_TRANSPORT_TYPE_INVALID != p_ssa_ctx->transport) && 
        (((ICF_ADDRESS_PLAN_SIPS_URI == p_sic_ctx->dest_addr.addr_type) &&
                (ICF_TRANSPORT_TYPE_TLS != p_ssa_ctx->transport)) || 
            ((ICF_ADDRESS_PLAN_SIP_URI == p_sic_ctx->dest_addr.addr_type) &&
             (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctx->transport))))
    {
        ret_val = ICF_FAILURE;
        return ret_val;
    }

    /*IMP: 
     * Updation needed in update_call_obj for ICF_SSA_USER_ADDR_FRM_SIC*/
    if (ICF_FAILURE == 
                icf_ssa_update_callobj_for_profile(p_ssa_pdb))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            
        ret_val = ICF_FAILURE;
    }
    else if(ICF_FALSE == p_glb_cfg_data->precondition_required)
    {    
        /*precondition: remove the "precondition" from supported
          hdr list when QOS is OFF systemwide */
        if((Sdf_co_null != p_ssa_pdb->p_ssa_ctxt->p_call_obj) &&
           (Sdf_co_null != p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData))
         {   
             ret_val = icf_ssa_modify_callobj_profile_for_precondition(
                        p_ssa_pdb,
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                        &sdf_error);
         }   
    }    
    /* IMP: 
     * Updation needed in set_to_in_reg_call_obj for 
     * ICF_SSA_USER_ADDR_FRM_SIC*/
    /* To header will be set */
    if ((ICF_SUCCESS == ret_val) &&
            (ICF_FAILURE == icf_ssa_set_to_in_sic_callobj(p_ssa_pdb,
                    (icf_uint8_t *)proto)))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
#if 0
    /*Request URI to be set as destination address*/
    else if (Sdf_co_fail == 
                sdf_ivk_uaMakeAddrSpecFromConstituents(
                    &pAddrSpec, (Sdf_ty_s8bit*)server_addr, 
                    (Sdf_ty_s32bit)server_port,
                    pScheme, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }

    else if (Sdf_co_fail == sdf_ivk_uaChangeRequestURI(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                pAddrSpec, &sdf_error))
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        ret_val = ICF_FAILURE;
    }
#endif
    
    /********************ICF 8.0***********************/
    /*Fill Route Header from Service Route if stored for user-id while 
      registering*/
    if (ICF_FAILURE != ret_val)
    {
        /* Fill Route Header from Service Route if stored for user-id while 
           registering*/
        if(ICF_FAILURE == 
                icf_ssa_set_RouteHeaderListToInitData(p_ssa_pdb,
                    p_sic_ctx->p_user_address,
                    p_sic_ctx->line_id,p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
    }
    if (ICF_FAILURE == ret_val)
    {
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        ret_val = ICF_FAILURE;
    }
    else if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                &p_overlap_trans_info,
                "OPTIONS",
                &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
        ret_val = ICF_FAILURE;
    }
        else if (ICF_NULL == p_overlap_trans_info)
        {
            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == 
                sdf_ivk_uaSetTransportSchemeInTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction, 
                p_overlap_trans_info,
                    proto, &sdf_error))
    {
        /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "OPTIONS",
                Sdf_en_uacTransaction);

        ret_val = ICF_FAILURE;
    }
        else if (Sdf_co_fail == sdf_ivk_uaMakeTransaction(
                    (Sdf_ty_s8bit *)"OPTIONS", 
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    &sdf_error))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/

            sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "OPTIONS",
                    Sdf_en_uacTransaction);
              
            ret_val = ICF_FAILURE;
        }
      /* To add the P-Access-Network Info header to the SipMsg */
       else if ( ICF_FAILURE == 
                icf_ssa_form_and_insert_access_nw_info_hdr(
                p_ssa_pdb, p_overlap_trans_info->pSipMsg))
       {
           ret_val = ICF_FAILURE;
       }
      /* To add security association headers*/
       else if(ICF_FAILURE == icf_ssa_form_and_insert_security_agreement_hdrs(
                                 p_ssa_pdb,(icf_uint8_t *)"OPTIONS",
                                 p_overlap_trans_info->pSipMsg))
       {
           sdf_ivk_uaClearTransaction(
                    p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info,
                    "OPTIONS",
                    Sdf_en_uacTransaction);

           ret_val = ICF_FAILURE;
       }
/*    sip_freeSipAddrSpec(pAddrSpec);*/
/* KSLOCWORKS */
        else
        {
        if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity)
        {
            icf_string_st                 addr_val = {0, "0"};
#ifdef ICF_IPSEC_ENABLED
            /* check if SA exists */
            if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
            {
                /* get the corresponding REG context and populate the SSA ctxt and 
                 * SSA pdb with SA ctxt and REGM ctxt structure pointers 
                 */
                ret_val = icf_ssa_set_sa_ctxt_for_otg_req(p_ssa_pdb,
                        p_ssa_pdb->p_glb_pdb->p_call_ctx->p_preferred_identity);

            }
#endif
            if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_SIP_URI)
            {
                icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sip:");
                icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
                icf_port_strcat( addr_val.str, (icf_uint8_t *)">");
            }
            else if( 
                    p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_TEL_URI)
            {
                icf_port_strcpy( addr_val.str, (icf_uint8_t *)"tel:");
                icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
            }
            else if(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->
                    addr_type == ICF_ADDRESS_PLAN_E164)
            {
                icf_port_strcpy(addr_val.str,(icf_uint8_t *)"<sip:");

                icf_port_strcat(addr_val.str,
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );

                icf_port_strcat(addr_val.str,(icf_uint8_t *)"@");

                /* now appending the self IP/domain */
                /*If per line self transport then copy address from line_data*/
                if(ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
                {
                    if(ICF_NULL != p_ssa_pdb->p_line_data)
                    {
                        icf_port_memcpy(&self_addr,
                                    &(p_ssa_pdb->p_line_data->self_addr),
                                    sizeof(icf_transport_address_st));
                    }
                    else
                    {
                        ret_val = ICF_FAILURE;
                    }
                }
                else
                {
                    icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                                    sizeof(icf_transport_address_st));
                }
                if(ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                               self_addr.addr.addr_type)
                {
                    icf_port_strcat(addr_val.str,self_addr.addr.addr.domain.str);
                }
                else/*Assumption that it will be IPV4*/
                {
                    if(ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                                          &(self_addr),self_ip))
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else
                    {
                        icf_port_strcat(addr_val.str,self_ip);
                    }
                }
                icf_port_strcat(addr_val.str, (icf_uint8_t *)">");
            }
            else if( p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->p_preferred_identity->addr_type
                    == ICF_ADDRESS_PLAN_SIPS_URI)
            {
                icf_port_strcpy( addr_val.str, (icf_uint8_t *)"<sips:");
                icf_port_strcat( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
                icf_port_strcat( addr_val.str, (icf_uint8_t *)">");
            }
            else
            {
                icf_port_strcpy( addr_val.str, 
                        p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        p_preferred_identity->addr_val.str );
            }

    /* Klocwork warning removal.*/ 
    if (ICF_NULL != p_overlap_trans_info)
    {      
    if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
        p_ssa_pdb, 
        (icf_uint8_t*)"P-Preferred-Identity",
                        addr_val.str,
        p_overlap_trans_info->pSipMsg))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to insert unknown header (P-Preferred-Identity)"));
        sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "OPTIONS",
                Sdf_en_uacTransaction);

        /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
        
        return ICF_FAILURE;
    }
    }
    else
    {
        return ICF_FAILURE;
    }  
    }
    /* Insert Header/Tag/Body if any given by the application */

    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count)
    {
        if (ICF_NULL == p_overlap_trans_info)
        {
           return ICF_FAILURE;
        }    	
        if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list),
            ICF_TRUE, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
    }
    
    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list.count)
    {
        if (ICF_NULL == p_overlap_trans_info)
        {
           return ICF_FAILURE;
        }    	
        if (ICF_FAILURE == icf_ssa_insert_tag_list_in_sip_msg(
            p_ssa_pdb, &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->tag_list),
            ICF_TRUE, p_overlap_trans_info->pSipMsg))
        {
            ret_val = ICF_FAILURE;
        }
    }
#ifdef ICF_IPSEC_ENABLED
        /* if SA exists, send the Securiy-Verify Header in the outgoing MESSAGE */
        if ((ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled) &&
                /* if SA exits */
                (ICF_NULL != p_ssa_pdb->p_sa_context))
        {
            /* insert security-verify header in the otg OPTIONS */
            if (ICF_FAILURE == icf_ssa_get_sec_verify_string (p_ssa_pdb,&p_value,
                        p_ssa_pdb->p_sa_context))
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_FAILURE ==     
                    icf_ssa_insert_unknown_hdr_in_sip_msg (
                        p_ssa_pdb,
                        (icf_uint8_t*)"Security-Verify",
                        p_value, 
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg))
            {
                ICF_PRINT(("\nFailed to insert unknown header \
                            (Security-Verify)"));
                ret_val = ICF_FAILURE;
            }
            if (ICF_NULL != p_value)
            {
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_value,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
            }
            if (ICF_SUCCESS == ret_val )
            {
                ICF_PRINT(("\nSecurity Verify Header inserted to \
                            outgoing MESSAGE "));
            }
        }
#endif
    
    if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list.count)
    {
        if (ICF_FAILURE == icf_ssa_insert_body_list_in_sdf_list(
            p_ssa_pdb,&(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->body_list) , 
            ICF_TRUE, &(p_overlap_trans_info->slMsgBodyList)))
        {
                sdf_ivk_uaClearTransaction(\
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                        p_overlap_trans_info,\
                        "OPTIONS",\
                        Sdf_en_uacTransaction);

                /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                            p_ssa_ctxt->p_call_obj));*/
                return ICF_FAILURE;

        }
            /*Message body header changes Start*/
            else if ( ICF_FAILURE == \
                    icf_ssa_SetAllMsgBody(\
                        Sdf_co_null,p_overlap_trans_info,\
                        (icf_int8_t *)p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
                        body_list.content_type.str,\
                        &sdf_error))
            {
                sdf_ivk_uaClearTransaction(\
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,\
                        p_overlap_trans_info,\
                        "OPTIONS",\
                Sdf_en_uacTransaction);

                /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->\
                            p_ssa_ctxt->p_call_obj));*/
        
                return ICF_FAILURE;
            }
            /*Message body header changes End*/
    }
        if (ICF_SUCCESS == ret_val)
    {
#ifdef ICF_LOAD_STAT
        p_ssa_pdb->p_glb_pdb->load_data.otg_options_attempts++;
#endif

    /*Set EXPLICIT CONNECT in case of TCP/TLS and INVALID as mode will be decided
     *from NAPTR response later*/
            if ((ICF_TRANSPORT_TYPE_INVALID == p_ssa_pdb->p_ssa_ctxt->transport) ||
                (ICF_NULL != (ICF_SSA_TCP_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask)) ||
                (ICF_NULL != (ICF_SSA_TLS_TRANSPORT & p_ssa_pdb->p_ssa_ctxt->bitmask)))
            {
                ICF_SSA_SET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask,
                        ICF_SSA_EXPLICIT_CONNECT_REQ);
            }
        p_ssa_pdb->p_ssa_ctxt->p_overlap_transaction = p_overlap_trans_info;

        if ( ICF_FAILURE == icf_ssa_send_to_peer(
            p_ssa_pdb,
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            p_overlap_trans_info->pSipMsg,
            &options,
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "OPTIONS",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
        else if ( Sdf_co_fail == sdf_ivk_uaEndTransaction(
            p_ssa_pdb->p_ssa_ctxt->p_call_obj,
            Sdf_co_null,
            "OPTIONS",
            &sdf_error))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction(
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info,
                "OPTIONS",
                Sdf_en_uacTransaction);
            /*sdf_ivk_uaFreeCallObject(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj));*/
            ret_val = ICF_FAILURE;
        }
    }
        }
    /*Klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_overlap_trans_info)

        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;

} /* icf_ssa_send_options_req */

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_msg_body_frm_sip_message
 * DESCRIPTION:     This function gets the first unknnown message body
 * from the SIP message structure and sets it in the message body list struct
 ******************************************************************************/
icf_return_t    icf_ssa_get_msg_body_frm_sip_message(
        INOUT  icf_ssa_pdb_st         *p_ssa_pdb,
        INOUT    SipMessage             *p_sip_msg,
        /*INOUT    Sdf_st_callObject      *p_call_object,*/
        INOUT       en_SipMessageType dReqRespType,
        OUT   icf_msg_body_list_st   *p_body_list
        )
{
    icf_return_t      ret_val = ICF_SUCCESS, dummy_ret_val = ICF_SUCCESS;
    icf_msg_body_st   *p_msg_body = ICF_NULL;
    icf_uint8_t       *p_media_type = ICF_NULL;
    Sdf_ty_s8bit      *p_buffer = Sdf_co_null;
    Sdf_ty_u32bit     bufLength = 0;
    Sdf_ty_u32bit     dCount = 0;
    Sdf_st_error      sdf_error;
    SipError          sip_error;
    SipHeader         content_type_hdr;
    SipMsgBody        *p_sip_msg_body = Sdf_co_null;
    en_SipMsgBodyType body_type;
    icf_uint8_t    body_count = 0;
    icf_uint8_t    *p_ContentTypeVal = ICF_NULL;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    p_body_list->count = 0;
    p_body_list->body = ICF_NULL;
    if (SipFail == sip_getMsgBodyCount(p_sip_msg, &dCount, &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailed to get MsgBodyCount from SipMessage"));
        ret_val = ICF_FAILURE;
    }
    else if ( ICF_NULL < dCount)
    {
        /* Get the top level content-type header from SIP message
     */
        if (SipFail == sip_getHeader(p_sip_msg, SipHdrTypeContentType,
                    &content_type_hdr, &sip_error))
        {
            /* SPR 19010: setting the failure bitmask*/
            ICF_SSA_SET_COMMON_BITMASK(
                p_ssa_pdb->p_ssa_ctxt->failure_bitmask, 
                ICF_SSA_FAILURE_RESP_CODE_400)

            ICF_PRINT(((icf_uint8_t *)"\nFailed to get Content-Type Header"));
            ret_val = ICF_FAILURE;
            return ret_val;
        }
        else if(ICF_FAILURE == icf_ssa_get_content_type_frm_msg(\
                /*p_call_object*/dReqRespType,p_ssa_pdb,&content_type_hdr,\
                &p_ContentTypeVal))
        {
            /* SPR 19010 : setting the failure bitmask*/
            ICF_SSA_SET_COMMON_BITMASK(
                p_ssa_pdb->p_ssa_ctxt->failure_bitmask, 
                ICF_SSA_FAILURE_RESP_CODE_400)

            ICF_PRINT(((icf_uint8_t *)"Failed to get Content-Type Header from SIP"\
                   " message\n"));
            /* Free the local reference */
            sip_freeSipHeader(&content_type_hdr);
            ret_val = ICF_FAILURE;
        return ret_val;
        }
        else if(ICF_NULL == p_ContentTypeVal)
        {
            /* SPR 19010 : setting the failure bitmask*/
            ICF_SSA_SET_COMMON_BITMASK(
                p_ssa_pdb->p_ssa_ctxt->failure_bitmask, 
                ICF_SSA_FAILURE_RESP_CODE_400)

            ICF_PRINT(((icf_uint8_t *)"Failed to get Content-Type Header Value from SIP"\
                   " message\n"));

            sip_freeSipHeader(&content_type_hdr);
            return ICF_FAILURE;
        }    

        for(body_count=0; body_count < dCount; body_count++)
        {
            
            /* Get the message body type in the SIP message.
            */
            if(SipFail == sip_getMsgBodyTypeAtIndex(p_sip_msg,\
                &body_type,body_count,\
                (SipError *)&sip_error))
            {
                ICF_PRINT(((icf_uint8_t *)"Failed to get the message body "
                    "type\n"));
                ret_val = ICF_FAILURE;
                break;
            }

            if(SipSdpBody == body_type)
            {
                /* Ignore the SDP body. SDP has already extracted from the message.*/
                continue;
            }
            
            /* Extract the message body from SIP message.
            */
            if(Sdf_co_success == sdf_ivk_uaGetUnknownBodyFromSipMessage(\
                p_sip_msg,body_count,&p_buffer,\
                &bufLength,&sdf_error))
            {
            /* allocate memory for a msg body list node and 
            * add to List
                */
                
                if(0 == p_body_list->count)
                {
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,\
                        ICF_PORT_SIZEOF(icf_msg_body_st),\
                        ICF_MEM_COMMON,p_msg_body,\
                        ICF_DONOT_RET_ON_FAILURE,p_ssa_pdb->p_ecode,\
                        ret_val)
                        
                }
                else if(ICF_NULL != p_msg_body)
                {
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,\
                        ICF_PORT_SIZEOF(icf_msg_body_st),\
                        ICF_MEM_COMMON,p_msg_body->next,\
                        ICF_DONOT_RET_ON_FAILURE,p_ssa_pdb->p_ecode,\
                        ret_val)
                }

                if ( ICF_FAILURE == ret_val)
                {
                    /* Free the local reference */
                    sip_freeSipHeader(&content_type_hdr);
                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,\
                        p_media_type,\
                        ICF_MEM_COMMON,\
                        p_ssa_pdb->p_ecode,\
                        dummy_ret_val)
                }
                else if(ICF_NULL != p_msg_body)
                    
                {
                    if(p_body_list->count)
                    {
                        p_msg_body=p_msg_body->next;
                    }
                    else
                        p_body_list->body = p_msg_body;

                    if (ICF_NULL != p_msg_body)
                    {
                        p_msg_body->next = ICF_NULL; 
                    }
                    p_body_list->count++;
                    
                    sip_listGetAt(&(p_sip_msg->slMessageBody),\
                        body_count,(SIP_Pvoid *)&p_sip_msg_body,\
                        &sip_error);
                }
            }
            /* Fill the mime headers for each body as per the 
            * message body type
            */
            switch(body_type)
            {
            case SipSdpBody :
            /* Application SDP has already extracted from SIP message
            * Thus ignore the message body.
                */
                break;
                
            case SipIsupBody :
            case SipAppSipBody :
            /* At present ICF does not support body
            *  headers extraction mechanism except
            *  MIME headers
                */
                ICF_ASSERT(p_ssa_pdb->p_glb_pdb,\
                    p_ssa_pdb->p_line_data)
                    
                    break;
            case SipUnknownBody :
            case SipMultipartMimeBody :
                if((p_sip_msg_body && \
                    (icf_port_strcmp(\
                    (icf_uint8_t*)(((SipContentTypeHeader *) (content_type_hdr.pHeader))->pStr1),\
                    (icf_uint8_t *)"multipart/mixed") == 0)) || (p_sip_msg_body && \
                    (icf_port_strcmp(\
                    (icf_uint8_t*)(((SipContentTypeHeader *) (content_type_hdr.pHeader))->pStr1),\
                    (icf_uint8_t *)"multipart/related")==0)))
                {
                    ret_val = icf_ssa_get_mime_hdrs_from_sip_msg(\
                                /*p_call_object*/dReqRespType,p_ssa_pdb,p_sip_msg_body,\
                                p_msg_body);
                }
                break;
                         case SipBodyAny :
                               /* Just to remove warnings */
                                break;
            }
            
            if ((ICF_SUCCESS == ret_val) && (ICF_NULL != p_msg_body))
            {
                p_msg_body->length= bufLength;

                                if (ICF_NULL == p_ContentTypeVal)
                                {
				    /* Free the local reference */
				    sip_freeSipHeader(&content_type_hdr);
					
				    ICF_MEMFREE(
						p_ssa_pdb->p_glb_pdb,
						p_msg_body,
						ICF_MEM_COMMON,
						p_ssa_pdb->p_ecode,
						dummy_ret_val)
							
				    ICF_MEMFREE(
						p_ssa_pdb->p_glb_pdb,
						p_media_type,
						ICF_MEM_COMMON,
						p_ssa_pdb->p_ecode,
						dummy_ret_val)

                                    return ICF_FAILURE;                               
                                }
                                                
                /* Set the top level content-type*/
                icf_port_strcpy(p_body_list->\
                    content_type.str,p_ContentTypeVal);
                
                p_body_list->content_type.str_len = \
                    (icf_int16_t )icf_port_strlen(p_body_list->\
                    content_type.str);
                
                    /* Allocate memory for message body value and copy the recvd
                    * msg body
                */
                if (ICF_NULL != p_msg_body->length)
                {
                    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        bufLength,
                        ICF_MEM_COMMON,
                        p_msg_body->value,
                        ICF_DONOT_RET_ON_FAILURE,
                        p_ssa_pdb->p_ecode, ret_val)

                    if ( ICF_FAILURE == ret_val)
                    {
                        /* Free the local reference */
                        sip_freeSipHeader(&content_type_hdr);
                        
                        ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_msg_body,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            dummy_ret_val)
                            
                        ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_media_type,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            dummy_ret_val)
                            
                        ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_ContentTypeVal,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            dummy_ret_val)
                        break;                            
                    }
                    else
                    {   
                        if (p_buffer) icf_port_memcpy(p_msg_body->value,(icf_int8_t*)p_buffer,\
                                bufLength);
                        /*Klocwork Warning Removal*/
                        ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                             p_msg_body->value)
                    }
                }
                
            }
            else
            {
                ret_val = icf_cmn_free_msg_body_list(p_ssa_pdb->p_glb_pdb,
                    p_body_list,
                    p_ssa_pdb->p_ecode);
                break;
            }
            
         }/*End of For Loop for Message Bodies*/

         /* Free the local reference */
        sip_freeSipHeader(&content_type_hdr);

    }

    if(ICF_NULL != p_ContentTypeVal)
    {
        ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_ContentTypeVal,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
    }


    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
ICF_SIC_END

/*******************************************************************************
 * FUNCTION:        icf_print_pdu
 * DESCRIPTION:     This function is create an external message to send network 
 *                  PDUs to application with API-ICF_TRACE_NW_BUFF_IND
 ******************************************************************************/
icf_return_t icf_print_pdu(icf_glb_pdb_st *p_glb_pdb,
                               icf_uint8_t* p_buf, 
                               icf_uint8_t* p_host, 
                               icf_uint32_t port, 
                               icf_uint32_t len)
{
/*ZyXEL Porting*/
#ifndef ICF_TRACE_ENABLE	
	/*Because a lot of debug messages printed on the screen is not we like(extra loading). 
	mark here to disable SIP packet trace messages don't printf on the screen.
	*/
	return ICF_SUCCESS;
#else
    icf_internal_msg_st              internal_msg;
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_return_t                     dummy_ret_val = ICF_SUCCESS;
    icf_msg_st                       *p_pa_msg = ICF_NULL;
    icf_uint32_t                      msg_len = 0;    
    icf_trace_nw_buff_ind_st         *p_nw_buff_ind = ICF_NULL;
    icf_error_t                      ecode;
    icf_config_data_st               *p_cfg_data = ICF_NULL;
    icf_uint32_t                     i;

    ICF_PRINT(((icf_uint8_t *)"\n-----------------------------------------------------\n"));
    ICF_PRINT(((icf_uint8_t *)"PRINTING SIP PDU OF LENGTH: %d----\n",len ));
    ICF_PRINT(((icf_uint8_t *)"-----------------------------------------------------\n"));
    for(i = 0; i < len; i++)
    {
        if ((p_buf[i] > ICF_MAX_NON_PRINTABLE_CHARACTER)
                ||( p_buf[i] == ICF_NEXT_LINE_CHARACTER))
            ICF_PRINT(((icf_uint8_t *)"%c", p_buf[i]));
    }
    ICF_PRINT(((icf_uint8_t *)"\n----------------------------------------------------\n"));

    /*Create an external message and send message to ADM*/ 
    /* get cfg data for getting the max number of applications*/
    if(ICF_FAILURE == icf_dbm_get_module_glb_data(     
        p_glb_pdb ,
        (icf_int_module_id_t const) ICF_INT_MODULE_CFG,
        (icf_void_t *)&p_cfg_data,
        &ecode))
    {
        return ICF_FAILURE;
    }
    
    if (ICF_TRUE == p_cfg_data->nw_trace_enabled)
    {
        /*Calculate the message length*/
        msg_len = sizeof(icf_api_header_st) + sizeof(icf_trace_nw_buff_ind_st) + len;
        
        /*Allocate memory for API header strucure */
        ICF_MEMGET(p_glb_pdb, msg_len - len, ICF_MEM_COMMON, p_pa_msg,
            ICF_RET_ON_FAILURE, &ecode, ret_val)
            
        /* Fill the message header for ICF_TRACE_NW_BUFF_IND */        
        p_pa_msg->hdr.api_id = ICF_TRACE_NW_BUFF_IND;
        p_pa_msg->hdr.api_length = (icf_uint16_t)msg_len;
        p_pa_msg->hdr.call_id = ICF_INVALID_CALL_ID;
        p_pa_msg->hdr.app_id = ICF_GENERIC_APP_ID;
            
        /*Fill message payload*/
        p_nw_buff_ind = (icf_trace_nw_buff_ind_st*)&(p_pa_msg->payload[0]);
        
        p_nw_buff_ind->nw_address.addr.addr_type = ICF_TRANSPORT_ADDRESS_IPV4_ADDR;
        
#if 0
        /* sscanf is crashing on device */
        icf_port_sscanf(p_host, "%d.%d.%d.%d", 
            &p_nw_buff_ind->nw_address.addr.addr.ipv4_addr.octet_1,
            &p_nw_buff_ind->nw_address.addr.addr.ipv4_addr.octet_2,
            &p_nw_buff_ind->nw_address.addr.addr.ipv4_addr.octet_3,
            &p_nw_buff_ind->nw_address.addr.addr.ipv4_addr.octet_4);
#else
        dummy_ret_val = icf_port_str_to_trans_addr(p_host, &(p_nw_buff_ind->nw_address.addr));
#endif
        
        p_nw_buff_ind->nw_address.port_num = (icf_uint16_t)port;    

        ICF_MEMGET(p_glb_pdb, len+2, ICF_MEM_COMMON, 
            p_nw_buff_ind->nw_buffer.p_buff,
            ICF_DONOT_RET_ON_FAILURE, &ecode, ret_val)
        if (ICF_FAILURE == ret_val || ICF_NULL == p_nw_buff_ind->nw_buffer.p_buff)
        {
           ICF_MEMFREE(p_glb_pdb, 
                       p_pa_msg, 
                       ICF_MEM_COMMON,
                       &ecode, 
                       ret_val ) 
           return ICF_FAILURE;
        } 

        icf_port_memcpy(p_nw_buff_ind->nw_buffer.p_buff,p_buf,len);
        p_nw_buff_ind->nw_buffer.p_buff[len]='\0';
        
        p_nw_buff_ind->nw_buffer.len = len;
        
        /*Fill header in internal message structure*/
        internal_msg.msg_hdr.msg_id = ICF_TRACE_NW_BUFF_IND;
        
        internal_msg.msg_hdr.p_glb_pdb = p_glb_pdb;
        
        internal_msg.msg_hdr.payload_length = (icf_uint16_t)msg_len;
        
        /*Assign p_pa_msg to p_pa_msg_data of icf_internal_msg_st*/
        internal_msg.p_msg_data = (icf_uint8_t*)p_pa_msg;    
        
        /*Call icf_adm_process_mesg(p_internal_msg)*/
        ret_val = icf_adm_process_mesg(&internal_msg);
        
        /*If process msg return fail*/
        if(ICF_FAILURE == ret_val)
        {        
            
        }  /* if(ICF_FAILURE == ret_val) */
        
        /*Deallocate API header structure*/
        ICF_MEMFREE(p_glb_pdb, p_nw_buff_ind->nw_buffer.p_buff, ICF_MEM_COMMON,
            &ecode, dummy_ret_val )

        ICF_MEMFREE(p_glb_pdb, p_pa_msg, ICF_MEM_COMMON,
            &ecode, dummy_ret_val )
    }
 
     return ret_val;
#endif
/*ZyXEL Porting end*/
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_add_ContactHeaderToSipMsg
 * DESCRIPTION:     This function adds a List of contacts to the SIP message
 ******************************************************************************/

icf_return_t icf_ssa_add_ContactHeaderToSipMsg
    (Sdf_st_callObject *pObject,
     Sdf_ty_slist *pslContactList,
     Sdf_st_overlapTransInfo *pOverlapTransInfo,
     Sdf_st_error *pErr)
{
    Sdf_ty_slist                 contact_addr_list;
    icf_boolean_t            contact_list_valid = ICF_TRUE;
    icf_return_t             ret_val=ICF_SUCCESS;
    Sdf_st_transaction *pTransaction = Sdf_co_null;
    Sdf_ty_u32bit i = 0, dSize = 0;
    Sdf_st_listIterator dListIterator;
    SipMessage            *pSipMsg = Sdf_co_null;

    if(Sdf_co_null == pslContactList)
    {
        /* Get the Contact list from InitData */
        if (Sdf_co_fail == sdf_listInit(
            &contact_addr_list,
            __sdf_fn_uaFreeCompleteHeader,
            Sdf_co_false,
            pErr))
        {
            /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
            ret_val = ICF_FAILURE;
            contact_list_valid = ICF_FALSE;
        }
        else if (Sdf_co_fail == sdf_fn_uaCloneSipHeadersList(
            &contact_addr_list,
            &(pObject->pInitData->slContact),
            pErr))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            pslContactList = &contact_addr_list;
        }
    }
    else
    {
        contact_list_valid = ICF_FALSE;
    }

    if(ICF_SUCCESS == ret_val)
    {
        
        sdf_listSizeOf(pslContactList, &dSize, pErr);
        
        if (dSize > 0)
        {
            if( pOverlapTransInfo == Sdf_co_null )
            {
                if (sdf_ivk_uaGetTransactionFromCallObject(pObject, \
                    Sdf_en_uacTransaction, &pTransaction,pErr) == Sdf_co_fail)
                {
                    pErr->errCode=Sdf_en_callObjectAccessError;
                    return Sdf_co_fail;
                }
                pSipMsg = pTransaction->pSipMsg;
                
                sdf_ivk_uaFreeTransaction(pTransaction);
            }
            else
                pSipMsg = pOverlapTransInfo->pSipMsg;
            
            
            if(sip_deleteAllHeaderType(pSipMsg, SipHdrTypeContactAny, \
                (SipError *)&(pErr->stkErrCode)) == SipFail)
            {
                pErr->errCode=Sdf_en_headerManipulationError;
                ret_val = ICF_FAILURE;
            }
            else
            {
                sdf_listInitIterator(pslContactList, &dListIterator, pErr);
                
                while (dListIterator.pCurrentElement != Sdf_co_null)
                {
                    SipHeader *pContactHdr = Sdf_co_null;
                    
                    pContactHdr = (SipHeader*)\
                        (dListIterator.pCurrentElement->pData);
                    
                    if (pContactHdr == Sdf_co_null)
                    {
                        sdf_listNext(&dListIterator, pErr);
                        i++;
                        continue;
                    }
                    
                    if (SipFail == sip_insertHeaderAtIndex(pSipMsg, pContactHdr, \
                        (Sdf_ty_u32bit)i, (SipError *)&(pErr->stkErrCode)))
                    {
                        pErr->errCode=Sdf_en_headerManipulationError;
                        ret_val = ICF_FAILURE;
                        break;
                    }
                    sdf_listNext(&dListIterator, pErr);
                    i++;
                }
            }
        }
    }
    if(ICF_TRUE == contact_list_valid)
    {
        sdf_listDeleteAll(&contact_addr_list, pErr);
    }
    return ret_val;
}
/*******************************************************************************
 * FUNCTION:        icf_ssa_fetch_matching_overlap_txn
 *
 * DESCRIPTION:     This function fetches the matching overlap transaction
 *                  corresponding to the msg type and transaction state
 *                  state from the list of overlapped transactions in the
 *                  call object
 *
 ******************************************************************************/
icf_return_t icf_ssa_fetch_matching_overlap_txn(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT      Sdf_ty_messageType       msg_type,
        INOUT      Sdf_ty_state             trans_state,
        INOUT      Sdf_st_callObject        *p_call_obj,
        INOUT    Sdf_st_overlapTransInfo  **p_p_match_overlap_txn)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    Sdf_st_error                        sdf_error;
    icf_uint32_t                     list_size = 0, count = 0;

    Sdf_st_overlapTransInfo             *p_ovtxn = Sdf_co_null;

    
    if(ICF_NULL == p_ssa_pdb)
    {
        return ICF_FAILURE;
    }
    
    p_ssa_pdb=p_ssa_pdb; 
        
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /*
     * We iterate through the list of overlapped transactions and

     * fetch the overlap transaction with the requisite msg_type
     * and transaction state
     */

    if ( Sdf_co_fail ==
            sdf_listSizeOf(&(p_call_obj->slOverlapTransInfo),
                (Sdf_ty_u32bit*)(&list_size), &sdf_error))
    {
        /*Raise a Major error here - UATK_PROCESSING FAILURE*/
        ret_val = ICF_FAILURE;
    }
    else
    {
        for (count = 0; count < list_size; count++)
        {
            if( Sdf_co_fail == sdf_listGetAt(
                        &(p_call_obj->slOverlapTransInfo),
                        count,
                        (Sdf_ty_pvoid)&p_ovtxn,
                        &sdf_error))
            {
                /*Raise MajorError - UATK_PROCESSING FAILURE*/
                ret_val = ICF_FAILURE;
                break ;
            }
            else
            {
                /*
                * Check for the message type and the transaction state
                */
                if(msg_type == p_ovtxn->dMsgType)
                {
                    if((trans_state == p_ovtxn->dState) || 
                       (Sdf_en_transactionCancel == p_ovtxn->dState))
                    {
                        /*
                         * Found the matching transaction
                         */
                         *p_p_match_overlap_txn = p_ovtxn;
                         break;
                    }
                    /* SPR 19007: In case the requested transaction type was "Sent"
                     * but the message has not been sent and DNS query is ongoing 
                     * for the same then also return the matching overlap transaction.
                     */
                    else if((Sdf_en_transactionSent == trans_state) &&
                            (Sdf_en_dnsQuery == p_ovtxn->dTxnDnsState))
                    {
                        /*
                         * Found the matching transaction
                         */
                        *p_p_match_overlap_txn = p_ovtxn;
                        break;
                    }
                }
            }
        }
        if (count == list_size || ICF_FAILURE == ret_val)
        {
            /*Raise MajorError - NO TXN TO BE RESPONDED TO*/
            ret_val = ICF_FAILURE ;
        } /* if (count == list_size) */
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_set_RouteHeaderListToInitData
 *
 * DESCRIPTION:     This function makes the Route header from the
 *                  Service Route if presnent in the RGN block
 *                  Else set the default Outbound Proxt as
 *                  Preloaded Route,Currently It Does not handle
 *                  Record Route
 ******************************************************************************/
icf_return_t icf_ssa_set_RouteHeaderListToInitData(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT      icf_address_st        *p_local_address,
        INOUT      icf_line_id_t        line_id,
        INOUT    icf_error_t*         p_ecode)
{

    icf_rgm_context_st       *p_rgn_blk_addr = Sdf_co_null;
    SipHeader                *p_temp_hdr = Sdf_co_null;
    icf_boolean_t            is_serv_rte_present = ICF_FALSE;
    Sdf_ty_u32bit            size = 0, serv_rte_index = 0;
    SipHeader                *p_header = Sdf_co_null;
    SipAddrSpec              *pSrvRteAddrSpec = Sdf_co_null;
    SipError                 SipErr;

    icf_return_t             ret_val = ICF_SUCCESS;
    icf_transport_address_st *p_proxy_addr = ICF_NULL;
    icf_uint8_t              proxy_address[ICF_MAX_STR_LEN];    
    icf_boolean_t            port_matched = ICF_FALSE;
    Sdf_st_error             sdf_error;
    icf_boolean_t            is_proxy_cfg = ICF_FALSE, send_route = ICF_TRUE;
    icf_address_st           *p_rem_addr = ICF_NULL;

    icf_uint8_t              *p_temp = ICF_NULL;
    icf_return_t             user_dom_is_ip = ICF_SUCCESS;
    icf_int8_t               *p_rem_port = ICF_NULL;
    icf_uint8_t              *p_rem_ip = ICF_NULL;
    icf_return_t             temp_ret_val = ICF_TRUE;
    
#ifdef ICF_SIGCOMP_SUPPORT
    icf_transport_address_st  *p_sigcomp_proxy_addr = ICF_NULL;
    icf_boolean_t             is_to_add_sigcomp_param_in_route = ICF_FALSE;
    icf_void_t                *p_sigsa_ctxt = ICF_NULL;
#endif

#ifdef NON_IMS_CLIENT
/* To remove warning */
p_local_address=p_local_address;
p_ecode=p_ecode;
#endif
    /* To remove warning */
    line_id=line_id;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        
    /********************ICF 8.0********************/
    /*If it is a direct routed call , no need to fill the route header ,
      return sucess from here*/
    if (ICF_FALSE == ICF_IS_BIT_SET(p_ssa_pdb->p_glb_cfg_data->default_settings,
                            ICF_CFG_CC_CALL_THRU_SIP_PROXY))
    {
        return ICF_SUCCESS;
    }

    if (ICF_SSA_USER_ADDR_FRM_SIC & p_ssa_pdb->common_bitmask)
    {
        p_rem_addr = &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->dest_addr);
    }
    else
    {
        p_rem_addr = &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr);
    }

#ifdef ICF_SIGCOMP_SUPPORT
#ifdef ICF_IPSEC_ENABLED
    if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
    {
        icf_rgm_glb_data_st         *p_rgm_glb_data  = ICF_NULL;

        if (ICF_FAILURE == \
                icf_dbm_get_module_glb_data(
                        p_ssa_pdb->p_glb_pdb,\
                        ICF_INT_MODULE_REGM, 
                        (icf_void_t **)(&p_rgm_glb_data),
                        p_ssa_pdb->p_ecode))
        {
            /*ICF_SIGSA_TRACE(("\nFailure while getting RGM Global Data in SIGSA\n"));    */
            return ICF_FAILURE;
        }
        p_sigsa_ctxt = p_rgm_glb_data->p_sigsa_ctxt;
        }
        else
        {
            p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
        }
#else
    p_sigsa_ctxt = p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt;
#endif
#endif

    if (ICF_SUCCESS == ret_val)
    {
        if (!(ICF_SSA_SEC_SERVER_ADDRESS_IS_USED & p_ssa_pdb->p_ssa_ctxt->bitmask_1))
        {
             /* Set the Proxy address as stored in the line_data */
             p_proxy_addr = p_ssa_pdb->p_ssa_ctxt->p_rem_addr_active;
        }
        else
        {
             sdf_listDeleteAll(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData->slPreLoadedRoute),
                               &sdf_error);
             p_proxy_addr = p_ssa_pdb->p_ssa_ctxt->p_rem_addr_inactive;
        }

        if (ICF_NULL == p_proxy_addr)
        {
            return ICF_SUCCESS;
        }
        is_proxy_cfg = ICF_TRUE;
    }
    
#ifdef ICF_SIGCOMP_SUPPORT
    /* For SigComp query Sigsa whether Any updated sigcomp address is
     * present or not */
    /* Currently It is assumed that if sigcomp support is on then 
     * Peer supports Sigcomp and ICF does not send OPTION method to
     * P-CSCF : So below code commented */
    if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->sigcomp_required)
    {
        is_to_add_sigcomp_param_in_route = ICF_TRUE;
    }
    /*
    if((IPPSTK_NULL != p_ssa_pdb->p_ssa_ctxt) &&
       (IPPSTK_NULL != p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt) &&
       (IPPSTK_SUCCESS == ippstk_sigsa_get_sigcomp_proxy_addrs_from_ctxt
                        (p_ssa_pdb->p_ssa_ctxt->p_sigsa_ctxt,
                        &p_sigcomp_proxy_addr,
                        &is_to_add_sigcomp_param_in_route,p_ecode)))
    {
        if(IPPSTK_NULL != p_sigcomp_proxy_addr)
        {
            p_proxy_addr = p_sigcomp_proxy_addr;
        }
    }
    */    
#endif
    /***************************ICF 8.0********************************/
    /* If Service Route is present then check whether first Route header
     * stored in service route points to the proxy which is configured
     * in our databse, If yes then we will not add it to the Route header
     */
    
    if (ICF_NULL == p_local_address)
    {
         is_serv_rte_present = ICF_FALSE;
    }
    /* Get Registration Block as per the Local Address */
    else if(ICF_FAILURE == icf_rgm_fetch_ctxt_wrt_uri_wrt_line(
        p_ssa_pdb->p_glb_pdb,p_local_address,&p_rgn_blk_addr,line_id,p_ecode))
    {
        /*Do Nothing*/
    }
    else if(ICF_NULL != p_rgn_blk_addr && ICF_NULL == p_rgn_blk_addr->p_srv_rte)
    {
        ICF_PRINT(((icf_uint8_t*)"\n[SSA]:No header in Service route header list"));
    }
    else if( p_rgn_blk_addr && (Sdf_co_fail == sdf_listSizeOf(
                ((Sdf_ty_slist*)p_rgn_blk_addr->p_srv_rte),
                &size, &sdf_error)))
    {
        ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Failure in getting size of Service-Route\
                    header list from Registration Context"));
    }
    else if ( ICF_NULL == size)
    {
        ICF_PRINT(((icf_uint8_t*)"\n[SSA]:No header in Service route header list"));
    }
    else
    {
        /*   sdf_listDeleteAll(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData->slPreLoadedRoute),SdfError);*/
        is_serv_rte_present = ICF_TRUE;
    }

    if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
            p_proxy_addr->addr.addr_type)
    {
        icf_port_strcpy(proxy_address,p_proxy_addr->addr.addr.domain.str);
    }
    else
    {
        icf_ssa_convert_to_IP_addr(
           p_proxy_addr,proxy_address);

    }

    if(ICF_TRUE == is_serv_rte_present)
    {
        if(Sdf_co_fail == sdf_listGetAt(
                    (Sdf_ty_slist*)p_rgn_blk_addr->p_srv_rte, 
                    serv_rte_index,
                    (Sdf_ty_pvoid *)&p_header, &sdf_error))
        {
            ICF_PRINT(((icf_uint8_t*)"\n[SSA]:Failure in hdr retrieval,going for \
                        next"));
        }

        else if(Sdf_co_fail == sip_getAddrSpecFromFromHdr(p_header, &pSrvRteAddrSpec,
                    &SipErr))
        {
            ret_val = ICF_FAILURE;
        }
        else if ((SipAddrSipUri == pSrvRteAddrSpec->dType) || 
                 (SipAddrSipSUri == pSrvRteAddrSpec->dType))

        {
#ifdef ICF_IPSEC_ENABLED                       
             /* if IPsec is confgured and SA is established by now,
              * we will use the proxy protected server port for sending
              * this request */
            
            if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
            {
                /* if SA is established by now */
                if (ICF_NULL != p_ssa_pdb->p_sa_context)
                {
                    if(p_ssa_pdb->p_sa_context->
                           p_proxy_security_params->port_s ==
                              *(pSrvRteAddrSpec->u.pSipUrl->dPort))
                    {
                        ICF_PRINT(("\n[SSA]:\
                                   Proxy Address matched with Service-\
                                   Route's First entry"));
                        port_matched = ICF_TRUE;
                    }
                }
            }
#endif
        }
        
        if(pSrvRteAddrSpec != Sdf_co_null)
        {    
            sip_freeSipAddrSpec(pSrvRteAddrSpec);
        }
    }    

    /* Here we are assuming that if port match is true then the first
     * service should also contain comp=sigcomp param in the fisrt entry
     * if the outbound proxy supports sigcomp
     */
        
    if(ICF_FALSE == port_matched)
    { /*It shall be executed even IP is not matched*/
        if(ICF_TRUE == is_serv_rte_present) 
        {      
#ifdef ICF_SIGCOMP_SUPPORT
            if(ICF_TRUE == 
                    is_to_add_sigcomp_param_in_route)
            {
                if ( Sdf_co_fail == 
                        sdf_ivk_uaAddDefaultPreLoadedRoute(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                            Sdf_co_null,
                            proxy_address,
                            p_proxy_addr->port_num,
                            "lr;comp=sigcomp",/*pParam*/
                            ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->
                              transport)?"sips":"sip"),
                            &sdf_error))
                {
                    /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                    ret_val = ICF_FAILURE;
                }
            }
            else
            {
                if ( Sdf_co_fail == 
                        sdf_ivk_uaAddDefaultPreLoadedRoute(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                            Sdf_co_null,
                            proxy_address,
                            p_proxy_addr->port_num,
                            "lr",/*pParam*/
                            ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->
                              transport)?"sips":"sip"),
                            &sdf_error))
                {
                    /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                    ret_val = ICF_FAILURE;
                }

            }

#else
            if(ICF_FAILURE == ret_val)
            {
                /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
            }
#ifndef ICF_LOAD_STAT          
            else if ( Sdf_co_fail == 
                  sdf_ivk_uaAddDefaultPreLoadedRoute(
                      p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                      Sdf_co_null,
                      (Sdf_ty_s8bit *)proxy_address,
                      p_proxy_addr->port_num,
                      "lr",/*pParam*/
                      "sip",
                      &sdf_error))
            {
                /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                ret_val = ICF_FAILURE;
            }
#endif            
#endif /*SIGCOMP check*/
        
        }/*ICF_TRUE == is_serv_rte_present*/
        
        /*Service route header is not present ; add the proxy as the default 
          route*/
        else 
        {
            if(ICF_FAILURE == ret_val)
            {
                /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
            }
            else
            {
                /* Fix for SPR:19886 (Merged CSR-1-7334757)*/
                /* If the INVITE is being generated because of 302
                 * then do not validate the remote party with Proxy.If the
                 * route is added for any request initiated from SIC then
                 * populate the route address otherwise if the request in not
                 * initiated from SIC then check whether it is a redirected
                 * INVITE request or not. If redirected do not validate the
                 * remote party address with proxy and insert proxy as route
                 * address.*/
                if((ICF_SSA_USER_ADDR_FRM_SIC & p_ssa_pdb->common_bitmask) ||
                        ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt) &&
                         (ICF_NULL == p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->
                          p_diversion_header_list)))
                {                
                    if ((ICF_ADDRESS_PLAN_SIP_URI == p_rem_addr->addr_type ) ||
                            (ICF_ADDRESS_PLAN_SIPS_URI == p_rem_addr->addr_type))
                    {
                        p_temp = icf_port_strchr(p_rem_addr->addr_val.str,'@');
                        /* Duplicate the string following the @ sign */ 

                        if(ICF_NULL != p_temp)
                        {        
                            p_rem_ip = icf_port_strdup(p_temp + 1) ;
                        }
                        else
                        {
                            p_rem_ip = icf_port_strdup(p_rem_addr->addr_val.str);
                        }

                        if(ICF_NULL != p_rem_ip)
                        {    
                            icf_port_strtokr((icf_int8_t *)p_rem_ip,":",&p_rem_port);

                            user_dom_is_ip = icf_port_check_if_ip(p_rem_ip);

                            /* Compare the user's domain and proxy address in these
                               scenarios                            
                               1) If the user address is of type user@<IP> and 
                               proxy address is also an IP address 
                               2) If the user address is of type user@<domain> and
                               proxy address is also a domain name
                               If both happens to be same then compare the port
                               numbers if they are also same then dont send the 
                               route header  
                             */ 
                            if(((ICF_SUCCESS == user_dom_is_ip) && 
                                        (ICF_TRANSPORT_ADDRESS_IPV4_ADDR == 
                                         p_proxy_addr->addr.addr_type)) ||
                                    ((ICF_FAILURE == user_dom_is_ip) && 
                                     (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                                      p_proxy_addr->addr.addr_type)))
                            {
                                if(!(icf_port_strcmp(p_rem_ip,proxy_address)))
                                {
                                    /* If IP are same then compare ports
                                     * to be same . No port in address 
                                     * would mean default port 5060 */

                                    /* Fix for CSR 1-7680323: SPR 19955 */
					                /* Insert Route header if remote port is not specified
                                       and proxy port is 5060, or if both are 5060.
                  					   This is required when proxy address is configured as 
                 				 	   domain name so that SRV query is not made and directly
                                       A query is made since port is already known. Without
                                       this fix, we pass port number as 0 in SetTo() hence
                                       UATK attempts SRV first. So insert Route header in
                                       the message with port 5060.
				                	*/
                                    if((ICF_NULL == p_rem_port) && 
                                            (5060 == p_proxy_addr->port_num))
                                    {
                                        send_route = ICF_TRUE;
                                    } 
                                    else if((ICF_NULL != p_rem_port) && 
                                            (icf_port_atoi((const icf_int8_t *)p_rem_port) == 
                                            p_proxy_addr->port_num) &&
                						    (5060 == p_proxy_addr->port_num))
                                    {
                                        send_route = ICF_TRUE;
                                    }
                                    else if(ICF_NULL != p_rem_port && 
                                            icf_port_atoi((const icf_int8_t *)p_rem_port) == 
                                            p_proxy_addr->port_num)
                                    {
                                        send_route = ICF_FALSE;
                                    }
                                }
                            }
                        }
                        icf_port_strfree(p_rem_ip);
                    }
                }
                if(ICF_TRUE == send_route)
                {
                    if ( Sdf_co_fail == 
                            sdf_ivk_uaAddDefaultPreLoadedRoute(
                                p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                                Sdf_co_null,
                        (Sdf_ty_s8bit *)proxy_address,
                                p_proxy_addr->port_num,
                                "lr",/*pParam*/
                                ((ICF_TRANSPORT_TYPE_TLS ==
                                p_ssa_pdb->p_ssa_ctxt->transport)?"sips":
                                "sip"),&sdf_error))
                    { 
                        /*Raise/SetMajorError here:UATK_PROCESSING_FAILURE*/
                        ret_val = ICF_FAILURE;
                    }
                }/*if send route was true*/
            }/*ICF_FAILURE != ret_val*/
        }/*ICF_TRUE != is_serv_rte_present*/
    }/*ICF_FALSE == port_matched*/  

    if(ICF_FAILURE == ret_val)
    {
        return ret_val;
    }
    else if(ICF_TRUE == is_serv_rte_present)
    {
        SipError        SipErr;
        for(;serv_rte_index < size ;serv_rte_index++)
        {
            if(Sdf_co_fail == sdf_listGetAt(
                        (Sdf_ty_slist*)p_rgn_blk_addr->p_srv_rte,
                        serv_rte_index,
                        (Sdf_ty_pvoid *)&p_header, &sdf_error))
            {
                ICF_PRINT(((icf_uint8_t*)"\n[SSA]:Failure in hdr retrieval,going for \
                            next"));
            }
            else if (SipFail ==sip_initSipHeader(&p_temp_hdr,
                        SipHdrTypeRoute, &SipErr))
            {
                ret_val = ICF_FAILURE;
            }
            else if(SipFail == sip_cloneSipHeader(p_temp_hdr,
                        p_header, &SipErr))
            {
                ret_val = ICF_FAILURE;
            }
            if(ICF_SUCCESS == ret_val)
            {
                if (sdf_listAppend(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj->
                                pInitData->slPreLoadedRoute),
                                p_temp_hdr, &sdf_error) == Sdf_co_fail)
                {
                    ret_val = ICF_FAILURE;
                }
                /*Klocwork warning removal*/
                else
                {
                  ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_temp_hdr)
                }
            }
            /*Free the memory allocated for p_temp_hdr for any of the above
             * failure leg .*/
            if (ICF_FAILURE == ret_val)
            {
                /*Klocwork warning removal*/
                sip_freeSipHeader(p_temp_hdr);
                if(ICF_NULL != p_temp_hdr)
                {

                    /*Stack has decrement the ref count but the memory
                      * allocated has not been free so freeing the memory
                      * in failure case.*/

                    ICF_MEMFREE(
                                p_ssa_pdb->p_glb_pdb,
                                p_temp_hdr,
                                ICF_MEM_COMMON,
                                p_ssa_pdb->p_ecode,
                                temp_ret_val)
                }
                ICF_PRINT(((icf_uint8_t*)"\n[SSA]:Failure to insert Route header")); 
                break ; 
            }
            
        }/*for(;serv_rte_index < size ;serv_rte_index++)*/
    }/*ICF_TRUE == is_serv_rte_present*/
    ICF_PRINT(((icf_uint8_t*)"\n[SSA]: icf_ssa_set_RouteHeaderListToInitData"));
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_make_aka_auth_hdr
 *
 * DESCRIPTION:     This function makes the authorization header for the scenario
 *                  when challenge algo is AKA.
 *                  
 *
 ******************************************************************************/
 icf_return_t icf_ssa_make_aka_auth_hdr(
            INOUT    icf_ssa_pdb_st            *p_ssa_pdb,
            INOUT    SipMessage                *p_sip_msg)
{
    icf_return_t         ret_val = ICF_SUCCESS,
                         dummy_ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st      *p_ssa_ctxt = ICF_NULL;
    SipHeader            *pHeader = ICF_NULL;
    Sdf_ty_s8bit         *pHdrName = ICF_NULL;
    Sdf_ty_s8bit         *pFixdBody = ICF_NULL,
                         *p_body = ICF_NULL ;
    Sdf_ty_s32bit        HdrBodyLen = 0,
                         usr_name_sz = 0;
    Sdf_ty_s32bit        realm_size = 0;
    Sdf_ty_s32bit        uri_size = 0;
    Sdf_ty_s8bit         *pRealm = ICF_NULL;
    Sdf_ty_s8bit         *pUri = ICF_NULL;
    Sdf_ty_s8bit         *pNonce = ICF_NULL;
    Sdf_ty_s8bit         *pResponse = ICF_NULL;
    SipError             sip_err = 0;
    icf_rgm_context_st   *p_rgm_context = ICF_NULL;
    /* Rel 8.2 Klocworks fix */
    icf_string_st        authentication_key = {0,"\0"};
    /* Rel 8.2 Klocworks fix end */
    icf_error_t          ecode = ICF_NULL;
    icf_line_data_st     *p_line_data = ICF_NULL;
    icf_user_db_node_st  *p_user_db = ICF_NULL;
    
    /* These two variables are used to make this function a generic
     * one so that it can be used for processing all challenges.Currently
     * this function was being used in case of REGISTER only
     */
    icf_cmn_auth_data_st *p_auth_data_sent = ICF_NULL;
    icf_address_st       *p_user_address = ICF_NULL;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        
    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
        
    /* Copy the rgm_context pointer locally */
    p_rgm_context = (icf_rgm_context_st *)(p_ssa_ctxt->p_rgm_ctxt);
       
    if(ICF_NULL != p_rgm_context)
    {
        p_auth_data_sent = &(p_rgm_context->auth_data_sent);
    }
    else
    {
        p_auth_data_sent = &(p_ssa_ctxt->auth_data_sent);
    }
    /* Determining the user address to be used in fetching the auth key
     * from either user db node or line data through the function
     * icf_dbm_get_public_uri_node_from_uri_for_line
     */
    if(ICF_NULL != p_ssa_ctxt->p_call_ctxt)
    {
        p_user_address = 
        &p_ssa_ctxt->p_call_ctxt->local_address;
    }
    else if(p_ssa_ctxt->p_rgm_ctxt)
    {
        p_user_address = 
            &p_ssa_ctxt->p_rgm_ctxt->rgm_user_address;
    }
    else if(p_ssa_ctxt->p_sic_ctxt)
    {
        p_user_address = 
            p_ssa_ctxt->p_sic_ctxt->p_user_address;		
    }

    if(SipFail == (sip_initSipHeader(&pHeader, SipHdrTypeUnknown,&sip_err)))
    {
        ICF_PRINT(((icf_uint8_t*)"\nFailed to initialize Auth Header"));
        sip_freeSipHeader(pHeader);
        ret_val = ICF_FAILURE;
    }
    /*Delete existing Authorization header before inserting new Auth header
     *with response=""*/
    else if (ICF_FAILURE == icf_ssa_delete_auth_headers(p_ssa_pdb, p_sip_msg))
    {
        sip_freeSipHeader(pHeader);
        /*Klocwork awrning removal*/
        ICF_MEMFREE(
            p_ssa_pdb->p_glb_pdb,
            pHeader,
            ICF_MEM_COMMON,
            p_ssa_pdb->p_ecode,
            dummy_ret_val)

        ret_val = ICF_FAILURE;
    }
    else
    {

        /* Inserting the Header name in the unknown Header */
        Sdf_mc_strdup(pHdrName,"Authorization");
        
        if(ICF_NULL == pHdrName)
        {
            sip_freeSipHeader(pHeader);
            /*Klocwork awrning removal*/
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                pHeader,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
            ret_val = ICF_FAILURE;
        }
        
        if ((ICF_FAILURE != ret_val) && 
                (sip_setNameInUnknownHdr(pHeader,pHdrName,&sip_err) == SipFail))
        {
            ICF_PRINT(((icf_uint8_t*)"\nFailed to Set name"));
            sip_freeSipHeader(pHeader);

            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                pHeader,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)

            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                pHdrName,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
                
            ret_val = ICF_FAILURE;
        }

        if((ICF_FAILURE != ret_val) && (ICF_NULL != p_user_address)) 
        {

            /* building the Header Body */
            
            pFixdBody = "Digest username=\"";
            pRealm = "\",realm=\"";
            pNonce = "\",nonce=\"";
            pUri = "\",uri=\"";
            pResponse = "\",response=\"\"";
        
            /* Fetching auth key from line data/user db node */
                     
            if(ICF_SUCCESS == icf_dbm_get_public_uri_node_from_uri_for_line(
                          p_ssa_pdb->p_glb_pdb,
                          p_ssa_pdb->p_line_data->line_id,
                          p_user_address,
                          ICF_USER_DB_USE_PUBLIC_URIS,
                          &p_user_db, &ecode) &&
    	                 (p_user_db->flags & ICF_USER_DB_AUTH_PRMS_PER_USER))

            {
                if(p_user_db->flags & ICF_USER_DB_AUTH_KEY_RECD)
		        {
		            icf_port_memcpy(
		                &authentication_key,
		   	            &p_user_db->authentication_key,
			            (icf_uint32_t)ICF_PORT_SIZEOF(icf_string_st));		
		        }
            }
            else if(ICF_SUCCESS == icf_dbm_fetch_line_cntxt_blk(
							p_ssa_pdb->p_glb_pdb,
                            p_ssa_pdb->p_line_data->line_id,
							(icf_void_t *)&(p_line_data),
							&ecode))
         	{
                if(p_line_data->line_data_received & 
			        ICF_CFG_LINE_DATA_AUTH_KEY_RECD)
		        {
		            icf_port_memcpy(
				        &authentication_key,
				        &p_line_data->authentication_key,
				        (icf_uint32_t)ICF_PORT_SIZEOF(icf_string_st));		    
		        }
            }
            else
            {
                /* Auth key not found */
                ret_val = ICF_FAILURE;
                ICF_PRINT(((icf_uint8_t *)"\nAuth key not found"));
                
                sip_freeSipHeader(pHeader);
 
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    pHeader,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
            }
        }
    }
    
    if(ICF_FAILURE != ret_val)
    {
        /*Calculating Name string length minus NULL char at the end*/

        usr_name_sz = Sdf_mc_strlen((const icf_int8_t *)authentication_key.str);
        realm_size = Sdf_mc_strlen((const icf_int8_t *)p_auth_data_sent->realm.str);
        uri_size = Sdf_mc_strlen((const icf_int8_t *)p_auth_data_sent->uri.str);
            
        /*Calculating total body length */

        HdrBodyLen = Sdf_mc_strlen(pFixdBody) + 
                     Sdf_mc_strlen(pRealm) + 
                     Sdf_mc_strlen(pNonce) + 
                     Sdf_mc_strlen(pUri) + 
                     Sdf_mc_strlen(pResponse) +
                     usr_name_sz + realm_size + uri_size + 1;
            
        ICF_MEMGET(
                p_ssa_pdb->p_glb_pdb,
                HdrBodyLen+1,
                ICF_MEM_COMMON,
                p_body,
                ICF_DONOT_RET_ON_FAILURE,
                p_ssa_pdb->p_ecode,
                ret_val)

        if(ICF_FAILURE == ret_val)
        {
            sip_freeSipHeader(pHeader);  
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    pHeader,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
        }
        else
        {
            if ( ICF_NULL != pFixdBody)
			{
				icf_port_strcpy((icf_uint8_t*)p_body, (icf_uint8_t*)pFixdBody);
			}
            icf_port_strcat((icf_uint8_t*)p_body, (icf_uint8_t*)authentication_key.str);
        
            /* New parameters being appended to the authorization header */
          
            /* Append Realm  */
			if (ICF_NULL != pRealm)
			{
            icf_port_strcat((icf_uint8_t*)p_body, (icf_uint8_t*)pRealm);
            icf_port_strcat((icf_uint8_t*)p_body, p_auth_data_sent->realm.str);
        	}

            /* Append Nonce  */
			if (ICF_NULL != pNonce)
			{
            icf_port_strcat((icf_uint8_t*)p_body, (icf_uint8_t*)pNonce);
        	}
            
			/* Append URI */
            if (ICF_NULL != pUri)
			{
			icf_port_strcat((icf_uint8_t*)p_body, (icf_uint8_t*)pUri);
            icf_port_strcat((icf_uint8_t*)p_body, p_auth_data_sent->uri.str);
            }

            /* Append Null Response  */
            if (ICF_NULL != pResponse)
			{
			icf_port_strcat((icf_uint8_t*)p_body, (icf_uint8_t*)pResponse);
        	}

            /* Preparing the Message Body */
            if (sip_setBodyInUnknownHdr(pHeader,p_body,&sip_err) == SipFail)
            {
                ICF_PRINT(((icf_uint8_t*)"\nFailed to set body"));
                
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_body,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)

                    sip_freeSipHeader(pHeader);

                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    pHeader,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
                    
                ret_val = ICF_FAILURE;
            }
            
            else if (ICF_FAILURE == sip_insertHeaderAtIndex(
                        p_sip_msg, pHeader,0, &sip_err))
            {
                 sip_freeSipHeader(pHeader);
        
                 ICF_MEMFREE(
                     p_ssa_pdb->p_glb_pdb,
                     pHeader,
                     ICF_MEM_COMMON,
                     p_ssa_pdb->p_ecode,
                     dummy_ret_val)

                 ret_val = ICF_FAILURE;
            }
            else
            {
                sip_freeSipHeader(pHeader);

                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    pHeader,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
            }
        }
    }
    /*Klocwork warning removal*/
    else if(ICF_NULL != pHeader)
    {

        ICF_MEMFREE(
              p_ssa_pdb->p_glb_pdb,
              pHeader,
              ICF_MEM_COMMON,
              p_ssa_pdb->p_ecode,
              dummy_ret_val)
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}/* function icf_ssa_make_aka_auth_hdr() ends here */


/*******************************************************************************
 * FUNCTION:        icf_ssa_add_rgm_app_data
 *
 * DESCRIPTION:     This function adds the app related data: hdr/ tag/ msg list
 *                  to the overlap transaction: In case of REGISTER message
 *
 ******************************************************************************/
 icf_return_t        icf_ssa_add_rgm_app_data(
     INOUT     icf_ssa_pdb_st                    *p_ssa_pdb,
     INOUT     Sdf_st_overlapTransInfo             *p_overlap_trans_info)
 {
     
     icf_return_t                     ret_val = ICF_SUCCESS;
     icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;

     icf_rgm_context_st        *p_rgm_context = ICF_NULL;
     icf_uint16_t                loop_app = ICF_NULL;
     icf_header_list_st        *p_hdr_list = ICF_NULL;
     icf_tag_list_st            *p_tag_list = ICF_NULL;
     icf_msg_body_list_st        *p_msg_list = ICF_NULL;
     
     
     
     ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
         
    /* Copy the ssa ctxt pointer locally */
     p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
     ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))
         
    /* Copy the rgm_context pointer locally */
    p_rgm_context = (icf_rgm_context_st *)(p_ssa_ctxt->p_rgm_ctxt);
         
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_rgm_context))

    /* here the tags from the mandatory headers will be removed */
    if (ICF_FAILURE == icf_ssa_rgm_remove_tags(p_ssa_pdb,
                                    p_overlap_trans_info->pSipMsg))
    {
        ret_val = ICF_FAILURE;
    }

         
    else

    {/* tag removal success: starts */
         
    /* To add the additional tags/headers/msg_body to REGISTER 
     * as received from the application data */
         
     /* Loop for all the applications in rgm_context 
     * for the entries with is_valid as TRUE */
         
         
     for (loop_app = 0; loop_app < p_ssa_pdb->p_glb_cfg_data->max_applications ;
                            loop_app++)
     {
         if (ICF_FALSE == p_rgm_context->p_app_data_list[
             loop_app].is_valid)
             continue;
         
         /* for loop_app begins */
         if (ICF_HDR_LIST_PRESENT & p_rgm_context->
             p_app_data_list[loop_app].bitmask)
             
         {
             /* Header list present: Insert: begin */
             p_hdr_list = &(p_rgm_context->p_app_data_list[
                 loop_app].header_list);
             if ((ICF_FAILURE == ret_val)||
                 (ICF_FAILURE ==
                 icf_ssa_insert_header_list_in_sip_msg(
                 p_ssa_pdb,p_hdr_list,
                 ICF_FALSE,
                 p_overlap_trans_info->pSipMsg)))
                 
             {
                 /* Error during addition of header list */
                 ret_val = ICF_FAILURE;
             }
             
         }/* Header list present: Insert: end */
         
         
         if (ICF_TAG_LIST_PRESENT & p_rgm_context->
             p_app_data_list[loop_app].bitmask)
         {
             /* Tag list present: Insert: begin */
             p_tag_list = &(p_rgm_context->p_app_data_list[
                 loop_app].tag_list);
             if ((ICF_FAILURE == ret_val)||
                 (ICF_FAILURE ==
                 icf_ssa_insert_tag_list_in_sip_msg(
                 p_ssa_pdb,p_tag_list,
                 ICF_FALSE,
                 p_overlap_trans_info->pSipMsg)))
             {
                 /* Error during addition of tag list */
                 ret_val = ICF_FAILURE;
             }
         }/* Tag list present: Insert: end */
         
         if (ICF_BODY_LIST_PRESENT & p_rgm_context->
             p_app_data_list[loop_app].bitmask)
         {
             Sdf_st_error   sdf_error;

             /* Msg_body list present: Insert: begin */
             p_msg_list = &(p_rgm_context->p_app_data_list[
                 loop_app].body_list);
             if ((ICF_FAILURE == ret_val)||
                 (ICF_FAILURE ==
                 icf_ssa_insert_body_list_in_sdf_list(
                 p_ssa_pdb,p_msg_list,
                 ICF_FALSE,
                 &(p_overlap_trans_info->slMsgBodyList))))
             {
                 /* Error during addition of msg_body list */
                 ret_val = ICF_FAILURE;
             }
            /*Message body header changes Start*/
            else if (ICF_FAILURE == icf_ssa_SetAllMsgBody(\
                Sdf_co_null, p_overlap_trans_info,\
                (icf_int8_t *)p_msg_list->content_type.str,&sdf_error))
            {
                
                ret_val = ICF_FAILURE;
            }
         }/* Msg_body list present: Insert: end */
         
         
     }/* for loop_app Ends */
    
    }/* tag removal success: ends */


     ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;

         
}/* icf_ssa_add_rgm_app_data() ends here */

/*******************************************************************************
 * FUNCTION:        icf_ssa_fill_uac_auth
 *
 * DESCRIPTION:     This function fills the UAC auth info member using
 *                  auth_sent member of rgm_context
 *
 ******************************************************************************/
 icf_return_t icf_ssa_fill_uac_auth(
            INOUT    icf_ssa_pdb_st                *p_ssa_pdb,
            INOUT     Sdf_st_uacAuthInfo              *p_uac_auth_info)
 {
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;
    /* Rel 8.2 Klocworks fix */
    icf_string_st                    temp_nc = {0,"\0"};
    /* Rel 8.2 Klocworks fix end */
    icf_rgm_context_st               *p_rgm_context = ICF_NULL;
    Sdf_ty_u32bit                    new_cnonce_int = 0;
    /* Rel 8.2 Klocworks fix */
    icf_string_st                    authentication_key = {0,"\0"},
                                     authentication_password = {0,"\0"};
    /* Rel 8.2 Klocworks fix end */
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt))

    /* Copy the rgm_context pointer locally */
    p_rgm_context = (icf_rgm_context_st *)(p_ssa_ctxt->p_rgm_ctxt);
         
    ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_rgm_context))
    /* Fixed for SPR 16051: Here we fetch the credentials 
	   from either the user_db coress to rgm_user_address 
	   or from line data depending on the opetion PA has
	   selected */
	if(ICF_FAILURE == icf_cmn_get_auth_params(
			        p_ssa_pdb->p_glb_pdb, 
				&p_rgm_context->rgm_user_address,
				p_ssa_pdb->p_line_data->line_id,
				&authentication_key,
				&authentication_password))
	{
		ret_val = ICF_FAILURE;
		return ret_val;
	}
     
     /* Set UserName  */
     Sdf_mc_strdup(
         p_uac_auth_info->pUserName, 
         (icf_int8_t*)authentication_key.str);

         if (ICF_CHALLENGE_ALGO_AKA == p_rgm_context->challenge_algo)
         {
             if (ICF_AUTH_RES_PRESENT &
                 p_rgm_context->auth_data_sent.auth_data_present)
             {
                 /* Set the RES received into the UAC auth Info */
                 Sdf_mc_strdup(
                     p_uac_auth_info->pPassword,
                     (icf_int8_t*)p_rgm_context->auth_data_sent.res.str);
             }
             else
             {
                 /* Set the password as null into the UAC auth Info */
                 p_uac_auth_info->pPassword = Sdf_co_null;
             }
             
         }
         /* For MD5 copy password as configured by set_self_id */
         else
         {
             Sdf_mc_strdup(
                 p_uac_auth_info->pPassword,
                    (icf_int8_t*)authentication_password.str);
         }    
             /* Initializing the QoP, Cnonce and NonceCount as Sdf_co_null */
             p_uac_auth_info->pQop = Sdf_co_null;
             p_uac_auth_info->pCnonce = Sdf_co_null;
             p_uac_auth_info->pNonceCount = Sdf_co_null;
             
             if (ICF_AUTH_QOP_PRESENT &
                 p_rgm_context->auth_data_sent.auth_data_present)
             {
             /*********** QoP ****************/
             /* Qop was received in 401 and 
              * client_nonce has some non_null value:
              * cnonce is MUST to be sent when QoP received */
                 
                 Sdf_mc_strdup(
                     p_uac_auth_info->pQop,
                     (icf_int8_t*)p_rgm_context->auth_data_sent.qop.str);
             
                /*********** cnonce ****************/
                /* For every challenge, the value of cnonce will be generated 
                 * afresh and also saved in rgm_ctxt->auth_data_sent */
                if (ICF_REQ_AGAIN_AFTER_CHALLENGE & p_rgm_context->indicator)
                {
                    /* Clear the previous value from rgm_ctxt */
                    icf_port_memset(
                        &(p_rgm_context->auth_data_sent.cnonce),
                        0,
                        ICF_PORT_SIZEOF(icf_string_st));

                    /* Generate a fresh value */
                    if (Sdf_co_fail == 
                          sdf_fn_uaGetCurrentTimeInMicroSecs(&new_cnonce_int))
                    {
                        ret_val = ICF_FAILURE;
                        return ret_val;
                    }

                    /* Save the fresh value in rgm_ctxt */
                    icf_port_sprintf((icf_int8_t *)p_rgm_context->auth_data_sent.cnonce.str,
                    (icf_int8_t *)"%u", new_cnonce_int);
                    p_rgm_context->auth_data_sent.cnonce.str_len =
                     (icf_uint16_t)icf_port_strlen(p_rgm_context->auth_data_sent.cnonce.str);
                    p_rgm_context->auth_data_sent.auth_data_present |=
                     ICF_AUTH_CNONCE_PRESENT;

                    /* reset the indicator bit till next challenge */
                    ICF_RESET_BIT(p_rgm_context->indicator,
                        ICF_REQ_AGAIN_AFTER_CHALLENGE);
                }

             if (ICF_AUTH_CNONCE_PRESENT &
                 p_rgm_context->auth_data_sent.auth_data_present)
             {
                 
                 /* cNonce is picked from rgm_context */
                 Sdf_mc_strdup(
                     p_uac_auth_info->pCnonce,
                     (icf_int8_t*)p_rgm_context->auth_data_sent.cnonce.str);

                /* save this value for sending in Re-reg or De-reg */
                 icf_port_memcpy(
                        &p_rgm_context->client_nonce,
                        &p_rgm_context->auth_data_sent.cnonce,
                        ICF_PORT_SIZEOF(icf_string_st));
               }

                /*********** Nonce-count/nc ****************/
             if (ICF_AUTH_NC_PRESENT &
                 p_rgm_context->auth_data_sent.auth_data_present)
             {
                 temp_nc.str_len = 0;
                 /* Convert the nonce_count to string */
                 icf_ssa_compute_nc(p_ssa_pdb->p_glb_pdb,
                     p_ssa_ctxt, &temp_nc, 
                     p_rgm_context->auth_data_sent.nonce_count,
                     p_ssa_pdb->p_ecode);
                 
                 /* increment the value for sending in next request */
                 (p_rgm_context->auth_data_sent.nonce_count)++;
                      
                 if (temp_nc.str_len)
                 {
                     Sdf_mc_strdup(
                         p_uac_auth_info->pNonceCount,
                         (icf_int8_t*)temp_nc.str);
                 }
             }/* Nonce count present */

             }/* QoP received: ends */
             else
             {
                 /* No qop: nothing to do */
             }
         
     ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;             
             
}/* Function icf_ssa_fill_uac_auth() ends here */

/*******************************************************************************
 * FUNCTION:        icf_ssa_chk_n_append_auts
 *
 * DESCRIPTION:     This function appends the AUTS parameter to Authorization header 
 *                  if it is present in the scenario when the challenge algo is AKA.
 *
 ******************************************************************************/
icf_return_t icf_ssa_chk_n_append_auts(
            INOUT    icf_ssa_pdb_st                    *p_ssa_pdb,
            INOUT    SipMessage                        *p_sip_msg)
{
    icf_return_t                     ret_val = ICF_SUCCESS,
                                     dummy_ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st                  *p_ssa_ctxt = ICF_NULL;
    icf_rgm_context_st               *p_rgm_context = ICF_NULL;
    /* Rel 8.2 Klocworks fix */
    icf_string_st                    encoded_auts = {0,"\0"},auth_param = {0,"\0"};
    /* Rel 8.2 Klocworks fix end */
    SipParam                         *p_sip_param = Sdf_co_null;
    SipError                         sip_err = 0;
    Sdf_ty_u32bit                    count = 0;
    icf_int8_t                      *p_auts_value = ICF_NULL;
    SipHeader                        dHeader;
    /* This stores the challenge algo from either ssa_ctxt or rgm_ctxt */
    icf_challenge_algo_t             challenge_algo = ICF_CHALLENGE_ALGO_INVALID;

    /* This variable will point to either p_rgm_context->auth_data_sent or
     * p_ssa_ctxt->auth_data_sent. This is used to make this function
     * a generic one so that it can be used in the case of REGISTER
     * and other methods as well.
     */
    icf_cmn_auth_data_st             *p_auth_data_sent = ICF_NULL;
    /* This boolean is ised to indicate whether p_auts_value has to be
     * freed or not. */
    icf_boolean_t                     auts_to_be_freed = ICF_FALSE;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
      
    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->p_call_obj->pAppData->pData;

    /* Copy the rgm_context pointer locally */
    p_rgm_context = (icf_rgm_context_st *)(p_ssa_ctxt->p_rgm_ctxt);

    if(ICF_NULL != p_rgm_context)
    {
        p_auth_data_sent = &(p_rgm_context->auth_data_sent);
        challenge_algo = p_rgm_context->challenge_algo;
    }
    else
    {
        p_auth_data_sent = &(p_ssa_ctxt->auth_data_sent);
        challenge_algo = p_ssa_ctxt->challenge_algo;
    }

    if(ICF_CHALLENGE_ALGO_AKA == challenge_algo)
    {
        if(ICF_AUTH_AUTS_PRESENT & p_auth_data_sent->auth_data_present)
        {
            /* encode base 64: auth_data_sent.auts by */
            /* The invocation of Base-64 API encodeBase64
             * has been removed from here in process of 
             * OPEN_SOURCE_REMOVAL.The earlier API invocation
             * was as below:
               
               icf_encodeBase64((icf_int8_t *)p_auth_data_sent->auts.str,
                            (icf_int8_t *)encoded_auts.str);
             */
            encoded_auts.str_len = (icf_uint16_t)icf_port_strlen((icf_uint8_t *)encoded_auts.str);
            icf_port_strcpy(auth_param.str, (icf_uint8_t *)"\"");
            icf_port_strcat(auth_param.str, encoded_auts.str);
            icf_port_strcat(auth_param.str, (icf_uint8_t *)"\"");

            Sdf_mc_strdup(p_auts_value,(icf_int8_t *) auth_param.str);

            if (SipFail == sip_initSipParam(&p_sip_param, &sip_err))
            {
                auts_to_be_freed = ICF_TRUE;
                ret_val = ICF_FAILURE;
            }
            else if (SipFail == sip_listInit(&(p_sip_param->slValue),
                                    __sip_freeString,
                                    &sip_err))
            {
                auts_to_be_freed = ICF_TRUE;
                ret_val = ICF_FAILURE;

            }
            else if (SipFail == sip_listInsertAt(&(p_sip_param->slValue), 0,
                        (icf_void_t *)(p_auts_value),&sip_err))
            {
                auts_to_be_freed = ICF_TRUE;
                ret_val = ICF_FAILURE;
            }
            else 
            {                
                icf_port_strcpy(auth_param.str,(icf_uint8_t *)"auts");
                auth_param.str_len = (icf_uint16_t)icf_port_strlen((icf_uint8_t *)auth_param.str);

                ICF_MEMGET(
                    p_ssa_pdb->p_glb_pdb,
                    auth_param.str_len + 1,
                    ICF_MEM_COMMON,
                    p_sip_param->pName,
                    ICF_DONOT_RET_ON_FAILURE,
                    p_ssa_pdb->p_ecode,
                    ret_val)

                if(ICF_FAILURE != ret_val)
                {
                    icf_port_strcpy((icf_uint8_t*)p_sip_param->pName, auth_param.str);

                    if(SipFail == sip_getHeaderCount(p_sip_msg, SipHdrTypeAuthorization,
                                                     &count, &sip_err))
                    {
                        ret_val = ICF_FAILURE;
                    }
            
                    /* If multiple headers of same type is found, we choose the first header
                     * index 0 and insert the tags to that header,*/
                    else if(SipFail == sip_getHeaderAtIndex(p_sip_msg, 
                                       SipHdrTypeAuthorization, &dHeader, 0, &sip_err))
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else if (SipFail == sip_insertParamAtIndexInAuthorizationHdr(
                                        &dHeader,p_sip_param,0,&sip_err))  
                    {
                        sip_freeSipHeader(&dHeader);
                        ret_val = ICF_FAILURE;
                    }
                    else
                    {                
                        sip_freeSipHeader(&dHeader);
                    }
                }
            }    
        }/* AUTS present ends */
    }/* Challenge algo is AKA ends */

    sip_freeSipParam(p_sip_param);

    /* free auts */
    if(ICF_TRUE == auts_to_be_freed)
    {
        if(ICF_NULL != p_auts_value)
        {
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_auts_value,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
        }
    }


    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;             

}/* Function icf_ssa_chk_n_append_auts() ends here */


/*******************************************************************************
 * FUNCTION:        icf_ssa_make_contact_of_app_data
 *
 * DESCRIPTION:     This function creates a contact header using the app_data
 *
 * RETURNS            SUCCESS: Contact header created successfully
 *                    FAILURE:
 *
 ******************************************************************************/
icf_return_t     icf_ssa_make_contact_of_app_data(
            INOUT        icf_ssa_pdb_st       *p_ssa_pdb,
            INOUT         icf_rgm_app_ctxt_st    *p_app_data,
            INOUT         SipHeader               **p_p_contact_hdr,
            OUT            icf_error_t            *p_ecode)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    SipError            sip_err;
    SipContactHeader    *p_contact_hdr = ICF_NULL;
    Sdf_ty_s8bit        contact_addr[ICF_MAX_STR_LEN] = "\0";
#ifdef IMS_CLIENT
    Sdf_ty_s8bit        app[ICF_MAX_STR_LEN] = "\0";
#endif

#ifdef ICF_NAT_RPORT_SUPPORT
    icf_rport_config_data_st            *p_rport_config_data = ICF_NULL;
#endif
    icf_uint8_t        str_duration[ICF_MAX_STR_LEN] = "\0";
    /*icf_glb_pdb_st               *p_glb_pdb = p_ssa_pdb->p_glb_pdb;*/
    icf_config_data_st           *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    Sdf_st_error                    Error;  
    icf_uint16_t                 port_num = 0;
    icf_uint32_t                    duration = ICF_NULL;
    icf_tag_st                    temp_tag;
    icf_address_st               *p_user_address = ICF_NULL;
        icf_transport_address_st     *p_contact_address = ICF_NULL;
    icf_uint8_t                    *p_temp = ICF_NULL;
        icf_transport_address_st    self_addr;
    
        /* To Remove Warnings */
        p_ecode=p_ecode;
        ICF_SSA_INIT_TRANS_ADDR(&self_addr)
    
     /*If per line self transport then copy address from line_data*/
       if (ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
       {
           icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                           sizeof(icf_transport_address_st));
#ifdef ICF_NAT_RPORT_SUPPORT
           p_rport_config_data = p_ssa_pdb->p_line_data->p_rport_config_data;
#endif
       }
       else
       {
           icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                           sizeof(icf_transport_address_st));
#ifdef ICF_NAT_RPORT_SUPPORT
            p_rport_config_data = &(p_glb_cfg_data->rport_config_data);
#endif
       }
    
#ifdef ICF_NAT_RPORT_SUPPORT
    if(ICF_TRUE == p_rport_config_data->is_rport_reqd)
    {
        p_contact_address = &(p_rport_config_data->contact_ip_addr);
    }
    else
    {
        p_contact_address = &(self_addr);
        
    }    
#else
    p_contact_address = &(self_addr);

#endif



    if(ICF_APP_ID_INVALID == p_app_data->app_id)
    {
        return ICF_FAILURE;
    }
    if (sip_initSipHeader(p_p_contact_hdr, SipHdrTypeContactNormal, \
                        &(sip_err)) == SipFail)
    {
        sip_freeSipHeader(*p_p_contact_hdr);
        return ICF_FAILURE;
    }
    p_contact_hdr = (SipContactHeader *) ((*p_p_contact_hdr)->pHeader);

    /* Making of contact header For application */
    /*
          Username = app_appid;
          Addr_spec = sip uri;
          IP, Port from global data.*/
            
    /* Make the contact address */
    /* expires=value in each contact header */
    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt)
    {
    duration = (p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->rgm_duration/1000);
    
    /* To add expires tag in Contact header */
    icf_port_memset((icf_void_t *)(&temp_tag),
        0, ICF_PORT_SIZEOF(icf_tag_st));
    
    icf_port_strcpy(temp_tag.hdr_name.str,
        (icf_uint8_t *)"Contact");
    temp_tag.hdr_name.str_len = 
        (icf_uint16_t)icf_port_strlen(
        temp_tag.hdr_name.str);
    
    icf_port_strcpy(temp_tag.tag_value.str,
        (icf_uint8_t *)"expires=");
    icf_port_sprintf((icf_int8_t *)str_duration,"%d",duration);
    icf_port_strcat(temp_tag.tag_value.str,
        str_duration);
#if 0
/*  Merging of CSR 5477009  */
    icf_port_strcat(temp_tag.tag_value.str,
        " ");
/*  Merging End */
#endif
    
    temp_tag.tag_value.str_len = 
        (icf_uint16_t)icf_port_strlen(
        temp_tag.tag_value.str);
    
    temp_tag.next = ICF_NULL;
    }    
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_glb_pdb,ICF_TRUE)
/* Start: Multiple Public Users ICF5.0*/

    /* the contact shall be in the format %s_%d@ip where %s is the 
     * user address and %d is the app_id*/

    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt)
    {
        /* The userId in Contact header should be the userid configured through 
         * set_line_params api. If this is not configured, then the userid part
         * of From header should be used.
         */
        p_user_address = &(p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->rgm_user_address);
        if ((ICF_NULL != p_ssa_pdb->p_line_data) &&
                (ICF_NULL != p_ssa_pdb->p_line_data->contact_user_info.str_len))
        {
            icf_port_strcpy(contact_addr, 
                p_ssa_pdb->p_line_data->contact_user_info.str);
        }
        else
        {
            icf_port_strcpy(contact_addr,p_user_address->addr_val.str);
        }

        if (( ICF_ADDRESS_PLAN_SIP_URI == p_user_address->addr_type) ||
                        (ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type))
        {
            p_temp = icf_port_strchr(contact_addr,'@');
            if(ICF_NULL != p_temp)
            {
                *p_temp = '\0';
            }
            icf_port_sprintf(app,"_%d@",p_app_data->app_id);
            icf_port_strcat(contact_addr,app);
        }
        /*
         * If the address type is SIP URI ,then we will
         * extract the userid from the SIP URI and then 
         * append the self IP address and port in order
         * to form the contact header
         */
        else if((ICF_ADDRESS_PLAN_TEL_URI == p_user_address->addr_type)||
            (ICF_ADDRESS_PLAN_E164 == p_user_address->addr_type))
        {
            icf_port_sprintf(app,"_%d@",p_app_data->app_id);
            icf_port_strcat(contact_addr,app);
        }
        else
        {
            contact_addr[0]='\0';
        }
    }
/* End: Multiple Public Users ICF5.0*/
ICF_CHECK_IMS_END
#endif
/*Forming the contact for both IMS and NON-IMS mode 
  The following field ie ICF_CHECK_IMS_START is commented 
  so that it works for both IMS and NON-IMS mode */    
#ifdef NON_IMS_CLIENT
/*ICF_CHECK_IMS_START(p_glb_pdb,ICF_FALSE)*/
    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt)
    {
        /* Fix for SPR: 19999 (Merged CSR 1-7615941: SPR 19912)*/
        /* The userId in Contact header should be the userid configured through 
         * set_line_params api. If this is not configured, then the userid part
         * of From header should be used.
         */
        p_user_address = &(p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->rgm_user_address);
        if (ICF_NULL != p_ssa_pdb->p_line_data->contact_user_info.str_len)
        {
            icf_port_strcpy((icf_uint8_t *)contact_addr, 
                p_ssa_pdb->p_line_data->contact_user_info.str);
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)contact_addr,
                    p_user_address->addr_val.str);
        }
        if ( ICF_ADDRESS_PLAN_E164 ==
                p_user_address->addr_type)
        {
            icf_port_strcat((icf_uint8_t *)contact_addr,(icf_uint8_t *)"@");
        }
        /*
         * If the address type is SIP URI ,then we will
         * extract the userid from the SIP URI and then 
         * append the self IP address and port in order
         * to form the contact header
         */

        else if (( ICF_ADDRESS_PLAN_SIP_URI ==
                                p_user_address->addr_type )||
                         ( ICF_ADDRESS_PLAN_SIPS_URI ==
                                p_user_address->addr_type ))
        {
            p_temp = icf_port_strchr((icf_uint8_t *)contact_addr,(icf_uint8_t)'@');
            if(ICF_NULL != p_temp)
            {
             *p_temp = '\0';
            }
            icf_port_strcat((icf_uint8_t *)contact_addr,(icf_uint8_t *)"@");
        }
        else
        {
            contact_addr[0]='\0';
        }
    }
/*ICF_CHECK_IMS_END*/
#endif

    if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
        self_addr.addr.addr_type)
    {
        icf_port_strcat((icf_uint8_t *)contact_addr,
            (icf_uint8_t *)self_addr.addr.addr.domain.str);

    }
    else 
    {
#ifdef ICF_IPV6_ENABLED
        icf_uint8_t remote_ip[ICF_MAX_IPV6_ADDRESS_LENGTH] = {'\0'};
#else
        icf_uint8_t remote_ip[32] = {'\0'};
#endif
        
        if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
            p_contact_address,remote_ip))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            icf_port_strcat((icf_uint8_t *)contact_addr, (icf_uint8_t *)remote_ip);
        }
    }

    if(ICF_NULL == p_user_address)
        return ICF_FAILURE;
    
#ifdef ICF_IPSEC_ENABLED
    if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->ipsec_enabled)
    {
        icf_ipsec_sa_context_st              *p_sa_context = ICF_NULL;

        p_sa_context = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;

        /* check is SA exists */
        if (ICF_NULL != p_sa_context)
        {
            port_num = p_sa_context->p_ue_security_params->port_s;
        }
        else

        {
            port_num = p_contact_address->port_num;
        }
    }
    else
#endif
    {
        if (ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type)
        {
            port_num = p_glb_cfg_data->p_tls_init_data->tls_sip_serv_port_num;
        }
        else
        {
            port_num = p_contact_address->port_num;
        }   
     }
     if (sdf_ivk_uaMakeAddrSpecFromConstituents(&(p_contact_hdr->pAddrSpec), contact_addr,
                                port_num,
                                (ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type)?"sips":"sip",
                                &Error) == Sdf_co_fail)
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        /* Adding the expires=value tag in contact header*/
        Sdf_ty_slist        s_list;
        
        if (sdf_listInit(&s_list, __sdf_fn_uaFreeString, Sdf_co_false, &Error)             
            == Sdf_co_fail)
        {
            ret_val = ICF_FAILURE ;
        }
        else if (sdf_ivk_uaInsertHeaderParam(*p_p_contact_hdr, 
            (Sdf_ty_s8bit *)temp_tag.tag_value.str,  
            &s_list, 0, &Error) == Sdf_co_fail)
        {
            ret_val = ICF_FAILURE ;
            sdf_listDeleteAll(&s_list, &Error);
        
        }
        sdf_listDeleteAll(&s_list, &Error);

        if (ICF_TRUE == 
            ICF_IS_BIT_SET(p_app_data->bitmask,ICF_TAG_LIST_PRESENT ) &&
            ICF_TRUE == 
             ICF_IS_BIT_SET(p_app_data->bitmask,ICF_TAGS_REFRESHED))
        {
            /* Insert Application specific Contact Header tags to contact header */
            
            icf_uint16_t list_count = (icf_uint16_t)p_app_data->tag_list.count;
            icf_tag_st   *p_tag = p_app_data->tag_list.tag;
            en_HeaderType   hdr_type = 0;
            /*
            Loop on the tag list of the application
            {
            if (hdr_name == contact) then 
            add value to the ParamaList of the contact Header.


            } Loop on tag list ends 
            */
            while (list_count > 0 && ICF_NULL != p_tag) 
            {
                /* Check whether tag is for Contact header or not*/
                SipError err;
                icf_ssa_get_hdr_type_from_name(p_tag->hdr_name.str, &hdr_type, &err);
                
                if((hdr_type == SipHdrTypeContactNormal)   ||
                   (hdr_type == SipHdrTypeContactWildCard) ||
                   (hdr_type == SipHdrTypeContactAny))
                {
                    if ( p_tag->tag_type & ICF_TAG_TYPE_SIP_URI_PARAM)
                    {
                        icf_ssa_append_sip_uri_param_in_sip_hdr(
                            p_ssa_pdb,p_tag->tag_value.str,*p_p_contact_hdr);
                        
                    }
                    else if ( p_tag->tag_type & ICF_TAG_TYPE_SIP_URI_HDR_PARAM)
                    {
                        icf_ssa_append_sip_uri_hdr_param_in_sip_hdr(
                            p_ssa_pdb,p_tag->tag_value.str,*p_p_contact_hdr);
                    }
                    else if ( p_tag->tag_type & ICF_TAG_TYPE_HDR_PARAM)
                    {
                        Sdf_ty_slist        sList;

                        if(sdf_listInit(&sList, __sdf_fn_uaFreeString, Sdf_co_false, &Error)             
                            == Sdf_co_fail)
                        {
                            ret_val = ICF_FAILURE ;
                        }
                        /* instead of sending a list of values
                        * corresponding to a tag in a list we send the entire tag=value portion
                        * as a string to InsertHeaderParam, thus the second argument.
                        */
                        
                        else if (sdf_ivk_uaInsertHeaderParam(*p_p_contact_hdr, 
                            (Sdf_ty_s8bit *)p_tag->tag_value.str,  
                            &sList, 0, &Error) == Sdf_co_fail)
                        {
                            ret_val = ICF_FAILURE ;
                            sdf_listDeleteAll(&sList, &Error);
                            break;
                        }
                        sdf_listDeleteAll(&sList, &Error);
                    }
                    else
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Ignoring Invalid Tag Type\n"));
                    }
                }
                list_count = (icf_uint16_t)(list_count - 1);
                p_tag = p_tag->next;
            }
        }/* Tag list present: Insert: end */
    }

    if(ICF_SUCCESS == ret_val)
    {
        icf_address_st  temp_addr;

        if ( ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type)
        {
            temp_addr.addr_type = ICF_ADDRESS_PLAN_SIPS_URI;
        }
        else
        {
            temp_addr.addr_type = ICF_ADDRESS_PLAN_SIP_URI;
        }

        if('\0' != contact_addr[0])
        {
            icf_port_strcpy(temp_addr.addr_val.str,(icf_uint8_t *)contact_addr);
            temp_addr.addr_val.str_len = (icf_uint16_t)icf_port_strlen(temp_addr.addr_val.str);

            if(ICF_FAILURE == icf_dbm_append_uri_to_address_list(
                        p_ssa_pdb->p_glb_pdb,
                        &temp_addr,
                        &(p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->p_contact_uri_list),
                        p_ssa_pdb->p_ecode))
            {
                ret_val = ICF_FAILURE;
            }
        }
    }
    return ret_val;
}/* Function icf_ssa_make_contact_of_app_data() ends here */

/*******************************************************************************
 * FUNCTION:        icf_ssa_make_contact_list_for_reg
 *
 * DESCRIPTION:     This function makes contact list for Register request
 *                  
 ******************************************************************************/

icf_return_t icf_ssa_make_contact_list_for_reg(
     INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
     INOUT    Sdf_ty_slist              *p_contact_addr_list)
{
    icf_return_t                   ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st                *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    icf_rgm_context_st             *p_rgm_ctxt = p_ssa_ctxt->p_rgm_ctxt;
    icf_uint8_t                    loop_app=0;
    SipHeader                      *p_contact_hdr = ICF_NULL;
    Sdf_st_error                   SdfError;
    Sdf_st_error                   sdf_error;
    if (ICF_NULL != p_rgm_ctxt->p_contact_uri_list)
    {
        /* free the contact list */
        icf_dbm_delete_address_list(p_ssa_pdb->p_glb_pdb,
            &(p_rgm_ctxt->p_contact_uri_list),
            p_ssa_pdb->p_ecode);
        p_rgm_ctxt->p_contact_uri_list = ICF_NULL;
    }

    if (ICF_TRUE == p_rgm_ctxt->auto_reg_flag)
    {
        /* Make Dummy contact address for Auto Register */
        icf_rgm_app_ctxt_st         dummy_app_ctxt;
        icf_port_memset((icf_void_t*)&dummy_app_ctxt,0,sizeof(icf_rgm_app_ctxt_st));
        dummy_app_ctxt.app_id = ICF_DUMMY_APP_ID;
        if(ICF_FAILURE == icf_ssa_make_contact_of_app_data(p_ssa_pdb,
                                                           &dummy_app_ctxt,
                                                           &p_contact_hdr,
                                                           p_ssa_pdb->p_ecode))
        {
                ret_val = ICF_FAILURE;
        }
        else
        {
            /* Got a valid Contact Header, Append to the List */
            if (sdf_listAppend(p_contact_addr_list, p_contact_hdr, &SdfError) == Sdf_co_fail)
            {
                ret_val = ICF_FAILURE;
            }
        }
    }
    if(ICF_SUCCESS == ret_val)
    {
        
        for(;loop_app<p_ssa_pdb->p_glb_cfg_data->max_applications;loop_app++)
        {
            icf_rgm_app_ctxt_st    *p_app_data =
                (icf_rgm_app_ctxt_st*)
                &(p_rgm_ctxt->p_app_data_list[loop_app]);
            
            if (ICF_FALSE == p_app_data->is_valid)
                continue;

            if (ICF_RGM_APP_DEREG_ON_PROBATION &
                    p_app_data->app_indicator)
                continue;
            
            if(ICF_FAILURE == 
                (ret_val = icf_ssa_make_contact_of_app_data(p_ssa_pdb,
                p_app_data,
                &p_contact_hdr,
                p_ssa_pdb->p_ecode)))
            {
                break;
            }
            else if(ICF_NULL != icf_port_strlen(p_ssa_pdb->trans_param))
            {
                if (ICF_FAILURE ==
                        icf_ssa_insert_param_in_addr_spec(
                            p_ssa_pdb, 
                            ((SipContactHeader*)
                             (p_contact_hdr->pHeader))->pAddrSpec,
                            (icf_uint8_t *)"transport",p_ssa_pdb->trans_param, &sdf_error))
                {
                    ret_val = ICF_FAILURE;
                    break;
                }
                icf_port_strcpy(p_ssa_pdb->trans_param,(icf_uint8_t *)"\0");
            }
            /* Got a valid Contact Header, Append to the List */
            if (sdf_listAppend(p_contact_addr_list, p_contact_hdr, &SdfError) == Sdf_co_fail)
            {
                ret_val = ICF_FAILURE;
                break;
            }

            
        }

#ifdef ICF_SIGCOMP_SUPPORT
        /* Check The Config data whether we are supporting 
        * sigcomp or not,If Yes then add comp=sigcomp param
        * in the contact header
        */
        if(ICF_TRUE == 
            p_glb_cfg_data->sigcomp_required)
        {
            Sdf_st_error  sdf_error;
            if(ICF_FAILURE == 
                icf_ssa_AddParamToContactHdrList(
                p_contact_addr_list,
                "comp=sigcomp",
                &sdf_error))
            {
            /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                *major ERROR*/
                ret_val = ICF_FAILURE;
            }
            
        }
        
#endif
    }
    /*Klocwork warning removal*/
    if((ICF_FAILURE == ret_val) && (ICF_NULL != p_contact_hdr))
    {
       ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                   p_contact_hdr,
                   ICF_MEM_COMMON,
                   p_ssa_pdb->p_ecode,
                   ret_val)
       ret_val = ICF_FAILURE;
    }
       
    return ret_val;
}     

/* Manually merged code for filter related things */

/*******************************************************************************
 * FUNCTION:        icf_ssa_match_string
 *
 * DESCRIPTION:     This function matches two strings based on the match_type  
 *                  given. Returns ICF_SUCCESS if the strings satisfy the 
 *                  match criteria, otherwise ICF_FAILURE is returned.
 *
 ******************************************************************************/

icf_return_t icf_ssa_match_string(
                                        INOUT icf_uint8_t *p_target, 
                                        INOUT icf_uint8_t *p_match_str, 
                                        INOUT icf_match_type_t match_type,
                                        OUT icf_boolean_t *p_match_success)
{
    icf_return_t ret_val = ICF_SUCCESS;
    *p_match_success = ICF_FALSE;
    switch(match_type)
    {
    case ICF_EXACT_STRING_MATCH :
        {
            if(0 == icf_port_strcmp(p_target,p_match_str))
                *p_match_success = ICF_TRUE;
            break;
        
        }
    case ICF_SUB_STRING_MATCH :
        {
            if(ICF_NULL != icf_port_strstr((const icf_int8_t *)p_target,(const icf_int8_t *)p_match_str))
                *p_match_success = ICF_TRUE;
            break;
        }
    default : break;
    }
    return ret_val;
}


/*******************************************************************************
 * FUNCTION:        icf_ssa_match_header_filter
 *
 * DESCRIPTION:     This function matches a SIP message against filters  
 *                  on Header Name and Header Content
 *
 ******************************************************************************/
icf_return_t icf_ssa_match_header_filter(
                                           INOUT  SipMessage            *p_sip_msg, /* Sip message */
                                           INOUT  icf_int_filter_st    *p_int_filter, /* Filter to be matched */
                                           OUT icf_boolean_t        *p_match,
                                           OUT icf_error_t        *p_ecode)
{
    icf_uint8_t i;
    icf_string_node_st *p_curr_node=ICF_NULL;
    en_HeaderType dType;
    SipError sip_err;
    icf_uint8_t *p_temp_buff,*p_remainingbuff,*p_token,*p_header_name;

    icf_boolean_t match_success = ICF_FALSE;
    icf_uint32_t dCount,temp_strlen;
    icf_uint8_t index;
    icf_return_t ret_val=ICF_SUCCESS;

    /* To remove warnings */
    p_ecode=p_ecode;

    p_temp_buff=p_remainingbuff=p_token=p_header_name=ICF_NULL;

    if(ICF_FILTER_BY_HEADER_CONTENT == p_int_filter->filter_type)
    {
        p_header_name = p_int_filter->target_header.str;
    }
    
    for(i=0,p_curr_node=p_int_filter->filter_expr.p_match_str_list;
        i<p_int_filter->filter_expr.count;
        i++,p_curr_node = (icf_string_node_st *)p_curr_node->p_next)
    {
        match_success = ICF_FALSE;
        if(ICF_FILTER_BY_HEADER_NAME == p_int_filter->filter_type)
        {
            p_header_name = p_curr_node->p_str;
        }

        /* get header type */
        icf_ssa_get_hdr_type_from_name(p_header_name, &dType, &sip_err);
        
        /* There can be multiple hdrs for that type */
        /* Get Header Count */
        if (SipFail == sip_getHeaderCount(p_sip_msg, dType, &dCount, \
            &sip_err))
        {
            return ICF_FAILURE;
        }
        
        /* Iterate through the list to get all headers of type dType */
        for(index = 0; ((index < dCount) && (ICF_FALSE == match_success)); index++)
        {
            
            /* Construct Header from SipMessage */
            /* Fix for CSR 1-7436195 */
            /* Coverity bug fix */
            if((SipFail == sip_getHeaderAsStringAtIndex(p_sip_msg,dType,((SIP_S8bit **)&p_temp_buff),\
                            index, &sip_err)) ||
                    (ICF_NULL == p_temp_buff))
                return ICF_FAILURE;
            temp_strlen = icf_port_strlen(p_temp_buff);
            /* Tokenize the : separated string into hdr name/value.*/
            p_token = icf_port_strchr(p_temp_buff,':');
        
            if (ICF_NULL == p_token)
            {                    
                fast_memfree(0, p_temp_buff, &sip_err);
                return ICF_FAILURE;
            }

            *p_token = '\0';
            p_token ++;
            /*p_token = icf_port_strtok(p_temp_buff,":",&p_remainingbuff); */
            
            if(ICF_FILTER_BY_HEADER_CONTENT == p_int_filter->filter_type)
            {
                if(0 != icf_port_strcmp(p_temp_buff,p_header_name))
                {
                    fast_memfree(0, p_temp_buff, &sip_err);
                    continue;
                }
                            /* Remove Leading Spaces from header content*/
                while(icf_port_isspace(*p_token))
                    p_token++;

            }
            else
            {
                p_token = p_temp_buff;
            }

            /* Compare the header with the match string
            * If matches, allocate memory and store in call ctxt,
            * else continue with next header from list.
            */
            icf_ssa_match_string(
                p_token, 
                p_curr_node->p_str,
                p_int_filter->match_type,
                &match_success);

            /* free the memory allocated for p_temp_buff */
            fast_memfree(0, p_temp_buff, &sip_err);
            p_temp_buff = p_remainingbuff = ICF_NULL;
        }

        /* break if match_all is true and match_success is false 
           or match_all is false and match_success is true */
        if(match_success != p_int_filter->filter_expr.match_all)
            break;
    }
    *p_match = match_success;
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_match_req_line_filter
 *
 * DESCRIPTION:     This function matches a SIP message against filters  
 *                  on Request Line 
 *
 ******************************************************************************/

icf_return_t icf_ssa_match_req_line_filter(
                                              INOUT  SipMessage            *p_sip_msg,
                                              INOUT  icf_int_filter_st    *p_int_filter,
                                              OUT icf_boolean_t        *p_match,
                                              OUT icf_error_t        *p_ecode)
{
    icf_string_node_st *p_curr_node=ICF_NULL;
    /* Codenomicon fixes: CSR 1-7132323: SPR 19484 */
	/* Req-line should be large string */
    icf_large_string_st target_str = {0,"\0"};
    icf_uint8_t i;
    icf_boolean_t match_success=ICF_FALSE;
    icf_return_t ret_val = ICF_SUCCESS;
     /* To remove warning */
     p_ecode=p_ecode;

    if( ICF_FAILURE == icf_ssa_get_reqline_as_string(p_sip_msg,target_str.str))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        for(i=0,p_curr_node=p_int_filter->filter_expr.p_match_str_list;
        i<p_int_filter->filter_expr.count;
        i++,p_curr_node = (icf_string_node_st *)p_curr_node->p_next)
        {    
            match_success = ICF_FALSE;
            icf_ssa_match_string(
                target_str.str,
                p_curr_node->p_str,
                p_int_filter->match_type,
                &match_success);
            if(match_success != p_int_filter->filter_expr.match_all)
                break;
        }
    }
    *p_match = match_success;
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_map_req_to_app_filter
 *
 * DESCRIPTION:     This function matches a SIP message against the application  
 *                  filter criteria to find out which application is the correct
 *                  one for handling the message. 
 *                  * The app id of first matching filter criteria is filled in 
 *                    p_app_id. 
 *                  * If none of the filters match then the default
 *                    application id is filled in p_app_id. 
 *                  * If none of the filters match and no default application is 
 *                    configured, then ICF_INVALID_APP_ID is filled in p_app_id.
 *
 ******************************************************************************/
icf_return_t icf_ssa_map_req_to_app_filter (
                                                  INOUT  icf_ssa_pdb_st *p_ssa_pdb,
                                                  INOUT  SipMessage        *p_sip_msg,
                                                  OUT icf_app_id_t   *p_app_id,
                                                  OUT icf_error_t    *p_ecode)
{
    
    icf_dbm_data_st    *p_dbm_data = ICF_NULL;
    icf_config_data_st *p_cfg_data = ICF_NULL;
    icf_app_conf_st    *p_app_conf = ICF_NULL;
    icf_app_id_t       forward_app_id,default_app_id ;
    icf_uint8_t        app_index;
    icf_boolean_t      match_success = ICF_FALSE;
    icf_return_t       ret_val = ICF_SUCCESS;
    SipReqLine            *pReqLine=ICF_NULL;
    SipAddrSpec           *p_addr_spec = ICF_NULL;
    SipError              sip_err;
    icf_uint8_t *p_start,*p_end,*p_target_str;
    icf_int8_t app_num_str[ICF_MAX_STR_LEN] = "";

    p_start = p_end = p_target_str = ICF_NULL;

    

    /* get dbm data for getting application data */
    if(ICF_FAILURE == icf_dbm_get_module_glb_data(
        p_ssa_pdb->p_glb_pdb ,
        (icf_int_module_id_t const)ICF_INT_MODULE_DBM,
        (icf_void_t *)&p_dbm_data,
        p_ecode))
    {
        return ICF_FAILURE;
    }
    
    /* get cfg data for getting the max number of applications*/
    if(ICF_FAILURE == icf_dbm_get_module_glb_data(     
        p_ssa_pdb->p_glb_pdb ,
        (icf_int_module_id_t const) ICF_INT_MODULE_CFG,
        (icf_void_t *)&p_cfg_data,
        p_ecode))
    {
        return ICF_FAILURE;
    }

    
    p_app_conf = p_dbm_data->p_app_conf;
    forward_app_id = default_app_id = ICF_INVALID_APP_ID;

    /* First - check the request line and extract user name
       If username is in the format of APP_xx, match the 
       message only with app-id xx */

    /* Get the user name from the message */
    if (SipFail == sip_getReqLineFromSipReqMsg(p_sip_msg,
                &pReqLine,&sip_err))
    {
        return ICF_FAILURE;
    }

#ifdef ICF_WITH_MUATK_2_2
    p_addr_spec = pReqLine->pAddrSpec;
#else
    p_addr_spec = pReqLine->pRequestUri;
#endif
    

    /*********************************************************************
    
    The code below tries to extract the application id
    for requests coming on the application contact. 
    if the user name in the request uri ends with "_n" where n is a number
    we first try to match the filter of the application n.
    This will override the normal sequential filter matching mechanism
    where the filters are matched in the order in which the applications
    are added. 
    This code can fail in a scenario where the username is not a contact 
    address but has a similar format and more than 1 application has the
    same filter criteria.
    ************************************************************************/

    if(SipAddrReqUri == p_addr_spec->dType)
    {
        p_end = icf_port_strchr((icf_uint8_t *)p_addr_spec->u.pUri,(icf_uint8_t)'@');
        p_target_str = (icf_uint8_t *)p_addr_spec->u.pUri;
        
    }

    else if(ICF_NULL != p_addr_spec->u.pSipUrl->pUser)
    {
        p_end = (icf_uint8_t *)p_addr_spec->u.pSipUrl->pUser + icf_port_strlen((icf_uint8_t *)p_addr_spec->u.pSipUrl->pUser);
        p_target_str = (icf_uint8_t *)p_addr_spec->u.pSipUrl->pUser;
    }
    if(p_end != ICF_NULL)
    {
        for(p_start = p_end - 1;p_start > p_target_str;p_start--)
        {
            if((*p_start == '_') || (*p_start < '0') || (*p_start > '9'))
            {
                break;
            }
        }

        if((p_start > p_target_str) && (*p_start == '_'))
        {
            icf_uint8_t temp_char = *p_end;
            p_start++;
            *p_end = '\0';
            icf_port_strcpy((icf_uint8_t *)app_num_str,(icf_uint8_t *)p_start);
            *p_end = temp_char;
        }
    }
    sip_freeSipReqLine(pReqLine);

    
    if(0 != icf_port_strcmp((icf_uint8_t *)app_num_str,(icf_uint8_t *)""))
    {
        icf_app_id_t app_num;
        app_num = icf_port_atoi(app_num_str);
        if(0 < app_num )
        {
            /* app id valid */
            for( app_index = 0;
            app_index < p_cfg_data->max_applications; app_index ++)
            {
                if(ICF_FALSE == p_app_conf[app_index].is_valid) 
                    continue; /* this index is invalid, move to next */

                if(app_num == p_app_conf[app_index].app_id)
                {
                    if(ICF_FAILURE == icf_ssa_match_app_filter(p_ssa_pdb,p_sip_msg,
                        p_app_conf + app_index,
                        &match_success,p_ecode))
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else if(ICF_TRUE == match_success)
                    {
                        /* Filter matched */
                        *p_app_id = app_num;
                        return ICF_SUCCESS;
                    }
                    break;
                }
            }
        }
    }

 
    /*iterate on all applications*/
    for (app_index = 0;app_index<p_cfg_data->max_applications;
        app_index++)
    {
        match_success=ICF_FALSE;  /*filter not matched till now*/
        if(ICF_FALSE == p_app_conf[app_index].is_valid) 
            continue; /* this index is invalid, move to next */
        
        /* filter_list empty and no default application found till now */

        if (ICF_NULL == p_app_conf[app_index].p_filter_list)
        {
            if (default_app_id == ICF_INVALID_APP_ID )
            {
                /* match supported methods */
                if(ICF_FAILURE == icf_ssa_match_app_methods(p_ssa_pdb,p_sip_msg,
                    p_app_conf + app_index,
                    &match_success,p_ecode))
                {
                    ret_val = ICF_FAILURE;
                    break; /* break out of the for loop */
                }
                else if(ICF_TRUE == match_success)
                {
                    /* if supported methods match*/
                    default_app_id = p_app_conf[app_index].app_id;
                }
            }
            continue;
        }

        if(ICF_FAILURE == icf_ssa_match_app_filter(p_ssa_pdb,p_sip_msg,
            p_app_conf + app_index,
            &match_success,p_ecode))
        {
            ret_val = ICF_FAILURE;
            break;
        }


        if(ICF_TRUE == match_success) 
            /* if current application's filter criteria matched the message */
        {
            forward_app_id = p_app_conf[app_index].app_id;
            break;
        }
    }
    /* No application matched, assign the default application as the handler */
    if(ICF_SUCCESS == ret_val)
    {
        if(ICF_INVALID_APP_ID == forward_app_id) 
            forward_app_id = default_app_id; 
        *p_app_id = forward_app_id;
    }
    else
    {
        *p_app_id = ICF_INVALID_APP_ID;
    }
    
    return ret_val;
}

#ifdef ICF_SESSION_TIMER
/*******************************************************************************
 * FUNCTION:        icf_ssa_set_session_timer_details
 *
 * DESCRIPTION:     This function sets the session timer related headers 
 *                    to the default values
 *
 ******************************************************************************/

icf_return_t icf_ssa_set_session_timer_details(
    icf_ssa_pdb_st        *p_ssa_pdb,
    Sdf_st_callObject     *p_call_obj)
{
    Sdf_st_error dErr;
    icf_return_t ret_val = ICF_TRUE;
    icf_session_timer_data_st      *p_session_timer_data = ICF_NULL;

    if (ICF_NULL == p_ssa_pdb ||
        ICF_NULL == p_ssa_pdb->p_ssa_ctxt ||
        ICF_NULL == p_ssa_pdb->p_ssa_ctxt->p_call_ctxt)
    {
        ret_val = ICF_FAILURE;
    }
    else if (ICF_FALSE == p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->session_timer_enable)
    {
       ICF_PRINT(((icf_uint8_t *)"\nSession Timer is Disabled,this function should not get hit.\n"))
       ret_val = ICF_FAILURE;
    }
    else
    if ((ICF_NULL == p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_session_timer_data))
    {
        ICF_PRINT(((icf_uint8_t *)"\nSession Timer is Either Disabled or sesion timer data is unavailable.\n"))
        ret_val = ICF_FAILURE;
    }
    /* Fix for crash in outgoing call */
    if(ICF_FAILURE == ret_val)
    {
        /*do nothing*/
    }
    else
    {
        ICF_PRINT(((icf_uint8_t *)"\n [SSA] Entered icf_ssa_set_session_timer_details"));
        p_session_timer_data = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_session_timer_data;

        if ((ICF_TRUE == p_session_timer_data->session_refresher_reqd)&&
            ((sdf_ivk_uaSetRefresher(p_call_obj,p_session_timer_data->session_timer_refresher, &dErr)) == Sdf_co_fail))
        {
            ret_val = ICF_FAILURE;
        }
        else if((ICF_SESSION_REFRESHER_NONE != 
		     p_session_timer_data->session_timer_refresher))
        { 
            /* FIX for SPR 13210, SSA will set session timer 
             value from configuration data */

            if((sdf_ivk_uaSetSessionInterval(p_call_obj, 
                p_session_timer_data->session_timer, &dErr)) == Sdf_co_fail)
            {
                ret_val= ICF_FAILURE;
            }
            else
            if((sdf_ivk_uaSetMinSe (p_call_obj, 
                p_session_timer_data->min_se,  &dErr)) == Sdf_co_fail)
            {
                ret_val= ICF_FAILURE;
            }
            else
            {
                p_call_obj->pSessionTimer->dIsSupportedTimer = Sdf_co_true;
            }
        }
    }
    ICF_PRINT(((icf_uint8_t *)"\n [SSA] Exited icf_ssa_set_session_timer_details"));
    return ret_val; 
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_start_session_timer
 *
 * DESCRIPTION:     This function Starts the Session timer if it is not 
 *                    started by UATK
 *
 ******************************************************************************/
Sdf_ty_retVal icf_ssa_start_session_timer(
                                             Sdf_st_callObject **ppCallObj,
                                             icf_glb_pdb_st *p_glb_pdb,
#ifdef ICF_WITH_MUATK_2_2
                                             Sdf_st_eventContext *pEventContext,
#endif
                                             Sdf_st_error *pErr)
{
    Sdf_ty_bool dIsActiveTimer;
    Sdf_ty_u32bit SessionInterval = 0;
    Sdf_ty_retVal ret_val = Sdf_co_success;
    icf_uint16_t  st_timer_range;
	icf_uint16_t  end_timer_range;
    Sdf_ty_u32bit tempSessionInterval = 0;
    Sdf_ty_refresher  dRefresher = Sdf_en_invalidRefesher;

    if(ICF_NULL == p_glb_pdb)
    {
       ICF_PRINT(((icf_uint8_t *)"p_glb_pdb is null"));
       return ICF_FAILURE;
    }

    ICF_FUNCTION_ENTER(p_glb_pdb);
    
    if ((sdf_ivk_uaIsActiveSessionTimer(*ppCallObj, &dIsActiveTimer, \
                    pErr)) == Sdf_co_fail)
    {
        ret_val = Sdf_co_fail;
    }
    /*dIsActiveTimer will be true when UATK starts session timer*/
    if(dIsActiveTimer==Sdf_co_false)
    {
        tempSessionInterval = (*ppCallObj)->pSessionTimer->dSessionInterval;

        if(491 == p_glb_pdb->p_call_ctx->inc_response_code)
        {
            /* If a UAC receives a 491 response to a re-INVITE, it SHOULD start a
             *  timer with a value T chosen as follows:
             *      1. If the UAC is the owner of the Call-ID of the dialog ID
             *      (meaning it generated the value), T has a randomly chosen value
             *      between 2.1 and 4 seconds in units of 10 ms.
             *      2. If the UAC is not the owner of the Call-ID of the dialog ID, T
             *      has a randomly chosen value of between 0 and 2 seconds in units
             *      of 10 ms.
             */
            /* In this case, the same session refresh timer is being used as retry after timer.
             */
            if(p_glb_pdb->p_call_ctx->common_bitmask & ICF_CALL_DIR)
            {
                /* incoming call */
                st_timer_range = ICF_CMN_INC_RACE_TIMER_LOW_LIMIT;
                end_timer_range = ICF_CMN_INC_RACE_TIMER_UP_LIMIT;
            }
            else
            {
                /* outgoing call */
                st_timer_range = ICF_CMN_OG_RACE_TIMER_LOW_LIMIT;
                end_timer_range = ICF_CMN_OG_RACE_TIMER_UP_LIMIT;
            }
            if(ICF_FAILURE == icf_cmn_generate_timer(&SessionInterval,
                        st_timer_range, end_timer_range))
            {
                ret_val = Sdf_co_fail;
            }

            /* In this case, UATK takes timer duration in seconds and divides it by 2 
             * if it is refersher. The below logic, starts the timer for 1 and 2 seconds only
             */
            SessionInterval /= 1000;
            SessionInterval += (0==SessionInterval)?1:0;
            SessionInterval *= 2;

            (*ppCallObj)->pSessionTimer->dSessionInterval = SessionInterval;


        }        
        else if(sdf_ivk_uaGetSessionInterval(*ppCallObj,&SessionInterval,pErr)
                == Sdf_co_fail)
        {
            ret_val = Sdf_co_fail;
        }
        else if(Sdf_co_fail == sdf_ivk_uaGetRefresher(*ppCallObj,&dRefresher,pErr))
        {  
            ret_val = Sdf_co_fail;
        }

        /* SPR 20158: In case the Refresher is not set as Local or Remote, Session
         * timer should not be started.
         */
        /*SPR 20193 Due to fix of SPR 20158 Now the dRefresher is having
         * invalid as default value but refresher is not extracted in 491
         case therefore the below condition never fulfills for 491 case
         and so the session timer did not get started again after RE-INV
         491 flow. As we are not using the dRefresher flag in 491 case 
         we should not check the same when starting session timer*/
        if((SessionInterval !=0) && (((Sdf_en_refresherLocal == dRefresher) ||
                                      (Sdf_en_refresherRemote == dRefresher)) ||
                (491 == p_glb_pdb->p_call_ctx->inc_response_code)))
        {
            /*Starts the session timer*/
#ifdef ICF_WITH_MUATK_2_2
            if ((sdf_ivk_uaStartRefresh(*ppCallObj,pEventContext, pErr)) == Sdf_co_fail)
#else
            if ((sdf_ivk_uaStartRefresh(*ppCallObj,pErr)) == Sdf_co_fail)
#endif
            {
                 ret_val = Sdf_co_fail;
            }
            else{
                ICF_PRINT(((icf_uint8_t *)"\n [SSA] Session Timer started by SSA"));
            }

            (*ppCallObj)->pSessionTimer->dSessionInterval = tempSessionInterval;
        }
    }
    else{
        ICF_PRINT(((icf_uint8_t *)"\n [SSA] Session Timer started by UATK"));
    }

    ICF_FUNCTION_EXIT(p_glb_pdb);
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_set_refresher_method
 *
 * DESCRIPTION:     This function sets the subsequest session refresh request
 *                    for session timer
 *                    
 *
 ******************************************************************************/
/* SPR 9591- Changed the function prototype to pass the SipMessage instead of the
 * transaction pointer as being done earlier
 */
Sdf_ty_retVal icf_ssa_set_refresher_method(SipMessage *p_message,
                                              icf_glb_pdb_st *p_glb_pdb,
                                              icf_ssa_ctxt_st **p_ssa_ctxt,
                                              Sdf_st_error *pErr)
{

    SipHeader dAllowHeader = {SipHdrTypeAny,SIP_NULL};
    SIP_S8bit *p_allow_value = SIP_NULL;
    Sdf_ty_u32bit no_of_allow_headers = 0;
    Sdf_ty_u32bit index =0;
    icf_session_timer_data_st      *p_session_timer_data = ICF_NULL;
    icf_return_t  ret_value = ICF_SUCCESS;
    icf_return_t  ret_val = ICF_SUCCESS;
    icf_boolean_t is_update_rcvd = ICF_FALSE;
    icf_config_data_st  *p_glb_cfg_data = ICF_NULL;
    icf_error_t    ecode = ICF_ERROR_NONE;
    icf_ssa_pdb_st       *p_ssa_pdb = ICF_NULL;
    
    if(ICF_NULL == p_glb_pdb)
    {
       ICF_PRINT(((icf_uint8_t *)"p_glb_pdb is null"));
       return ICF_FAILURE;
    }

    p_glb_pdb=p_glb_pdb;

    if (ICF_NULL == *p_ssa_ctxt)
    {
        ICF_PRINT(((icf_uint8_t *)"\nSSA Ctxt received is NULL.\n"))
        return ICF_FAILURE;
    }

    p_ssa_pdb = (icf_ssa_pdb_st *)((*p_ssa_ctxt)->p_ssa_pdb);

    if ((ICF_NULL == p_ssa_pdb)||
        (ICF_NULL == p_ssa_pdb->p_glb_pdb))
    {
        ICF_PRINT(((icf_uint8_t *)"\nSSA PDB/GLB PDB in SSA PDB is NULL.\n"))
        return ICF_FAILURE;
    }

    if (ICF_NULL == (*p_ssa_ctxt)->p_call_ctxt)
    {
        ICF_PRINT(((icf_uint8_t *)"\nUnable to Fetch Call Ctxt from SSA Ctxt.\n"))
        return ICF_FAILURE;
    }
    if ((ICF_TRUE == (*p_ssa_ctxt)->p_call_ctxt->session_timer_enable) &&
        (ICF_NULL == (*p_ssa_ctxt)->p_call_ctxt->p_session_timer_data))
    {
        ICF_PRINT(((icf_uint8_t *)"\nSession Timer is Either Disabled or sesion timer data is unavailable.\n"))
        return ICF_FAILURE;
    }
 
    ICF_FUNCTION_ENTER(p_glb_pdb);
  
    p_session_timer_data = (*p_ssa_ctxt)->p_call_ctxt->p_session_timer_data;

    /* If Remote UA supports UPDATE method then 
     * store update as subsequent session refresh request
     * otherwise store invite as subsequest session refresh request
     */
    ICF_SSA_SET_SESSION_REFRESH_REQ((*p_ssa_ctxt),
            Sdf_en_refresherInvite);

    if(ICF_NULL == p_ssa_pdb->p_line_data)
    {
        ICF_CHECK_IF_VAR_IS_NULL(p_glb_pdb, \
                p_ssa_pdb->p_ssa_ctxt, ret_value)
        if(ICF_FAILURE == ret_value) 
        {
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_glb_pdb);
            return ret_val;            
        }
        if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                    p_ssa_pdb->p_glb_pdb, p_ssa_pdb->p_ssa_ctxt->line_id,
                    &(p_ssa_pdb->p_line_data), p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
            ICF_PRINT(((icf_uint8_t*)"\[SSA]:Failure in fetching line data\n"));
            ICF_FUNCTION_EXIT(p_glb_pdb);
            return ret_val;
        }
    }
    
    if (ICF_FAILURE == icf_dbm_get_module_glb_data(
                p_glb_pdb,
                (icf_int_module_id_t)
                ICF_INT_MODULE_CFG,
                (icf_void_t *)&(p_glb_cfg_data),
                &ecode))
    {
        /*
         * If there was failure in retreiving date for
         * Module CFG return success and the refresh 
         * method would be INVITE
         */
        ICF_PRINT(((icf_uint8_t*)"\n[SSA]:Failure in GLB Cfg data retreival!!!"));
        return ret_val;
    }


    /*Start SPR 19189 */
    ICF_CHECK_IF_VAR_IS_NULL(p_glb_pdb, \
                     pErr, ret_value)
    if(ICF_FAILURE == ret_value)
    {
           ret_val = ICF_FAILURE;
           ICF_FUNCTION_EXIT(p_glb_pdb);
           return Sdf_co_fail;
    }
    /*End SPR 19189 */ 
    
    /* Get the Allow headers count and find for UPDATE method in all headers. if 
     * UPDATE method is present in Allow Header then set subsequent session
     * refresh request as Sdf_en_refresherUpdate */

    if(ICF_CFG_SESSION_REFRESH_METHOD_UPDATE == p_session_timer_data->session_refresher_method)
    {
        /* CSR 1-6188936: Check if allow header is received from remote and
		 * update is present in allow header then set refresher method as UPDATE
		 * else check for further conditions */
        if(ICF_ALLOW_HDR_RECEIVED & (*p_ssa_ctxt)->p_call_ctxt->allowed_value)
		{
		    if (ICF_ALLOW_HDR_RCVD_WO_UPDATE & (*p_ssa_ctxt)->p_call_ctxt->allowed_value)
			{
				ICF_SSA_SET_SESSION_REFRESH_REQ((*p_ssa_ctxt),Sdf_en_refresherInvite);	
			}
			else if(ICF_UPDATE_PRESENT_IN_ALLOW_HDR & (*p_ssa_ctxt)->p_call_ctxt->allowed_value)
			{
				ICF_SSA_SET_SESSION_REFRESH_REQ((*p_ssa_ctxt),Sdf_en_refresherUpdate);
			}
		}
        /* Get the Allow headers count and find for UPDATE method 
		 * in all headers. if UPDATE method is present in Allow Header 
		 * then set subsequent session refresh request as 
		 * Sdf_en_refresherUpdate */
        else if(sip_getHeader(p_message,SipHdrTypeAllow, &dAllowHeader,(SipError*)&(pErr->stkErrCode)) != SipFail)
        {
		    if(sip_getHeaderCount(p_message,SipHdrTypeAllow,
			                          &no_of_allow_headers,(SipError*)&(pErr->stkErrCode)) != SipFail)
            {
			    sip_freeSipHeader(&dAllowHeader);
				for(index = 0;index < no_of_allow_headers;index++)
				{
					if(sip_getHeaderAtIndex(p_message,
											SipHdrTypeAllow, &dAllowHeader, 
											index, (SipError*)&(pErr->stkErrCode)) != SipFail)
					{
						if(sip_getMethodFromAllowHdr(&dAllowHeader,&p_allow_value,
        					(SipError*)&(pErr->stkErrCode)) != Sdf_co_fail)
                        {
							if(strcmp(p_allow_value,"UPDATE") == 0)
							{
								ICF_SSA_SET_SESSION_REFRESH_REQ((*p_ssa_ctxt),Sdf_en_refresherUpdate);
                                is_update_rcvd = ICF_TRUE;
								break;
							}
						}
						sip_freeSipHeader(&dAllowHeader);
					}
				}
			}
			else
			{
				sip_freeSipHeader(&dAllowHeader);
			}
		}
        /* CSR 1-6178201 : If Application has set the bitmask for strict Update
		 * as session refresh method then set Update as session refresh method
		 * as allow header is not received.
		 */
        
        /*Fix for SPR: 19999 (Merged CSR 1-7547597 : SPR 19898)*/
		else if (((ICF_CALL_CONFIG_SESSION_REFRESH_METHOD_STRICT_UPDATE == 
								(ICF_CALL_CONFIG_SESSION_REFRESH_METHOD_STRICT_UPDATE &
								 p_glb_cfg_data->default_settings)) ||
                  (ICF_TRUE == p_ssa_pdb->p_line_data->session_refresh_method_strict_update)) &&
                  (ICF_ALLOW_HDR_RECEIVED != 
								 (ICF_ALLOW_HDR_RECEIVED & (*p_ssa_ctxt)->p_call_ctxt->allowed_value)))
		{        
			ICF_SSA_SET_SESSION_REFRESH_REQ((*p_ssa_ctxt),Sdf_en_refresherUpdate);
		}
    }

    /* Reset the ICF_ALLOW_HDR_RCVD_WO_UPDATE and ICF_ALLOW_HDR_RECEIVED bitmasks
     */
	(*p_ssa_ctxt)->p_call_ctxt->allowed_value &= ~(ICF_ALLOW_HDR_RCVD_WO_UPDATE);
	(*p_ssa_ctxt)->p_call_ctxt->allowed_value &= ~(ICF_ALLOW_HDR_RECEIVED);

    /* CSR 1-6223345: SPR 18865: If an 'Allow' header is received, the above
	   'for' loop breaks and the memory acquired for it is never freed.
       Thus freeing the memory here.
    */
	if(ICF_TRUE == is_update_rcvd)
	{
		sip_freeSipHeader(&dAllowHeader);
	}
 
    ICF_FUNCTION_EXIT(p_glb_pdb);
    return Sdf_co_success;
}
#endif /*Session Timer*/
#if 0
/*****************************************************************************
 * FUNCTION:        icf_ssa_is_update_present_in_allow_hdr
 *
 * DESCRIPTION:     This function checks that whether update
 *                  method is present in the ALLOW header of 
 *                  a received SIP message.
 *
 *****************************************************************************/
Sdf_ty_retVal icf_ssa_is_update_present_in_allow_hdr(SipMessage *p_message,
                                                     icf_glb_pdb_st *p_glb_pdb,
                                                     icf_ssa_ctxt_st **p_ssa_ctxt,
                                                     Sdf_st_error *pErr)
{

    SipHeader dAllowHeader;
    SIP_S8bit *p_allow_value;
    Sdf_ty_u32bit no_of_allow_headers = 0;
    Sdf_ty_u32bit index =0;

#ifdef ICF_TRACE_ENABLE
        icf_return_t    ret_val = 0;
#endif


    if(ICF_NULL == p_glb_pdb)
    {
       ICF_PRINT(("p_glb_pdb is null"));
       return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_glb_pdb);


    /* Get the Allow headers count and find for UPDATE method in all headers. if 
     * UPDATE method is present in Allow Header then set the flag allowed_value
     * in call context to ICF_UPDATE_ALLOWED_IN_200OK  */
      
    if(sip_getHeader(p_message,
        SipHdrTypeAllow, &dAllowHeader,(SipError*)&(pErr->stkErrCode)) != SipFail){

        if(sip_getHeaderCount(p_message,SipHdrTypeAllow,
            &no_of_allow_headers,(SipError*)&(pErr->stkErrCode)) != SipFail){
                        sip_freeSipHeader(&dAllowHeader);
            for(index = 0;index < no_of_allow_headers;index++){

                if(sip_getHeaderAtIndex(p_message,
                    SipHdrTypeAllow, &dAllowHeader,
                    index, (SipError*)&(pErr->stkErrCode)) != SipFail){

                    if(sip_getMethodFromAllowHdr(&dAllowHeader,&p_allow_value,
                        (SipError*)&(pErr->stkErrCode)) != Sdf_co_fail){

                        if(strcmp(p_allow_value,"UPDATE") == 0){
                                  
                            /* Setting value of allowed_value to ICF_UPDATE_ALLOWED_IN_200OK  */
                          (*p_ssa_ctxt)->p_call_ctxt->allowed_value = ICF_UPDATE_ALLOWED_IN_200OK ; 
                            
                        }
                    }
                                        sip_freeSipHeader(&dAllowHeader);
                }
            }
        }
                else
                {
                        sip_freeSipHeader(&dAllowHeader);
                }
    }

    ICF_FUNCTION_EXIT(p_glb_pdb);
    return Sdf_co_success;
}

#endif

/*****************************************************************************
 * FUNCTION:        icf_ssa_flush_alive_connections
 *
 * DESCRIPTION:     This function flushes all alive connections corresponding
 *                  to a call on TCP.This scenario occurs if we have 2 
 *                  TCP connections for the same dialog
 *
 *****************************************************************************/
icf_return_t icf_ssa_flush_alive_connections(
        icf_ssa_pdb_st        *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st          *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    icf_nw_interface_info_st nw_interface_info;
    icf_interface_info_st     interface_info;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if(ICF_NULL == p_ssa_ctxt)
    {
        return ICF_FAILURE;
    }
    else
    {
        p_ssa_ctxt->p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    }
    /* Changes for closing the connection fd if the connection 
       is non persistent
    */   
    if (p_ssa_ctxt->p_conn_table_req_entry != ICF_NULL)
    {
        if (ICF_TRUE == p_ssa_ctxt->p_conn_table_req_entry->is_persistent)
        {
            ICF_SSA_DEC_CONN_REF_COUNT(p_ssa_ctxt->p_conn_table_req_entry);
        }
        else
        {
             nw_interface_info.bitmap = ICF_INTF_INFO_PROTOCOL_TCP;
             nw_interface_info.receiver_fd = p_ssa_ctxt->p_conn_table_req_entry->conn_fd;

            interface_info.p_port_info = p_ssa_pdb->p_glb_pdb->p_glb_data->p_glb_port_info;
			interface_info.interface_type = ICF_INTF_TYPE_FIFO;
			interface_info.fd_id = nw_interface_info.receiver_fd;
			interface_info.interface_type = ICF_INTF_TYPE_TCP;
			ret_val = icf_port_tcp_non_blocking_peek(&interface_info,
			    (icf_void_t*)(((icf_global_port_info_st*)(p_ssa_pdb->
			    p_glb_pdb->p_glb_data->p_glb_port_info))->
			    ext_info.p_tcp_recv_buffer),
				p_ssa_pdb->p_ecode);
			if(ICF_FAILURE == ret_val)
			{
					/* Close the TCp socket on purge timer expiry if
					 * this is an incoming connection
					 */
					if(ICF_NULL == (ICF_TCP_DATA_SERVER_PORT & 
											p_ssa_pdb->p_ssa_glb_data->
                                    p_ssa_tcpm_conn_db->bitmap))
					{ 
							icf_es_close_tcp_conn(
											p_ssa_pdb->p_glb_pdb->p_glb_data->p_glb_port_info,
											&nw_interface_info, p_ssa_pdb->p_ecode);
							p_ssa_pdb->p_conn_table_entry = p_ssa_ctxt->p_conn_table_req_entry;
							icf_ssa_remove_conn_entry(p_ssa_pdb, p_ssa_ctxt->p_conn_table_req_entry->conn_fd);
							p_ssa_pdb->p_conn_table_entry = ICF_NULL;
							p_ssa_ctxt->p_conn_table_req_entry = ICF_NULL;
					}
			}
			else
			{
					ICF_PRINT(((icf_uint8_t *)"\n[SSA]:TCP Data pending on Socket %d.Socket Not Closed",interface_info.fd_id));
					ret_val = ICF_FAILURE;
			}
		}
		/* Changes for closing the connection fd if the connection 
       is non persistent
    */ 
   }  
    if ((ICF_NULL != p_ssa_ctxt->p_conn_table_resp_entry) &&(
            p_ssa_ctxt->p_conn_table_resp_entry != p_ssa_ctxt->p_conn_table_req_entry))
    {
        if (ICF_TRUE == p_ssa_ctxt->p_conn_table_resp_entry->is_persistent)
        {
            ICF_SSA_DEC_CONN_REF_COUNT(p_ssa_ctxt->p_conn_table_resp_entry);
        }
        else
        {
             nw_interface_info.bitmap = ICF_INTF_INFO_PROTOCOL_TCP;
             nw_interface_info.receiver_fd = p_ssa_ctxt->p_conn_table_resp_entry->conn_fd;
			 interface_info.p_port_info = p_ssa_pdb->p_glb_pdb->p_glb_data->p_glb_port_info;
			 interface_info.interface_type = ICF_INTF_TYPE_FIFO;
			interface_info.fd_id = nw_interface_info.receiver_fd;
			interface_info.interface_type = ICF_INTF_TYPE_TCP;
			ret_val = icf_port_tcp_non_blocking_peek(&interface_info,
			    (icf_void_t*)(((icf_global_port_info_st*)(p_ssa_pdb->
			    p_glb_pdb->p_glb_data->p_glb_port_info))->
			    ext_info.p_tcp_recv_buffer),
				p_ssa_pdb->p_ecode);
			if(ICF_FAILURE == ret_val)
			{
					/* Close the TCp socket on purge timer expiry if
					 * this is an incoming connection
					 */
					if(ICF_NULL == (ICF_TCP_DATA_SERVER_PORT & 
											p_ssa_pdb->p_ssa_glb_data->
                                    p_ssa_tcpm_conn_db->bitmap))
					{ 
							icf_es_close_tcp_conn(
											p_ssa_pdb->p_glb_pdb->p_glb_data->p_glb_port_info,
											&nw_interface_info, p_ssa_pdb->p_ecode);
							p_ssa_pdb->p_conn_table_entry = p_ssa_ctxt->p_conn_table_resp_entry;
							icf_ssa_remove_conn_entry(p_ssa_pdb, p_ssa_ctxt->p_conn_table_resp_entry->conn_fd);
							p_ssa_pdb->p_conn_table_entry = ICF_NULL;
							p_ssa_ctxt->p_conn_table_resp_entry = ICF_NULL;
					}
			}
			else
			{
					ICF_PRINT(((icf_uint8_t *)"\n[SSA]:TCP Data pending on Socket %d.Socket Not Closed",interface_info.fd_id));
					ret_val = ICF_FAILURE;
			}

        }
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


/****************************************************************************
 * FUNCTION:           icf_ssa_add_transport_param_in_contact_hdr
 *
 * DESCRIPTION:        This routine fetch contact headers from InitData
 *                     Check if transport is TCP or UDP then insert 
 *                     transport=tcp/udp paramater in contact header
 * 
 *****************************************************************************/
icf_return_t   icf_ssa_add_transport_param_in_contact_hdr(
        icf_ssa_pdb_st        *p_ssa_pdb,
        Sdf_st_initData          *p_init_data,
        Sdf_st_error             *p_error)
{
    icf_return_t       ret_val = ICF_SUCCESS;
    Sdf_ty_u32bit         dSize = 0;
    SipHeader             *p_contact_header = SIP_NULL;
    icf_uint32_t       iterator1 = 0;
    icf_int8_t        *p_param = ICF_NULL;
    icf_uint8_t        param[] = "udp";
    Sdf_st_error          sdf_error;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    
    if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_glb_cfg_data->self_mode)
    || (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_glb_cfg_data->self_mode))
    {
        Sdf_mc_strdup(p_param, (icf_int8_t*)param);
        if (ICF_TRANSPORT_TYPE_UDP != p_ssa_pdb->p_ssa_ctxt->transport &&
            ICF_NULL != p_param)
        {
            icf_port_strcpy((icf_uint8_t*)p_param,(icf_uint8_t *)"tcp");
        }
    }
    else if (ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->p_glb_cfg_data->self_mode)
    {
        Sdf_mc_strdup(p_param, (icf_int8_t*)param);
    }
    else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_glb_cfg_data->self_mode)
    {
        Sdf_mc_strdup(p_param,(icf_int8_t *)"tls");
    }
    else
    {
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ICF_SUCCESS;
    } /* else */

    if(ICF_NULL == p_param)
    {
        ret_val = ICF_FAILURE;
    }
    /*Get the Size of Conatact Header List*/
    else if(Sdf_co_fail == sdf_listSizeOf(&(p_init_data->slContact),&dSize,p_error))
    {
        ret_val = ICF_FAILURE;
    }
    /*If list contains elements*/
    else if(dSize !=0)
    {
        /*
        SipContactParam  contactParam;
        contactParam.dType = SipCParamExtension;
        contactParam.u.pExtensionAttr = param;
        */

        /*Fetch all the Contact headers from initdata*/
        for(iterator1=0; iterator1<dSize; iterator1++)
        {
            if(Sdf_co_fail == sdf_listGetAt(&(p_init_data->slContact),
                        iterator1, (Sdf_ty_pvoid *)&p_contact_header,p_error))
            {
                ret_val = ICF_FAILURE;
                break;
            }
            else if (ICF_FAILURE ==
                    icf_ssa_insert_param_in_addr_spec(
                        p_ssa_pdb, 
                        ((SipContactHeader*)
                         (p_contact_header->pHeader))->pAddrSpec,
                        (icf_uint8_t*)"transport", (icf_uint8_t*)p_param, &sdf_error))
            {
                ret_val = ICF_FAILURE;
            }
            /*
               else if (Sdf_co_fail == 
               sip_insertContactParamAtIndexInContactHdr(p_contact_header,
                        &contactParam, 0, &sip_err))
            {
                ret_val = ICF_FAILURE;
                break;
            }*/
        } /* for(iterator1=0; iterator1<dSi... */

    } /* if(dSize !=0) */

    ICF_MEMFREE(
            p_ssa_pdb->p_glb_pdb,
            p_param,
            ICF_MEM_COMMON,
            p_ssa_pdb->p_ecode,
            ret_val)

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;
} /* icf_ssa_add_param_in_contact_hdr */



/*******************************************************************************
 * FUNCTION:        icf_ssa_insert_param_in_addr_spec
 *
 * DESCRIPTION:     This function inserts parametrs into the addr spec passed
 *                  to it as a paramter
 *                  1. The parmater name and value are also passed to this
 *                     function
 *
 ******************************************************************************/
icf_return_t icf_ssa_insert_param_in_addr_spec(
        icf_ssa_pdb_st   *p_ssa_pdb,
        SipAddrSpec    *p_addr_spec,
        icf_uint8_t *p_param,
        icf_uint8_t *p_value,
        Sdf_st_error *p_sdf_error)
{
    /* CSR_1_7199359 Merged SPR 19672 Start */
    icf_uint8_t  param_list_string[ICF_MAX_STR_LEN] = "\0";
    /* CSR_1_7199359 Merged SPR 19672 End */

    icf_return_t ret_val = ICF_SUCCESS;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (p_addr_spec) { 
	switch (p_addr_spec->dType)
    {
        case SipAddrReqUri:
            {
                SIP_S8bit *p_temp = SIP_NULL;
                icf_uint8_t    uri_size = ICF_NULL;

                /* In this case we have to make the string completely */
                icf_port_strcat(param_list_string,(icf_uint8_t *)";");
                icf_port_strcat(param_list_string,p_param);
                
                if (ICF_NULL == p_addr_spec->u.pUri)
                {
                   return ICF_FAILURE;
                }
                                
                if((Sdf_co_null != p_value) && 
                    (0 < icf_port_strlen((icf_uint8_t *)p_addr_spec->u.pUri)))
                {
                    icf_port_strcat(param_list_string,(icf_uint8_t *)"=");
                    icf_port_strcat(param_list_string,p_value);
                }

                /* 
                 * uri_size is the total size of the TEL URL
                 * Since memory is not allocated for the paramters,
                 * we shall allocate memory for a string which
                 * shall hold the TEL URL along with the parameters.
                 */
                uri_size = (icf_uint8_t)(icf_port_strlen((icf_uint8_t *)p_addr_spec->u.pUri) +
                    icf_port_strlen(param_list_string)+1 );

                /*Memory allocation for pUri in addr spec*/
                ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                        uri_size,
                        ICF_MEM_COMMON,
                        p_temp,
                        ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode,
                        ret_val)


                /*
                 * Copy the contents of the existing TEL URL
                 * into the string p_temp ,the memory for which
                 * has been allocated in the previous step
                 * Concate the paramter(name-value) pair
                 */
                icf_port_strcpy((icf_uint8_t *)p_temp, (icf_uint8_t *)p_addr_spec->u.pUri);
                icf_port_strcat((icf_uint8_t *)p_temp, (icf_uint8_t *)param_list_string);

                /* Free the memory for the existing uri*/
                ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_addr_spec->u.pUri,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)

                /*
                 * Now assign the pointer to the newly formed TEL URL
                 * to the SIP address spec
                 */
                p_addr_spec->u.pUri = p_temp;
                break;
            }
        case SipAddrSipUri:
        case SipAddrSipSUri:
            {
                SipList *p_dest = &((p_addr_spec->u).pSipUrl->slParam);

                if(Sdf_co_fail == icf_ssa_append_par_to_sip_list(
                            p_ssa_pdb,p_dest,
                            p_param,p_value,p_sdf_error))
                {
                    ret_val = ICF_FAILURE;
                } /* "transport",tp,p_err)) */
            } /* case SipAddrSipSUri: */
            break;
        default:
            break;
    } /* switch (pSipAddrSpec->dType) */
	}
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} /* icf_ssa_insert_param_in_addr_spec */


/*******************************************************************************
 * FUNCTION:        icf_ssa_append_par_to_sip_list
 *
 * DESCRIPTION:     This function appends a parameter to given SIP list
 *
 ******************************************************************************/
icf_return_t icf_ssa_append_par_to_sip_list(
        icf_ssa_pdb_st      *p_ssa_pdb,
        SipList                *p_dest,
        icf_uint8_t         *p_param_name,
        icf_uint8_t         *p_paramValue,
        Sdf_st_error           *p_err)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_return_t     dummy_ret_val = ICF_SUCCESS;
    SipParam            *p_temp_param = Sdf_co_null;
    Sdf_ty_s8bit        *p_dup_value = Sdf_co_null;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if(SipFail == sip_initSipParam(&p_temp_param,
                (SipError *)&(p_err->stkErrCode)))
    {
        ret_val = ICF_FAILURE;
    }
    else if(Sdf_co_null != p_temp_param)
    {
        p_temp_param->pName = (SIP_S8bit*)STRDUPACCESSOR((const icf_int8_t *)p_param_name);
        if(Sdf_co_null != p_paramValue)
        {
            p_dup_value = (SIP_S8bit*)STRDUPACCESSOR((const icf_int8_t *)p_paramValue);
            
            if (ICF_NULL != p_dup_value)
            {
                if (0 != icf_port_strlen((icf_uint8_t*)p_dup_value))
                {
                    if (SipFail == sip_listAppend(
                                &(p_temp_param->slValue),
                                p_dup_value,
                                (SipError *)&(p_err->stkErrCode)))
                    {
                        ret_val = ICF_FAILURE;
                    }
                }
                else
                {
                    ICF_MEMFREE(
                            p_ssa_pdb->p_glb_pdb,
                            p_dup_value,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            dummy_ret_val)
                }
            }
        }
    }
    if (ICF_FAILURE != ret_val)
    {
        if ( SipFail == sip_listAppend(
                    p_dest, p_temp_param,
                    (SipError *)&(p_err->stkErrCode)))
        {
            ret_val = ICF_FAILURE;
        }
    }

    if (ICF_FAILURE == ret_val)
    {
        if ( Sdf_co_null != p_dup_value)
        {
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_dup_value,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
        }

        if (Sdf_co_null != p_temp_param)
        {
             if(Sdf_co_null != p_temp_param->pName)
             {
               ICF_MEMFREE(
                       p_ssa_pdb->p_glb_pdb,
                       p_temp_param->pName,
                       ICF_MEM_COMMON,
                       p_ssa_pdb->p_ecode,
                       dummy_ret_val)
              } /* if(p_temp_param->pName != Sdf_co... */

            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_temp_param,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
        }
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val ;
} /* icf_ssa_append_par_to_sip_list */


/*****************************************************************************
 * FUNCTION:        icf_ssa_check_for_trans_param
 *
 * DESCRIPTION:     Function to derive transport mode based on proxy mode
 *                  and mode received in remote party address in create call
 * This function checks for combinations of trnasport param given in req UR
 * peer mode ( proxy/registrar) as configured with ICF to determine if
 * revert is possible and to store the decided transport in ssa ctxt
 * transport_mode - this should be given by calling fn, based on  whether it 
 * is registrar or for proxy
 * p_param_val - is the pointer to transport string given by App for the
 * request in processing as part of the request URI
 *****************************************************************************/
icf_return_t icf_ssa_check_for_trans_param(
        icf_ssa_pdb_st        *p_ssa_pdb,
        icf_transport_mode_et transport_mode,
        icf_uint8_t           *p_param_val,
        icf_boolean_t         is_outbound_defined)
{
    icf_return_t   ret_val = ICF_SUCCESS;
    icf_transport_mode_et remote_mode;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (ICF_NULL != p_param_val)
    {
        /* CSR 1-6421580 : SPR 19024 */
		/* This comparison should be case insensitive */
        if (!icf_port_strcmpi(p_param_val, (icf_uint8_t *)"tcp"))
            remote_mode = ICF_TRANSPORT_TYPE_TCP;
        else if (!icf_port_strcmpi(p_param_val, (icf_uint8_t *)"tls"))
            remote_mode = ICF_TRANSPORT_TYPE_TLS;
        else
            remote_mode = ICF_TRANSPORT_TYPE_UDP;
    }
    else
        remote_mode = ICF_TRANSPORT_MODE_BOTH;

    /*If remote transport mode is present, then derive transport mode
     * on the basis of transport_mode and rem_mode in create_call*/
    if (ICF_NULL != p_param_val)
    {
        if (ICF_TRANSPORT_MODE_BOTH == transport_mode)
        {
            if (ICF_TRANSPORT_TYPE_TCP == remote_mode)
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else if (ICF_TRANSPORT_TYPE_UDP == remote_mode)
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else if (ICF_TRANSPORT_TYPE_TLS == remote_mode)
            {
               ret_val = ICF_FAILURE;
            }
            else
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_MODE_BOTH;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_TRUE;
            }
        }
        else if ((ICF_TRANSPORT_TYPE_TCP == transport_mode)) 
        {
            if (ICF_TRANSPORT_TYPE_TCP == remote_mode)
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else if (ICF_TRANSPORT_TYPE_UDP == remote_mode)
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_TRANSPORT_TYPE_TLS == remote_mode)
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_MODE_BOTH;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
        }
        else if (ICF_TRANSPORT_TYPE_UDP == transport_mode)
        {
            if (ICF_TRANSPORT_TYPE_TCP == remote_mode)
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_TRANSPORT_TYPE_TLS == remote_mode)
            {
                ret_val = ICF_FAILURE;
            }
            else if (ICF_TRANSPORT_TYPE_UDP == remote_mode)
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_MODE_BOTH;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
        }
        else if (ICF_TRANSPORT_TYPE_TLS == transport_mode)
        {
            if (ICF_TRANSPORT_TYPE_TLS == remote_mode)
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TLS;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else if ((ICF_TRANSPORT_TYPE_UDP == remote_mode) && (ICF_FALSE == is_outbound_defined))
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else if ((ICF_TRANSPORT_TYPE_UDP == remote_mode) && (ICF_TRUE == is_outbound_defined))
            {
                ret_val = ICF_FAILURE;
            }
            else if ((ICF_TRANSPORT_TYPE_TCP == remote_mode) && (ICF_FALSE == is_outbound_defined))
            {
                p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
                p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
            }
            else if ((ICF_TRANSPORT_TYPE_TCP == remote_mode) && (ICF_TRUE == is_outbound_defined))
            {
                ret_val = ICF_FAILURE;
            }
        }
    } /* if (ICF_TRUE == remote_mode... */
    else
    {
        p_ssa_pdb->send_trans_param = ICF_FALSE;

        if ((ICF_TRANSPORT_TYPE_TCP == transport_mode) ||
                (ICF_TRANSPORT_MODE_BOTH == transport_mode))
        {
            p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
            p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
        } /* if (ICF_TRANSPORT_TYPE_TCP ... */
        else if (ICF_TRANSPORT_TYPE_UDP == transport_mode)
        {
            p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
            p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
        }
        else if (ICF_TRANSPORT_TYPE_TLS == transport_mode)
        {
            p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TLS;
            p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
        }
#if 0
        else
        {
            p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_MODE_BOTH;
            p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_TRUE;
        }
#endif
    }
    if (ICF_TRANSPORT_MODE_BOTH == 
            p_ssa_pdb->p_ssa_ctxt->transport )
    {
        p_ssa_pdb->p_ssa_ctxt->transport = 
            p_ssa_pdb->p_glb_cfg_data->self_mode;
    }
    if ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport) && 
        (ICF_NULL == p_ssa_pdb->p_glb_cfg_data->p_tls_init_data))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Error : TLS data is not configured and derived transport mode is TLS "));
    ret_val = ICF_FAILURE;
    } 
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} /* icf_ssa_check_for_trans_param */

/*******************************************************************************
 * FUNCTION:        icf_ssa_check_for_new_conn
 *
 * DESCRIPTION:     This function checks if new connection received, then it
 *                  updates it in ssa context
 *
 ******************************************************************************/
icf_return_t   icf_ssa_check_for_new_conn(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT  icf_ssa_ctxt_st *p_ssa_ctxt,
        INOUT  Sdf_st_callObject *p_call_obj)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    /*Following is used to hold the ssa ctxt stored in 
    p_ssa_pdb, we need to invoke the TCPSM with ssa_pdb having the 
    original ssa ctxt.  we will use this variable to 
    store whateer value is in the ssa_pdb.p_ssa_ctxt and
    then restore it after we are done with processing*/
    icf_ssa_ctxt_st      *p_temp_ssa_ctxt = ICF_NULL;
    icf_ssa_tcpm_conn_data_st  **p_p_temp_conn = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    

    if (p_ssa_pdb->dMsgType == SipMessageRequest)
        p_p_temp_conn = &(p_ssa_ctxt->p_conn_table_resp_entry);
    else
        p_p_temp_conn = &(p_ssa_ctxt->p_conn_table_req_entry);

    if (ICF_NULL == *p_p_temp_conn)
    {
        *p_p_temp_conn = 
            p_ssa_pdb->p_conn_table_entry;
#ifdef ICF_SECURE_SUPPORT
        if (p_ssa_pdb->p_conn_table_entry->prot_conn_bitmask & ICF_TRANSPORT_TLS)
        {
            p_ssa_ctxt->p_conn_table_resp_entry = p_ssa_pdb->p_conn_table_entry;
            p_ssa_ctxt->p_conn_table_req_entry = p_ssa_pdb->p_conn_table_entry;
        }
#endif

    } /* if (ICF_MAX_NO_OF_PERSISTENT_CONNECTIONS == p_s... */
    else
    {
        p_temp_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;

        p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;
        /*Invoke TCP-SM to replace ssa_ctx connection
         * with ssa_pdb connection*/
        ICF_SSA_IVK_TCPSM_FRM_CTX(p_ssa_pdb, p_ssa_ctxt, \
            ICF_SSA_TCPM_REPLACE_CONN_FD, ret_val)
        p_ssa_pdb->p_ssa_ctxt = p_temp_ssa_ctxt;
        *p_p_temp_conn = 
            p_ssa_pdb->p_conn_table_entry;
#ifdef ICF_SECURE_SUPPORT
        if (p_ssa_pdb->p_conn_table_entry->prot_conn_bitmask & ICF_TRANSPORT_TLS)
        {
            p_ssa_ctxt->p_conn_table_resp_entry = p_ssa_pdb->p_conn_table_entry;
            p_ssa_ctxt->p_conn_table_req_entry = p_ssa_pdb->p_conn_table_entry;
        }
#endif

    } /* else */    

    if (ICF_SUCCESS == ret_val)
    {
        ret_val = icf_ssa_copy_conn_fd_to_callobj(
                p_ssa_pdb,
                p_call_obj,
                p_ssa_pdb->p_conn_table_entry->conn_fd);
    } /* if (ICF_SUCCESS == ret_val) */

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;
} /* INOUT  icf_ssa_pdb_st *p_ssa... */

/*******************************************************************************
 * FUNCTION:        icf_ssa_copy_conn_fd_to_callobj
 *
 * DESCRIPTION:     This function copies new connection FD to call object
 *
 ******************************************************************************/
icf_return_t   icf_ssa_copy_conn_fd_to_callobj(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT  Sdf_st_callObject *p_call_obj,
        INOUT    icf_int32_t    conn_fd)
{
        icf_return_t     ret_val = ICF_SUCCESS;
    Sdf_st_listIterator dListIterator;
    Sdf_st_error        sdf_error;
#ifdef ICF_SECURE_SUPPORT
    icf_ssa_ctxt_st     *p_ssa_ctxt = (icf_ssa_ctxt_st *)p_call_obj->pAppData->pData;
#endif
 

    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }  
    p_ssa_pdb=p_ssa_pdb;  
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if ( ICF_NULL != p_call_obj->pUasTransaction)
    {
        p_call_obj->pUasTransaction->dSocket.dSockfd = conn_fd;
#ifdef ICF_SECURE_SUPPORT                
        if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
        {
            p_call_obj->pUasTransaction->dSocket.dProtocol =
                Sdf_en_protoTls;
        }
        else
        {
#endif
            p_call_obj->pUasTransaction->dSocket.dProtocol =
                Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
        }
#endif
    }
    if ( ICF_NULL != p_call_obj->pUacTransaction)
    {
        p_call_obj->pUacTransaction->dSocket.dSockfd = conn_fd;
#ifdef ICF_SECURE_SUPPORT                
        if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
        {
            p_call_obj->pUacTransaction->dSocket.dProtocol =
                Sdf_en_protoTls;
        }
        else
        {
#endif
            p_call_obj->pUacTransaction->dSocket.dProtocol =
                Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
        }
#endif
    }
    sdf_listInitIterator(&(p_call_obj->slOverlapTransInfo), \
            &dListIterator, &sdf_error);

    while (dListIterator.pCurrentElement != Sdf_co_null)
    {
        Sdf_st_overlapTransInfo *p_overlap_trans_info;

        p_overlap_trans_info = (Sdf_st_overlapTransInfo *) \
            (dListIterator.pCurrentElement->pData);
        if ( Sdf_co_null != p_overlap_trans_info)
        {
            p_overlap_trans_info->dSocket.dSockfd = conn_fd;
#ifdef ICF_SECURE_SUPPORT                
            if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
            {
                 p_overlap_trans_info->dSocket.dProtocol =
                     Sdf_en_protoTls;
            }
            else
            {
#endif            
                 p_overlap_trans_info->dSocket.dProtocol =
                     Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT                
            }
#endif        
        }
        sdf_listNext(&dListIterator, &sdf_error);
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        
    return ret_val;
} /* INOUT    icf_uint16_t   conn_f... */

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_method_name
 *
 * DESCRIPTION:     This utility function will be invoked to populate the method
 *                     name in the string function argument. The function will 
 *                     check the bitmaks and accordingly get the function name.
 *                     The function is invoked from within the function 
 *                     icf_ssa_send_dialog_initiator_msg, when attempting to 
 *                     revert to UDP if the connection on TCP has failed.
 *
 ******************************************************************************/
icf_return_t    icf_ssa_get_method_name(
        INOUT   icf_uint32_t  bitmask,
        INOUT   icf_uint8_t    *pMethod
)
{
    if (ICF_SSA_REG_PENDING & bitmask)
    {
        icf_port_strcpy(pMethod, (icf_uint8_t *)"REGISTER");
    }
    else
       if (ICF_SSA_SUBS_PENDING & bitmask)
       {
           icf_port_strcpy(pMethod,(icf_uint8_t *)"SUBSCRIBE");
       }
    else
    if (ICF_SSA_REFER_PENDING & bitmask)
    {
        icf_port_strcpy(pMethod, (icf_uint8_t *)"REFER");
    }
    else
    if (ICF_SSA_PUBLISH_PENDING & bitmask)
    {
        icf_port_strcpy(pMethod, (icf_uint8_t *)"PUBLISH");
    }
    else
    if (ICF_SSA_OPTION_PENDING & bitmask)
    {
        icf_port_strcpy(pMethod, (icf_uint8_t *)"OPTIONS");
    }
    else
    if (ICF_SSA_MESSAGE_PENDING & bitmask)
    {
        icf_port_strcpy(pMethod, (icf_uint8_t *)"MESSAGE");
    }
    else
    {
        return ICF_FAILURE;
    }
    return ICF_SUCCESS;
}


/*******************************************************************************
 * FUNCTION:        icf_ssa_reset_fd_in_uaCallObj
 *
 * DESCRIPTION:     This function will invoke sdf_ivk_uaResetSockFd in a loop so 
 *                    that all the fd's are reset in the CallObj. 
 *
 ******************************************************************************/
void icf_ssa_reset_fd_in_uaCallObj(
    INOUT     Sdf_st_callObject        *pCallObject,
    INOUT         icf_uint16_t            sockFd)
{
    /* local variables */
    Sdf_ty_retVal    ret_val = Sdf_co_success;
    Sdf_st_error    sdf_error;

    do 
    {
        ret_val = sdf_ivk_uaResetSockFd(pCallObject,
                (Sdf_ty_socketId)sockFd, &sdf_error);
    } while (ret_val == Sdf_co_success);

    return;
}


#ifdef ICF_IPSEC_ENABLED
/*******************************************************************************
 * FUNCTION:        icf_ssa_get_sec_client_string
 *
 * DESCRIPTION:     This function will create the string (from the security 
 *                    param structure) that will be inserted in the Security 
 *                    Client Header in the outgoing Register Request
 *
 ******************************************************************************/
icf_return_t    icf_ssa_get_sec_client_string (
        INOUT         icf_ssa_pdb_st                  *p_ssa_pdb,
        INOUT         icf_uint8_t                     **p_p_str,
        INOUT            icf_ipsec_security_params_st   *p_sec_params
        )
{
    /* local variables */
    icf_error_t                      ecode = ICF_NULL;
    icf_return_t                     ret_val    = ICF_SUCCESS;
    icf_rgm_glb_data_st              *p_dbm_rgm_glb_data = ICF_NULL;
    icf_uint8_t                      tmpStr[50] = "\0";
    icf_uint8_t                      count =0;
    icf_uint8_t                      *p_str = ICF_NULL;

    /* get memory for the the p_str argument */
    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
         ICF_MAX_SEC_HDR_LEN,
         ICF_MEM_COMMON, 
         (icf_void_t*)(p_str),
         ICF_RET_ON_FAILURE, 
         &ecode, ret_val);

    /* make the string to be inserted in the Security Param header */
    icf_port_strcpy(p_str, "ipsec-3gpp; alg=");
    /* fetch the RGM glb data to get self algos */
    ret_val = icf_dbm_get_module_glb_data(
                 p_ssa_pdb->p_glb_pdb,
                 (icf_int_module_id_t)(ICF_INT_MODULE_REGM),
                 (icf_void_t **)(&p_dbm_rgm_glb_data),
                 &ecode);     
             
    ICF_ASSERT(
        p_ssa_pdb->p_glb_pdb,(ICF_NULL != p_dbm_rgm_glb_data))
    while (count < ICF_MAX_SUPP_I_ALGO)
    {
        icf_port_strcpy(
            tmpStr,
            p_dbm_rgm_glb_data->p_ue_algo_list->integrity_algo[count].str);
                
        icf_port_strcat(p_str, tmpStr);
        count += 1;
        if ((ICF_NULL != 
            p_dbm_rgm_glb_data->p_ue_algo_list->integrity_algo[count].str_len) &&
            (count < ICF_MAX_SUPP_I_ALGO))
        {
            icf_port_strcat(p_str, ",");
        }
        tmpStr[0] ='\0';
    }
    
    count =0;
    icf_port_strcat(p_str, "; ealg=");
    while (count < ICF_MAX_SUPP_E_ALGO)
    {
        icf_port_strcpy(
                tmpStr,
                p_dbm_rgm_glb_data->p_ue_algo_list->encryption_algo[count].str);
                
        icf_port_strcat(p_str, tmpStr);
        count += 1;
        if ((count < ICF_MAX_SUPP_E_ALGO) &&
            (ICF_NULL != 
            p_dbm_rgm_glb_data->p_ue_algo_list->encryption_algo[count].str_len))
            
        {
            icf_port_strcat(p_str, ",");
        }
        tmpStr[0] ='\0';
    }
    
    icf_ssa_get_sec_string(p_str, p_sec_params);

    *p_p_str = p_str;

    return ret_val;

}

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_sec_string
 *
 * DESCRIPTION:     This function will create the string (from the security 
 *                    param structure) that will be inserted in the Security 
 *                    Client/Verfiy Header in the outgoing Protected messages  
 *
 ******************************************************************************/
icf_void_t    icf_ssa_get_sec_string(
        INOUT     icf_uint8_t                        *pString,
        INOUT     icf_ipsec_security_params_st        *p_sec_params
)
{
    /* local variables */
    icf_uint8_t        tmpString[50];

    icf_port_strcat(pString, "; spi-c=");
    icf_port_sprintf( tmpString, "%d", p_sec_params->spi_c);
    icf_port_strcat(pString, tmpString);

    icf_port_strcat(pString, "; spi-s=");
    icf_port_sprintf( tmpString, "%d", p_sec_params->spi_s);
    icf_port_strcat(pString, tmpString);
    
    icf_port_strcat(pString, "; port-c=");
    icf_port_sprintf( tmpString, "%d", p_sec_params->port_c);
    icf_port_strcat(pString, tmpString);
        
    icf_port_strcat(pString, "; port-s=");
    icf_port_sprintf( tmpString, "%d", p_sec_params->port_s);
    icf_port_strcat(pString, tmpString);

    return;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_sec_verify_string
 *
 * DESCRIPTION:     This function will create the string (from the security 
 *                    param structure) that will be inserted in the Security 
 *                    Verify Header in the outgoing Protected Messages  
 *
 ******************************************************************************/
icf_return_t    icf_ssa_get_sec_verify_string (
        INOUT         icf_ssa_pdb_st            *p_ssa_pdb,
        INOUT         icf_uint8_t                **p_str,
        INOUT         icf_ipsec_sa_context_st    *p_sec_context
        )
{
    /* local variables */
    icf_error_t                ecode = ICF_NULL;
    icf_return_t                ret_val    = ICF_SUCCESS;
    icf_uint8_t                tmpStr[50];

    /* get memory for the the p_str argument */
    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
         ICF_MAX_SEC_HDR_LEN,
         ICF_MEM_COMMON, 
         (icf_void_t*)(*p_str),
         ICF_RET_ON_FAILURE, 
         &ecode, ret_val);

    /* make the string to be inserted in the Security Param header */
    icf_port_strcpy((*p_str), "ipsec-3gpp; q=");
    icf_port_sprintf(tmpStr, "%s", p_sec_context->p_q_value);
    icf_port_strcat((*p_str), tmpStr);

    icf_port_strcat((*p_str), "; alg=");
    icf_port_sprintf(tmpStr,"%s",p_sec_context->p_integrity_algo);    
    icf_port_strcat((*p_str), tmpStr);

    if (ICF_NULL != p_sec_context->p_encryption_algo)
    {
        icf_port_strcat((*p_str), "; ealg=");
        icf_port_sprintf(tmpStr,"%s",p_sec_context->p_encryption_algo);    
        icf_port_strcat((*p_str), tmpStr);
    }

    icf_ssa_get_sec_string((*p_str), 
        p_sec_context->p_proxy_security_params);            
    
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_fetch_sa_context
 *
 * DESCRIPTION:     This function will fetch a SA context for an incoming 
 *                    message from the network. The fetched SA context and the 
 *                    corresponding REGM context are save in the SSA PDB for 
 *                    future use in SSA processing of the message. 
 *
 ******************************************************************************/
icf_return_t    icf_ssa_fetch_sa_context(
        INOUT   icf_ssa_pdb_st  *p_ssa_pdb,
        INOUT   icf_nw_interface_info_st    *p_nw_info
)
{
    /* local variables */
    icf_boolean_t            sa_exists = ICF_FALSE;
    icf_uint8_t                node_count =0;
    icf_rgm_context_st        *p_rgm_context = ICF_NULL;
    icf_config_data_st        *p_dbm_cfg_data = ICF_NULL;
    icf_return_t                ret_val = ICF_SUCCESS;
    
    
    ret_val = icf_dbm_get_module_glb_data(
                 p_ssa_pdb->p_glb_pdb,
                 (icf_int_module_id_t)(ICF_INT_MODULE_CFG),
                 (icf_void_t **)(&p_dbm_cfg_data),
                 p_ssa_pdb->p_ecode);     
             
    ICF_ASSERT(
        p_ssa_pdb->p_glb_pdb,(ICF_NULL != p_dbm_cfg_data))

    for (node_count =0; 
        node_count < p_dbm_cfg_data->max_registration_req; 
        node_count ++) 
    {
        /* currently there will be only one RGM context */ 
        if (ICF_SUCCESS == icf_dbm_get_used_rgn_blk(
                p_ssa_pdb->p_glb_pdb,
                (icf_uint8_t)node_count,
                &p_rgm_context,
                p_ssa_pdb->p_ecode))
        {
            /* check if an SA exists in the REGM ctxt */
            if ((ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context) ||
                (ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context))
            {
                sa_exists = ICF_TRUE;
            }
            /* check if the message is recvd on a valid SA either old or new */
            if ((ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context) && 
                (p_nw_info->remote_port_num == 
                ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context->p_proxy_security_params->port_s))
            {
                /* message revd on old SA */
                p_ssa_pdb->p_sa_context = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context;
                p_ssa_pdb->p_rgm_context = p_rgm_context;
                break;
            }
            else  /* check for new SA context */
            if ((ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context) && 
                (p_nw_info->remote_port_num == 
                ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->p_proxy_security_params->port_s))
            {
                p_ssa_pdb->p_sa_context =  ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
                p_ssa_pdb->p_rgm_context = p_rgm_context;
                break;
            }
        }
        else
        {
            ret_val = ICF_FAILURE;
            break;
        }
    } /* for loop ends here */
    /* if a SA exists and the message is recvd on an invalid SA, we need to 
     * return failure
     */
    if ((ICF_FAILURE != ret_val) && (sa_exists == ICF_TRUE ) &&
        (ICF_NULL == p_ssa_pdb->p_sa_context))
    {
        /* error except for error responses */
        ret_val = ICF_FAILURE;
    }
    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_set_sa_ctxt_for_otg_req
 *
 * DESCRIPTION:     Each new transaction will be sent on the network using the 
 *                    new SA if it is active by then. Incase the new SA is not 
 *                    active by then, the new transaction will be sent out on the 
 *                    old SA 
 *                    The function would be invoked each time a non-Register 
 *                    request is being sent out from ICF. For a register request 
 *                    the RGM context would be fetched from the SSA context 
 *                    itself.
 *                    The extracted SA context and the corresponding REG context
 *                    will be saved in the SSA PDB for future reference.
 *
 ******************************************************************************/
icf_return_t    icf_ssa_set_sa_ctxt_for_otg_req(
        INOUT   icf_ssa_pdb_st  *p_ssa_pdb,
        INOUT   icf_address_st  *p_address
)
{
    /* local variables */
    icf_rgm_context_st    *p_rgm_context = ICF_NULL;
    icf_return_t            ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st        *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;

    /* fetch the corresponding REGM context for this context */
    if (ICF_FAILURE == icf_rgm_fetch_ctxt_for_uri(
            p_ssa_pdb->p_glb_pdb,
            p_address,
            &p_rgm_context,
            p_ssa_pdb->p_ecode)) 
    {
        /* Error */
        ret_val = ICF_FAILURE;
    }

    /* each new outgoing transaction will first be attempted on the NEW SA. 
     * But if the SA is not yet active, the message will be sent on the 
     * old SA.This will happen only incase of parallel registration 
     */
    if ((ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context) && /* SA exists */
        (ICF_TRUE == ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->is_active))
    {
        /* save the SA context and the REGM context pointers in the
         * SSA PDB for future reference
         */
        p_ssa_pdb->p_sa_context = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
        p_ssa_pdb->p_rgm_context = p_rgm_context ;

        /* also set these pointers in the SSA ctxt. Required incase of 
         * transaction time-out scenarios */
        p_ssa_ctxt->ssa_sa_context.p_sa_context = 
            ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context;
        p_ssa_ctxt->ssa_sa_context.p_rgm_context = 
            p_rgm_context;
    }
    else if ((ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context) && 
        (ICF_TRUE == ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context->is_active))
    {
        /* save the SA context and the REGM context pointers in the
         * SSA PDB for future reference
         */
        p_ssa_pdb->p_sa_context = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context;
        p_ssa_pdb->p_rgm_context = p_rgm_context ;

        /* also set these pointers in the SSA ctxt. Required incase of 
         * transaction time-out scenarios */
        p_ssa_ctxt->ssa_sa_context.p_sa_context = 
            ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context;
        p_ssa_ctxt->ssa_sa_context.p_rgm_context = 
            p_rgm_context;
    }
    else /* if SA doens't exist */
    if (ICF_NULL != ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context) 
    {
        p_ssa_pdb->p_sa_context = ICF_NULL;
        p_ssa_pdb->p_rgm_context = p_rgm_context ;
    }
    
    return ret_val;
}


/*******************************************************************************
 * FUNCTION:        icf_ssa_rgm_delete_old_sa_ind
 *
 * DESCRIPTION:     This utility function will be invoked from within all 
 *                    UACCallbacks that handle responses from the network, like 
 *                    sdf_ivk_txnComplete. The function will check the count of 
 *                    the active transactions on a give SA. If the count is 0, 
 *                    SSA will send an indication to REGM to delete the SA 
 *                    
 *                    This indication will be sent to REGM incase of transaction 
 *                    completion of non-REGISTER transactions. For REGISTER 
 *                    transactions, the REGM internally takes care to delete the 
 *                    old SA when there no pending transactions are active on it.
 *                    
 *                    This indication is also sent to RGM after the 
 *                    send_call_to_peer() is successful for an outgoing response 
 *                    to the received non-Invite transaction or 200 OK for the 
 *                    Invite transaction that was originally initiated by ICF. 
 *
 ******************************************************************************/
icf_return_t    icf_ssa_rgm_delete_old_sa_ind(
        INOUT   icf_ssa_pdb_st  *p_ssa_pdb        
)
{
    /* local variables */
    icf_uint8_t        tmpString[256] = "\0";
    /*icf_ssa_ctxt_st  *p_ssa_ctxt = */
    /*    (icf_ssa_ctxt_st*)(p_call_obj->pAppData->pData);*/
    
    /* by now we have extracted the regm context the associated SA with
     * the transaction. These pointers are saved in the ssa_pdb. */
    
    if ((ICF_NULL != p_ssa_pdb->p_sa_context) &&
       (p_ssa_pdb->p_sa_context == ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_old_sa_context))
    {
      /* check if the SA is old SA */
      /* send an internal message to RGM */
        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = 
                                ICF_DELETE_OLD_SA;
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 
            ICF_PORT_SIZEOF(icf_rgm_context_st);

        /* Populate the internal message payload */
        p_ssa_pdb->p_internal_msg->p_msg_data = 
            (icf_uint8_t *)p_ssa_pdb->p_rgm_context;

        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CFG;
    
        icf_ssa_get_sec_string (tmpString, 
            p_ssa_pdb->p_sa_context->p_ue_security_params);

        ICF_PRINT(("\nDeleting old SA \n%s", tmpString));

        /*Send the message to original module*/
        icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);

    }
    /* if the saved SA context is the new context, then this trigger need not
     * be sent to REGM
     */
    return ICF_SUCCESS;
}


/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_parse_sec_serv_header
 ** DESCRIPTION:  This function parses the received Security-Server header 
 **               in the received 401 from the network. The header is parsed
 **               the received params are saved in the reg context.
 **
 ***************************************************************************/
icf_return_t icf_ssa_parse_sec_serv_header(
        INOUT  icf_ssa_pdb_st           *p_ssa_pdb,
        INOUT  icf_ipsec_sa_context_st  *p_sa_context,
        INOUT  Sdf_st_callObject             *p_call_obj,
        INOUT  SipHeader                     dHeader)

{
    /* local variables */
    icf_return_t         ret_val = ICF_SUCCESS;
    icf_int8_t          *pToken = ICF_NULL;
    SIP_S8bit                *pBuffer = SIP_NULL, *pTmpBuffer = ICF_NULL;
    SIP_S8bit                *pAllocBuff = ICF_NULL;

    icf_ipsec_security_params_st *p_proxy_security_params = ICF_NULL;
/* To remove warning */
     p_call_obj=p_call_obj;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
            
    
    pBuffer = (((SipUnknownHeader *)
#ifdef ICF_WITH_MUATK_2_2
        (dHeader.pHeader))->pStr2);
#else
        (dHeader.pHeader))->pBody);
#endif
        
    pTmpBuffer = icf_port_strdup(pBuffer);    
    /* check if q value is received in the incoming sec-server header */    
    pToken = icf_port_strtokr(pBuffer,"q", &pBuffer);
    if (ICF_NULL != pToken)
    {    
        /* get the value of q value */
        icf_ssa_get_sec_value(pBuffer, &pToken);
        p_sa_context->p_q_value = icf_port_strdup(pToken);
    }
    /* reassign the tmpBuf pointer to pBuff, since the order of these params 
     * is not fixed in the header */
    pBuffer = icf_port_strdup(pTmpBuffer);
    pAllocBuff = pBuffer;

    /* now get the algo from the received header */
    pToken = icf_port_strstr(pBuffer, "alg");
    pBuffer = pToken;

    if (ICF_NULL != pToken)
    {
        icf_uint8_t      *pTmpToken = ICF_NULL;

        icf_ssa_get_sec_value(pBuffer, &pToken);
        if (ICF_NULL != (pTmpToken = 
                icf_port_strtokr(pToken, ",", &pBuffer)))
        {
            p_sa_context->p_integrity_algo = icf_port_strdup(pTmpToken);
        }
        else
        {
            p_sa_context->p_integrity_algo = icf_port_strdup(pToken);
        }
    }
    else
    {
        ret_val = ICF_FAILURE ;
    }
    if (ICF_SUCCESS == ret_val)
    {
        /* reassign the tmpBuf pointer to pBuff, since the order of these 
         * params is not fixed in the header */
        
        icf_port_strfree(pAllocBuff);
        pAllocBuff = ICF_NULL;

        pBuffer = icf_port_strdup(pTmpBuffer);
        pAllocBuff = pBuffer;

        /* get the ealgo if present in the received header */
        pToken = icf_port_strstr(pBuffer,"ealg");
        pBuffer = pToken;
        if (ICF_NULL != pToken)
        {
            icf_uint8_t      *pTmpToken = ICF_NULL;
            icf_ssa_get_sec_value(pBuffer,
                        &pToken);
            p_sa_context->p_encryption_algo = icf_port_strdup(pToken);
            if (ICF_NULL != (pTmpToken = 
                icf_port_strtokr(pToken, ",",&pToken)))
            {
                p_sa_context->p_encryption_algo = icf_port_strdup(pTmpToken);
            }
            else
            {
                p_sa_context->p_encryption_algo = icf_port_strdup(pToken);
            }
        }
    }
    /* get the spi-c if present in the received header. This is mandatory, if 
     * not present parsing fails */
    if (ICF_SUCCESS == ret_val)
    {
        /* reassign the tmpBuf pointer to pBuff, since the order of these 
         * params is not fixed in the header */
        icf_port_strfree(pAllocBuff);
        pAllocBuff = ICF_NULL;

        pBuffer = icf_port_strdup(pTmpBuffer);
        pAllocBuff = pBuffer;
        
        pToken = icf_port_strstr(pBuffer,"spi-c");
        pBuffer = pToken;

        if (ICF_NULL != pToken)
        {
            icf_ssa_get_sec_value(pBuffer, &pToken);
            /* allocate memory to store the server security params */
            ICF_MEMGET(
                p_ssa_pdb->p_glb_pdb,
                ICF_PORT_SIZEOF(icf_ipsec_security_params_st),
                ICF_MEM_COMMON,
                p_proxy_security_params,
                ICF_RET_ON_FAILURE,
                p_ssa_pdb->p_ecode,
                ret_val);
            p_proxy_security_params->spi_c = icf_port_atoi(pToken);
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
    }
    /* get the spi-s if present in the received header. This is mandatory, if 
     * not present parsing fails  */
    if (ICF_SUCCESS == ret_val)
    {
        /* reassign the tmpBuf pointer to pBuff, since the order of these 
         * params is not fixed in the header */
        icf_port_strfree(pAllocBuff);
        pAllocBuff = ICF_NULL;

        pBuffer = icf_port_strdup(pTmpBuffer);
        pAllocBuff = pBuffer;

        pToken = icf_port_strstr(pBuffer,"spi-s");
        pBuffer = pToken;

        if (ICF_NULL != pToken)
        {
            icf_ssa_get_sec_value(pBuffer, &pToken);
            p_proxy_security_params->spi_s = icf_port_atoi(pToken);
        }
        else
        {
            /* delete the memory allocated for the security params */    
            ICF_MEMFREE(
                  p_ssa_pdb->p_glb_pdb,
                  p_proxy_security_params,
                  ICF_MEM_COMMON,
                  p_ssa_pdb->p_ecode,
                  ret_val);

            ret_val = ICF_FAILURE;
        }
    }
    /* get the port-c if present in the received header. This is mandatory, if 
     * not present parsing fails  */
    if (ICF_SUCCESS == ret_val)
    {
        /* reassign the tmpBuf pointer to pBuff, since the order of these 
         * params is not fixed in the header */
        icf_port_strfree(pAllocBuff);
        pAllocBuff = ICF_NULL;

        pBuffer = icf_port_strdup(pTmpBuffer);
        pAllocBuff = pBuffer;

        pToken = icf_port_strstr(pBuffer,"port-c");
        pBuffer = pToken ;

        if (ICF_NULL != pToken)
        {
            icf_ssa_get_sec_value(pBuffer, &pToken);
            p_proxy_security_params->port_c = icf_port_atoi(pToken);
        }
        else
        {
            /* delete the memory allocated for the security params */    
            ICF_MEMFREE(
                  p_ssa_pdb->p_glb_pdb,
                  p_proxy_security_params,
                  ICF_MEM_COMMON,
                  p_ssa_pdb->p_ecode,
                  ret_val);

            ret_val = ICF_FAILURE;
        }
    }
    /* get the port-s if present in the received header. This is mandatory, if 
     * not present parsing fails  */
    if (ICF_SUCCESS == ret_val)
    {
        /* reassign the tmpBuf pointer to pBuff, since the order of these 
         * params is not fixed in the header */
        icf_port_strfree(pAllocBuff);
        pAllocBuff = ICF_NULL;

        pBuffer = icf_port_strdup(pTmpBuffer);
        pAllocBuff = pBuffer;

        pToken = icf_port_strstr(pBuffer,"port-s");
        pBuffer = pToken;

        if (ICF_NULL != pToken)
        {
            icf_ssa_get_sec_value(pBuffer,
                        &pToken);
            p_proxy_security_params->port_s = icf_port_atoi(pToken);
        }
        else
        {
            /* delete the memory allocated for the security params */    
            ICF_MEMFREE(
                  p_ssa_pdb->p_glb_pdb,
                  p_proxy_security_params,
                  ICF_MEM_COMMON,
                  p_ssa_pdb->p_ecode,
                  ret_val);

            ret_val = ICF_FAILURE;
        }
    }

    if (ICF_SUCCESS == ret_val)
    {
        p_sa_context->p_proxy_security_params = p_proxy_security_params;
        p_proxy_security_params = ICF_NULL;
    }

    if (pTmpBuffer)
        icf_port_strfree(pTmpBuffer);
    if (pAllocBuff)
        icf_port_strfree(pAllocBuff);
    return ret_val;
}


/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_sec_value
 ** DESCRIPTION:  
 **
 ***************************************************************************/
icf_void_t icf_ssa_get_sec_value(
    INOUT     SIP_S8bit        *pBuffer,
    INOUT     icf_int8_t    **p_pToken)
{
    /* local variables */
    icf_uint8_t    seps[] = ";", *pToken = ICF_NULL;
    icf_uint8_t  count =0;


    /*count = icf_port_strlen(pToken);*/
    while(pBuffer[count] != '=')
    {
        count ++;
    }
    count += 1;
    while (pBuffer[count] == ' ')
    {
        count ++;
    }    
    
    pBuffer = pBuffer+count;

    pToken = icf_port_strtok(pBuffer, seps);
    *p_pToken = pToken;

    return ;
}

#if 0
/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_sa_conn_db
 ** DESCRIPTION: 
 **
 **************************************************************************/
icf_return_t    icf_ssa_get_sa_conn_db(
    INOUT     icf_ssa_glb_data_st    *p_ssa_glb_data,
    INOUT     icf_uint16_t            port_num,
    INOUT     icf_uint8_t            *pIndex)
{
    /* local variables */
    icf_return_t        ret_val = ICF_SUCCESS;
    icf_uint8_t        count =0;

    for (count =0; count <ICF_MAX_SA_CONNECTIONS; count++)
    {
        if (port_num == p_ssa_glb_data->sa_conn_db_node[count].prot_port_num)
        {
            *pIndex = count;
            break;
        }
    }

    if (ICF_MAX_SA_CONNECTIONS == count)
    {
        *pIndex = ICF_MAX_SA_CONNECTIONS;
        ret_val = ICF_FAILURE;
    }

    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_sa_tcp_conn_db
 ** DESCRIPTION: 
 **
 **************************************************************************/
icf_return_t    icf_ssa_get_sa_tcp_conn_db(
    INOUT     icf_ssa_glb_data_st    *p_ssa_glb_data,
    INOUT     icf_uint16_t            port_num,
    INOUT     icf_uint8_t            *pIndex)
{
    /* local variables */
    icf_return_t        ret_val = ICF_SUCCESS;
    icf_uint8_t        count =0;

    for (count =0; count <ICF_MAX_SA_CONNECTIONS; count++)
    {
        if (port_num == p_ssa_glb_data->sa_tcp_conn_db_node[count].
                            prot_port_num)
        {
            *pIndex = count;
            break;
        }
    }

    if (ICF_MAX_SA_CONNECTIONS == count)
    {
        *pIndex = ICF_MAX_SA_CONNECTIONS;
        ret_val = ICF_FAILURE;
    }

    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_sa_conn_db_node_index
 ** DESCRIPTION:  
 **
 ***************************************************************************/
icf_return_t icf_ssa_get_sa_conn_db_node_index (
    INOUT     icf_ssa_pdb_st    *p_ssa_pdb,
    INOUT     icf_uint8_t        *pIndex
    )
{
    /* local variables */
    icf_return_t        ret_val = ICF_FAILURE;
    icf_uint8_t        count =0;
    
    *pIndex = ICF_MAX_SA_CONNECTIONS;

    do
    {
        if (ICF_INVALID_FD == 
        p_ssa_pdb->p_ssa_glb_data->sa_conn_db_node[count].fd)
        {
            *pIndex = count;
            ret_val = ICF_SUCCESS;
            break;
        }
        count += 1;
    } while (count < ICF_MAX_SA_CONNECTIONS);
    
    return ret_val;
}


/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_sa_tcp_conn_db_node_index
 ** DESCRIPTION:  
 **
 ***************************************************************************/
icf_return_t icf_ssa_get_sa_tcp_conn_db_node_index (
    INOUT     icf_ssa_pdb_st    *p_ssa_pdb,
    INOUT     icf_uint8_t        *pIndex
    )
{
    /* local variables */
    icf_return_t        ret_val = ICF_FAILURE;
    icf_uint8_t        count =0;
    
    *pIndex = ICF_MAX_SA_CONNECTIONS;

    do
    {
        if (ICF_INVALID_FD == 
        p_ssa_pdb->p_ssa_glb_data->sa_tcp_conn_db_node[count].fd)
        {
            *pIndex = count;
            ret_val = ICF_SUCCESS;
            break;
        }
        count += 1;
    } while (count < ICF_MAX_SA_CONNECTIONS);
    
    return ret_val;
}
#endif

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_checkNdeleteRouteHdr
 ** DESCRIPTION:  The function is invoked to delete the existing Route Set 
 **               from the Message, Persistent Route Set and Pre-Loaded
 **               Route Set and then create a new Route Set for sending
 **               the Register on the SA and protected ports.
 **
 ***************************************************************************/
icf_result_t   icf_ssa_checkNdeleteRouteHdr(
          Sdf_st_callObject           *pCallObj)
{
    /* local variable */
    Sdf_st_error                SdfErr;
/*    Sdf_st_listIterator         dListIterator;*/
    Sdf_st_initData *pInitData = Sdf_co_null;


    /*sip_getHeaderCount(pCallObj->pUacTransaction->pSipMsg,SipHdrTypeRoute ,\*/
/*            &dCount,(SipError *)&(SdfErr.stkErrCode));*/

   /* if(dCount != 0)*/
    {
        /* Remove preloaded reoute info from Call Object profile (if any) */
        sip_deleteAllHeaderType (pCallObj->pUacTransaction->pSipMsg, \
                SipHdrTypeRoute,\
                (SipError *)&(SdfErr.stkErrCode));

        /* Also Delete the Preloaded Route Info from the Init Data so that
         * for other transaction like cancel It will not be filled and
         * the message wont be sent to the outbound proxy
         */
        if(((sdf_ivk_uaGetInitDataFromCallObject(pCallObj, &pInitData, \
                            &SdfErr)) == Sdf_co_success) && 
                (pInitData != Sdf_co_null))
        {
            sdf_listDeleteAll(&(pInitData->slPreLoadedRoute), &SdfErr);
            sdf_ivk_uaFreeInitData(pInitData);

        } /* pErr)) == Sdf_co_sucicf_ssa_copy_conn_fd_to_callobcess) */

        /* Delete the Route header information from the common info */
        sdf_listDeleteAll(&(pCallObj->pCommonInfo->slInvRoute),&SdfErr);
        if( pCallObj->pCommonInfo->dPreloadedSet == Sdf_co_true)
        {
            pCallObj->pCommonInfo->dPreloadedSet = Sdf_co_false;
        }

        /* Delete the Route header From Persistent Headers */
        sdf_ivk_uaDeleteHeaderListByCorrelation( \
                &(pCallObj->slPersistentHeaders), 
                "uat-routeset", 
                &SdfErr);
    }
    return ICF_SUCCESS;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_sa_set_ssa_ctxt_node
 ** DESCRIPTION:  The function will set the SSA context to the TCP conn DB
 **               when the same connection is shared by more than one SSA 
 **               contexts 
 **
 ***************************************************************************/
icf_void_t   icf_ssa_sa_set_ssa_ctxt_node(
        INOUT    icf_ssa_pdb_st   *p_ssa_pdb )
{
    /* local variables */
    icf_uint32_t      count =0;
    icf_ssa_ctxt_st      **pp_ssa_ctxt_local= ICF_NULL;
    
    while (count < ICF_MAX_NO_OF_PERSISTENT_CONNECTIONS) 
    {
        pp_ssa_ctxt_local = 
            &(p_ssa_pdb->p_ssa_glb_data->ssa_tcpm_conn_db[\
            p_ssa_pdb->ssa_conn_db_index].p_ssa_ctxt) + count;
        
        if(ICF_NULL != (*pp_ssa_ctxt_local))
        {
            count +=1;
        }
        else
        {
            *pp_ssa_ctxt_local= p_ssa_pdb->p_ssa_ctxt;
            break;
        }
    }
   
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_open_sa_server
 ** DESCRIPTION:  The function will be invoked on request from REGM (after SA
 **               creation the first time). Here we will open both TCP and
 **               UDP servers on the protected ports
 **
 ***************************************************************************/
icf_return_t icf_ssa_open_sa_server(
    INOUT    icf_ssa_pdb_st   *p_ssa_pdb)
{
    /* local variables */
    
    icf_uint8_t              trans_addr[ICF_MAX_STR_LEN] = "\0";
    icf_uint16_t             self_prot_port =0;
    /*Fix For SPR: 19531 (Klocwork Warning Removal)*/
    icf_uint32_t             fd_id = ICF_INVALID_FD ;
    icf_glb_pdb_st           *p_glb_pdb = p_persistent_glb_pdb;
    icf_transport_address_st *p_transport_address = ICF_NULL;
    icf_return_t             ret_val = ICF_SUCCESS;

  
   ICF_PRINT(("\nEntered Function: icf_ssa_open_sa_server"));
        
    p_transport_address = &(p_ssa_pdb->p_glb_cfg_data->self_ip_address);
    if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
        p_transport_address->addr.addr_type)
    {
        icf_port_strcpy(trans_addr, 
            p_transport_address->addr.addr.domain.str);
    }
    else 
    {
        icf_ssa_convert_to_IP_addr(p_transport_address,
            trans_addr);
    }
    
    /* TCP server will be openned only if the transport mode is configured
     * to TCP or BOTH 
     */
    if ((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_glb_cfg_data->self_mode)||
       (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_glb_cfg_data->self_mode))
    {
         /* incase of TCP, we will bind the server port with self server port
          * and then later bind it to the self client port if SA exists */
        self_prot_port = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
            p_ue_security_params->port_s;

        /* we will open TCP and UDP server ports for protected self ports */
        /* open TCP servers fisrt */
        if ( ICF_FAILURE == icf_port_open_channel( 
            self_prot_port,
            ICF_TRANSPORT_TYPE_TCP, 
            ICF_TRUE, 
            trans_addr, 
            (icf_uint32_t*)&fd_id, 
            p_ssa_pdb->p_ecode))
        {
            ICF_PRINT(("[SSA]:Failure in TCP open server for PROT Port\n"));
            ret_val = ICF_FAILURE ;
        }
        
        /* save the FD in ssa_sa_tcp_conn_db node in ssa_pdb */
        p_ssa_pdb->p_ssa_glb_data->
            sa_conn_db_node[ICF_SSA_TCP_SA_CONNECTION].fd = fd_id;
        p_ssa_pdb->p_ssa_glb_data->
            sa_conn_db_node[ICF_SSA_TCP_SA_CONNECTION].prot_port_num = 
            self_prot_port;
        
        /* this fd needs to be set in the read fd set */
        icf_port_set_sa_fd(
            p_glb_pdb->p_glb_data->p_glb_port_info,
            ICF_TRANSPORT_TYPE_TCP,
            fd_id);
    }
    /* open UDP server if UDP is configured in the system */
    if ((ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->p_glb_cfg_data->self_mode) ||
       (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_glb_cfg_data->self_mode))
    {
        /* if SA exists */
        self_prot_port = ((icf_rgm_glb_data_st *)(p_ssa_pdb->p_glb_rgm_data))->p_new_sa_context->
            p_ue_security_params->port_s;

        /* open UDP server port */
        if ( ICF_FAILURE == icf_ssa_sa_open_udp_channel( 
            self_prot_port,
            ICF_TRANSPORT_TYPE_UDP, 
            trans_addr, 
            (icf_uint32_t*)&fd_id, 
            p_ssa_pdb->p_ecode))
        {
            ICF_PRINT(("[SSA]:Failure in UDP open server for PROT Port\n"));
            ret_val = ICF_FAILURE ;
        }
        
        ICF_PRINT(("\nSSA:UDP SERVER port for SA opened successfully "));
        /* save the FD in ssa_sa_tcp_conn_db node in ssa_pdb */
        p_ssa_pdb->p_ssa_glb_data->
            sa_conn_db_node[ICF_SSA_UDP_SA_CONNECTION].fd = fd_id;
        p_ssa_pdb->p_ssa_glb_data->
            sa_conn_db_node[ICF_SSA_UDP_SA_CONNECTION].prot_port_num = 
            self_prot_port;
        
        /* this fd needs to be set in the read fd set */
        icf_port_set_sa_fd(
            p_glb_pdb->p_glb_data->p_glb_port_info,
            ICF_TRANSPORT_TYPE_UDP,
            fd_id);
    }
    return ret_val;
}

icf_return_t icf_ssa_close_sa_server(
    INOUT    icf_ssa_pdb_st   *p_ssa_pdb)
{
    ICF_PRINT(("\n:SSA: Entered Function: icf_ssa_close_sa_server"));

    /* we need to close the servers that we have opened in out system
     * for SA ports
     */
    icf_es_port_close_sa_servers(
        p_ssa_pdb->p_glb_pdb->p_glb_data->p_glb_port_info);

    return ICF_SUCCESS;    
}
#endif /* ICF_IPSEC_ENABLED */
/*******************************************************************************
 * 
 * FUNCTION:        icf_ssa_send_authorized_req
 *
 * DESCRIPTION:     This function constructs and sends req with 
 *                  Authentication info on network. DIGEST and basic schemes are
 *                  supported.
 *                  1.Initialize the UAC auth info list 
 *                  2.Iterate through the authorization params list
 *                  stored in the SSA ctxt.This list was returned when
 *                  the PROXY/REGISTRAR/UAS challenged us with 401/407 response 
 *                  asking for authorization parameters.
 *                  3.If the scheme present in the elements of this list
 *                  is "Digest" or "Basic",populate the authorization parameters from
 *                  that configured on the line and append the same to the
 *                  UAC auth info list initialized earlier. 
 *                  4. Invoke sdf_ivk_uaFormRequestWithAuthorization with the
 *                  authorization paramters and send the request to peer.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_authorized_req(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_return_t               ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st            *p_ssa_ctxt = ICF_NULL;
    Sdf_st_overlapTransInfo       *p_overlap_trans_info = Sdf_co_null;
    Sdf_st_error                  sdf_error , *p_err = &sdf_error;
    Sdf_ty_slist                  uac_auth_info_list;
    Sdf_ty_u32bit                 index = 0;
    Sdf_ty_u32bit                  new_cnonce_int = 0;
    icf_uint8_t                      cnonce_str[ICF_MAX_STR_LEN] = "\0";    
    icf_address_st             *p_user_address = ICF_NULL;
    /* Rel 8.2 Klocworks fix */
    icf_string_st               authentication_key = {0,"\0"},
                                authentication_password = {0,"\0"};  
    /* Rel 8.2 Klocworks fix end */
    
    /* This is used to indicate whether in the case of AKA challenge algo,
     * MAC failure has occurred */
    icf_boolean_t is_mac_failure = ICF_FALSE;
    /* This is used to indicate whether in the case of AKA challenge algo,
     * SQN failure has occurred */
    icf_boolean_t is_sqn_failure = ICF_FALSE;
    /* This app_id is passed to the AKA processing function */
    icf_app_id_t app_id = ICF_INVALID_APP_ID;

    Sdf_st_authenticationParams     *p_auth_params = Sdf_co_null;
    Sdf_st_uacAuthInfo              *p_uac_auth_info = Sdf_co_null;
    /* This is the local pointer to the SIP message that is being passed 
     * to the functions icf_ssa_chk_n_append_auts and icf_ssa_make_aka_auth_hdr
     */
    SipMessage                      *p_sip_msg = Sdf_co_null;
    Sdf_st_headerList    *pHeaderList = Sdf_co_null;
    SipHeader            *p_event_hdr = Sdf_co_null, \
                         *p_sub_state_hdr = Sdf_co_null, \
                         *p_content_type_hdr = Sdf_co_null;
#ifdef SDF_THREAD_SAFE
    Sdf_ty_slist         slHeaderList = {0,0,'\0','\0',{PTHREAD_MUTEX_INITIALIZER,0,0},0};
#else
    Sdf_ty_slist         slHeaderList = {0,0,'\0','\0',0};  
#endif

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt;
    
    /*Fix for SPR : 19188 (Rel 7.1.2 SPR merging for SPR 18918)*/
    /* SPR 18918: If SSA context is not present then return failure
     * as further processing is not possible.
     */
    ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb, p_ssa_ctxt,ret_val)
    if(ICF_FAILURE == ret_val)
    {
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }    

    /* Initialize the uac auth info list */
    if (Sdf_co_fail == sdf_listInit( &uac_auth_info_list,\
             __sdf_fn_uaFreeUacAuthInfo, Sdf_co_false, &sdf_error))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        /* Fixed for SPR 16051: Here we fetch the user db node 
           corresponding to the user in ssa_ctxt so that we can
           use the auth key and passwd from the user_db */
        if(p_ssa_ctxt->p_call_ctxt)
        {
            p_user_address = 
				&p_ssa_ctxt->p_call_ctxt->local_address;
            app_id = p_ssa_ctxt->p_call_ctxt->app_id;
		}
		else if(p_ssa_ctxt->p_rgm_ctxt)
		{
		    p_user_address = 
				&p_ssa_ctxt->p_rgm_ctxt->rgm_user_address;	
		}
		else if(p_ssa_ctxt->p_sic_ctxt)
		{
		    p_user_address = 
				p_ssa_ctxt->p_sic_ctxt->p_user_address;		
            app_id = p_ssa_ctxt->p_sic_ctxt->app_id;
		}

	    /* Fixed for SPR 16051: Here we fetch the credentials 
		from either the user_db coress to rgm_user_address 
		or from line data depending on the opetion PA has
		selected */
	    if(ICF_NULL != p_user_address)
		{
		    ret_val = icf_cmn_get_auth_params(
		                        p_ssa_pdb->p_glb_pdb, 
		                        p_user_address,
		                        p_ssa_pdb->p_line_data->line_id,
		                        &authentication_key,
		                        &authentication_password);
                }
		else
		{
			ret_val = ICF_FAILURE;
		}

		if(ICF_FAILURE == ret_val)
		{
			return ret_val;
		}

        /* Auth info list is intialized,  start processing  the auth param
         * list one by one*/
        for (index = 0; index < p_ssa_ctxt->auth_params_list_size; index++)
        {
            /* Rel 8.2 Klocworks fix */
            icf_string_st temp_unq_algo = {0,"\0"};
            /* Rel 8.2 Klocworks fix end */

            /* Get the auth param list element from ssa context 
             * TBD: DOES it get incremented in case of multiple 401/407 */ 
            if (Sdf_co_fail == sdf_listGetAt( p_ssa_ctxt->p_auth_params_list,\
                  index, (Sdf_ty_pvoid *)&p_auth_params, &sdf_error))
            {
                sdf_listDeleteAll(&uac_auth_info_list,p_err);

                ret_val = ICF_FAILURE;
                break;
            }

            /* Unqouting the algo string */
	    sdf_fn_uaUnq(p_auth_params->pAlgorithm,(icf_int8_t *)temp_unq_algo.str);
             
            /* Validate challenge algo */
            if(ICF_SUCCESS == icf_cmn_validate_challenge_algo(
                                       temp_unq_algo.str))
            {
                /* initialize uac auth info list element */
                if (Sdf_co_fail == sdf_ivk_uaInitUacAuthInfo(\
                            &p_uac_auth_info,p_err))
                {
                    sdf_listDeleteAll(&uac_auth_info_list,p_err);
                    ret_val = ICF_FAILURE;
                    break;
                }
               /*Klocwork Warning Removal*/
               else
                {
                  ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_uac_auth_info)
                }
                /* If the challenge algo is AKA, initiate AKA processing */
                if(ICF_CHALLENGE_ALGO_AKA == p_ssa_ctxt->challenge_algo)
                {
                    icf_boolean_t      resp_sync_flag;
                    icf_uint8_t        sip_method_name;

                    /* Find the # define for SIP method corresponding to string */
                    ICF_SSA_GET_METHOD_NAME(p_ssa_pdb,sip_method_name)
                  
                   /* The four parameters passed as NULL after app_id parameter
                    * are not required in case of AKA challenge for NON-REGISTER
                    * request. So they are passed as NULL or 0.
                    */
                    ret_val = icf_cmn_process_aka_challenge(
                            p_ssa_ctxt->p_glb_pdb,
                            &(p_ssa_ctxt->auth_data_recd),
                            &(p_ssa_ctxt->auth_data_sent),
                            p_user_address,
                            p_ssa_pdb->p_line_data->line_id,
                            app_id,
                            ICF_NULL,ICF_NULL,ICF_NULL, 0,
                            sip_method_name,
                            &resp_sync_flag,
                            p_ssa_pdb->p_ecode);
 
                    /* The above function will set the ecode accrording to the result
                     * of the AKA procedure.(ie to decide whether to send res,auts or
                     * nothing in the Authorization header */

                    /* If ecode is ICF_CAUSE_INVALID_AUTH_PARAM
                     *
                     *     No Authorization response will be sent and application 
                     *     will be indicated of the failure.
                     * 
                     * If ecode is ICF_CAUSE_SQN_OUT_OF_RANGE 
                     * 
                     *     Indicates SQN failure at server side.
                     *     A new request with credentials will be sent out with
                     *     Authorization header containing response parameter with
                     *     value NULL and auts parameter.
                     *    
                     * If ecode is ICF_CAUSE_HOME_NETWORK_NOT_AUTH
                     *
                     *      Indicates MAC failure at server side. 
                     *      A new request with credentials will be sent with
                     *      Authorization header containing no response and no
                     *      auts parameter.
                     *
                     * If ecode is NULL
                     *  
                     *     AKA procedure has successfully calculated challenge response.
                     *     A new request with credentials will be sent out with
                     *     Authorization header containing the challenge response
                     *     as computed by the AKA procedure.
                     */

                    if(ICF_FAILURE != ret_val)
                    {
                        if(ICF_CAUSE_SQN_OUT_OF_RANGE == *(p_ssa_pdb->p_ecode))
                        {
                            /* SQN failure at server side */
                            /* Success to be set so that a new request with credentials
                             * can be sent out with Authorization header containing
                             * response parameter with value NULL and auts parameter.
                             */
                            is_sqn_failure = ICF_TRUE;
                        }    
                        else if(ICF_CAUSE_HOME_NETWORK_NOT_AUTH == *(p_ssa_pdb->p_ecode))
                        {
                            /* MAC failure at server side */
                            /* Success to be set so that a new request with credentials
                             * can be sent out with Authorization header containing no
                             * response and no auts parameter.
                             */
                            is_mac_failure = ICF_TRUE;
                        }
                    }
					else
                    {
                        if(ICF_CAUSE_INVALID_AUTH_RESP_STATUS == *(p_ssa_pdb->p_ecode))
                        {
                            ICF_SSA_APP_TRACE(p_ssa_pdb,
                                ICF_TRACE_INVALID_AKA_AUTH_STATUS)
                        }
                    }
                }
                
                /* Forming Authorization header in case there is no MAC failure.For
                 * the case of MAC failure, the Authorization header is formed by
                 * the function icf_ssa_make_aka_auth_header 
                 */ 
                if((ICF_FAILURE != ret_val) &&
                        (ICF_FALSE == is_mac_failure))
                {

                /* Set UserName irrespective of the challenge ALGO */
                Sdf_mc_strdup( p_uac_auth_info->pUserName,\
                           (icf_int8_t*)authentication_key.str);

                /* In case of AKA, password is computed by the aka
                 * procedure and stored in ssa context.
                 */

                if(ICF_CHALLENGE_ALGO_AKA == p_ssa_ctxt->challenge_algo)
                {
                    if(ICF_AUTH_RES_PRESENT & p_ssa_ctxt->auth_data_sent.auth_data_present)
      		        {
                        /* Set the RES received into the UAC auth Info */
                        Sdf_mc_strdup(
                                   p_uac_auth_info->pPassword,
                                   (icf_int8_t*)p_ssa_ctxt->auth_data_sent.res.str);
      	            }
      		        else
      		        {
                        /* In this case auts parameter will be sent with a NULL password.*/
                        /* Set the password as null into the UAC auth Info */
                        p_uac_auth_info->pPassword = Sdf_co_null;
                    }
                }
                /* In case of MD5, copy password from auth params configured */
                else
                {
                    Sdf_mc_strdup( p_uac_auth_info->pPassword,
                               (icf_int8_t*)authentication_password.str);
                }

                /* process qop */
                if (p_auth_params->pQop != Sdf_co_null)
                {
                    icf_string_st           temp_nc;
                    icf_uint8_t             *p_temp = ICF_NULL;
                    icf_boolean_t           send_nonce = ICF_TRUE;
                    
                    p_temp = (icf_uint8_t *) p_auth_params->pQop;
                    if (ICF_NULL != icf_port_strstr((const icf_int8_t *)p_temp, (const icf_int8_t *)"auth-int"))
                    {
                        Sdf_mc_strdup(p_uac_auth_info->pQop, "auth-int");
                    }
                    else if (ICF_NULL != icf_port_strstr((const icf_int8_t *)p_temp, (const icf_int8_t *)"auth"))
                    {
                        Sdf_mc_strdup(p_uac_auth_info->pQop, "auth");
                    }
                    else
                    {
                        Sdf_mc_strdup(p_uac_auth_info->pQop, "");
                        send_nonce = ICF_FALSE;
                    }                 
                    
                    if (ICF_TRUE == send_nonce)
                    {
                        /* cnonce */
                        /* This function is invoked when a request was
                         * challenged and ICF is sending the request again with
                         * Auth params. So every time this function is
                         * invoked, cnonce will be generated afresh.
                         */
                        if (Sdf_co_fail == 
                          sdf_fn_uaGetCurrentTimeInMicroSecs(&new_cnonce_int))
                        {
                            sdf_listDeleteAll(&uac_auth_info_list,p_err);
                            ret_val = ICF_FAILURE;
                            break;
                        }
                        icf_port_sprintf((icf_int8_t *)cnonce_str,"%u", new_cnonce_int);
                        Sdf_mc_strdup(p_uac_auth_info->pCnonce, (icf_int8_t*)cnonce_str);

                        /* nc OR nonce-count */
                        icf_port_memset((icf_void_t *)&temp_nc, 0, 
                            ICF_PORT_SIZEOF(icf_string_st));
                    
                        /* Convert the nc OR nonce_count to string */
                        (p_ssa_ctxt->nc)++;
                        icf_ssa_compute_nc(p_ssa_pdb->p_glb_pdb,
                            p_ssa_ctxt, &temp_nc, 
                            p_ssa_ctxt->nc,
                            p_ssa_pdb->p_ecode);
                    
                        if (temp_nc.str_len)
                        {
                            Sdf_mc_strdup(
                                p_uac_auth_info->pNonceCount,
                                (icf_int8_t*)temp_nc.str);
                        }
                    } /* if (send_nonce) */
                } /* if (p_auth_params->pQop) */
            
                /* add the uac info element to list */
                if (Sdf_co_fail == sdf_listAppend( &uac_auth_info_list,\
                            (Sdf_ty_pvoid)p_uac_auth_info, p_err))
                {
                    sdf_listDeleteAll(&uac_auth_info_list,p_err);

                    ret_val = ICF_FAILURE;
                    break;
                }

                }/* end of if(ret_val == ICF_SUCCESS) */
            } /* End validate and algo */
            else
            {
                /* Authentication algo not supported */
                sdf_listDeleteAll(&uac_auth_info_list,p_err);
                ret_val = ICF_FAILURE;
                break;

            } /* End else(validate scheme and algo) */
        } /* End for(index) */

 
        /* TBD: Check for IPPSKT_FAILURE */ 
        /*
         * Now form a request with authorization. The list of
         * authentication params and uac auth info structures
         * are passed to this API
         */
        /* Set the transport mode in local variable */

        if(ICF_FAILURE != ret_val)
        {
            if(ICF_FAILURE == icf_ssa_process_before_sending_auth_req(
                      p_ssa_pdb,&p_ssa_ctxt->p_call_obj,&p_overlap_trans_info))
            {
                sdf_listDeleteAll(&uac_auth_info_list,p_err);
                if(ICF_TRUE == is_mac_failure)
                {
                    sdf_ivk_uaFreeUacAuthInfo(p_uac_auth_info);
                }
                ret_val = ICF_FAILURE;
                /* If we the above function fails,we need not proceed any further as 
                 * no transaction has been created.
                 */
                return ret_val;
            }
            else if(sdf_ivk_uaAddExtraHeaders(p_ssa_ctxt->p_call_obj,
                       p_overlap_trans_info,(Sdf_ty_s8bit *) p_ssa_pdb->p_method, p_err) 
                                == Sdf_co_fail)
            {
                ret_val = ICF_FAILURE;
            }

            /*  Fix for CSR 1-7618644 : SPR 19989 */
            /*  If method is NOTIFY then copy the message body into 
             *  overlap transaction. */
            if (ICF_NULL == icf_port_strcmp(p_ssa_pdb->p_method,\
                        (icf_uint8_t *)"NOTIFY"))
            {
                if ((ICF_FAILURE != ret_val) &&
                   (ICF_TRUE == p_ssa_pdb->copy_msg_body_from_persitent_data) &&
                  (Sdf_co_fail == sdf_ivk_uaCopyMsgBodyFromPersistent ( 
                            &(p_ssa_ctxt->p_call_obj->slPersistentMsgBodyList),
                            &(p_overlap_trans_info->slMsgBodyList),
                            (Sdf_ty_s8bit *)"persistent",p_err)))
                {
                    ret_val = ICF_FAILURE;
                }
            }
            /*spr 16926 Avoiding copy of SDP if method is BYE*/
            /*CSR-1-5634729: modified below condition for copy_msg_body_from_persitent_data*/ 
            else if(ICF_NULL != icf_port_strcmp(p_ssa_pdb->p_method,(icf_uint8_t *)"BYE"))
            {
                 if ((ICF_FAILURE != ret_val) &&
                   (ICF_TRUE == p_ssa_pdb->copy_msg_body_from_persitent_data) &&
                  (Sdf_co_fail == sdf_ivk_uaCopyMsgBodyFromPersistent (
                    &(p_ssa_ctxt->p_call_obj->slPersistentMsgBodyList),
                    &(p_ssa_ctxt->p_call_obj->pUacTransaction->slMsgBodyList),
                    (Sdf_ty_s8bit *)"persistent",p_err)))
                {
                    ret_val = ICF_FAILURE;
                }
            }
            else
            {
                /* if method is BYE and application has provided body list then 
                 * copy the same on BYE after challenge
                 */ 
                if ((ICF_FAILURE != ret_val) &&
                   (ICF_SSA_MSG_BODY_RECVD_FOR_BYE & p_ssa_ctxt->bitmask_1) &&
                  (Sdf_co_fail == sdf_ivk_uaCopyMsgBodyFromPersistent (
                    &(p_ssa_ctxt->p_call_obj->slPersistentMsgBodyList),
                    &(p_ssa_ctxt->p_call_obj->pUacTransaction->slMsgBodyList),
                    (Sdf_ty_s8bit *)"persistent",p_err)))
                {
                    ret_val = ICF_FAILURE;
                }
            }
            /*Fix for CSR 1-7507275 SPR 20063*/
		    if((ICF_FAILURE != ret_val) && 
               (ICF_NULL == icf_port_strcmp(p_ssa_pdb->p_method,
                                            (icf_uint8_t *)"PRACK")))
		    {
		         p_overlap_trans_info->dRseq = 
                     p_ssa_ctxt->p_call_obj->pCommonInfo->dRemoteRseq.dRseq;
                 /*  Set the state as Sdf_en_overlapTransactionSent because stack
                  *  is not able to change the state from idle to
                  *  Sdf_en_overlapTransactionSent so setting the
                  *  state as Sdf_en_overlapTransactionSent.
                  */
                 p_overlap_trans_info->dState = Sdf_en_overlapTransactionSent;
	     	}
            /*CSR-1-5634729 start*/
            if((ICF_FAILURE != ret_val) &&
               (ICF_NULL == icf_port_strcmp(p_ssa_pdb->p_method,(icf_uint8_t *)"REFER")))
            {
               /*  CSR 1-5685130 Merge */
	           /*Copy ReferTo and RefrdBy From Persistent to Processed*/
	          if(sdf_ivk_uaCopyHeaderListByCorrelation(\
			      &(p_ssa_ctxt->p_call_obj->slPersistentHeaders),\
			      &(p_overlap_trans_info->slProcessedHeaders),\
			      (Sdf_ty_s8bit *)"uat-ReferTo",p_err)==Sdf_co_fail)
	           {
		          ICF_PRINT(((icf_uint8_t*)"Failed to Add ReferTo Headers\n"));
		          ret_val = ICF_FAILURE;
	           }
               /*  CSR 1-5685130 Merge */
	           if(sdf_ivk_uaCopyHeaderListByCorrelation(\
		          &(p_ssa_ctxt->p_call_obj->slPersistentHeaders),\
			      &(p_overlap_trans_info->slProcessedHeaders),\
			      (Sdf_ty_s8bit *)"uat-ReferredBy",p_err)==Sdf_co_fail)
	           {
		          ICF_PRINT(((icf_uint8_t*)"Failed to Add RefrdBy Headers\n"));
		          return Sdf_co_fail;
	           }
               /*CSR-1-5634729 end*/
            }

            /* SPR 19999: CSR 1-7618644 
             * Copy the headers event, subscription state and content type in the
             * NOTIFY message.
             */
            if((ICF_FAILURE != ret_val) &&
                (ICF_NULL == icf_port_strcmp(p_ssa_pdb->p_method,(icf_uint8_t *)"NOTIFY")))
			{

					/*Retrieve the Event, Subsription-State and Content Type header From 
					  Persistent header list*/
					if(Sdf_co_fail == sdf_ivk_uaGetHeaderListByCorrelation(\
											&(p_ssa_ctxt->p_call_obj->slPersistentHeaders),\
											(Sdf_ty_s8bit *)"uat-Event",\
											&slHeaderList,\
											p_err))
					{
							ICF_PRINT(((icf_uint8_t*)"Failed to Add Event Header\n"));
							ret_val = ICF_FAILURE;
					}
					else if(Sdf_co_fail == sdf_listGetAt(&slHeaderList, 0, \
											(Sdf_ty_pvoid *)&pHeaderList, p_err))
					{
							sdf_listDeleteAll(&slHeaderList,p_err);
							ICF_PRINT(((icf_uint8_t*)"Failed to Add Event Header\n"));
							ret_val = ICF_FAILURE;

					}

					else if(Sdf_co_fail == sdf_listGetAt(&(pHeaderList->slHeaders),0,\
											(Sdf_ty_pvoid *)&p_event_hdr,p_err))
					{
							sdf_listDeleteAll(&slHeaderList,p_err);
							(void)sdf_ivk_uaFreeHeaderList(pHeaderList);
							ICF_PRINT(((icf_uint8_t*)"Failed to Add Event Header\n"));
							ret_val = ICF_FAILURE;
					}
					else
					{
							sdf_listDeleteAll(&slHeaderList,p_err);
					}
					if (ICF_FAILURE != ret_val)
					{
							if(Sdf_co_fail == sdf_ivk_uaGetHeaderListByCorrelation(\
													&(p_ssa_ctxt->p_call_obj->slPersistentHeaders),\
													(Sdf_ty_s8bit *)"uat-Subscriptionstate",\
													&slHeaderList,\
													p_err))
							{
									ICF_PRINT(((icf_uint8_t*)"Failed to Add Subscription state Header\n"));
									ret_val = ICF_FAILURE;
							}
							else if(Sdf_co_fail == sdf_listGetAt(&slHeaderList, 0, \
												(Sdf_ty_pvoid *)&pHeaderList, p_err))
							{
									sdf_listDeleteAll(&slHeaderList,p_err);
									ICF_PRINT(((icf_uint8_t*)"Failed to Add subscription state Header\n"));
									ret_val = ICF_FAILURE;

							}

							else if(Sdf_co_fail == sdf_listGetAt(&(pHeaderList->slHeaders),0,\
													(Sdf_ty_pvoid *)&p_sub_state_hdr,p_err))
							{
									sdf_listDeleteAll(&slHeaderList,p_err);
									ICF_PRINT(((icf_uint8_t*)"Failed to Add subscription state Header\n"));
									ret_val = ICF_FAILURE;
							}
							else
							{
									sdf_listDeleteAll(&slHeaderList,p_err);
							}
					}
					if (ICF_FAILURE != ret_val)
					{
							if(Sdf_co_fail == sdf_ivk_uaGetHeaderListByCorrelation(\
													&(p_ssa_ctxt->p_call_obj->slPersistentHeaders),\
													(Sdf_ty_s8bit *)"uat-contenttype",\
													&slHeaderList,\
													p_err))
							{
									ICF_PRINT(((icf_uint8_t*)"Failed to Add Content Type Header\n"));
									ret_val = ICF_FAILURE;
							}
							else if(Sdf_co_fail == sdf_listGetAt(&slHeaderList, 0, \
													(Sdf_ty_pvoid *)&pHeaderList, p_err))
							{
									sdf_listDeleteAll(&slHeaderList,p_err);
									ICF_PRINT(((icf_uint8_t*)"Failed to Add Content Type Header\n"));
									ret_val = ICF_FAILURE;

							}

							else if(Sdf_co_fail == sdf_listGetAt(&(pHeaderList->slHeaders),0,\
													(Sdf_ty_pvoid *)&p_content_type_hdr,p_err))
							{
									sdf_listDeleteAll(&slHeaderList,p_err);
									ICF_PRINT(((icf_uint8_t*)"Failed to Add Content Type Header\n"));
									ret_val = ICF_FAILURE;
							}
							else
							{
									sdf_listDeleteAll(&slHeaderList,p_err);
							}
					}
			}
        }/* end ret_val != ICF_FAILURE */

        /* Now form the Authorization header iff there is no MAC failure. In that
         * case the Authorization header will contain no res and no auts parameter
         */
        if((ICF_FALSE == is_mac_failure) && (ICF_FAILURE != ret_val))
        {   
           if (Sdf_co_fail == sdf_ivk_uaFormRequestWithAuthorization(\
               p_ssa_ctxt->p_call_obj, p_overlap_trans_info, (Sdf_ty_s8bit*)(p_ssa_pdb->p_method),
               Sdf_co_true, p_ssa_ctxt->p_auth_params_list,\
               &uac_auth_info_list, p_err))
           {
              /*Raise/Set Error/Alarm here UATK PROCESSING FAILURE*/
              sdf_listDeleteAll(&uac_auth_info_list,p_err);

              sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
                      p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, \
                      Sdf_en_uacTransaction);

              ret_val = ICF_FAILURE;
           }
           /* Check and append auts parameter if required in case of AKA challenge */
           else if(ICF_CHALLENGE_ALGO_AKA == p_ssa_ctxt->challenge_algo)
           {
               if(ICF_TRUE == is_sqn_failure)
               {
                   /* Setting the pointer to SIP message */
                   if(Sdf_co_null == p_overlap_trans_info)
                   {
                       p_sip_msg = p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg;
                   }
                   else
                   {
                       p_sip_msg = p_overlap_trans_info->pSipMsg;
                   }

                   if(ICF_FAILURE == icf_ssa_chk_n_append_auts(p_ssa_pdb,
                                         p_sip_msg))
                   {
                       /* AUTS appending fails */

                       sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
                           p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, \
                           Sdf_en_uacTransaction);

                       ret_val = ICF_FAILURE;
                   }
               }
           }

           /*Fix for SPR : 19188 (Rel 7.1.2 SPR merging for SPR 19143)*/
           /* If the request to be sent is INVITE with authroziation header
            * checking whether reffered-by header need to be inserted.*/
           if ((ICF_FAILURE != ret_val) && 
                   (ICF_NULL == icf_port_strcmp(p_ssa_pdb->p_method,(icf_uint8_t*)"INVITE")))
           {
               /* Insert the refer-by header only when call setup is not
                * completed.*/
               /* This will take care of scenario when outgoing INVITE request
                * inititated after receiving refer from network is rejected
                * with 401 or 407 response.Here we are forming the new INVITE
                * request with Authorization header.This INVITE request must contain
                * the refer-by header as initial call setup is not
                * completed.However for the subsequent Re-Invite for session
                * refresh when call connect is done IPTK must not insert the
                * refer-by header in Re-INVITE request.*/
               
				/* Fix for CSR 1-8366831: SPR 20317 */
				/* INVITE with Replaces sent after challenge must also contain
				 * Replaces header
				 */
               if (!(ICF_CALL_CONNECT_DONE & p_ssa_ctxt->p_call_ctxt->common_bitmask))
               {
                   
                   /* Being a outgoing INVITE request fetch sip message from
                    * UAC transaction*/
                   if (ICF_NULL != p_ssa_ctxt->p_call_obj->pUacTransaction)
                   {    
                       p_sip_msg   = p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg;
                   }
                   /* Forms and inserts a referred by header in the SipMsg
                    * passed */
                   	if ((ICF_NULL != p_ssa_ctxt->p_call_ctxt->p_referred_party_addr) &&
						(ICF_FAILURE == icf_ssa_form_and_insert_ref_by_hdr(p_ssa_pdb,
                                   p_sip_msg)))
                   	{
                       	sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
                                p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, \
                                Sdf_en_uacTransaction);
                        ret_val = ICF_FAILURE;                        
                   	}
					if ((ICF_NULL != p_ssa_ctxt->p_call_ctxt->p_replaces_header) &&
						(ICF_FAILURE == icf_ssa_form_and_insert_replaces_hdr(p_ssa_pdb,
                                   p_sip_msg)))
                   {
                       sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
                                p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, \
                                Sdf_en_uacTransaction);
                        ret_val = ICF_FAILURE;                        
                   }
               }
           }
           /* Fix for SPR: 19886 (Merged CSR 1-7444867)*/
           /* Fix for SPR: 19788
            * If the INVITE request is generated with Authentication info and
            * call connect is not done, check whether diversion header list is
            * present in call context or not. If present insert the Diversion
            * header in outgoing INVITE SIP request.
            */
           if((ICF_FAILURE != ret_val) && (ICF_NULL == 
                       icf_port_strcmp(p_ssa_pdb->p_method,(icf_uint8_t *)"INVITE"))
                   && (ICF_NULL != p_ssa_ctxt->p_call_ctxt) &&
                   !(p_ssa_ctxt->p_call_ctxt->common_bitmask & ICF_CALL_CONNECT_DONE))
           {   
               if ((ICF_NULL != p_ssa_ctxt->p_call_ctxt->p_diversion_header_list)
                       && (ICF_NULL != p_ssa_ctxt->p_call_ctxt->
                           p_diversion_header_list->no_of_diversion_data))
               {
				   /* SPR 19927: check for NULL before retrieving the Sip message
					* from the transaction.
					*/
	               if (ICF_NULL != p_ssa_ctxt->p_call_obj->pUacTransaction)
                   {    
                       p_sip_msg   = p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg;
                   }
				   
                   if (ICF_FAILURE == 
                           icf_ssa_form_and_insert_div_hdr(
                               p_ssa_pdb,p_sip_msg))
                   {
                       ret_val = ICF_FAILURE;
                   }       
               }
           }   
		   /* SPR 19999 - Fix for CSR 1-7618644 : SPR 19989.
			*If method is NOTIFY then copy the Event, Subscription state
			* and Content-Type header into Sip message
			*/
		   else if((ICF_FAILURE != ret_val) && (ICF_NULL == 
						   icf_port_strcmp(p_ssa_pdb->p_method,\
								   (icf_uint8_t *)"NOTIFY")))
		   {
				   if(Sdf_co_null != p_event_hdr)
				   {
						   if ((Sdf_co_null != p_overlap_trans_info) &&
										   (Sdf_co_null!= p_overlap_trans_info->pSipMsg))
						   {
								   if(Sdf_co_fail == sip_insertHeaderAtIndex(p_overlap_trans_info->pSipMsg,\
												   p_event_hdr, \
												   0, \
												   (SipError *)&(p_err->stkErrCode)))
								   {
										   ret_val = ICF_FAILURE;
								   }
						   }
				   }
				   if(Sdf_co_null != p_sub_state_hdr)
				   {
						   if ((Sdf_co_null != p_overlap_trans_info) &&
										   (Sdf_co_null!= p_overlap_trans_info->pSipMsg))
						   {
								   if(Sdf_co_fail == sip_insertHeaderAtIndex(p_overlap_trans_info->pSipMsg,\
												   p_sub_state_hdr, \
												   0, \
												   (SipError *)&(p_err->stkErrCode)))
								   {
										   ret_val = ICF_FAILURE;
								   }
						   }
				   }
				   if(Sdf_co_null != p_content_type_hdr)
				   {
						   if ((Sdf_co_null != p_overlap_trans_info) &&
										   (Sdf_co_null!= p_overlap_trans_info->pSipMsg))
						   {
								   sip_deleteHeaderAtIndex(p_overlap_trans_info->pSipMsg,\
												   SipHdrTypeContentType, 0, \
												   (SipError *)&(p_err->stkErrCode));

								   if(Sdf_co_fail == sip_insertHeaderAtIndex(p_overlap_trans_info->pSipMsg,\
												   p_content_type_hdr, \
												   0, \
												   (SipError *)&(p_err->stkErrCode)))
								   {
										   ret_val = ICF_FAILURE;
								   }
						   }
				   }

		   }        
           
           if((ICF_FAILURE != ret_val) &&
              (ICF_FAILURE == icf_ssa_make_send_auth_req(p_ssa_pdb,
                    p_overlap_trans_info,p_err)))
           {
              ret_val = ICF_FAILURE;
           }
        }
        /* MAC failure has occurred.Insert Authorization header with no res and no
         * auts paramter.
         */
        else if(ICF_FAILURE != ret_val)
        { 
            /* Now we are freeing the lists p_ssa_ctxt->p_auth_params_list 
             * and uac_auth_info_list as the stack API called below uses these
             * to form the Authorization header.In the case of MAC failure,the
             * subsequent function call to icf_ssa_make_aka_auth_hdr will make
             * the Authorization header.
             *
             * The lists size is being set to 0 by this call to sdf_listDeleteAll.
             * This is required as the stack API compares the sizes of the two
             * lists passed to it and returns failure if they are unequal.
             */

            sdf_listDeleteAll(p_ssa_ctxt->p_auth_params_list, p_err);
            sdf_listDeleteAll(&uac_auth_info_list,p_err);

            if(Sdf_co_fail == sdf_ivk_uaFormRequestWithAuthorization(\
                   p_ssa_ctxt->p_call_obj, p_overlap_trans_info, (Sdf_ty_s8bit*)p_ssa_pdb->p_method,
                   Sdf_co_true, p_ssa_ctxt->p_auth_params_list,\
                   &uac_auth_info_list, p_err))
            {
                sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
                       p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, \
                       Sdf_en_uacTransaction);

                ret_val = ICF_FAILURE;
            }
            /* Making Authorization header and inserting it into the outgoing
             * SIP message.
             */
            if(ICF_FAILURE != ret_val)
            {
                if(Sdf_co_null == p_overlap_trans_info)
                {
                    p_sip_msg = p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg;
                }
                else 
                {
                    p_sip_msg = p_overlap_trans_info->pSipMsg;
                }
 
                if(ICF_FAILURE == icf_ssa_make_aka_auth_hdr(p_ssa_pdb,
                                       p_sip_msg))
                {
                    sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
                            p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, \
                            Sdf_en_uacTransaction);

                    ret_val = ICF_FAILURE;
      	        }

                /*Fix for SPR : 19188 (Rel 7.1.2 SPR merging for SPR 19143)*/
                /* If the request to be sent is INVITE with authroziation header
                 * checking whether reffered-by header need to be inserted.*/
                if ((ICF_FAILURE != ret_val) && 
                        (ICF_NULL == icf_port_strcmp(p_ssa_pdb->p_method,(icf_uint8_t*)"INVITE")))
                {
                    /* Insert the refer-by header only when call setup is not
                     * completed.*/
                    /* This will take care of scenario when outgoing INVITE request
                     * inititated after receiving refer from network is rejected
                     * with 401 or 407 response.Here we are forming the new INVITE
                     * request with Authorization header.This INVITE request must contain
                     * the refer-by header as initial call setup is not
                     * completed.However for the subsequent Re-Invite for session
                     * refresh when call connect is done IPTK must not insert the
                     * refer-by header in Re-INVITE request.*/

					/* Fix for CSR 1-8366831: SPR 20317 */
                	/* INVITE with Replaces sent after challenge must also contain
                     * Replaces header
                 	 */
                    if (!(ICF_CALL_CONNECT_DONE & p_ssa_ctxt->p_call_ctxt->common_bitmask))
                    {
                        /* Forms and inserts a referred by header in the SipMsg
                         * passed */
                        if ((ICF_NULL != p_ssa_ctxt->p_call_ctxt->p_referred_party_addr) &&
                        	(ICF_FAILURE == icf_ssa_form_and_insert_ref_by_hdr(p_ssa_pdb,
                                    			p_sip_msg)))
                        {
                            sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
                                    p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, \
                                    Sdf_en_uacTransaction);
                            ret_val = ICF_FAILURE;                        
                        }
						if ((ICF_NULL != p_ssa_ctxt->p_call_ctxt->p_replaces_header) &&
                        	(ICF_FAILURE == icf_ssa_form_and_insert_replaces_hdr(p_ssa_pdb,
                                   				p_sip_msg)))
                        {
                            sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
                                    p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, \
                                    Sdf_en_uacTransaction);
                            ret_val = ICF_FAILURE;                        
                        }
                    }
                }
                /* Fix for SPR: 19886 (Merged CSR 1-7444867)*/
                /* Fix for SPR: 19788
                 * If the INVITE request is generated with Authentication info and
                 * call connect is not done, check whether diversion header list is
                 * present in call context or not. If present insert the Diversion
                 * header in outgoing INVITE SIP request.
                 */
                if((ICF_FAILURE != ret_val) && (ICF_NULL == 
                            icf_port_strcmp(p_ssa_pdb->p_method,(icf_uint8_t *)"INVITE"))
                        && (ICF_NULL != p_ssa_ctxt->p_call_ctxt) &&
                        !(p_ssa_ctxt->p_call_ctxt->common_bitmask & ICF_CALL_CONNECT_DONE))
                {   
                    if ((ICF_NULL != p_ssa_ctxt->p_call_ctxt->p_diversion_header_list)
                            && (ICF_NULL != p_ssa_ctxt->p_call_ctxt->
                                p_diversion_header_list->no_of_diversion_data))
                    {            
                        if (ICF_FAILURE == 
                                icf_ssa_form_and_insert_div_hdr(
                                    p_ssa_pdb,
                                    p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg))
                        {
                            ret_val = ICF_FAILURE;
                        }       
                    }
                }
                if (ICF_FAILURE != ret_val)
                {
                    if(ICF_FAILURE == icf_ssa_make_send_auth_req(p_ssa_pdb,
                                p_overlap_trans_info,p_err))
                    {
                        ret_val = ICF_FAILURE;
                    }
                }   
            }                  
        }
  
        /* TBD : Would we require auth para list in future */
        sdf_listDeleteAll(p_ssa_ctxt->p_auth_params_list, p_err);
        sdf_listDeleteAll(&uac_auth_info_list,p_err);
    } /* End else */
    
    /* We will free the structure p_uac_auth_info initialized by the stack
     * API sdf_ivk_uaInitUacAuthInfo only in the case of MAC failure or failure
     * due to some other processing.(like icf_cmn_process_aka_challenge returning
     * failure).In all other cases this structure is being used as it has
     * been populated by auth params.
     */
    if((ICF_FAILURE == ret_val)||(ICF_TRUE == is_mac_failure))
    {
       sdf_ivk_uaFreeUacAuthInfo(p_uac_auth_info);
    }
    /*Klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_overlap_trans_info)

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} /* End of icf_ssa_send_authorized_req */

/*******************************************************************************
 * 
 * FUNCTION:        icf_ssa_process_before_sending_auth_req
 *
 * DESCRIPTION:     This function perform misc function before sending auth req
 *                  for REGISTER and INVITE METHOD
 *
 ******************************************************************************/
icf_return_t icf_ssa_process_before_sending_auth_req(
        icf_ssa_pdb_st         *p_ssa_pdb,
        Sdf_st_callObject         **p_p_call_obj,
        Sdf_st_overlapTransInfo   **p_p_overlap_trans_info)
{
    icf_return_t  ret_val = ICF_SUCCESS;
    Sdf_st_error     sdf_error ;
    icf_ssa_ctxt_st  *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    Sdf_ty_s8bit     proto[ICF_MAX_SIZE_INT_USAGE_STR];
    Sdf_st_callObject              *p_call_obj = ICF_NULL;
    Sdf_st_overlapTransInfo   *p_overlap_trans_info = ICF_NULL;
    
    /* To remove warning */
    p_p_call_obj=p_p_call_obj;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

   if(ICF_NULL == p_ssa_ctxt)
    return ICF_FAILURE;

   if (Sdf_mc_strcasecmp((Sdf_ty_s8bit *)p_ssa_pdb->p_method,(Sdf_ty_s8bit *)"INVITE")==0) 
   {
        if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                                   p_ssa_ctxt->p_call_obj,
                                   &p_overlap_trans_info,
                                   "INVITE",
                                   &sdf_error))
        {
            /*Raise a Major error here - UATK_PROCESSING FAILURE*/
            sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                                   p_overlap_trans_info, "INVITE",
                                   Sdf_en_uacTransaction);

            p_call_obj = p_ssa_ctxt->p_call_obj;
            sdf_ivk_uaFreeCallObject(&p_call_obj);
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt, \
                       ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
            ret_val = ICF_FAILURE;
        }
   }
 else if (Sdf_mc_strcasecmp((Sdf_ty_s8bit *)p_ssa_pdb->p_method,(Sdf_ty_s8bit *)"SUBSCRIBE")==0) 
   {
        /* setting the Protocol */
       if((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_ssa_ctxt->transport)||
          (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_ssa_ctxt->transport))
       {
           icf_port_strcpy((icf_uint8_t *)proto,(icf_uint8_t *) "TCP");
       }
       else if(ICF_TRANSPORT_TYPE_UDP == 
               p_ssa_pdb->p_ssa_ctxt->transport)
       {
           icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
       }
       else if(ICF_TRANSPORT_TYPE_TLS == 
                p_ssa_pdb->p_ssa_ctxt->transport)
       {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
       }

       if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                   p_ssa_ctxt->p_call_obj,
                   &p_overlap_trans_info,
                   "SUBSCRIBE",
                   &sdf_error))
       {
           /*Raise a Major error here - UATK_PROCESSING FAILURE*/
           sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                   p_overlap_trans_info, "SUBSCRIBE",
                   Sdf_en_uacTransaction);
           p_call_obj = p_ssa_ctxt->p_call_obj;
           sdf_ivk_uaFreeCallObject(&p_call_obj);
           ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt, \
                   ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
               ret_val = ICF_FAILURE;
       }
       else if (Sdf_co_fail == sdf_ivk_uaSetTransportSchemeInTransaction(\
            p_ssa_ctxt->p_call_obj->pUacTransaction, p_overlap_trans_info,\
               proto, &sdf_error))
       {

           sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
                    p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method,\
                    Sdf_en_uacTransaction);

           ret_val = ICF_FAILURE;
       }

   }
  else if (Sdf_mc_strcasecmp((Sdf_ty_s8bit *)p_ssa_pdb->p_method,(Sdf_ty_s8bit*)"OPTIONS")==0) 
   {
       /* setting the Protocol */
       if((ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_ssa_ctxt->transport)||
          (ICF_TRANSPORT_MODE_BOTH == p_ssa_pdb->p_ssa_ctxt->transport))            
       {
             icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP");
       }
       else if(ICF_TRANSPORT_TYPE_UDP == 
               p_ssa_pdb->p_ssa_ctxt->transport)
       {
           icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
       }
       else if(ICF_TRANSPORT_TYPE_TLS == 
                p_ssa_pdb->p_ssa_ctxt->transport)
       {
            icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
       }

       if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                   p_ssa_ctxt->p_call_obj,
                   &p_overlap_trans_info,
                   "OPTIONS",
                   &sdf_error))
       {
           /*Raise a Major error here - UATK_PROCESSING FAILURE*/
           sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                   p_overlap_trans_info, "OPTIONS",
                   Sdf_en_uacTransaction);
           p_call_obj = p_ssa_ctxt->p_call_obj;
           sdf_ivk_uaFreeCallObject(&p_call_obj);
           ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt, \
                   ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
               ret_val = ICF_FAILURE;
       }
       else if (Sdf_co_fail == sdf_ivk_uaSetTransportSchemeInTransaction(\
            p_ssa_ctxt->p_call_obj->pUacTransaction, p_overlap_trans_info,\
               proto, &sdf_error))
       {

           sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,\
                    p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method,\
                    Sdf_en_uacTransaction);

           ret_val = ICF_FAILURE;
       }

   } 
   else 
   {
       if (Sdf_co_fail == sdf_ivk_uaStartTransaction(
                   p_ssa_ctxt->p_call_obj,
                   &p_overlap_trans_info,
                   (const Sdf_ty_s8bit *)p_ssa_pdb->p_method,
                   &sdf_error))
       {
           /*Raise a Major error here - UATK_PROCESSING FAILURE*/
           sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                   p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method,
                   Sdf_en_uacTransaction);
           p_call_obj = p_ssa_ctxt->p_call_obj;
           sdf_ivk_uaFreeCallObject(&p_call_obj);
           ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt, \
                   ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
               ret_val = ICF_FAILURE;
       }
   }
    *p_p_overlap_trans_info = p_overlap_trans_info;
    
    
       
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * 
 * FUNCTION:        icf_ssa_make_send_auth_req
 *
 * DESCRIPTION:     This function makes and send Authorized Req
 *
 ******************************************************************************/
icf_return_t icf_ssa_make_send_auth_req(
        icf_ssa_pdb_st         *p_ssa_pdb,
        Sdf_st_overlapTransInfo   *p_overlap_trans_info,
        Sdf_st_error               *p_err)
{
    icf_return_t ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st            *p_ssa_ctxt = ICF_NULL;
    icf_glb_pdb_st             *p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    SipMessage                 *p_sip_msg = Sdf_co_null;
    SipOptions                 sip_options;
    SipAddrSpec                *p_addr_spec = Sdf_co_null;
    Sdf_ty_u32bit              index = 0;
    Sdf_st_callObject          *p_call_obj = Sdf_co_null;
    icf_header_list_st         *p_hdr_list = ICF_NULL;
    icf_return_t               dummy_ret_val = ICF_SUCCESS;  
    
    if(ICF_NULL == p_glb_pdb)
    {
         ICF_PRINT(((icf_uint8_t *)"\nP_glb_pdb is null"));
         return ICF_FAILURE;          
    }
    ICF_FUNCTION_ENTER(p_glb_pdb)

    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt;
    if (ICF_NULL == p_ssa_ctxt)
    {
        return ICF_FAILURE;
    }

    /* SPR 19218 : Added NULL checks for merge of CSR 1-6458139 */ 
    ICF_CHECK_IF_VAR_IS_NULL(p_glb_pdb,
                             p_ssa_pdb->p_glb_cfg_data,
                             dummy_ret_val)
    if(ICF_FAILURE == dummy_ret_val)
    {
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_glb_pdb)
        return ret_val;
    }
    /* End SPR 19218 */
                                        
    p_call_obj = p_ssa_ctxt->p_call_obj;
   
    p_ssa_pdb->authorised_req=ICF_TRUE;

    if (Sdf_mc_strcasecmp((Sdf_ty_s8bit *)p_ssa_pdb->p_method,(Sdf_ty_s8bit *)"REGISTER")==0)
    {
        /*Changes to send contact header with the request*/
        while (index < p_ssa_ctxt->p_call_obj->pInitData->slContact.size)
        {
            SipHeader *pContactHdr = Sdf_co_null;

            sdf_listGetAt(&(p_ssa_ctxt->p_call_obj->pInitData->slContact),
                    index, (Sdf_ty_pvoid *)&pContactHdr, p_err);

            if (p_overlap_trans_info) sip_insertHeaderAtIndex(p_overlap_trans_info->pSipMsg, \
                    pContactHdr,(Sdf_ty_u32bit)index, \
                    (SipError *)&(p_err->stkErrCode));
            index++;
        }

        if (ICF_SUCCESS == ret_val &&
                ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_line_data->reg_mode)
        {
            if (p_overlap_trans_info) p_addr_spec = p_overlap_trans_info->pSipMsg->u.pRequest->pRequestLine->pAddrSpec;

            ret_val = icf_ssa_insert_param_in_addr_spec( p_ssa_pdb, 
                    p_addr_spec, (icf_uint8_t *)"transport", (icf_uint8_t *)"tcp",p_err);
        } /* else if (ICF_TRANSPORT_TYPE... */
        else if (ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->p_line_data->reg_mode)
        {
            if (p_overlap_trans_info) p_addr_spec = p_overlap_trans_info->pSipMsg->u.pRequest->pRequestLine->pAddrSpec;
            
            ret_val = icf_ssa_insert_param_in_addr_spec(
                p_ssa_pdb, p_addr_spec,
                (icf_uint8_t *)"transport", (icf_uint8_t *)"udp",p_err);
        }
        }/* if (Sdf_mc_strcasecmp(p_method,"REGISTER")==0) */

       if(ICF_NULL == p_overlap_trans_info)
       {
           p_sip_msg = p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg;
       }
       else
       {
           p_sip_msg = p_overlap_trans_info->pSipMsg;
       }
       
       /*CSR 1-6458139: In case the P-Early hedaer/P-Pref-Header
	    were present in initial INVITE, they must be sent again*/
       if (0 == Sdf_mc_strcasecmp((Sdf_ty_s8bit
                       *)p_ssa_pdb->p_method,(Sdf_ty_s8bit*)"INVITE"))
       {
           /* If the bitmask is set, then send P-Preferred-Identity header in
              INVITE
            */
           if((ICF_NULL != p_ssa_ctxt->p_call_ctxt) &&
              (ICF_PREFERRED_ID_HDR_REQD & p_ssa_ctxt->p_call_ctxt->common_bitmask))
           {
               if(ICF_FAILURE == icf_ssa_form_and_insert_pref_identity_hdr(
                                         p_ssa_pdb,
                                         p_sip_msg))
               {
                   ICF_PRINT(((icf_uint8_t*)"\nFailed to insert unknown header \
                        (P-Preferred-Identity)"));
                   sdf_ivk_uaClearTransaction(p_call_obj,
                                              p_overlap_trans_info, "INVITE",
                                              Sdf_en_uacTransaction);
                   sdf_ivk_uaFreeCallObject(&p_call_obj);

                   ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt, \
                       ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)

                   ret_val = ICF_FAILURE;
                   ICF_FUNCTION_EXIT(p_glb_pdb)
                   return ret_val;
              }
           }
           if(ICF_CALL_CONFIG_EARLY_MEDIA_HDR_SUPPORTED &
                p_ssa_pdb->p_glb_cfg_data->default_settings)
           {
               if (ICF_FAILURE ==
                   icf_ssa_insert_unknown_hdr_in_sip_msg(
                   p_ssa_pdb,
                   (icf_uint8_t*)"P-Early-Media",
                   (icf_uint8_t*)"recvonly,supported",
                   p_sip_msg))
               {
                   ICF_PRINT(((icf_uint8_t*)"\nFailed to insert unknown header \
                        (P-Early-Media)"));
                   sdf_ivk_uaClearTransaction(p_call_obj,
                                              p_overlap_trans_info, "INVITE",
                                              Sdf_en_uacTransaction);
                   sdf_ivk_uaFreeCallObject(&p_call_obj);

                   ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt, \
                               ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
                   ret_val = ICF_FAILURE;
                   ICF_FUNCTION_EXIT(p_glb_pdb)
                   return ret_val;
               }
           }
       }
        /*
         * The list of pAuthenticationParams and pUacAuthInfo are no longer
         * required and can be freed at this stage.
         */

        sip_options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;

     if (Sdf_mc_strcasecmp((Sdf_ty_s8bit *)p_ssa_pdb->p_method,(Sdf_ty_s8bit *)"SUBSCRIBE")==0)
        {
         /* The SUBSCRIBE request with credentials was carrying the 
             * headers specified in icf_subscribe_req->header_list twice
             * So remove it from here
             */
            p_hdr_list = ICF_NULL;
             /* &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->persistent_header_list);*/

    }
        else
        {
           if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx)
           {
              p_hdr_list = 
                &(p_ssa_pdb->p_glb_pdb->p_call_ctx->persistent_header_list);
           }
        }
 /* Following things need to be done when sending SUBSCRIBE with 
        * authentication parameters:
        * - Send the Expires header as was sent in initial SUBSCRIBE
        * - Send the Event header as was sent in initial SUBSCRIBE
        * - Send the Tag list as was sent in initial SUBSCRIBE
        */
        if (0 == Sdf_mc_strcasecmp((Sdf_ty_s8bit *)p_ssa_pdb->p_method,(Sdf_ty_s8bit *)"SUBSCRIBE"))
    {
        SipHeader                    *p_exp_hdr = SIP_NULL;
        SipHeader                    *p_event_hdr = SIP_NULL;
        SipError                     sip_err;

        /* Fix For SPR: 19999*/
		/* Fix for CSR 1-7502322: SPR 19844 */
		/* Expires header should be sent for UnSubscribe irrespective
		 * of App setting. For other SUBS messages, check whether Expires
		 * header needs to be sent or not.
		 */
        if ((!(ICF_SIC_EXPIRES_HDR_NOT_TO_BE_SEND & p_ssa_ctxt->p_sic_ctxt->bitmask)) ||
                (ICF_NULL == p_ssa_ctxt->p_sic_ctxt->app_requested_duration))
        {        
            /*Insert Expire header*/
            if (ICF_FAILURE == sip_initSipHeader(
                        &p_exp_hdr, SipHdrTypeExpiresSec, &sip_err))
            {
                sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
                ret_val = ICF_FAILURE;
            }
            else if (ICF_FAILURE == sip_setSecondsInExpiresHdr(
                        p_exp_hdr, p_ssa_ctxt->p_sic_ctxt->app_requested_duration,
                        &sip_err))
            {
                ret_val = ICF_FAILURE;
            }
            else if ( p_overlap_trans_info && (ICF_FAILURE == sip_setHeader(
                            p_overlap_trans_info->pSipMsg, 
                            p_exp_hdr, &sip_err)))
            {
                ret_val = ICF_FAILURE;
            }
        }
		if (ICF_FAILURE == ret_val)
		{
			ret_val = ICF_FAILURE;
			ICF_PRINT(((icf_uint8_t *)"\n[SSA]: Failed to set Expires header in SUBSCRIBE\n"));
		}        
        /* Insert Event header as SipHdrTypeEvent instead of SipHdrTypeUnknown */
        else if (ICF_FAILURE == sip_initSipHeader(
                    &p_event_hdr, SipHdrTypeEvent, &sip_err))
        {
            sip_freeSipHeader(p_event_hdr);
            ret_val = ICF_FAILURE;
        }
        else if (ICF_NULL == p_event_hdr)
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_FAILURE == sip_setEventTypeInEventHdr(
                    p_event_hdr,
                    Sdf_mc_strdupCT((const icf_int8_t *)p_ssa_ctxt->p_sic_ctxt->event_package.str),
                    &sip_err))
        {
            ret_val = ICF_FAILURE;
        }
        else if ( p_overlap_trans_info && (ICF_FAILURE == sip_setHeader(
                    p_overlap_trans_info->pSipMsg, p_event_hdr, &sip_err)))
        {
            ret_val = ICF_FAILURE;
        }
        else if ( p_overlap_trans_info && (ICF_NULL < p_ssa_ctxt->p_sic_ctxt->tag_list.count))
        {
            ret_val = icf_ssa_insert_tag_list_in_sip_msg(
                    p_ssa_pdb, &(p_ssa_ctxt->p_sic_ctxt->tag_list),
                    ICF_FALSE, p_overlap_trans_info->pSipMsg);
        }

        if (ICF_FAILURE == ret_val)
        {
            /*Raise a Major error here - UATK_PROCESSING FAILURE*/
            sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info, "SUBSCRIBE",
                    Sdf_en_uacTransaction);
            p_call_obj = p_ssa_ctxt->p_call_obj;
            sdf_ivk_uaFreeCallObject(&p_call_obj);
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,p_ssa_ctxt, \
                    ICF_MEM_COMMON, p_ssa_pdb->p_ecode, dummy_ret_val)
        }
        if (ICF_NULL != p_event_hdr)
        {
            sip_freeSipEventHeader((SipEventHeader*)p_event_hdr->pHeader);
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_event_hdr,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_ret_val)
        }
            sip_freeSipHeader((SIP_Pvoid)p_exp_hdr);
        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_exp_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
    }

    /* Insert the User-Agent header */
    if((ICF_FAILURE == ret_val)|| (ICF_FAILURE == dummy_ret_val))
    {
        /* do nothing */
    }
    else if (ICF_FAILURE == icf_ssa_insert_header_list_in_sip_msg(
                p_ssa_pdb,
                p_hdr_list,
                ICF_FALSE,
                p_sip_msg))
    {
        /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
        sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, 
                Sdf_en_uacTransaction);
        ret_val = ICF_FAILURE;
    }

    /*Insert P-Access-Network-Info hdr in SIP Message*/
    else if (ICF_FAILURE == 
                    icf_ssa_form_and_insert_access_nw_info_hdr(
                    p_ssa_pdb,p_sip_msg))
    {
        ret_val = ICF_FAILURE;
    }
   /* To add security association headers*/
    else if(ICF_FAILURE == icf_ssa_form_and_insert_security_agreement_hdrs(
                               p_ssa_pdb, (icf_uint8_t *)p_ssa_pdb->p_method,
                               p_sip_msg))
    {
        sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,
                p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, 
                Sdf_en_uacTransaction);
        ret_val = ICF_FAILURE;
    }
    /* Send request to peer */
    else if (ICF_FAILURE == icf_ssa_send_to_peer( p_ssa_pdb,\
                p_ssa_ctxt->p_call_obj, p_sip_msg,\
                &sip_options, p_err))
    {
        /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
        sdf_ivk_uaClearTransaction(p_ssa_ctxt->p_call_obj,\
                p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, Sdf_en_uacTransaction);
        ret_val = ICF_FAILURE;
    }
    else if (Sdf_co_fail == sdf_ivk_uaEndTransaction(\
                    p_ssa_ctxt->p_call_obj, Sdf_co_null, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, p_err))
        {
            /* Raise/Set Error: UATK_PROCESSING_FAILURE*/
            sdf_ivk_uaClearTransaction( p_ssa_ctxt->p_call_obj,
                    p_overlap_trans_info, (const Sdf_ty_s8bit *)p_ssa_pdb->p_method, Sdf_en_uacTransaction);
            ret_val = ICF_FAILURE;
        }


        ICF_FUNCTION_EXIT(p_glb_pdb)
        return ret_val;
}


/*******************************************************************************
 * 
 * FUNCTION:        icf_ssa_fetch_auth_param_list
 *
 * DESCRIPTION:     This function extracts auth param received in 401/407
 *
 ******************************************************************************/
icf_return_t icf_ssa_fetch_auth_param_list(
        icf_ssa_pdb_st         *p_ssa_pdb,
        Sdf_st_callObject         **p_p_call_obj,
        Sdf_st_overlapTransInfo   *pOverlapTransInfo
        )
{

    icf_return_t ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st            *p_ssa_ctxt = ICF_NULL;
    Sdf_st_error         err;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)


    /* Copy the ssa ctxt pointer locally */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt;

 
    /* Re-initialize the list in ssa ctxt */
    if (ICF_NULL != p_ssa_ctxt->p_auth_params_list)
    {
        sdf_listDeleteAll(
                p_ssa_ctxt->p_auth_params_list,
                &err);
    }
    else
    {
        ICF_MEMGET(
                p_ssa_pdb->p_glb_pdb,
                ICF_PORT_SIZEOF(Sdf_ty_slist),
                ICF_MEM_COMMON,
                p_ssa_ctxt->p_auth_params_list,
                ICF_RET_ON_FAILURE,
                p_ssa_pdb->p_ecode,
                ret_val)
    }

    if (Sdf_co_fail == sdf_listInit(
                p_ssa_ctxt->p_auth_params_list,
                __sdf_fn_uaFreeAuthenticationParams,
                Sdf_co_false,
                &err))
    {
        ret_val = Sdf_co_fail;
    }
    else if (Sdf_co_fail == sdf_ivk_uaGetAuthParams(
                *p_p_call_obj,
                pOverlapTransInfo,
                p_ssa_ctxt->p_auth_params_list,
                &err))
    {
        ret_val = Sdf_co_fail;
    }
    else
    {
        sdf_listSizeOf(
                p_ssa_ctxt->p_auth_params_list,
                &(p_ssa_ctxt->auth_params_list_size),
                &err);

        /* 
         * If no auth params are recd from PEER, then 
         * free thee list
         */
        if (ICF_NULL == p_ssa_ctxt->auth_params_list_size)
        {
            sdf_listDeleteAll(
                    p_ssa_ctxt->p_auth_params_list,
                    &err);
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_ssa_ctxt->p_auth_params_list,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
        }

    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_make_request_digest
 *
 * DESCRIPTION:     This creates request digest for digest authentication
 *                  
 * RETURNS:         ICF_SUCCESS in case of success and ICF_FAILURE in
 *                  case of failure.
 *
 ******************************************************************************/
icf_return_t icf_ssa_make_request_digest(
        INOUT    icf_glb_pdb_st *p_glb_pdb,
        IN      icf_www_authenticate_param_st *p_authenticate_params,
        INOUT    icf_authorisation_param_st   *p_authorization_params,
        IN         icf_uint32_t   msg_body_length, 
        IN         icf_uint8_t   *p_msg_body,
        OUT     icf_error_t    *p_ecode)
{
    icf_return_t                         ret_val = ICF_SUCCESS;
    icf_uint8_t   HA1[SDF_ADIGEST_HEX_CHECKSUM_LEN +1] = "";
    icf_uint8_t   HEntity[SDF_ADIGEST_HEX_CHECKSUM_LEN+1] = "";

    /* To remove warnings */
    p_glb_pdb=p_glb_pdb;
    p_ecode=p_ecode;

        /* 
         * Calculate the H(A1)
         */
        sdf_fn_uaDigestCalcHA1((Sdf_ty_s8bit *)p_authenticate_params->p_algorithm, 
                     (Sdf_ty_s8bit *)p_authorization_params->p_username,
                     (Sdf_ty_s8bit *)p_authenticate_params->p_realm, 
                     (Sdf_ty_s8bit *)p_authorization_params->p_passwd, 
                     (Sdf_ty_s8bit *)p_authenticate_params->p_challenge,
                     (Sdf_ty_s8bit *)p_authorization_params->p_cnonce, (Sdf_ty_s8bit *)HA1);

        /* 
         * Calculate the H(Entity)
         */
        sdf_fn_uaDigestCalcHEntity((Sdf_ty_s8bit *)p_msg_body,
                                            msg_body_length,(Sdf_ty_s8bit *)HEntity);

        /* 
         * Calculate the response digest
         */
        sdf_fn_uaDigestCalcResponse((Sdf_ty_s8bit *)HA1,
                     (Sdf_ty_s8bit *)p_authenticate_params->p_challenge, 
                     (Sdf_ty_s8bit *)p_authorization_params->p_nonce_count,
                     (Sdf_ty_s8bit *)p_authorization_params->p_cnonce, 
                     (Sdf_ty_s8bit *)p_authenticate_params->p_qop,
                     (Sdf_ty_s8bit *)p_authorization_params->p_method, 
                     (Sdf_ty_s8bit *)p_authorization_params->p_uri, (Sdf_ty_s8bit *)HEntity,
                     (Sdf_ty_s8bit *)p_authorization_params->p_response);

    return(ret_val);
}


/*******************************************************************************
 * FUNCTION:        icf_ssa_rgm_remove_tags
 *
 * DESCRIPTION:     This function removes the parameters from the mandatory headers
 *                  To/ From/  for REGISTER message. 
 *                    
 ******************************************************************************/
 icf_return_t        icf_ssa_rgm_remove_tags(
     INOUT     icf_ssa_pdb_st                    *p_ssa_pdb,
     INOUT     SipMessage                           *p_sip_msg)
{
     icf_return_t                     ret_val = ICF_SUCCESS;
     SipError                             sip_error;
     en_HeaderType                     hdr_type = ICF_NULL;
     
     
     ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
         
    
     ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_sip_msg))

     icf_ssa_get_hdr_type_from_name((icf_uint8_t *)"From", &hdr_type, &sip_error);
     if (ICF_FAILURE == icf_ssa_clear_tags_for_hdr(
                            p_ssa_pdb, p_sip_msg,hdr_type))
     {
         ret_val = ICF_FAILURE;

     }
     else
     {
         icf_ssa_get_hdr_type_from_name((icf_uint8_t *)"To", &hdr_type, &sip_error);
         if (ICF_FAILURE == icf_ssa_clear_tags_for_hdr(
                            p_ssa_pdb, p_sip_msg,hdr_type))
         {
             ret_val = ICF_FAILURE;
         }

     }
     

     ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;



}/* Function icf_ssa_rgm_remove_tags() ends */

 
 /*****************************************************************************
 * FUNCTION:        icf_ssa_clear_tags_for_hdr
 *
 * DESCRIPTION:     This function removes the parameters from the header type
 *                  passed in the parameter list. Only the "tag" parameter in
 *                    To/From headaer is left intatct.
 *                    
 *****************************************************************************/
icf_return_t        icf_ssa_clear_tags_for_hdr(
     INOUT     icf_ssa_pdb_st                    *p_ssa_pdb,
     INOUT     SipMessage                           *p_sip_msg,
     INOUT           icf_uint32_t                        hdr_type)     
{
     icf_return_t                     ret_val = ICF_SUCCESS;
     icf_uint32_t                     loop_param = ICF_NULL;
     icf_uint32_t                     index_param = ICF_NULL;
     icf_uint32_t                     loop_hdr = ICF_NULL;
     icf_uint32_t                     param_count = ICF_NULL;
     icf_uint32_t                     hdr_count = ICF_NULL;
     SipError                             sip_error;
     SipHeader                             temp_hdr;
     SipParam                             *p_sip_param = ICF_NULL;
     
     
     

    if(ICF_NULL == p_ssa_pdb)
    {
        return ICF_FAILURE;
    }
	p_ssa_pdb=p_ssa_pdb;       
	
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
         
    
     ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_sip_msg))


     if (SipFail == sip_getHeaderCount(p_sip_msg,
            hdr_type, &hdr_count, &sip_error))
     {
         ret_val = ICF_FAILURE;

     }
     else 
     {
         for (loop_hdr = 0; (loop_hdr < hdr_count) && 
                            (ICF_SUCCESS == ret_val); loop_hdr++)
         {
             if (SipFail == sip_getHeaderAtIndex(p_sip_msg,
                        hdr_type, &temp_hdr, loop_hdr,&sip_error))
            {
                ret_val = ICF_FAILURE;
                break;
            }

            if (SipFail == sip_getParamCountFromCommonHdr(&temp_hdr,&param_count,
                                            &sip_error))
            {
                ret_val = ICF_FAILURE;
                /* free header */
                sip_freeSipHeader(&temp_hdr);
                break;
            }
            
            loop_param = 0;
            index_param = 0;
            while (loop_param != param_count)
            {
                if (SipFail == sip_getParamAtIndexFromCommonHdr(&temp_hdr, &p_sip_param,
                        index_param, &sip_error))
                {
                    ret_val = ICF_FAILURE;
                    
                    break;
                }
                 
                /* For the headers To and From: the parameter with name "tag"
                 * is generated by UATK, hence we are not removing it. */

                if ((SipHdrTypeTo == hdr_type || SipHdrTypeFrom == hdr_type)&&
                        (!icf_port_strcmp((icf_uint8_t *)p_sip_param->pName, (icf_uint8_t *)"tag")))
                {
                    loop_param++;
                    index_param++;
                    sip_freeSipParam(p_sip_param);
                    continue;
                }
                sip_freeSipParam(p_sip_param);

                if (SipFail ==  sip_deleteParamAtIndexInCommonHdr(&temp_hdr, index_param,
                                        &sip_error))
                {
                    ret_val = ICF_FAILURE;
                    break;
                }
                loop_param++;
             }/* while loop ends on param list */

            /* free header */
            sip_freeSipHeader(&temp_hdr);

         }/* for loop on hdr list: ends */
     }/* hdr count found: success */

     ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;

 }/* Function icf_ssa_clear_tags_for_hdr() ends */



 /*****************************************************************************
 * FUNCTION:        icf_ssa_get_reqline_as_string
 *
 * DESCRIPTION:     This function gets the request line from the SIP Message
 *                  and fills it as a string in the parameter p_target_str
 *                    
 *****************************************************************************/
icf_return_t icf_ssa_get_reqline_as_string(SipMessage *p_sip_msg, 
                                                 icf_uint8_t *p_target_str)
{
    SipReqLine *pReqLine=ICF_NULL;
    SipAddrSpec    *p_addr_spec = SIP_NULL;
    SipError sip_err = 0;
    icf_string_st param_str = {0,"\0"};
    icf_return_t ret_val = ICF_SUCCESS;
    
    if (ICF_NULL == p_sip_msg)
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA] : p_sip_msg is NULL\n"));
        return ICF_FAILURE;
    }

    icf_port_strcpy(param_str.str,(icf_uint8_t *)"");

    if(SipMessageRequest != p_sip_msg->dType)
    {
        return ICF_SUCCESS;
    }
    if (SipFail == sip_getReqLineFromSipReqMsg(p_sip_msg,
                &pReqLine,&sip_err))
    {
        return ICF_FAILURE;
    }

#ifdef ICF_WITH_MUATK_2_2
    p_addr_spec = pReqLine->pAddrSpec;
#else
    p_addr_spec = pReqLine->pRequestUri;
#endif

    if(SipAddrReqUri == p_addr_spec->dType)
    {
        icf_port_strcpy(p_target_str,(icf_uint8_t *)p_addr_spec->u.pUri);
    }
    else if(SipFail == sip_formSipParamList(
            /* SPR 19218 : UATK CSR_1-6613911 Change Start */SIP_NULL,
            /* SPR 19218 : UATK CSR_1-6613911 Change End */
            (icf_int8_t *)param_str.str,
            &(p_addr_spec->u.pSipUrl->slParam),
            (SIP_S8bit *)";",
            1,
            &sip_err))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        icf_port_strcpy(p_target_str,(icf_uint8_t *)"");

        if(ICF_NULL != p_addr_spec->u.pSipUrl->pUser)
        {
            icf_port_strcat(p_target_str,(icf_uint8_t *)"sip:");
            icf_port_strcat(p_target_str,(icf_uint8_t *)p_addr_spec->u.pSipUrl->pUser);
        }
        if(ICF_NULL != p_addr_spec->u.pSipUrl->pPassword)
        {
            icf_port_strcat(p_target_str,(icf_uint8_t *)":");
            icf_port_strcat(p_target_str,(icf_uint8_t *)p_addr_spec->u.pSipUrl->pPassword);
           
        }
        if(ICF_NULL != p_addr_spec->u.pSipUrl->pHost)
        {
            icf_port_strcat(p_target_str,(icf_uint8_t *)"@");
            icf_port_strcat(p_target_str,(icf_uint8_t *)p_addr_spec->u.pSipUrl->pHost);
        }

        if(ICF_NULL != p_addr_spec->u.pSipUrl->dPort)
        {
            icf_string_st port_str;
            icf_port_itoa(*(p_addr_spec->u.pSipUrl->dPort),port_str.str);
            icf_port_strcat(p_target_str,(icf_uint8_t *)":");
            icf_port_strcat(p_target_str, port_str.str);
        }
        
        /* Param List */
        icf_port_strcat(p_target_str,param_str.str);
        
        if(ICF_NULL != p_addr_spec->u.pSipUrl->pHeader)
            icf_port_strcat(p_target_str,(icf_uint8_t *)p_addr_spec->u.pSipUrl->pHeader);

    }

    sip_freeSipReqLine(pReqLine);
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_add_string_list_in_default_header
 **
 ** DESCRIPTION:        This function adds a headrer with the name p_hdr_name
 **                     and populates it with the values specified in the 
 **                     string list p_hdr_content
 **
 *****************************************************************************/
icf_return_t icf_ssa_add_string_list_in_default_header(Sdf_st_initData *p_profile,
                                              icf_uint8_t *p_name,
                                              icf_string_list_st *p_hdr_content,
                                              Sdf_ty_bool dAddAlways,
                                              icf_error_t *p_ecode)
{
    icf_string_list_node_st *p_cur_node;
    Sdf_st_error   sdf_error;
    icf_return_t ret_val = ICF_SUCCESS;
    icf_uint32_t i;
    /*To remove warnings */
    p_ecode=p_ecode;
    if(ICF_NULL == p_hdr_content)
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        for(i = p_hdr_content->count,p_cur_node = p_hdr_content->p_list;
        i--; 
        p_cur_node = p_cur_node->p_next)
        {
            if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,
                (icf_int8_t *)p_name,
                (icf_int8_t *)p_cur_node->str.str,
                dAddAlways,
                &sdf_error))
            {
                ret_val = ICF_FAILURE;
                break;
            }
        }
    }
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_make_app_profile
 **
 ** DESCRIPTION:        This function makes a SIP profile for an ICF application
 **
 *****************************************************************************/
icf_return_t icf_ssa_make_app_profile(Sdf_st_initData *p_profile,
                                            icf_ssa_pdb_st *p_ssa_pdb)
{
    icf_return_t      ret_val = ICF_SUCCESS;
    icf_app_conf_st   *p_app_conf = p_ssa_pdb->p_app_conf;

    /* Clone from default profile */
    if ( ICF_FAILURE == icf_ssa_clone_profile_data(p_ssa_pdb->p_glb_pdb,
        p_profile, p_ssa_pdb->p_ssa_glb_data->p_default_profile,p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    else if(ICF_NULL == p_app_conf)
    {
        /* Do nothing */
    }
    /* Supported Methods */
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
        p_profile,
        (icf_uint8_t *)"Allow", 
        &(p_app_conf->app_profile.supported_methods),
        Sdf_co_true,
        p_ssa_pdb->p_ecode)
        )
    {
        ret_val = ICF_FAILURE;
    }
    /* Supported Events */
    
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
        p_profile,
        (icf_uint8_t*)"Supported", 
        &(p_app_conf->app_profile.supported_events),
        Sdf_co_true,
        p_ssa_pdb->p_ecode)
        )
    {
        ret_val = ICF_FAILURE;
    }
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
        p_profile,
        (icf_uint8_t *)"Accept", 
        &(p_app_conf->app_profile.supported_content_types),
        Sdf_co_false,
        p_ssa_pdb->p_ecode)
        )
    {
        ret_val = ICF_FAILURE;
    }
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
        p_profile,
        (icf_uint8_t *)"Accept-Encoding", 
        &(p_app_conf->app_profile.supported_encodings),
        Sdf_co_true,
        p_ssa_pdb->p_ecode)
        )
    {
        ret_val = ICF_FAILURE;
    }
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
        p_profile,
        (icf_uint8_t *)"Accept-Language", 
        &(p_app_conf->app_profile.supported_languages),
        Sdf_co_true,
        p_ssa_pdb->p_ecode)
        )
    {
        ret_val = ICF_FAILURE;
    }
#if 0 /* This ICF release does not handle PRACK */
    /* Hardcoding 100 rel in supported header */
    else if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Supported","100rel",Sdf_co_true,&sdf_error))
    {
        ret_val = ICF_FAILURE;
    }
#endif

    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_make_profile_for_reg
 **
 ** DESCRIPTION:        This function makes a SIP profile for a registration
 **                     message
 **
 *****************************************************************************/

icf_return_t icf_ssa_make_profile_for_reg(Sdf_st_initData *p_profile,icf_ssa_pdb_st *p_ssa_pdb)
{
    icf_return_t                 ret_val = ICF_SUCCESS;
    Sdf_st_error                    sdf_error;
    icf_app_conf_st              *p_app_conf;
    icf_uint32_t                 count;
    icf_error_t                  *p_ecode;
    
    p_ecode = p_ssa_pdb->p_ecode;

    /* Remove all Extra Headers */
    if(Sdf_co_fail == sdf_listDeleteAll(&(p_profile->slExtraHeadersList), &sdf_error))
    {
        ret_val = ICF_FAILURE;
    }

    /* Clone from default profile */
    else if ( ICF_FAILURE == icf_ssa_clone_profile_data(p_ssa_pdb->p_glb_pdb,
        p_profile, p_ssa_pdb->p_ssa_glb_data->p_default_profile,p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        icf_uint8_t *p_hdr_name[ICF_NUM_APP_PROFILE_HDRS-1]={(icf_uint8_t *)"Allow", 
            (icf_uint8_t *)"Accept", 
            (icf_uint8_t *)"Accept-Encoding",
            (icf_uint8_t *)"Accept-Language"
        };
        /* Hardcoding 100 rel in supported header */
        /* 6_3_enhancement merge */
#if 0
        if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,p_hdr_name[1],"100rel",Sdf_co_true,&sdf_error))
        {
            /* clean up*/
            ret_val = ICF_FAILURE;
        }
#ifdef IMS_CLIENT
ICF_CHECK_IMS_START(p_ssa_pdb->p_glb_pdb,ICF_TRUE)

        /* Hardcoding path in supported header for IMS mode */
        if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,p_hdr_name[1],"path",Sdf_co_true,&sdf_error))
        {
            /* clean up*/
            ret_val = ICF_FAILURE;
        }

ICF_CHECK_IMS_END
#endif
        else 
#endif
        {
            icf_uint32_t counter;
            icf_rgm_app_ctxt_st    *p_app_data;

            for(count = 0;count<p_ssa_pdb->p_glb_cfg_data->max_applications;count++)
            {
                p_app_data =(icf_rgm_app_ctxt_st*)
                    &(p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->p_app_data_list[count]);

                counter = 0;
                
                
                if (ICF_FALSE == p_app_data->is_valid)
                    continue;
                
                if(ICF_FAILURE == icf_cfg_fetch_app_conf(
                    p_ssa_pdb->p_glb_pdb,
                    p_app_data->app_id,
                    &p_app_conf,
                    p_ecode))
                {
                    /* Free Memory */
                    ret_val = ICF_FAILURE;
                }         
                 else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(p_profile,p_hdr_name[counter++],&(p_app_conf->app_profile.supported_methods),Sdf_co_true,p_ecode))

                {
                    ret_val = ICF_FAILURE;
                }
#if 0
                else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(p_profile,p_hdr_name[counter++],&(p_app_conf->app_profile.supported_events),p_ecode))
                {
                    ret_val = ICF_FAILURE;
                }
#endif
                else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(p_profile,p_hdr_name[counter++],&(p_app_conf->app_profile.supported_content_types),Sdf_co_true,p_ecode))

                {
                    ret_val = ICF_FAILURE;
                }
                else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(p_profile,p_hdr_name[counter++],&(p_app_conf->app_profile.supported_encodings),Sdf_co_true,p_ecode))

                {
                    ret_val = ICF_FAILURE;
                }
                else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(p_profile,p_hdr_name[counter++],&(p_app_conf->app_profile.supported_languages),Sdf_co_true,p_ecode))
                {
                    ret_val = ICF_FAILURE;
                }
                if(ICF_FAILURE == ret_val)
                    break;
            }
        }
    }
    if(ICF_FALSE == p_ssa_pdb->p_glb_cfg_data->precondition_required)
    {   
         /*precondition: delete the precondition tag from the supported 
           header list*/
         ret_val = icf_ssa_modify_callobj_profile_for_precondition(
                    p_ssa_pdb,
                    p_profile, 
                    &sdf_error);
    }     
    /*********************ICF 8.0*********************/
    /*To the supported header add the default value "Path" */
    if (ICF_FAILURE != ret_val)
    {    
        if(Sdf_co_fail ==
                icf_ssa_addDefaultHeader(p_profile,"Supported","path",
                    Sdf_co_true,&sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
    }    
    
    return ret_val;
}


/*****************************************************************************
 ** FUNCTION:           icf_ssa_make_profile_for_internal_subscribe
 **
 ** DESCRIPTION:        This function makes a SIP profile for ICF initated 
 **                     SUBSCRIBE.Also if the ICF_SIC_AUTO_SUBSCRIPTION_FOR_REG_EVENT
 **                     bitmask is set in sic_ctxt it will add application/reginfo+xml
 **                     as supported content type in application profile.
 **
 *****************************************************************************/
icf_return_t icf_ssa_make_profile_for_internal_subscribe(Sdf_st_initData *p_profile,
                                                               icf_ssa_pdb_st *p_ssa_pdb)
{
    icf_return_t                 ret_val = ICF_SUCCESS;
    Sdf_st_error                 sdf_error;
    icf_error_t                  *p_ecode;
    icf_app_conf_st              *p_app_conf = ICF_NULL;
    icf_uint8_t                  *p_sptd_ctype = 
                                       (icf_uint8_t*)"application/reginfo+xml";
    icf_boolean_t                match_found = ICF_FALSE;
    icf_string_list_node_st      *p_list = ICF_NULL;
    
    p_ecode       = p_ssa_pdb->p_ecode;

    if(ICF_NULL == p_ssa_pdb->p_app_conf)
    {
        /* SPR 19776: NULL check is added for p_ssa_pdb->p_app_conf , in case it is 
         * not available then fetch the same from configuration. While sending the
         * message to secondary proxy, the function icf_ssa_process_otg_subs_req is 
         * directly called instead of icf_ssa_process_message. If an SSA APT handliing
         * function is invoked directly then p_ssa_pdb->p_app_conf wil always be NULL.
         */
        if(ICF_FAILURE == icf_cfg_fetch_app_conf(
                    p_ssa_pdb->p_glb_pdb,
                    p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->app_id,
                    &(p_ssa_pdb->p_app_conf),
                    p_ssa_pdb->p_ecode))
        {
            ICF_ALARM(((icf_uint8_t *)"[SSA] Not able set the applcation conf in the call context\n"));
            return ICF_FAILURE;
        }
    }
    p_app_conf    = p_ssa_pdb->p_app_conf;
    p_list        = p_app_conf->app_profile.supported_content_types.p_list;
    
    /* Clone from default profile */
    if ( ICF_FAILURE == icf_ssa_clone_profile_data(p_ssa_pdb->p_glb_pdb,
        p_profile, p_ssa_pdb->p_ssa_glb_data->p_default_profile,p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    /* If this is a subscribe request for reg event package triggered
     * internally by IPTK add application/reginfo+xml in Accept header along
     * with application profile if it is not added by application and make it
     * as a by default support .*/
    else if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt) &&
               (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt) &&
               (p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->bitmask &
                  ICF_SIC_AUTO_SUBSCRIPTION_FOR_REG_EVENT) && 
               (ICF_NULL != p_list))
    {
        /* If the auto subscription for reg event package is on IPTK shall by
         * default support the content type "application/reginfo+xml" ,so
         * inserting the content type "application/reginfo+xml" in application
         * profile .This will prevent the 415 response send for NOTIFY
         * received after subscription context for reg event package has been
         * deallocated and hence 481 response is send for the NOTIFY.*/

        /* Get the last node of supported_content_type link list maintained in
         * application profile*/
        while (ICF_NULL != p_list->p_next)
        {
            /* If the "application/reginfo+xml" is already added by application
             * as supported content type set the boolean value match_found as
             * TRUE so that it is not added again in application profile.*/
            if(0 == icf_port_strcmp(p_list->str.str,(icf_uint8_t*)"application/reginfo+xml"))
			{
			    match_found = ICF_TRUE;
				break;
			}            
            p_list = p_list->p_next;
        }
        /* Check for application/reginfo+xml in the last node of supported
         * content type list which is not done by the above while loop.*/ 
        if ((ICF_FALSE == match_found) && (0 ==
                    icf_port_strcmp(p_list->str.str,(icf_uint8_t*)"application/reginfo+xml")))
        {
            match_found = ICF_TRUE;
        }    
        if (ICF_FALSE == match_found)
        {    
            /* Reach of control here means "application/reginfo+xml" is not 
             * added by application as supported content type ,and auto
             * subscription for reg event package is ON.Allocate the
             * memory for the same and add "application/reginfo+xml" to
             * application profile .*/
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                    ICF_PORT_SIZEOF(icf_string_list_node_st),
                    ICF_MEM_COMMON,
                    p_list->p_next, 
                    ICF_RET_ON_FAILURE,
                    p_ecode,
                    ret_val)

            icf_port_memcpy(
                        &(p_list->p_next->str.str),(p_sptd_ctype),
                        icf_port_strlen(p_sptd_ctype)+1);

            p_list->p_next->str.str_len = icf_port_strlen(p_sptd_ctype);
            /* Incrementing the count of supported_content_type in application
             * profile*/
            p_app_conf->app_profile.supported_content_types.count++;           
        }
        if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Accept",
            "application/reginfo+xml",Sdf_co_true,&sdf_error))
        {
                /* clean up*/
            ret_val = ICF_FAILURE;
        }    
    }    
    /*else part for handling the other IPTK initiated subscribe request*/
    else 
    {    
        /* Hardcoding reg event package in the request */
        if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Supported",
                                             "reg",Sdf_co_true,&sdf_error))
        {
            /* clean up*/
            ret_val = ICF_FAILURE;
        }
        /* Hardcoding reg event package in the request */
        else if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Allow",
                                           "NOTIFY",Sdf_co_true,&sdf_error))
        {
            /* clean up*/
            ret_val = ICF_FAILURE;
        }  
        /* Hardcoding reg event package: content-type accepted in the NOTIFY */
 
        /* Fix for SPR 10936
         */
        else if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Accept",
                "application/reginfo+xml",Sdf_co_true,&sdf_error))
        {
            /* clean up*/
            ret_val = ICF_FAILURE;
        }
        else if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Accept",
                "multipart/mixed",Sdf_co_true,&sdf_error))
        {
            /* clean up*/
            ret_val = ICF_FAILURE;
        }
        else if(Sdf_co_fail == icf_ssa_addDefaultHeader(p_profile,"Accept",
                "multipart/related",Sdf_co_true,&sdf_error))
        {
            /* clean up*/
            ret_val = ICF_FAILURE;
        }
    }

    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_validate_basic_method
 **
 ** DESCRIPTION:        This function checks if the method in sip message is 
 **                     supported by the application. This fn checks only the 
 **                     basic methods (INVITE,ACK,CANCEL,OPTIONS,BYE)
 **                     p_invalid is set to true if method recieved one of the 
 **                     basic methods and the application supports basic
 **                     methods. Otherwise it is set to false
 **
 *****************************************************************************/
icf_return_t icf_ssa_validate_basic_method(
                                                 icf_ssa_pdb_st *p_ssa_pdb,
                                                 SipMessage *p_sip_msg, 
                                                 icf_boolean_t *p_invalid)
{
    icf_uint8_t *p_method;
    Sdf_ty_messageType dMethodType = Sdf_en_unknownRequest;
    Sdf_st_error sdf_err;
    icf_return_t ret_val = ICF_SUCCESS;
    icf_boolean_t match_found = ICF_FALSE;
    *p_invalid = ICF_FALSE;

    if(sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg, \
        ((Sdf_ty_s8bit ** )&p_method),  &sdf_err) == Sdf_co_fail)
    {
        ret_val = ICF_FAILURE;
    }
    else if(Sdf_co_fail == sdf_fn_uaGetMethodNameAsEnum((const Sdf_ty_s8bit *)p_method, &dMethodType, &sdf_err))
    {
        ret_val = ICF_FAILURE;
    }
    else if(ICF_NULL == p_ssa_pdb->p_app_conf)
    {
        *p_invalid = ICF_TRUE;
    }
    else if ( ( (dMethodType == Sdf_en_invite)||   
        (dMethodType == Sdf_en_ack)    || \
        (dMethodType == Sdf_en_cancel) ||     \
        (dMethodType == Sdf_en_update) || \
        (dMethodType == Sdf_en_bye)    ||     \
        (dMethodType == Sdf_en_options)||
        (dMethodType == Sdf_en_prack)) &&
        (ICF_FALSE == p_ssa_pdb->p_app_conf->app_profile.basic_method_support))
    {
        *p_invalid = ICF_TRUE;
    }
    else
    {
        icf_string_list_st *p_supp_methods =
            &(p_ssa_pdb->p_app_conf->app_profile.supported_methods);

        if(ICF_NULL == p_supp_methods)
        {
            *p_invalid = ICF_TRUE;
        }
        else
        {
            icf_string_list_node_st *p_cur_node = ICF_NULL;
            icf_uint8_t i = 0;

            for(i = (icf_uint8_t)p_supp_methods->count,p_cur_node = p_supp_methods->p_list;
                    i--; 
                    p_cur_node = p_cur_node->p_next)
            {
                if(0 == icf_port_strcasecmp((const icf_int8_t *)p_method,(const icf_int8_t *)p_cur_node->str.str))
                {
                    match_found = ICF_TRUE;
                    break;
                }                
                else if (((Sdf_en_invite == dMethodType) || 
                            (Sdf_en_cancel == dMethodType) ||
                            (Sdf_en_ack == dMethodType) ||
                            (Sdf_en_bye == dMethodType) ||
                            (Sdf_en_options == dMethodType) ||
                            (Sdf_en_update == dMethodType) ||
                            (Sdf_en_prack == dMethodType)
                         ) &&
                        (0 == 
                         icf_port_strcasecmp((const icf_int8_t *)p_cur_node->str.str,(const icf_int8_t *)"INVITE"))
                        )
                { 
                    match_found = ICF_TRUE;
                    break;
                }
            }
        }
    }

    if((ICF_TRUE == *p_invalid) || (ICF_FALSE == match_found))  
    {
        *p_invalid = ICF_TRUE;
        if(Sdf_en_unknownRequest == dMethodType)
        {
            p_ssa_pdb->p_ssa_ctxt->failure_bitmask |=
                ICF_SSA_FAILURE_RESP_CODE_501;
        }
        else
        {
            p_ssa_pdb->p_ssa_ctxt->failure_bitmask |=
                ICF_SSA_FAILURE_RESP_CODE_405;
        }
    }

    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_make_allow_hdr_from_app_profile
 **
 ** DESCRIPTION:        This function makes an allow header from the methods 
 **                     specified in the supported methods list of an application
 *****************************************************************************/

icf_return_t icf_ssa_make_allow_hdr_from_app_profile(icf_ssa_pdb_st *p_ssa_pdb,
                                                           SipHeader **p_p_allow_hdr)
{
    SipError sip_err;
    icf_return_t ret_val=ICF_SUCCESS;
    /* Fix for CSR 1-7436195 */
    /* Coverity bug fix */
    icf_string_st allow_string = {0,"\0"};
    icf_uint32_t count;
    icf_string_list_node_st *p_cur_node;
    icf_app_id_t     app_id = ICF_APP_ID_INVALID;

    if(ICF_NULL == p_ssa_pdb->p_app_conf)
    {
        p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= ICF_SSA_FAILURE_RESP_CODE_405;
        /* The most obvious reason for sending 405 is that none of 
         * the configured applications supports the received method.
         * But the 405 response must contain Allow header. So we 
         * will form the Allow header from the profile of 1st app.
         * ICF always assigns app_id=1 to the 1st app.
         */
        app_id = 1;
        ret_val = icf_cfg_fetch_app_conf(
                   p_ssa_pdb->p_glb_pdb, app_id,
                   &(p_ssa_pdb->p_app_conf),p_ssa_pdb->p_ecode);

    }

    if(ICF_NULL == p_ssa_pdb->p_app_conf)
    {
        *p_p_allow_hdr = ICF_NULL;
        return ICF_FAILURE;
    }

    if(SipFail == sip_initSipHeader(p_p_allow_hdr, SipHdrTypeAllow,&sip_err))
     {
        sip_freeSipHeader(*p_p_allow_hdr);
        *p_p_allow_hdr = ICF_NULL; 
        return ICF_FAILURE;
     }

    icf_port_strcpy(allow_string.str,(icf_uint8_t *)"");

    if(ICF_TRUE == p_ssa_pdb->p_app_conf->app_profile.basic_method_support)
    {
        /* add the basic methods */
        icf_port_strcat(allow_string.str,(icf_uint8_t *)"INVITE,ACK,CANCEL,BYE,UPDATE,OPTIONS");
    }

    for(count = p_ssa_pdb->p_app_conf->app_profile.supported_methods.count,
        p_cur_node = p_ssa_pdb->p_app_conf->app_profile.supported_methods.p_list;
        count--;p_cur_node = p_cur_node->p_next)
    {
        /* add to allow header */
        if(ICF_NULL == icf_port_strstr((const icf_int8_t *)allow_string.str,
                             (const icf_int8_t *) p_cur_node->str.str))
        {
            if(0 < icf_port_strlen(allow_string.str))
            {
                icf_port_strcat(allow_string.str,(icf_uint8_t *)",");
            }
            icf_port_strcat(allow_string.str,p_cur_node->str.str);
        }
    }

    if(0 < icf_port_strlen(allow_string.str))
    {
        if(SipFail == sip_setMethodInAllowHdr(*p_p_allow_hdr,
                 Sdf_mc_strdupSdp((const icf_int8_t *)allow_string.str), &sip_err))
        {
            ret_val = ICF_FAILURE;
        }
    }
    else
    {
        sip_freeSipHeader(*p_p_allow_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                *p_p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        *p_p_allow_hdr = ICF_NULL;
    }
    
    if(ICF_FAILURE == ret_val)
    {
        sip_freeSipHeader(*p_p_allow_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                *p_p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        *p_p_allow_hdr = ICF_NULL;
    }
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_make_allow_hdr_for_reg
 **
 ** DESCRIPTION:        This function makes an allow header for REGISTER
 *****************************************************************************/

icf_return_t icf_ssa_make_allow_hdr_for_reg(icf_ssa_pdb_st *p_ssa_pdb,
                                                           SipHeader **p_p_allow_hdr)
{
    SipError sip_err;
    icf_return_t ret_val=ICF_SUCCESS;
    icf_string_list_node_st *p_cur_node;
    icf_string_st allow_string;
    icf_uint8_t count1,count2;
    icf_rgm_app_ctxt_st    *p_app_data;
    icf_app_conf_st *p_app_conf;
    icf_error_t ecode;
    icf_boolean_t basic_methods = ICF_FALSE;


  

    if(SipFail == sip_initSipHeader(p_p_allow_hdr, SipHdrTypeAllow,&sip_err))
     {
        sip_freeSipHeader(*p_p_allow_hdr);
        return ICF_FAILURE;
     }

    icf_port_strcpy(allow_string.str,(icf_uint8_t *)"");
    
    /* Iterate on every application */
    for(count1 = 0;count1<p_ssa_pdb->p_glb_cfg_data->max_applications;count1++)
    {
        p_app_data =(icf_rgm_app_ctxt_st*)
            &(p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->p_app_data_list[count1]);
        
        if (ICF_FALSE == p_app_data->is_valid)
            continue;
        
        if(ICF_FAILURE == icf_cfg_fetch_app_conf(
            p_ssa_pdb->p_glb_pdb,
            p_app_data->app_id,
            &p_app_conf,
            &ecode))
        {
            /* Free Memory */
            ret_val = ICF_FAILURE;
            break;
        }
        if ((ICF_FALSE == basic_methods)&&
            (ICF_TRUE == p_app_conf->app_profile.basic_method_support))
        {
            basic_methods = ICF_TRUE;
            if(0 < icf_port_strlen(allow_string.str))
            {
                icf_port_strcat(allow_string.str,(icf_uint8_t *)",");
            }
            /* add the basic methods */
            icf_port_strcat(allow_string.str,(icf_uint8_t *)"INVITE,ACK,CANCEL,BYE,OPTIONS");
        }

        /* Iterate on all methods */
        for(count2 = (icf_uint8_t)p_app_conf->app_profile.supported_methods.count,
            p_cur_node = p_app_conf->app_profile.supported_methods.p_list;
        count2--;
        p_cur_node = p_cur_node->p_next)
        {
            if(ICF_NULL == icf_port_strstr((const icf_int8_t *)allow_string.str,
                                          (const icf_int8_t *)p_cur_node->str.str))
            {
                /* add to allow header */
                if(0 < icf_port_strlen(allow_string.str))
                {
                    icf_port_strcat(allow_string.str,(icf_uint8_t *)",");
                }
                icf_port_strcat(allow_string.str,p_cur_node->str.str);
            }
        }
    }
    if(ICF_SUCCESS == ret_val)
    {
        if(0 < icf_port_strlen(allow_string.str))
        {
            if(SipFail == sip_setMethodInAllowHdr(*p_p_allow_hdr,
                Sdf_mc_strdupSdp((const icf_int8_t *)allow_string.str), &sip_err))
            {
                ret_val = ICF_FAILURE;
            }
        }
        else
        {
            sip_freeSipHeader(*p_p_allow_hdr);
            
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                *p_p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        }

    }

    if(ICF_FAILURE == ret_val)
    {
        sip_freeSipHeader(*p_p_allow_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                *p_p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        ret_val = ICF_FAILURE;
    }
    return ret_val;
}

/*****************************************************************************
 ** FUNCTION:           icf_ssa_make_allow_hdr_for_int_subscribe
 **
 ** DESCRIPTION:        This function makes an allow header for SUBSCRIBE
 *****************************************************************************/
icf_return_t icf_ssa_make_allow_hdr_for_int_subscribe(icf_ssa_pdb_st *p_ssa_pdb,
                                                           SipHeader **p_p_allow_hdr)
{
    SipError sip_err;
    icf_return_t ret_val=ICF_SUCCESS;

    if(SipFail == sip_initSipHeader(p_p_allow_hdr, SipHdrTypeAllow,&sip_err))
     {
        sip_freeSipHeader(*p_p_allow_hdr);
        return ICF_FAILURE;
     }
    
    if(SipFail == sip_setMethodInAllowHdr(*p_p_allow_hdr,Sdf_mc_strdupSdp("NOTIFY"), &sip_err))
    {
        sip_freeSipHeader(*p_p_allow_hdr);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                *p_p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        ret_val = ICF_FAILURE;
        *p_p_allow_hdr = ICF_NULL;
        
    }

    return ret_val;
}


/*****************************************************************************
** FUNCTION: icf_ssa_addDefaultHeader
**
** DESCRIPTION: Adds Header information to the call profile.
**
******************************************************************************/
icf_return_t icf_ssa_addDefaultHeader
    (Sdf_st_initData *pInitData,
    icf_int8_t *pName,
    icf_int8_t *pValue,
    Sdf_ty_bool dAddAlways,
    Sdf_st_error *pErr)
{
    Sdf_ty_s8bit *current_name = Sdf_co_null;
    Sdf_ty_s8bit *pTmpValue = Sdf_co_null;
    Sdf_ty_u32bit valueCount,match_found=0;
    Sdf_ty_u32bit index=0;
    Sdf_st_configExtraHeaders *pConfHdr = Sdf_co_null;
    Sdf_st_listIterator dListIterator;
    Sdf_ty_bool duplicate_value = Sdf_co_false;

    /* Error checks in the input parameters */
    sdf_listInitIterator(&(pInitData->slExtraHeadersList), \
        &dListIterator, pErr);
#ifdef ICF_STRICT_TEST
    if(ICF_NULL == pValue)
    {
        pErr->errCode=Sdf_en_invalidParamError;
        ICF_ALARM(((icf_uint8_t *)" :[SSA]: Invalid Value in default header\n"));
        return Sdf_co_fail;
    }
    else if(ICF_NULL == *pValue)
    {
        pErr->errCode=Sdf_en_invalidParamError;
        ICF_ALARM(((icf_uint8_t *)" :[SSA]: Invalid Value in default header\n"));
                return Sdf_co_fail;
    }
#endif

    while (dListIterator.pCurrentElement != Sdf_co_null)
    {
        pConfHdr =(Sdf_st_configExtraHeaders *) \
                    (dListIterator.pCurrentElement->pData);


        if(pConfHdr->pParam == Sdf_co_null)
        {    
            pErr->errCode=Sdf_en_invalidParamError;
            return Sdf_co_fail;
        }

        if(sip_getNameFromSipParam(pConfHdr->pParam,&current_name,\
                (SipError*)&(pErr->stkErrCode)) == SipFail)
        {
            pErr->errCode=Sdf_en_headerManipulationError;
            return Sdf_co_fail;
        }
        if(Sdf_mc_strcasecmp((Sdf_ty_s8bit*)current_name,
                    (Sdf_ty_s8bit*)pName) ==0)
        {
            Sdf_ty_s8bit *p_val= Sdf_co_null;
            if( sip_getValueCountFromSipParam(pConfHdr->pParam,&valueCount,\
                (SipError*)&(pErr->stkErrCode)) == SipFail)
            {
                pErr->errCode=Sdf_en_headerManipulationError;
                return Sdf_co_fail;
            }
               for (index =0;index<valueCount;index++ )
            {
               if(SipFail == sip_getValueAtIndexFromSipParam(
                   pConfHdr->pParam,
                   &p_val, 
                   index, 
                   (SipError*)&(pErr->stkErrCode)))
               {
                   return Sdf_co_fail;
               }
               if(0 ==
                       Sdf_mc_strcasecmp((Sdf_ty_s8bit*)p_val,(Sdf_ty_s8bit*)pValue))
               {
                   /* Do not add this value as it is already present*/
                   duplicate_value = Sdf_co_true;
                   break;
               }
            }
            /* Add the tag in Supported header only if it is not 'timer'. 
               This tag is also added by the SIP stack.
            */
            if((Sdf_co_false == duplicate_value) &&
               (0 != Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pValue,(Sdf_ty_s8bit*)"timer")))        
            {
                pTmpValue = Sdf_mc_strdupCallHandler(pValue);
                if(sip_insertValueAtIndexInSipParam(pConfHdr->pParam, pTmpValue, \
                    valueCount, (SipError*)&(pErr->stkErrCode)) == SipFail)
                {
                    pErr->errCode=Sdf_en_headerManipulationError;
                    return Sdf_co_fail;
                }
            }
            match_found =1;
        }
        sdf_listNext(&dListIterator, pErr);
    }

    if(!match_found)
    {
        if(sdf_ivk_uaInitConfigExtraHeaders(&pConfHdr,pErr) == Sdf_co_fail)
        {
           /* klockworks warning removal*/
            sip_freeSipParam(pConfHdr->pParam);
            sdf_ivk_uaFreeConfigExtraHeaders(pConfHdr);
            pErr->errCode=Sdf_en_noMemoryError;
            return Sdf_co_fail;
        }

        pTmpValue = Sdf_co_null;

        pTmpValue = Sdf_mc_strdupCallHandler(pName);

        if (sip_setNameInSipParam(pConfHdr->pParam, pTmpValue, \
            (SipError*)&(pErr->stkErrCode)) == SipFail)
        {
            pErr->errCode=Sdf_en_headerManipulationError;
            sip_freeSipParam(pConfHdr->pParam);
            sdf_ivk_uaFreeConfigExtraHeaders(pConfHdr);
            return Sdf_co_fail;
        }

        pTmpValue = Sdf_co_null;

        pTmpValue = Sdf_mc_strdupCallHandler(pValue);


        if(sip_insertValueAtIndexInSipParam(pConfHdr->pParam, pTmpValue, 0, \
            (SipError*)&(pErr->stkErrCode)) == SipFail)
        {
            pErr->errCode=Sdf_en_headerManipulationError;
            sip_freeSipParam(pConfHdr->pParam);
            sdf_ivk_uaFreeConfigExtraHeaders(pConfHdr);
            return Sdf_co_fail;
        }
        
        /* ---- CSR 1-4986136 ---- */	
        /* For an incoming call, the headers in subsequent messages in that
         * dialog are inserted by sdf_ivk_uaAddExtraHeaders( ) from 
         * slExtraHeadersList formed here. Now we need 
         * that the Supported and Accept headers should not be inserted from 
         * app-profile. Rather, they should be inserted in the SIP msg only if 
         * sent by app in that request's header list.
         * This expected behavior is same as for an outgoing call where the 
         * call object specific profile contains Supported and Accept from header 
         * list and not from app-profile formed during app_add_req.
         * Therefore, insert these headers in ExtraHeadersList for processing but 
         * do not send in each message.
         */


        /* ---- CSR 1-4986136 ---- */	
	/* For an incoming call, the headers in subsequent messages in that
	 * dialog are inserted by sdf_ivk_uaAddExtraHeaders( ) from 
	 * slExtraHeadersList formed here. Now we need 
         * that the Supported and Accept headers should not be inserted from 
         * app-profile. Rather, they should be inserted in the SIP msg only if 
         * sent by app in that request's header list.
         * This expected behavior is same as for an outgoing call where the 
         * call object specific profile contains Supported and Accept from header 
         * list and not from app-profile formed during app_add_req.
	 * Therefore, insert these headers in ExtraHeadersList for processing but 
	 * do not send in each message.
         */
	/*LOAD FIX 
	if ((0 == icf_port_strcasecmp("Supported", pName)) ||
		(0 == icf_port_strcasecmp("Accept", pName)))
	{
		dAddAlways = Sdf_co_false;
	}
	*/
        if (dAddAlways == Sdf_co_true)
        {
            pConfHdr->pData = Sdf_mc_strdupConfig("yes");
        }

        if(sdf_listAppend(&(pInitData->slExtraHeadersList),\
            (Sdf_ty_pvoid)pConfHdr,pErr) ==Sdf_co_fail)
        {
            pErr->errCode=Sdf_en_headerManipulationError;
            return Sdf_co_fail;
        }    
    }

    pErr->errCode = Sdf_en_noUaError;
    return Sdf_co_success;
}
/*****************************************************************************
** FUNCTION: icf_ssa_match_app_filter
**
** DESCRIPTION: Match application Filter
**
******************************************************************************/

icf_return_t icf_ssa_match_app_filter(icf_ssa_pdb_st *p_ssa_pdb,
                                        SipMessage *p_sip_msg,
                                        icf_app_conf_st *p_app_conf,
                                        icf_boolean_t *p_match_success,
                                        icf_error_t *p_ecode)
{
    icf_int_filter_st  *p_list_ptr = ICF_NULL;
    icf_uint8_t        *p_method=ICF_NULL;
    Sdf_st_error          sdf_err;

    if(ICF_NULL == p_app_conf->p_filter_list)
    {
        *p_match_success = ICF_TRUE;  
        return ICF_SUCCESS;
    }


    /*  match_filter */
    for (p_list_ptr = (p_app_conf->p_filter_list)->p_filter_list;  
    ICF_NULL != p_list_ptr;
    p_list_ptr = (icf_int_filter_st *)p_list_ptr->p_next)
    {
        *p_match_success = ICF_FALSE;  
        switch(p_list_ptr->filter_type) 
        {
        case ICF_FILTER_BY_HEADER_NAME :
            {
                /* check if header present */
                if(ICF_FAILURE == icf_ssa_match_header_filter(
                    p_sip_msg,
                    p_list_ptr,
                    p_match_success,
                    p_ecode))
                {
                    return ICF_FAILURE;
                }
                break;
            }
        case ICF_FILTER_BY_HEADER_CONTENT :
            {
                if(ICF_FAILURE == icf_ssa_match_header_filter(
                    p_sip_msg,
                    p_list_ptr,
                    p_match_success,
                    p_ecode))
                {
                    return ICF_FAILURE;
                }
                
                break;
            }
        case ICF_FILTER_BY_METHOD_NAME :
            {
                /*get method name*/
                if(Sdf_co_fail == sdf_ivk_uaGetMethodFromSipMessage(
                    p_sip_msg,
                    (( Sdf_ty_s8bit **)&p_method),
                    &sdf_err))
                {
                    return ICF_FAILURE;
                }
                icf_ssa_match_string(
                    p_method,
                    (p_list_ptr->filter_expr).p_match_str_list->p_str,
                    p_list_ptr->match_type,
                    p_match_success);
                break;
            }
        case ICF_FILTER_BY_REQ_URI_HDR_PARAM :
            {
                /* extract & match request uri */
                if(ICF_FAILURE == icf_ssa_match_req_line_filter(
                    p_sip_msg,
                    p_list_ptr,
                    p_match_success,
                    p_ecode))
                {
                    return ICF_FAILURE;
                }
                
                break;
            }
        default : break;
        }
        if(*p_match_success != (p_app_conf->p_filter_list)->match_all)
        {
            break;
        }
    }

    if(ICF_TRUE == *p_match_success)
    {
        /* Filter Matched, now match the supported methods */
        if(ICF_FAILURE == icf_ssa_match_app_methods(p_ssa_pdb,p_sip_msg,
                p_app_conf,
                p_match_success,p_ecode))
        {
            return ICF_FAILURE;
        }
    }
    return ICF_SUCCESS;
}


/*****************************************************************************
** FUNCTION: icf_ssa_match_app_methods
**
** DESCRIPTION: Match application's Supported Methods 
**
******************************************************************************/

icf_return_t icf_ssa_match_app_methods(icf_ssa_pdb_st *p_ssa_pdb,
                                        SipMessage *p_sip_msg,
                                        icf_app_conf_st *p_app_conf,
                                        icf_boolean_t *p_match_success,
                                        icf_error_t *p_ecode)
{
    
    icf_uint8_t        *p_method=ICF_NULL;
    Sdf_st_error       sdf_err;
    icf_string_list_st *p_supp_methods =
        &(p_app_conf->app_profile.supported_methods);

   /* To remove warnings */
    p_ssa_pdb=p_ssa_pdb;
    p_ecode=p_ecode; 
    *p_match_success = ICF_FALSE;
    if(ICF_NULL == p_supp_methods)
    {
        *p_match_success = ICF_TRUE;
    }
           
    if(ICF_NULL != p_supp_methods)
    {
        icf_string_list_node_st *p_cur_node = ICF_NULL;
        icf_uint32_t i = 0;
        
        /*See whether the Method matches with the suppoted
        *methods of the application or not
        */
        if(Sdf_co_fail == sdf_ivk_uaGetMethodFromSipMessage(
            p_sip_msg,
            (( Sdf_ty_s8bit **)&p_method),
            &sdf_err))
        {
            return ICF_FAILURE;
        }
        else
        {
            Sdf_ty_messageType  msg_type;
            sdf_fn_uaGetMethodNameAsEnum((const Sdf_ty_s8bit *)p_method, &msg_type, &sdf_err);
            for(i = p_supp_methods->count,p_cur_node = p_supp_methods->p_list;
            i--; 
            p_cur_node = p_cur_node->p_next)
            {
                if(0 == icf_port_strcasecmp((const icf_int8_t *)p_method,(const icf_int8_t *)p_cur_node->str.str))
                {
                    *p_match_success = ICF_TRUE;
                    break;
                }
                else if (((Sdf_en_invite == msg_type) || 
                    (Sdf_en_cancel == msg_type) ||
                    (Sdf_en_ack == msg_type) ||
                    (Sdf_en_bye == msg_type) ||
                    (Sdf_en_prack == msg_type) ||
                    (Sdf_en_options == msg_type) ||
                    (Sdf_en_update == msg_type)
                    ) &&
                    (0 == 
                    icf_port_strcasecmp((const icf_int8_t *)p_cur_node->str.str,(const icf_int8_t *)"INVITE"))
                    )
                { 
                    *p_match_success = ICF_TRUE;
                    break;
                }
            }
        }/* Get Method Succeded*/
    }/*(ICF_NULL != p_hdr_content)*/
    return ICF_SUCCESS;
}

/*Message body header changes start*/
/*****************************************************************************
** FUNCTION: icf_ssa_get_media_type_from_content_type
**
** DESCRIPTION: The function extracts the media_type from the content-type 
**              header provided by the application to be present in the SIP 
**              message header or in the message body part.
**
******************************************************************************/

icf_return_t icf_ssa_get_media_type_from_content_type(
        INOUT  icf_uint8_t      *p_content_type,
        OUT Sdf_ty_s8bit        **p_p_media_type
        )
{
    char               delim[10] = {'\0'};
    Sdf_ty_s8bit       *p_ctype = "\0";
        
    /* Parse the content-type string to extract the media_type value
     */
    strcpy(delim,";\r\n");

    if(ICF_NULL != p_content_type)
    {
        Sdf_mc_strdup(p_ctype,(icf_int8_t*)p_content_type);
        p_ctype = strtok(p_ctype,delim);
        Sdf_mc_strdup(*p_p_media_type,p_ctype);
        sdf_memfree(Sdf_mc_callHandlerMemId, \
            (Sdf_ty_pvoid *)&p_ctype, Sdf_co_null);
    }
    else
    {
        return ICF_FAILURE;
    }

    return ICF_SUCCESS;
    
}/*End of icf_ssa_get_media_type_from_content_type.*/


/*****************************************************************************
** FUNCTION: icf_ssa_get_content_type_from_msg
**
** DESCRIPTION: The function extracts the content_type from incoming
**              SIP message or message body. This will extract the Media
**              Type and parameters from the Content-Type, if any are 
**              present in the content-type header. This function will
**              invoke SIP APIS directly to get the content-type header 
**              values.
**
******************************************************************************/

icf_return_t icf_ssa_get_content_type_frm_msg(
         /*INOUT   Sdf_st_callObject  *pObj, */
        INOUT   en_SipMessageType  dReqRespType,
        INOUT   icf_ssa_pdb_st     *p_ssa_pdb,
        INOUT   SipHeader          *pHeader,
        OUT  icf_uint8_t        **p_p_content_type
        )
{
    icf_uint8_t    count = 0;
    icf_uint8_t    index = 0;
    Sdf_ty_s8bit   *pMediaType = ICF_NULL;
    SipError        error;
    SipParam        *p_param_list = ICF_NULL;
    SipError        pErr;
    Sdf_st_error    sdf_error;
    Sdf_ty_s8bit    temp_buff[300];
    Sdf_ty_s8bit    *pBuff;
    Sdf_st_initData *pInitData;
    icf_return_t    ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb);

    /* Get Media-Type from Content-Type header
     */
    pInitData = p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData ;
    if (sip_getMediaTypeFromContentTypeHdr(pHeader, &pMediaType,\
                &error) == SipFail)
        {
          ICF_PRINT(((icf_uint8_t *)"\nFailed to get media-type from Content-Type "\
                  "Header"));
          sip_freeSipHeader(pHeader);
          return ICF_FAILURE;
        }
    /* Fix for content-type validation in Body Part
     */
    /* Validate the Content-Type Header in the Incoming SIP
     * Message body part
     */
    /* Check if the message body list is supported
     */
    if(ICF_FAILURE == icf_ssa_IsSupportedMediaTypeInMsgBody(\
                        /*pObj*/dReqRespType,pInitData,pMediaType,&sdf_error))
    {
        /* Media-Type in Content-Type of message body part is not supported
         */
        /* Generate 415 response
         */
        ICF_PRINT(((icf_uint8_t *)"[SSA:] Validation of Content-Type failed\n"));
        /* SPR 11096 Changes Start : Set the bitmask in ssa-ctxt to 
         * to indicate that 415 response is to be sent.
         */
         /*
        SipOptions        dOptions;
        SipMessage        *pMessage = Sdf_co_null;
        Sdf_st_transaction    *pTransaction = Sdf_co_null;
        Sdf_st_overlapTransInfo    *pOverlapTransaction = Sdf_co_null;
        dOptions.dOption= SIP_OPT_CLEN | SIP_OPT_FULLFORM;
        if(ICF_NULL != pObj->pUasTransaction->pSipMsg)
            pMessage = pObj->pUasTransaction->pSipMsg;
        else
            pMessage = pObj->pUacTransaction->pSipMsg;
            */
            /* 
         * Bad Content received in Content-type header. 415 unsupported
         * formed by UATK. Send the SipMsg by using .
         * sdf_ivk_uaGetTransactionForSipMsg
          */
        /*
        if (sdf_ivk_uaRejectRequest(pObj,\
                pInitData,415, &pOverlapTransaction, &sdf_error) == Sdf_co_fail)
        {
            ICF_PRINT(("\n[SSA]:Failed to form 415 response "));
            return ICF_FAILURE;
        }
            
        pMessage = pOverlapTransaction->pSipMsg;

        ICF_PRINT(("[SSA:] Validation of Content-Type failed\n"));
            
        if (ICF_FAILURE == icf_ssa_send_to_peer(p_ssa_pdb,
                    (pObj), pMessage, &dOptions,&sdf_error))
        {
            ret_val = ICF_FAILURE;
        }

        sdf_ivk_uaFreeOverlapTransInfo(pOverlapTransaction);

        
        if(sdf_ivk_uaGetTransactionForSipMsg(\
                (pObj), pMessage, &pTransaction, \
            &pOverlapTransaction, &sdf_error) == Sdf_co_success)
        {
            if(pOverlapTransaction == Sdf_co_null)
            {
                pMessage = pTransaction->pSipMsg;
                sdf_ivk_uaFreeTransaction(pTransaction);
            }
            else
            {
                pMessage = pOverlapTransaction->pSipMsg;
                sdf_ivk_uaFreeOverlapTransInfo(pOverlapTransaction);
            }

                        
            ICF_PRINT(("[SSA:] Validation of Content-Type failed\n"));
            if (ICF_FAILURE == icf_ssa_send_to_peer(p_ssa_pdb,
                    (pObj), pMessage, &dOptions,&sdf_error))
            {
                ret_val = ICF_FAILURE;
            }

        }*/
        p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
                    ICF_SSA_FAILURE_RESP_CODE_415;
        ret_val = ICF_FAILURE;
    }
       /*End of generating 415 response
        */
    else
    {
        Sdf_mc_strcpy(temp_buff,pMediaType);

        /* Get Parameter Count from the Content - Type header
         */
#if 0    
        if(sip_getParamCountFromContentTypeHdr(pHeader,(unsigned int *)\
                           &count, &pErr)!=SipFail)
#endif
        /* fix taken from Presence testing team while testing on device */
        if (!pHeader || !pHeader->pHeader)
        {
        }
        else
        {
            SipCommonHeader    *pCommonHdr = ICF_NULL;
            
            pCommonHdr = (SipCommonHeader*)(pHeader->pHeader);
            count = (icf_uint8_t) pCommonHdr->slParam.size;
            /* For each parameter get the parameter name and value
             *  and append to the content-type as string to be 
             *  passed to the application.
             */
            for(index = 0; index < count ; index++)
            {
                if(SipFail != sip_getParamAtIndexFromContentTypeHdr(
                            pHeader,&p_param_list,index,&pErr))
                {

                    if(ICF_NULL != p_param_list)
                    {
                        sdf_fn_uaSprintf(temp_buff+Sdf_mc_strlen(temp_buff),\
                            ";%s=%s",p_param_list->pName,
                            p_param_list->slValue.head->pData);

                        sip_freeSipParam(p_param_list);
                    }
                    
                }
                else
                    break;
                    
            }/*end of For Loop*/
                              
            Sdf_mc_strdup(pBuff,temp_buff);
            *p_p_content_type = (icf_uint8_t*)pBuff;
            
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
    return ret_val;

}

/************************************************************************
** FUNCTION: icf_ssa_set_unknown_hdr_in_MimeHdr
**
** DESCRIPTION: This function populates the unknown header in the SIP 
**              message body. These headers will be provided by the 
**              application. This function will invoke the SIP APIs 
**              directly to set the header.
**
************************************************************************/

icf_return_t icf_ssa_set_unknown_hdr_in_MimeHdr(
        INOUT    icf_header_st     *p_msg_hdr,
        INOUT  SipMimeHeader     *pMimeHdr
        )
{
    SipHeader     *pHeader = Sdf_co_null;
    Sdf_ty_s8bit  *pUnknownHdr = Sdf_co_null;
    Sdf_ty_s8bit  *pUnknownHdrName = Sdf_co_null;
    icf_error_t   ecode = ICF_ERROR_NONE;
    SipError      sip_error = 0;
    icf_return_t  ret_val = ICF_SUCCESS;
    
    if(SipFail == sip_initSipHeader(&pHeader,SipHdrTypeUnknown,\
                (SipError *)&sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\nCould not insert Message Body header"\
                    " in the SIP message\n"));
        sip_freeSipHeader(pHeader);
        return ICF_FAILURE;
    }

    /*  Fix for spr 19013 */
    if (ICF_NULL == p_msg_hdr)
    {
        ICF_PRINT(((icf_uint8_t *)"\n p_msg_hdr  is NUll \n"));
        sip_freeSipHeader(pHeader); 
        if(ICF_NULL != pHeader)
        {
            ICF_MEMFREE(p_persistent_glb_pdb,
                         pHeader,
                         ICF_MEM_COMMON,
                         &ecode,
                         ret_val)
             ret_val = ICF_FAILURE;
        }
        return ICF_FAILURE;
    }

    Sdf_mc_strdup(pUnknownHdr,(Sdf_ty_s8bit*)p_msg_hdr->hdr_value.str);
    Sdf_mc_strdup(pUnknownHdrName,(Sdf_ty_s8bit*)p_msg_hdr->hdr_name.str);
    if(SipFail == sip_setNameInUnknownHdr(pHeader,pUnknownHdrName,\
        &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"Unable to set Message body header Name\n"));
        ret_val = ICF_FAILURE; 
    }
    else if(SipFail == sip_setBodyInUnknownHdr(pHeader,pUnknownHdr,\
                &sip_error))
    {
        ICF_PRINT(((icf_uint8_t *)"Unable to set Message body header Value\n"));
        ret_val = ICF_FAILURE; 
    }
    /* Set the SIP header as MIME header in the message body.
     */
    else if(SipFail == sip_bcpt_insertAdditionalMimeHdrAtIndexInMimeHdr(\
                pMimeHdr,pHeader, 0 , &sip_error))
    {
        /* Free any local reference*/
        ICF_PRINT(((icf_uint8_t *)"Unable to set MIME Header in the message body\n"));
        ret_val = ICF_FAILURE; 
        
    }

    sip_freeSipHeader(pHeader);
    /*Klocwork warning removal*/
    if(ICF_FAILURE == ret_val)
    {
        if(ICF_NULL != pHeader)
        {
            ICF_MEMFREE(p_persistent_glb_pdb,
                        pHeader,
                        ICF_MEM_COMMON, 
                        &ecode,
                        ret_val)
            ret_val = ICF_FAILURE;
        }
    }
    /* Free any local reference*/
    return ret_val; 
}

/************************************************************************
** FUNCTION: icf_ssa_form_and_insert_content_disp_hdr_in_msg
**
** DESCRIPTION: This function form and insert the content disposition 
**              header in the SIP message body headers in the outgoing 
**              request.
**
*************************************************************************/
icf_return_t icf_ssa_form_and_insert_content_disp_hdr_in_msg(
        INOUT    icf_header_st          *p_msg_hdr,
        INOUT  SipMimeHeader          *pMimeHdr
        )
{
    SipHeader        *pHeader = Sdf_co_null;
    Sdf_ty_s8bit     *pContentDisp = Sdf_co_null;
    SipError         sip_err;    
    icf_error_t      ecode = ICF_ERROR_NONE;
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_return_t     dummy_ret_val = ICF_SUCCESS;

    if(SipFail == sip_initSipHeader(&pHeader,\
                SipHdrTypeContentDisposition,\
                (SipError*)&sip_err))
    {
        ICF_PRINT(((icf_uint8_t *)"Failed to initialize Content Disposition "
                    "Header\n"));
        sip_freeSipHeader(pHeader);
        return ICF_FAILURE;

    }
    
    Sdf_mc_strdup(pContentDisp,(icf_int8_t*)p_msg_hdr->hdr_value.str);

    /* Set Content Disposition Type in the Content-Disposition header
     */
    if(SipFail == sip_setDispTypeInContentDispositionHdr(pHeader,\
                pContentDisp,(SipError *)&sip_err))
    {
        ICF_PRINT(((icf_uint8_t *)"Failed to insert Content Disposition Type"\
                " in Content- Disposition Header\n"));
        sip_freeSipHeader(pHeader);
        ret_val = ICF_FAILURE;
    }

    /* Set the Content - Disposition Header in the MIME Header
     */
    else if(SipFail == sip_bcpt_setContentDispositionInMimeHdr(pMimeHdr,
                  pHeader,&sip_err))
    {
        ICF_PRINT(((icf_uint8_t *)"Failed to insert the Content Disposition"\
                " Header in the SIP message body.\n"));
        sip_freeSipHeader(pHeader);
        ret_val = ICF_FAILURE;
    }
    /*Free any local reference
     */
    sip_freeSipHeader(pHeader);
    ICF_MEMFREE(
                 p_persistent_glb_pdb,
                 pHeader,
                 ICF_MEM_COMMON,
                 &ecode,
                 dummy_ret_val)

    return ret_val;
}

/************************************************************************
** FUNCTION: icf_ssa_fill_msg_body_hdrs
**
** DESCRIPTION: This function insert the message body headers in the 
**              outgoing Sip Message.
**
************************************************************************/
icf_return_t icf_ssa_fill_msg_body_hdrs(
        INOUT    icf_ssa_pdb_st        *p_ssa_pdb,
        INOUT    icf_header_list_st    *p_hdr_list,
            INOUT  SipMsgBody               *pMsgBody
        )
{
    en_HeaderType       dType = SipHdrTypeAny;    
    SipError            SipErr;
    icf_header_st    *p_hdr = ICF_NULL;
    icf_uint16_t     hdr_count = 0;
    icf_return_t     ret_val = ICF_SUCCESS;
        /* To remove warnings */
        p_ssa_pdb=p_ssa_pdb;

    if(ICF_NULL != p_hdr_list->hdr)
    {
        p_hdr = p_hdr_list->hdr;
    }
    else
        return ICF_SUCCESS;
    hdr_count = (icf_uint16_t)p_hdr_list->count;

   if(ICF_NULL == pMsgBody->pMimeHeader)
   {
       /* Allocate Memory for mime header */
        if(SipFail == sip_bcpt_initSipMimeHeader(&pMsgBody->pMimeHeader,
            (SipError*)&SipErr))
        {
        /* Failed to initialize SIP Mime Header */
            ret_val = ICF_FAILURE;
        }
   }

    while(ICF_NULL != p_hdr && 0 < hdr_count)
    {
        /* Get Header Type from Name*/
        icf_ssa_get_hdr_type_from_name(p_hdr->hdr_name.str,\
                &dType,&SipErr);
        if(SipHdrTypeContentDisposition == dType)
        {
            /* Invoke the function for filling content 
             * disposition header in the Message body
             */
            if(ICF_FAILURE == 
               icf_ssa_form_and_insert_content_disp_hdr_in_msg(\
                    p_hdr,pMsgBody->pMimeHeader))
            {
                 ret_val = ICF_FAILURE;
                 break;
            }
        }
        else if(ICF_FAILURE == icf_ssa_set_unknown_hdr_in_MimeHdr(\
            p_hdr,pMsgBody->pMimeHeader))
        {
            ret_val = ICF_FAILURE;
            break;
        }
        hdr_count-- ;
        p_hdr = p_hdr->next;
    }
   return ret_val;
}

/************************************************************************
** FUNCTION: icf_ssa_get_mime_hdrs_from_sip_msg
**
** DESCRIPTION: This function retrieves the MIME headers from the SIP 
**              message. This function will invoke the SIP API's directly
**              to get these headers.
**
************************************************************************/
icf_return_t icf_ssa_get_mime_hdrs_from_sip_msg(
        /*INOUT       Sdf_st_callObject *pObj, */
        INOUT          en_SipMessageType dReqRespType,
        INOUT       icf_ssa_pdb_st    *p_ssa_pdb,
        INOUT       SipMsgBody        *pMsgBody,
        INOUT     icf_msg_body_st   *p_msg_body
        )
{
    SipMimeHeader         *pMime = Sdf_co_null;
    SipHeader             *pContentDisp = Sdf_co_null;
    icf_header_list_st    *p_hdr_list = ICF_NULL;
    icf_header_st         *p_hdr = ICF_NULL;
    icf_header_st         *p_temp_hdr = ICF_NULL;
    icf_uint8_t           *p_disp_type;
    icf_uint8_t           *p_content_type=ICF_NULL;
    icf_uint8_t           *p_cid = ICF_NULL;
    SIP_S8bit              *p_cdesc=ICF_NULL;
    Sdf_ty_s8bit          *p_encoding=ICF_NULL;
    SipError              sip_err;
    Sdf_st_error          sdf_err;
    icf_return_t          ret_val = ICF_SUCCESS;
    SipBool                  sip_ret_val ;
    
    if (ICF_NULL == p_msg_body)
        return ICF_FAILURE;
        
    /* Get Mime Headers list from Message Body
     */
    if(SipFail != sip_bcpt_getMimeHeaderFromMsgBody(pMsgBody,&pMime,
                &sip_err))
    {
        /* Get Content-Type Header from Message Body
         */
                   
        ret_val = icf_ssa_get_content_type_from_mime_body(
                    /*pObj*/dReqRespType,p_ssa_pdb,\
                   pMsgBody,pMime,&p_content_type);

        if(ICF_SUCCESS == ret_val)
        {
            
            
            if (p_content_type) 
			{ 
				icf_port_memcpy(p_msg_body->content_type.str, p_content_type,\
                icf_port_strlen(p_content_type));
            	p_msg_body->content_type.str_len = (icf_uint16_t)icf_port_strlen(\
                p_content_type);
			}
            
            sdf_memfree(Sdf_mc_callHandlerMemId, \
                (Sdf_ty_pvoid *)&p_content_type,\
                Sdf_co_null);
            p_hdr_list = &(p_msg_body->msg_body_hdr_list);
            if(ICF_NULL != p_hdr_list->hdr)    
            {
                ret_val = ICF_FAILURE;
            }
            /* Get Content - Disposition Header from MIME Body
            */
            else if (sip_initSipHeader(&pContentDisp, SipHdrTypeAny, \
                (SipError*)&(sdf_err.stkErrCode)) == SipFail)
            {
                sip_freeSipHeader(pContentDisp);
                ret_val = ICF_FAILURE;
            }
            
            else if(SipFail != sip_bcpt_getContentDispositionFromMimeHdr(\
                pMime,((SipHeader ** )&pContentDisp), &sip_err))
            {
            /* Get the Content Disposition Type from MIME
            *  Body
                */
                if(SipFail == sip_getDispTypeFromContentDispositionHdr(\
                    pContentDisp,(( SIP_S8bit ** )&p_disp_type),&sip_err))
                {
                    sip_freeSipHeader(pContentDisp);
                    sdf_memfree(Sdf_mc_callHandlerMemId, \
                        (Sdf_ty_pvoid *)&pContentDisp,Sdf_co_null);

                    ret_val = ICF_FAILURE;
                }
                /* Allocate memory for the Content Disposition 
                * Header
                */
                /*if(ICF_SUCCESS == ret_val)*/
                else
                {
                    p_hdr = (icf_header_st *)
                        sdf_memget(0,sizeof(icf_header_st),\
                        &sdf_err);
                    /*Klocwork Warning Removal*/
                    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_hdr)

                    if(Sdf_co_null != p_hdr)
                    {
                        p_hdr_list->count ++;
                        Sdf_mc_strcpy(p_hdr->hdr_name.\
                            str,(Sdf_ty_s8bit *)\
                            "Content-Disposition");
                        
                        p_hdr->hdr_name.str_len = \
                            
                            (icf_uint16_t) icf_port_strlen(p_hdr->\
                            hdr_name.str);
                        Sdf_mc_strcpy(p_hdr->hdr_value.\
                            str,p_disp_type);
                        p_hdr->hdr_value.str_len = \
                            (icf_uint16_t) icf_port_strlen(p_hdr->\
                            hdr_value.str);
                        p_hdr->next = ICF_NULL;
                        
                        if(ICF_NULL == p_hdr_list->hdr)
                        {
                            p_hdr_list->hdr = p_hdr;
                            p_temp_hdr = p_hdr_list->hdr;
                        }
                    }
                }
                
            }/*End of if block for Content Disposition Header*/
            
            if (ICF_FAILURE  != ret_val)
            {
                sip_freeSipHeader(pContentDisp);
                sdf_memfree(Sdf_mc_callHandlerMemId, \
                    (Sdf_ty_pvoid *)&pContentDisp,Sdf_co_null);
            }
             /* Get Content-Id from MIME Body
            */

            if((ICF_SUCCESS == ret_val) &&
                                (SipFail != sip_bcpt_getContentIdFromMimeHdr(pMime, 
                &p_cid, &(sip_err))))
            {
            /* Allocate memory for the Content Id Header
                */
                p_hdr = (icf_header_st *)
                    sdf_memget(0,sizeof(icf_header_st),
                    &sdf_err);
                /*Klocwork Warning Removal*/
                ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_hdr)

                if(Sdf_co_null != p_hdr)
                {
                    p_msg_body->msg_body_hdr_list.count ++;
                    Sdf_mc_strcpy(p_hdr->hdr_name.str,\
                        (icf_uint8_t *)"Content-Id");
                    p_hdr->hdr_name.str_len = \
                       (icf_uint16_t) icf_port_strlen(p_hdr->\
                        hdr_name.str);
                    Sdf_mc_strcpy(p_hdr->hdr_value.str,\
                        (icf_uint8_t *)p_cid);
                    p_hdr->hdr_value.str_len = \
                        (icf_uint16_t) icf_port_strlen(p_hdr->hdr_value.str);
                    
                    p_hdr->next = ICF_NULL;
                    
                    if(ICF_NULL == p_hdr_list->hdr)
                    {
                        p_hdr_list->hdr = p_temp_hdr = p_hdr;                         
                    }
                    else if (ICF_NULL != p_temp_hdr)
                    {
                        p_temp_hdr->next = p_hdr;
                        p_temp_hdr = p_temp_hdr->next;
                    }
                                        else
                                        {
                                            ret_val = ICF_FAILURE;
                                        }
                }
                
            }/*End of if block for Content ID Header*/
            
            
            sip_ret_val=sip_bcpt_getContentDescFromMimeHdr(pMime,\
                &p_cdesc,&sip_err);
            
            if(SipFail != sip_ret_val)
            {
                
            /* Allocate memory for the Content Description 
            * Header
                */
                p_hdr = (icf_header_st *)
                    sdf_memget(0,sizeof(icf_header_st),
                    &sdf_err);
                /*Klocwork Warning Removal*/
                ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_hdr)

                if(Sdf_co_null != p_hdr)
                {
                    p_msg_body->msg_body_hdr_list.count ++;
                    Sdf_mc_strcpy(p_hdr->hdr_name.str,\
                        (icf_uint8_t *)"Content-Desc");
                    p_hdr->hdr_name.str_len = \
                        (icf_uint16_t) icf_port_strlen(p_hdr->hdr_name.str);
                    
                    Sdf_mc_strcpy(p_hdr->hdr_value.str,\
                        p_cdesc);
                    p_hdr->hdr_value.str_len = \
                        (icf_uint16_t) icf_port_strlen(p_hdr->hdr_value.str);
                    
                    p_hdr->next = ICF_NULL;
                    
                    if(ICF_NULL == p_hdr_list->hdr)
                    {
                        p_hdr_list->hdr = p_temp_hdr = p_hdr;                         
                    }
                    else if(ICF_NULL != p_temp_hdr)
                    {
                        p_temp_hdr->next = p_hdr;
                        p_temp_hdr = p_temp_hdr->next;
                        
                    }
                }
                
            }/*End of if block for Content Description Header*/
            
            
             /* Get Content-Transfer encoding Header from MIME Body
            */
            if(SipFail != sip_bcpt_getContentTransEncodingFromMimeHdr(
                pMime, &p_encoding,&sip_err))
            {
            /* Allocate memory for the Content transfer 
            * Encoding Header
                */
                p_hdr = (icf_header_st *)
                    sdf_memget(0,sizeof(icf_header_st),
                    &sdf_err);
                /*Klocwork Warning Removal*/
                ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_hdr)

                if(Sdf_co_null != p_hdr)
                {
                    p_msg_body->msg_body_hdr_list.count ++;
                    Sdf_mc_strcpy(p_hdr->hdr_name.str,\
                        (icf_uint8_t *)"Content-Encoding");
                    p_hdr->hdr_name.str_len = \
                        (icf_uint16_t)icf_port_strlen(p_hdr->hdr_name.str);
                    
                    Sdf_mc_strcpy( p_hdr->hdr_value.str,\
                        p_encoding);
                    p_hdr->hdr_value.str_len = \
                        (icf_uint16_t) icf_port_strlen(p_hdr->hdr_value.str);
                    
                    p_hdr->next = ICF_NULL;
                    if(ICF_NULL == p_hdr_list->hdr)
                    {
                        p_hdr_list->hdr = p_temp_hdr = p_hdr;                         
                    }
                    else
                    {
                        if ( p_temp_hdr ) {
						p_temp_hdr->next = p_hdr;
                        p_temp_hdr = p_temp_hdr->next;
						}
                        
                    }
                }
                
            }/*End of if block for Content Transfer Encoding Header*/
        }

        sip_bcpt_freeSipMimeHeader(pMime);
       
    }
return ret_val;
}



/************************************************************************
** FUNCTION: icf_ssa_get_content_type_from_mime_body
**
** DESCRIPTION: The function extracts the content-tpe for an individual
**              Msg Body
**
************************************************************************/
icf_return_t icf_ssa_get_content_type_from_mime_body(
    /*INOUT  Sdf_st_callObject   *pObj,*/
    INOUT   en_SipMessageType dReqRespType,
    INOUT  icf_ssa_pdb_st      *p_ssa_pdb,
    INOUT  SipMsgBody        *pMsgBody,
    INOUT  SipMimeHeader       *pMime,
    OUT icf_uint8_t    **p_p_content_type)
{

    SipHeader     *pContentType = Sdf_co_null;
    Sdf_st_error     sdf_error;
    icf_return_t  ret_val = ICF_SUCCESS;
    /* To Remove warning */
    pMsgBody=pMsgBody;


    if (sip_initSipHeader(&pContentType, SipHdrTypeAny, \
        (SipError*)&(sdf_error.stkErrCode)) == SipFail)
    {
        sip_freeSipHeader(pContentType); 
        return ICF_FAILURE;
    }
    
    if (sip_bcpt_getContentTypeFromMimeHdr(pMime, \
        &pContentType, (SipError*)&(sdf_error.stkErrCode)) \
        != SipFail)
    {    
        /* Extract the content - type header values from the
         * Sip message body.
         */
        if(ICF_FAILURE == icf_ssa_get_content_type_frm_msg(\
                    /*pObj*/dReqRespType,p_ssa_pdb,pContentType,\
                           p_p_content_type))
        {    
            sip_freeSipHeader(pContentType);
            sdf_memfree(Sdf_mc_callHandlerMemId,
                (Sdf_ty_pvoid *)&pContentType,Sdf_co_null);
            ret_val = ICF_FAILURE;

        }
        
        else
        {
            sip_freeSipHeader(pContentType);
              sdf_memfree(Sdf_mc_callHandlerMemId,
                (Sdf_ty_pvoid *)&pContentType, Sdf_co_null);
            ret_val = ICF_SUCCESS;
        }

    }    
    return ret_val;
}
/*Message body header changes ends*/

/*******************************************************************************
 ** FUNCTION:           icf_ssa_make_otg_app_profile
 **
 ** DESCRIPTION:        This function makes a SIP profile for an ICF application
 **                     for an outgoing message. The Supported and Accept 
 **                     headers are formed from the header list in request API 
 **                     instead of the stored app profile.
 **
 ******************************************************************************/
icf_return_t icf_ssa_make_otg_app_profile(
                Sdf_st_initData         *p_profile,
                icf_ssa_pdb_st       *p_ssa_pdb)
{
#if 0
    Sdf_st_error                        sdf_error;
#endif
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_app_conf_st                  *p_app_conf = p_ssa_pdb->p_app_conf;
    icf_string_list_st               *p_supported_types = ICF_NULL;
    icf_header_list_st               *p_hdr_list = ICF_NULL;
    icf_header_list_st               temp_hdr_list={0,0};
    icf_list_st                      *p_temp_list_node = ICF_NULL;

/* Dump */
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* ---------------------------------------------------------------------- */
    /* In case of outgoing INVITE request, the Supported headers will be picked 
     * from the header_list in call_ctx.
     * In case of outgoing SUBSCRIBE/MESSAGE/PUBLISH/REFER/out-of-dialog-REFER 
     * request, Supported and Accept headers will be picked from the header_list
     * in sic_ctx.
     * This function will not be invoked for any other outgoing request
     */
    if (ICF_NW_OTG_CALL_SETUP == p_ssa_pdb->p_internal_msg->msg_hdr.msg_id)
    {
        /* For INVITE */
        /*SPR 19590 change start*/
        ret_val = icf_cmn_fetch_curr_hdr_list_node_from_call_ctx(
                         p_ssa_pdb->p_glb_pdb,
                         &p_temp_list_node);
        if((ICF_NULL != p_temp_list_node) && 
                (ICF_NULL != p_temp_list_node->p_data))
        {    
            p_hdr_list =  &(((icf_header_link_list_st*)
                        (p_temp_list_node->p_data))->header_list);
        }    
        else
        {
              p_hdr_list = &temp_hdr_list;
        }
        /*SPR 19590 change end*/
    }
    else
    {
        /* For SUBSCRIBE/MESSAGE/PUBLISH/REFER/out-of-dialog-REFER */
         if (ICF_NULL < p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list.count)
        {
           p_hdr_list = &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->header_list);
        }
        else
        {
           if (ICF_FAILURE == icf_cmn_clone_header_list(p_ssa_pdb->p_glb_pdb,
                                   &(p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->\
					   persistent_header_list),
                                   &temp_hdr_list, p_ssa_pdb->p_ecode))
           {
               return ICF_FAILURE;
           }
           else
           {
              p_hdr_list = &temp_hdr_list;
           }
        }
    }
    /* 6_3_enhancement merge */
#if 0

    /* ---------------------------------------------------------------------- */
    /* ******* Handling for Supported header <<-->> supported_events  ******* */
    /* copy the supported events from header list into p_supported_events */
    if (ICF_FAILURE == icf_cmn_get_strlist_from_hdrlist(
                                p_ssa_pdb->p_glb_pdb,
                                p_hdr_list,
                                "Supported",
                                &p_supported_events))
    {
        ret_val = ICF_FAILURE;
    }
#endif
    /* ---------------------------------------------------------------------- */
    /* ****** Handling for Accept header <<-->> supported_content_types ***** */
    /* copy supported content-types from header list into p_supported_types */
    if (ICF_FAILURE == icf_cmn_get_strlist_from_hdrlist(
                                p_ssa_pdb->p_glb_pdb,
                                p_hdr_list,
                                (icf_uint8_t *)"Accept",
                                &p_supported_types))
    {
        ret_val = ICF_FAILURE;
    }
    /* ---------------------------------------------------------------------- */
    /* Clone from default profile */
    else if (ICF_FAILURE == icf_ssa_clone_profile_data(
                                p_ssa_pdb->p_glb_pdb,
                                p_profile,
                                p_ssa_pdb->p_ssa_glb_data->p_default_profile,
                                p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    else if(ICF_NULL == p_app_conf)
    {
        /* Do nothing */
    }
    /* Supported Methods */
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
                                p_profile,
                                (icf_uint8_t *)"Allow", 
                                &(p_app_conf->app_profile.supported_methods),
                                Sdf_co_true,
                                p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    /* Supported Content-Encoding */
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
                                p_profile,
                                (icf_uint8_t *)"Accept-Encoding", 
                                &(p_app_conf->app_profile.supported_encodings),
                                Sdf_co_true,
                                p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    /* Supported Content-Language */
    else if(ICF_FAILURE == icf_ssa_add_string_list_in_default_header(
                                p_profile,
                                (icf_uint8_t *)"Accept-Language", 
                                &(p_app_conf->app_profile.supported_languages),
                                Sdf_co_true,
                                p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    /* Supported Content-Type - to be picked from request API header list */
    if ((ICF_SUCCESS == ret_val) && 
             (ICF_NULL != p_supported_types))
    {
        if (ICF_NULL != p_supported_types->count)
        {
            ret_val = icf_ssa_add_string_list_in_default_header(
                                p_profile,
                                (icf_uint8_t *)"Accept", 
                                p_supported_types,
                                Sdf_co_true,
                                p_ssa_pdb->p_ecode);

            /* free the memory allocated to p_supported_types */
            icf_cmn_free_string_list(
                p_ssa_pdb->p_glb_pdb,
                p_supported_types,
                p_ssa_pdb->p_ecode);
                
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb, 
                p_supported_types,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode, 
                ret_val)
        }
    }
    /*Klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_supported_types)

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;

} /* End function icf_ssa_make_otg_app_profile() */
/****************************************************************************
 * FUNCTION:           icf_ssa_get_last_node_of_timer_list
 *
 * DESCRIPTION:        This routine fetches last node of timer list
 * 
 *****************************************************************************/
icf_ssa_timer_list_st** icf_ssa_get_last_node_of_timer_list(
        icf_ssa_timer_list_st **p_timer_list)
{
    icf_ssa_timer_list_st **p_temp, *p_list = *p_timer_list;

    if (ICF_NULL == p_list)
    {
        p_temp = p_timer_list;
    }
    else
    {
        while(ICF_NULL != p_list->p_next)
        {
            p_list = p_list->p_next;
        }
        p_temp = &(p_list->p_next);
    } /* else */
    return p_temp;
} /* icf_ssa_timer_list_st *p_timer... */


/****************************************************************************
 * FUNCTION:           icf_ssa_insert_timer_in_list
 *
 * DESCRIPTION:        This routine inserts a timer in list
 * 
 *****************************************************************************/
icf_return_t icf_ssa_insert_timer_in_list(
        icf_glb_pdb_st        *p_glb_pdb,
        icf_ssa_timer_list_st **p_timer_list,
        icf_timer_id_t        timer_id,
        icf_void_t            *p_timer_data)
{
    icf_return_t           ret_val = ICF_SUCCESS;
    icf_ssa_timer_list_st  **p_temp = ICF_NULL;
    icf_error_t            ecode = ICF_ERROR_NONE;
    icf_return_t return_val = ICF_SUCCESS;

    /* SPR 18880 */
    if(ICF_NULL == p_glb_pdb)
    {
        ICF_PRINT(((icf_uint8_t*)("\n[SSA]: p_glb_pdb is NULL.\n")))
        return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_glb_pdb)

    /* Check if the timer to be inserted is valid or not */
    if(ICF_TIMER_ID_INVALID == timer_id)
    {
        ICF_PRINT(((icf_uint8_t*)("\n[SSA]: Trying to insert an invalid timer-ID.\n")))
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_glb_pdb)
        return ICF_FAILURE;
    }

    ICF_CHECK_IF_VAR_IS_NULL(p_glb_pdb,
                             p_timer_data,
                             return_val)
    if(ICF_FAILURE == return_val)
    {
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_glb_pdb)
        return ICF_FAILURE;
    }

    p_temp = icf_ssa_get_last_node_of_timer_list(p_timer_list);

   
    ICF_MEMGET(p_glb_pdb,
            ICF_PORT_SIZEOF(icf_ssa_timer_list_st),
            ICF_MEM_COMMON,
            (*p_temp),
            ICF_RET_ON_FAILURE,
            &ecode,
            ret_val)

    (*p_temp)->timer_id = timer_id;
    (*p_temp)->p_timer_data = p_timer_data;
    (*p_temp)->p_next = ICF_NULL;

    return ret_val;
}


/****************************************************************************
 * FUNCTION:           icf_ssa_delete_timer_frm_list
 *
 * DESCRIPTION:        This routine deletes a timer from list of which timer
 *                     ID is passed
 * 
 *****************************************************************************/
icf_void_t icf_ssa_delete_timer_frm_list(
        icf_ssa_pdb_st   *p_ssa_pdb,
        icf_ssa_ctxt_st  *p_ssa_ctxt,
        icf_timer_id_t   tim_id)
{
    icf_return_t           ret_val = ICF_SUCCESS;

    icf_ssa_timer_list_st  *p_list = ICF_NULL;
    icf_ssa_timer_list_st  *p_temp = ICF_NULL;
    icf_return_t return_val = ICF_SUCCESS;

    /* SPR 18880 */
    if(ICF_NULL == p_ssa_pdb)
    {
        ICF_PRINT(((icf_uint8_t*)("\n[SSA]: p_ssa_pdb is NULL.\n")))
        return;
    }
    ICF_CHECK_IF_ANY_OF_TWO_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                                        p_ssa_ctxt,
                                        p_ssa_ctxt->p_timer_list,
                                        return_val)
    if(ICF_FAILURE == return_val)
    {
        return;
    }

    /* Check if the timer to be deleted is valid or not */
    if(ICF_TIMER_ID_INVALID == tim_id)
    {
        ICF_PRINT(((icf_uint8_t*)("\n[SSA]: Trying to delete an invalid timer-ID.\n")))
        return;
    }
        
    p_list = p_ssa_ctxt->p_timer_list;
    p_temp = p_ssa_ctxt->p_timer_list;

    while(ICF_NULL != p_list)
    {
        if(tim_id == p_list->timer_id)
        {
            if (p_temp == p_list)
            {
                p_ssa_ctxt->p_timer_list = p_list->p_next;
            } /* if (p_temp == p_list) */
            else
            {
                p_temp->p_next = p_list->p_next;
            }
            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_list,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
            p_ssa_ctxt->timer_count--;
            break;
        } /* if(tim_id == p_list->timer_id) */
        p_temp = p_list;
        p_list = p_list->p_next;
    } /* while(ICF_NULL != p_list->n... */
}


/****************************************************************************
 * FUNCTION:           icf_ssa_check_if_any_timers_exist
 *
 * DESCRIPTION:        THis fucntion checks whether any timer is running for 
 *                     the given p_ssa_ctxt or not, it can be checked if the 
 *                     timer list is NULL or not 
 *
 *****************************************************************************/
icf_boolean_t   icf_ssa_check_if_any_timers_exist(
       icf_ssa_ctxt_st  *p_ssa_ctxt)
{
    icf_boolean_t  is_timer_exist = ICF_FALSE;

    /* SPR 18880 : Added NULL checks */
    if(ICF_NULL == p_ssa_ctxt)
    {
        ICF_PRINT(((icf_uint8_t*)("\n[SSA]: p_ssa_ctxt is NULL.\n")))
        return ICF_FALSE;
    }
   
    if (ICF_NULL < p_ssa_ctxt->timer_count)
    {
        is_timer_exist = ICF_TRUE;
    }

    return is_timer_exist;
}

/*****************************************************************************
 * FUNCTION:         icf_ssa_form_and_insert_unknown_hdr
 *
 * DESCRIPTION:        This function forms and inserts an unknown 
 *                  header into the SIP message passed  to it
 *                  The name of the header and the contents are
 *                  passed to this function.
 * 
 *****************************************************************************/
 icf_return_t icf_ssa_form_and_insert_unknown_hdr (
         icf_ssa_pdb_st  *p_ssa_pdb,
         icf_uint8_t     *p_hdr_name,
         icf_uint8_t     *p_hdr_contents,
         SipMessage         *p_sip_msg)
{
    icf_return_t     ret_val = ICF_SUCCESS;
    icf_return_t     dummy_ret_val = ICF_SUCCESS;
    SipHeader            *p_sip_header = SIP_NULL;
    SipError            sip_error;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* 
     * If the p_hdr_contents is a blank string,do not 
     * insert the unknown header,just return SUCCESS
     */
    if (ICF_NULL == icf_port_strlen(p_hdr_contents))
    {
        ICF_SSA_DEBUG(("\[SSA]:User Agent is not configured,ret success\n"));
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }
    /* Init the unknown hdr */
    if (SipFail == sip_initSipHeader(
                &p_sip_header,SipHdrTypeUnknown,&sip_error))
    {
        sip_freeSipHeader(p_sip_header);
        ret_val = ICF_FAILURE;
    }
    /* Set the name into the unknown hdr */
    else if (SipFail == sip_setNameInUnknownHdr(
                p_sip_header,(Sdf_ty_s8bit*)icf_port_strdup(p_hdr_name),&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Set the contents into the unknown hdr */
    else if (SipFail == sip_setBodyInUnknownHdr(
            p_sip_header,(icf_int8_t *)icf_port_strdup(p_hdr_contents),&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Insert the unknown hdr into the SIP message */
    else if (SipFail == sip_insertHeaderAtIndex(
            p_sip_msg, p_sip_header,0,&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Free the header memoryr  */
    if (SIP_NULL != p_sip_header)
    {
        sip_freeSipHeader(p_sip_header);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_sip_header,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*****************************************************************************
 * FUNCTION:        icf_ssa_clear_options_context
 *
 * DESCRIPTION:     This function in invoked when call termination is
 *                  initiated and OPTIONS is ongoing.This function sends the 
 *                  failure resp (487 Request Terminated)for the OPTIONS request
 *                  1. Stop the OPTIONS timer and flush entry from the map
 *                  2. Send failure resp to peer
 *
 *****************************************************************************/
icf_return_t icf_ssa_clear_options_context(
        icf_ssa_pdb_st *p_ssa_pdb)
{
    icf_return_t                 ret_val = ICF_SUCCESS;
    icf_return_t                 return_val = ICF_SUCCESS;
    Sdf_st_overlapTransInfo         *p_ovtxn = Sdf_co_null;
    Sdf_st_error                    sdf_error = {0,0,0,"\0"};
    SipOptions                      options = {0};
    icf_ssa_ctxt_st              *p_ssa_ctxt = ICF_NULL;
    icf_uint16_t                 sdf_resp_code = 487;
    /* ICF_6_1_OPTIONS_SUPPORT start */
    icf_internal_msg_st                 internal_msg = {{0,0,0,0,0,0},0};
    icf_sic_clear_options_ctx_st *p_clear_opt_ctx = ICF_NULL;
    icf_return_t                 dummy_ret_val = ICF_SUCCESS;
    /* ICF_6_1_OPTIONS_SUPPORT end */
    if ((ICF_NULL == p_ssa_pdb) || (ICF_NULL == p_ssa_pdb->p_ssa_ctxt))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Either SSA pdb or SSA ctxt is null"));
        return ICF_FAILURE;
    }
    else
    {
       p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt; 
    }
    if (ICF_NULL == p_ssa_pdb->p_glb_pdb)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:GLB Pdb is Null"));
        return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

        /* ICF_6_1_OPTIONS_SUPPORT start */

        /* Options timer will be handled by SIC */

        /* ICF_6_1_OPTIONS_SUPPORT end */
    /*SPR 18928 If the call is established and incoming OPTIONS
      is pending to be responded and Application terminates the call
      then in this case the appropriate response code is 500, however 
      as this function is invoked from flows where BYE is received from
      peer then existing error code of 487 is appropriate as per section
      15.1.2 of RFC 3261.*/
    if((ICF_NULL != p_ssa_ctxt->p_call_ctxt) &&
       !(ICF_REL_TYPE_NW_INITIATED & p_ssa_ctxt->p_call_ctxt->release_type))
    {
       sdf_resp_code = 500;
    }
    /*
     * Reset the mapping in the map maintained
     * in the SSA global data.Also reset the bit OPTIONS_ONGOING
     */
    icf_ssa_flush_entry_frm_map(p_ssa_pdb,p_ssa_ctxt);

        /* ICF_6_1_OPTIONS_SUPPORT start */
        internal_msg.msg_hdr.msg_id =
                ICF_SIC_CLEAR_OPTIONS_CTX;
        internal_msg.msg_hdr.payload_length =
                sizeof(icf_sic_clear_options_ctx_st);
        internal_msg.msg_hdr.p_glb_pdb = p_ssa_pdb->p_glb_pdb;
#ifdef ICF_ERROR_ENABLE
        internal_msg.msg_hdr.ecode = ICF_ERROR_TYPE_UNDEFINED;
#endif
        internal_msg.msg_hdr.status = ICF_STATUS_CONTINUE;
        internal_msg.p_msg_data = ICF_NULL;
        ICF_MEMGET(
                p_ssa_pdb->p_glb_pdb,
                internal_msg.msg_hdr.payload_length,
                ICF_MEM_COMMON,
                internal_msg.p_msg_data,
                ICF_RET_ON_FAILURE,
                p_ssa_pdb->p_ecode,
                ret_val
                );
        p_clear_opt_ctx =
                (icf_sic_clear_options_ctx_st*)(internal_msg.p_msg_data);

        p_clear_opt_ctx->p_sic_ctx = p_ssa_ctxt->p_sic_ctxt;

        icf_sic_process_mesg(&internal_msg);

        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                internal_msg.p_msg_data,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,dummy_ret_val)

        /* ICF_6_1_OPTIONS_SUPPORT end */

    /*
     * Fetch the overlapped transaction pOverlapTransInfo
     * stored in the call object corresponding to OPTIONS
    * request received
     */
     /*  Fix for spr 18882 */
    ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
            p_ssa_pdb->p_ssa_ctxt->p_call_obj, return_val)
    if(ICF_FAILURE == return_val)
    {
         return return_val;
    }
    if( ICF_FAILURE == icf_ssa_fetch_matching_overlap_txn(
                p_ssa_pdb,Sdf_en_options,Sdf_en_transactionReceived,
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,&p_ovtxn))
    {
        /*Raise/Set an error here - UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
    else if (Sdf_co_fail == sdf_ivk_uaFormResponse(sdf_resp_code, "OPTIONS",
                p_ssa_ctxt->p_call_obj,
                p_ovtxn,
                Sdf_co_false,
                &sdf_error))
    {
        /*Raise/Set Error here:UATK_PROCESSING_FAILURE*/
        ret_val = ICF_FAILURE;
    }
    else
    {
       /* To add the P-Access-Network Info header to the response */
       if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx)
       {  
           if ( ICF_FAILURE == 
                      icf_ssa_form_and_insert_access_nw_info_hdr(
                      p_ssa_pdb,p_ovtxn->pSipMsg))
           {
               ret_val = ICF_FAILURE ;
           }
        }
        if(ICF_SUCCESS == ret_val)
        {
           /* Specify the stack options */
            options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;
           if (ICF_FAILURE == icf_ssa_send_to_peer(p_ssa_pdb,
                    p_ssa_ctxt->p_call_obj,
                    p_ovtxn->pSipMsg,
                    &options,&sdf_error))
           {
              /*Raise/Set Error here:UATK_PROCESSING_FAILURE*/
               ret_val = ICF_FAILURE;
           }
        }
    }
    /*Klocwork warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_ovtxn)

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;

}
/*****************************************************************************
 * FUNCTION:           icf_ssa_update_contact_in_profile
 *
 * DESCRIPTION:        This  routine:
 *                     1. Adds the contact header into the profile of call 
 *                     object
 *****************************************************************************/
icf_return_t icf_ssa_update_contact_in_profile(
        INOUT   icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_return_t                 ret_val = ICF_SUCCESS;
    icf_glb_pdb_st               *p_glb_pdb = p_ssa_pdb->p_glb_pdb;
    icf_config_data_st           *p_glb_cfg_data = p_ssa_pdb->p_glb_cfg_data;
    icf_address_st               *p_user_address = ICF_NULL;
    Sdf_st_initData                 *p_callobj_spec_profile = 
                                    p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData;
    Sdf_st_error                    sdf_error;
    Sdf_ty_s8bit                    self_ip[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                    from_user_addr[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                    display_name[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit                    contact_addr[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t                  *p_temp = ICF_NULL;
    icf_transport_address_st      *p_contact_address = ICF_NULL;
    icf_transport_address_st        self_addr;
    
#ifdef ICF_NAT_RPORT_SUPPORT
    icf_rport_config_data_st            *p_rport_config_data = ICF_NULL;
#endif

    ICF_FUNCTION_ENTER(p_glb_pdb)
    ICF_SSA_INIT_TRANS_ADDR(&self_addr)

    p_user_address = &(p_glb_pdb->p_call_ctx->local_address);

    /*If per line self transport then copy address from line_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE == p_glb_cfg_data->self_addr_per_line)
    {
        if (ICF_NULL != p_ssa_pdb->p_line_data)
        {
            icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                        sizeof(icf_transport_address_st));
#ifdef ICF_NAT_RPORT_SUPPORT
            p_rport_config_data = p_ssa_pdb->p_line_data->p_rport_config_data;
#endif
        }
        else
        {
             return ret_val;
        }
    }
    else
    {
        icf_port_memcpy(&self_addr, &(p_glb_cfg_data->self_ip_address),
                        sizeof(icf_transport_address_st));
#ifdef ICF_NAT_RPORT_SUPPORT
            p_rport_config_data = &(p_glb_cfg_data->rport_config_data);
#endif
    }
    
    

#ifdef ICF_NAT_RPORT_SUPPORT
   
    if(ICF_TRUE == p_rport_config_data->is_rport_reqd)
    {
        p_contact_address = &(p_rport_config_data->contact_ip_addr);
    }
    else
    {
        p_contact_address = &self_addr;            
    }        
#else
    p_contact_address = &self_addr;

#endif

    if ( ICF_LOCAL_NAME_PRESENT &
            p_glb_pdb->p_call_ctx->common_bitmask)
    {
        icf_port_strcpy((icf_uint8_t *)display_name, 
                (icf_uint8_t *)p_glb_pdb->p_call_ctx->local_name.str);
    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)display_name, (icf_uint8_t *)"");
    }

    /*
     * We copy the complete user address string from the local
     * address and then check if it is a E164, if it is then 
     * we append the self user address from global config data
     * to the string to get complete userid@hostname string
     */
    icf_port_strcpy((icf_uint8_t *)from_user_addr,
            (icf_uint8_t *)p_user_address->addr_val.str);
    
    if ( ICF_ADDRESS_PLAN_E164 ==
            p_user_address->addr_type)
    {
        icf_port_strcat((icf_uint8_t *)from_user_addr,(icf_uint8_t *)"@");

        if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                self_addr.addr.addr_type)
        {
            icf_port_strcat((icf_uint8_t *)from_user_addr,
                    (icf_uint8_t *)self_addr.\
                    addr.addr.domain.str);
            icf_port_strcpy((icf_uint8_t *)contact_addr,(icf_uint8_t *)from_user_addr);

        }
        else/*Assumption that it will be IPV4*/
        {
            icf_uint8_t remote_ip[16];
            icf_uint8_t contact_ip[16];

            if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                        &(self_addr), remote_ip))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                icf_port_strcpy((icf_uint8_t *)contact_addr,(icf_uint8_t *)from_user_addr);
                icf_port_strcat((icf_uint8_t *)from_user_addr, (icf_uint8_t *)remote_ip);
                if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                            p_contact_address, contact_ip))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    icf_port_strcat((icf_uint8_t *)contact_addr, (icf_uint8_t *)contact_ip);
                }
            }
        }
    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)contact_addr,(icf_uint8_t *)from_user_addr);
    }

    /*
     * If the address type is SIP URI ,then we will
     * extract the userid from the SIP URI and then 
     * append the contact IP address and port in order
     * to form the contact header
     */

   if ((ICF_ADDRESS_PLAN_SIP_URI ==
            p_user_address->addr_type) ||
    (ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type))
    {
        p_temp = icf_port_strchr((icf_uint8_t *)contact_addr,(icf_uint8_t)'@');
        if (ICF_NULL != p_temp)
        {
             *p_temp = '\0';
        }
        icf_port_strcat((icf_uint8_t *)contact_addr,(icf_uint8_t *)"@");

        if ( ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                 p_contact_address->addr.addr_type)
        {
            icf_port_strcat((icf_uint8_t *)contact_addr,(icf_uint8_t *)p_contact_address->addr.addr.domain\
                    .str);
        }
        else/*Assumption that it will be IPV4*/
        {
            icf_uint8_t remote_ip[16];

            if ( ICF_FAILURE == icf_ssa_convert_to_IP_addr(
                        p_contact_address,remote_ip))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                icf_port_strcat((icf_uint8_t *)contact_addr,(icf_uint8_t *)remote_ip);
            }
        }
    }
    /* 
     * In case of TEL URL,we just send the contact IP and port in the
     * contact addr
     */
    else if ( ICF_ADDRESS_PLAN_TEL_URI ==
            p_user_address->addr_type)
    {
        if(ICF_FAILURE == 
                icf_ssa_get_hostname_str_frm_trans_addr(
                    p_ssa_pdb,
                    p_contact_address,
                    (icf_uint8_t *)self_ip))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            icf_port_strcpy((icf_uint8_t *)contact_addr,(icf_uint8_t *)self_ip);
        }
    }
    if ( ICF_SUCCESS == ret_val)
    {
                    if (ICF_ADDRESS_PLAN_SIPS_URI == p_user_address->addr_type)
            {
                if (Sdf_co_fail == sdf_ivk_uaAddDefaultContact(
                            p_callobj_spec_profile,
                            display_name,
                            contact_addr,
                            p_glb_cfg_data->p_tls_init_data->tls_sip_serv_port_num,
                            "sips",
                            &sdf_error))
                {
                    /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                     * major ERROR*/
                    /* SPR-19519 Merged  SPR 19672 Start */
                    /*Don't free Init Data here.IPTK will reject request
     	             *on failure and then free initdata.
                     */	
     	            /*sdf_ivk_uaFreeInitData(p_callobj_spec_profile);*/
                    /* SPR-19519 Merged  SPR 19672 End */
                    ret_val = ICF_FAILURE;
                }
            }
            else
            {
                if (Sdf_co_fail == sdf_ivk_uaAddDefaultContact(
                            p_callobj_spec_profile,
                            display_name,
                            contact_addr,
                            p_contact_address->port_num,
                            "sip",
                            &sdf_error))
                {
                    /*Raise/Set alarm here for UATK_PROCESSING_FAILURE
                     * major ERROR*/
                    /* SPR-19519 Merged  SPR 19672 Start */
                    /*Don't free Init Data here.IPTK will reject request
     	             *on failure and then free initdata.
                     */	
     	            /*sdf_ivk_uaFreeInitData(p_callobj_spec_profile);*/
                    /* SPR-19519 Merged  SPR 19672 End */
                    ret_val = ICF_FAILURE;
                }
            }    
            if ((ICF_FAILURE != ret_val))
            {
                if (ICF_FAILURE ==
                        icf_ssa_add_transport_param_in_contact_hdr(
                            p_ssa_pdb,
                            p_callobj_spec_profile,
                            &sdf_error))
                {
                    ret_val = ICF_FAILURE;
                }
         }
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_replaces_header
 * DESCRIPTION:  1.Fetch the Replaces header 
 *               2.Extract n/w call id and map it to ipphone internal call id. 
 *               3.If not matched then send failure response to n/w.
 *
 ***************************************************************************/
icf_return_t icf_ssa_parse_replaces_header(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  Sdf_st_error		  *p_err)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_ty_slist            slMatchedHeadersList;
    Sdf_ty_u32bit           size = 0;
    SipError                err;
    Sdf_ty_s8bit            *p_replaces_call_id = Sdf_co_null;
    Sdf_ty_s8bit            *p_from_tag = Sdf_co_null;
    Sdf_ty_s8bit            *p_to_tag = Sdf_co_null;

    icf_error_t          *p_ecode = p_ssa_pdb->p_ecode;
    icf_ssa_ctxt_st      *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    icf_ssa_ctxt_list_st      *p_ssa_list = ICF_NULL;
    icf_ssa_ctxt_list_st      *p_ssa_temp = ICF_NULL;
    icf_ssa_ctxt_st      *p_mapped_ssa_ctxt = ICF_NULL;
    Sdf_st_callObject       *p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    icf_nw_inc_call_setup_st *p_internal_msg = 
        (icf_nw_inc_call_setup_st *)p_ssa_pdb->p_internal_msg->p_msg_data;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        /*    ICF_SSA_TRACE(p_ssa_pdb,ICF_TRACE_REPLACES_HDR_PRESENT)*/

        /* Extract Replaces Header */
        if(Sdf_co_fail == sdf_ivk_uaGetHeaderListByType(p_call_obj->
                    pUasTransaction->slUnprocessedHeaders, SipHdrTypeReplaces,
                    &slMatchedHeadersList,p_err))
        {
            /* 
             * Remove all elements from the list and free 
             * the node data of each node
             */
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            ret_val = ICF_FAILURE;
        } /* if(Sdf_co_success == sdf_ivk_u... */
    /* Extract the size of the matched header list */
        else if(Sdf_co_fail == sdf_listSizeOf (&slMatchedHeadersList,
                    &size, p_err))
        {
            /* 
             * Remove all elements from the list and free 
             * the node data of each node
             */
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            ret_val = ICF_FAILURE;
        } /* if(Sdf_co_fail == sdf_listSize... */

    /* Replaces Header present */
        else if(size > 0)
        {
            SipHeader *p_replaces_hdr;
            Sdf_st_headerList *p_replaces_hdr_list = Sdf_co_null;
            /* Get HeaderList at index 0*/
            if( Sdf_co_fail == sdf_listGetAt(
                        &slMatchedHeadersList,0
                        ,(Sdf_ty_pvoid)&p_replaces_hdr_list,p_err))
            {
                /* 
                 * Remove all elements from the list and free 
                 * the node data of each node
                 */
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                ret_val = ICF_FAILURE;
            } /* if( Sdf_co_fail == sdf_listGet... */
            /* Extarct the first Replaces header */
            else if(Sdf_co_fail == sdf_listGetAt(
                        &(p_replaces_hdr_list)->slHeaders,0,
                        (Sdf_ty_pvoid *)&p_replaces_hdr,
                        p_err))
            {
                /* 
                 * Remove all elements from the list and free 
                 * the node data of each node
                 */
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                ret_val = ICF_FAILURE;
            } /* if(Sdf_co_fail == sdf_listSize... */

            /* Extract the Replaces Call ID from the Replaces Header */
            else if(SipFail == sip_getCallidFromReplacesHdr(
                        p_replaces_hdr,
                        &p_replaces_call_id,
                        &err))
            {
                /* 
                 * Remove all elements from the list and free 
                 * the node data of each node
                 */
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                ret_val = ICF_FAILURE;
            }
            else if (SipFail == sip_getFromTagFromReplacesHdr(
                        p_replaces_hdr,
                        &p_from_tag,
                        &err))
            {
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                ret_val = ICF_FAILURE;
            }
            else if (SipFail == sip_getToTagFromReplacesHdr(
                        p_replaces_hdr,
                        &p_to_tag,
                        &err))
            {
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                ret_val = ICF_FAILURE;
            }
            if (ICF_FAILURE != ret_val)
            {
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                /* 
                 * Search for a matching SSA context corresponding to the 
                 * Replaces call ID in the global map between
                 * the SSA contexts and network call ID's
                 */
                ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(
                        p_ssa_pdb->p_glb_pdb,(icf_uint8_t *)p_replaces_call_id,
                        (icf_void_t **)&p_ssa_list,p_ecode);
                if (ICF_SUCCESS == ret_val)
                {
#ifdef ICF_LOOPBACK_SUPPORT
                    for (p_ssa_temp = p_ssa_list;p_ssa_temp != ICF_NULL; p_ssa_temp = p_ssa_temp->p_next)
                    {
                        if (ICF_SUCCESS == icf_ssa_cmp_replaces_tags(p_ssa_pdb, 
                                    p_ssa_temp->p_ssa_ctxt->p_call_obj, 
                                    (icf_uint8_t *)p_from_tag, 
                                    (icf_uint8_t *)p_to_tag, 
                                    p_err))
                        {
                            p_mapped_ssa_ctxt = p_ssa_temp->p_ssa_ctxt;
                            ret_val =  ICF_SUCCESS;
                            break;
                        }
                    }
                    if (ICF_NULL == p_ssa_temp)
                    {
                        ret_val = ICF_FAILURE;
                    }
#else
                    p_mapped_ssa_ctxt = p_ssa_list->p_ssa_ctxt;
#endif
                }
                if ((ICF_FAILURE == ret_val) ||
                        (ICF_NULL == p_mapped_ssa_ctxt))
                {
                    /*klocwork warning removal*/
                     sdf_memfree(Sdf_mc_callHandlerMemId, 
                                     (Sdf_ty_pvoid*)&(p_from_tag),p_err);
                     sdf_memfree(Sdf_mc_callHandlerMemId, 
                                       (Sdf_ty_pvoid*)&(p_to_tag),p_err);
                    /* 
                     * Replaces header has a call ID which is not 
                     * corresponding to any call on our end
                     * Set the failure bitmask which will send 
                     * 481 on the network
                     */
                    p_ssa_ctxt->failure_bitmask |= 
                        ICF_SSA_FAILURE_RESP_CODE_481;
                    ret_val = ICF_FAILURE;
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                        return ret_val;
                }

                /* 
                 * An SSA context corresponding to the 
                 * Replaces call ID is found.
                 * Copy this Replaces call ID to the setup
                 * request and set the corresponding bit in
                 * the bitmask of the setup request
                 */
                p_internal_msg->replace_call_id = 
                    p_mapped_ssa_ctxt->p_call_ctxt->call_id ;
                ICF_SSA_SET_COMMON_BITMASK(
                        p_internal_msg->bitmask, 
                        ICF_NW_INC_SETUP_RELACE_CALL_ID)
            }
        } /* else if(size > 0) */
    /*klocwork warning removal*/
    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_from_tag),p_err);
    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_to_tag),p_err);
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}

/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_ref_by_header
 * DESCRIPTION:  1.Fetch the Referred By header 
 *               2.Extract referred by address and display name and
 *               populate it in call context.
 *
 ***************************************************************************/
icf_return_t icf_ssa_parse_ref_by_header(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  Sdf_st_error          *p_err)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_ty_slist            slMatchedHeadersList;
    Sdf_ty_u32bit           size = 0;
    SipError                err;

    Sdf_st_callObject       *p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    icf_call_ctx_st      *p_call_ctx = p_ssa_pdb->p_glb_pdb->p_call_ctx;
    icf_error_t          *p_ecode = p_ssa_pdb->p_ecode;
    icf_nw_inc_call_setup_st *p_internal_msg = 
        (icf_nw_inc_call_setup_st *)p_ssa_pdb->p_internal_msg->p_msg_data;


    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
/*    ICF_SSA_TRACE(p_ssa_pdb,ICF_TRACE_REF_BY_HDR_PRESENT)*/

    if(Sdf_co_fail == sdf_ivk_uaGetHeaderListByType(
                p_call_obj->pUasTransaction->slUnprocessedHeaders,
                SipHdrTypeReferredBy
                ,&slMatchedHeadersList,p_err))
    {
        sdf_listDeleteAll(&slMatchedHeadersList,p_err);
        ret_val = ICF_FAILURE ;
    } /* if(Sdf_co_success == sdf_ivk_u... */
    else if(Sdf_co_fail == sdf_listSizeOf (&slMatchedHeadersList,
                &size, p_err))
    {
        sdf_listDeleteAll(&slMatchedHeadersList,p_err);
        ret_val= ICF_FAILURE;
    } /* if(Sdf_co_fail == sdf_listSize... */
    /* Referred-by Header present */
    else if(size >0)
    {
        SipHeader   *p_ref_by_hdr = SIP_NULL;
        SipAddrSpec *p_referrer = SIP_NULL;
        SIP_S8bit   *p_refer_disp_name = SIP_NULL;
        Sdf_st_headerList *p_ref_by_hdr_list = Sdf_co_null;
        /* Get HeaderList at index 0*/
        if( Sdf_co_fail ==
                sdf_listGetAt(&slMatchedHeadersList,0
                    ,(Sdf_ty_pvoid)&p_ref_by_hdr_list,p_err))
        {
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            ret_val = ICF_FAILURE;
        } /* if( Sdf_co_fail == sdf_listGet... */
        else if(Sdf_co_fail == sdf_listGetAt(&(p_ref_by_hdr_list)->
                    slHeaders,0,(Sdf_ty_pvoid *)&p_ref_by_hdr,
                    p_err))
        {
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            ret_val = ICF_FAILURE;
        } /* if(Sdf_co_fail == sdf_listSize... */

        else if(SipFail == sip_getReferrerFromReferredByHdr
                (p_ref_by_hdr, (SipAddrSpec **)&p_referrer,
                 &err))
        {
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            ret_val = ICF_FAILURE;
        }
        /*
         * We are not checking the return value of 
         * sip_getDispNameFromReferredByHdr as it 
         * is not mandatory to get the display name
         * Assumption : sip_getDispNameFromReferredByHdr
         * returns FAILURE if no display name is present
         */
        else if (SipSuccess == sip_getDispNameFromReferredByHdr(
                    p_ref_by_hdr,&p_refer_disp_name,&err) && 
                (SIP_NULL != p_refer_disp_name))
        {
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                    ICF_PORT_SIZEOF(icf_name_st),
                    ICF_MEM_COMMON, 
                    p_call_ctx->p_referred_party_name,
                    ICF_RET_ON_FAILURE, p_ecode, ret_val)
            icf_cmn_init_string((icf_string_st *)
                    (p_call_ctx->p_referred_party_name));
            /* Codenomicon fixes: CSR 1-7132323: SPR 19484 */
			/* String Copy should not exceed ICF_MAX_STR_LEN value */
            icf_port_strncpy(
                        (icf_int8_t *)p_call_ctx->p_referred_party_name->str,
                        (const icf_int8_t *)p_refer_disp_name,
						(ICF_MAX_STR_LEN - 1));
			p_call_ctx->p_referred_party_name->str[ICF_MAX_STR_LEN - 1] = '\0';
            p_call_ctx->p_referred_party_name->str_len = 
                (icf_uint16_t)icf_port_strlen(
                        (icf_uint8_t *)p_call_ctx->p_referred_party_name->str);

        }

        if (ICF_FAILURE != ret_val )
        {
            /*
             * Populate the p_referred_party_addr member of
             * the call ctx and set the bitmask in the internal message 
             * indicating the same
             */
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                    ICF_PORT_SIZEOF(icf_address_st),
                    ICF_MEM_COMMON, 
                    p_call_ctx->p_referred_party_addr,
                    ICF_RET_ON_FAILURE, p_ecode, ret_val)

            icf_cmn_init_address(p_call_ctx->p_referred_party_addr);
            if (ICF_FAILURE == 
                    icf_ssa_populate_address_from_sip_addr_spec(
                        p_ssa_pdb,p_referrer,
                        p_call_ctx->p_referred_party_addr))
            {
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_call_ctx->p_referred_party_name,
                        ICF_MEM_COMMON, p_ecode, ret_val)
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_call_ctx->p_referred_party_addr,
                        ICF_MEM_COMMON, p_ecode, ret_val)
                ret_val = ICF_FAILURE;
            }
            if (ICF_FAILURE != ret_val )
            {
                ICF_SSA_SET_COMMON_BITMASK(
                        p_internal_msg->bitmask,
                        ICF_NW_INC_SETUP_REF_BY) 
            }
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
        }
        /* Fix for CSR 1-6727350: SPR 19316 */
		/* Free the addr spec here */
		sip_freeSipAddrSpec(p_referrer);
        sip_freeSipHeader(p_ref_by_hdr);
    } /* if(size >0) */
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_n_validate_requri
 * DESCRIPTION:  This function does the folowing :
 *               1.Populates the local name of cal context on the 
 *                 basis of the dispaly name in the To header
 *               2.Extracts the Request URI and does validations on the
 *                 same.In case of failure ,sets failure bitmask accordingly
 *               3.Populates local address of call context on the 
 *                 basis of the ReqURI
 *               4.Invokes the utility function to update the Contact
 *                 header into the profile of the call object
 *
 ***************************************************************************/
icf_return_t icf_ssa_parse_n_validate_requri(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT  Sdf_st_error          *p_err)
{
    icf_return_t         ret_val = ICF_SUCCESS;

    Sdf_st_callObject       *p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    icf_call_ctx_st      *p_call_ctx = p_ssa_pdb->p_glb_pdb->p_call_ctx;
    icf_ssa_ctxt_st      *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    SipToHeader             *p_to = ((SipToHeader *)
            p_call_obj->pCommonInfo->pTo->pHeader);
    SipReqLine              *p_req_line = SIP_NULL ; 
    SipAddrSpec             *p_req_uri = SIP_NULL;
    Sdf_ty_u16bit           resp_code = 0;
    Sdf_ty_messageValidity  msg_val = Sdf_en_valid;
    SipError                err;
#ifdef ICF_REQ_URI_CALLED_PARTY_ADDR_PARSING
    icf_uint8_t             temp[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t             temp_old_addr[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t             temp_new_addr[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t             *p_user_part_full = ICF_NULL;
    icf_uint8_t             *p_user_part_pre = ICF_NULL;
    icf_uint8_t             *p_user_part_post = ICF_NULL;
    icf_uint8_t             *p_temp_old_addr = ICF_NULL;
    icf_uint8_t             *p_dial_string = ICF_NULL;
#endif /* #ifdef ICF_REQ_URI_CALLED_PARTY_ADDR_PARSING */

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /*
     * Extract the local address from the To header
     * and remote address from the From/p-asserted header 
     * and populate it in the call context
     * If the called/calling party addr is a SIP URI,then 
     * user@hostname is copied into the call context,
     * otherwise the entire URL is copied into the call
     * context
     */
    /* Copy the display name if present in the To header */
#ifdef ICF_WITH_MUATK_2_2
    if (SIP_NULL != p_to->pStr1)
    {
        /* Fix Done for SPR : 19307*/
        /* If the display name in To header is greater than ICF_MAX_STR_LEN ie
         * 128 character simply copy the first 127 character.*/ 
        if (ICF_MAX_STR_LEN < icf_port_strlen((icf_uint8_t *)p_to->pStr1))
        {
            icf_port_strncpy((icf_int8_t*)p_call_ctx->local_name.str,
                    (const icf_int8_t *)p_to->pStr1,
                    (ICF_PORT_SIZEOF(p_call_ctx->local_name.str) -1));
            p_call_ctx->local_name.str[ICF_MAX_STR_LEN - 1]='\0';             
        }
        else
        {
            icf_port_strcpy(p_call_ctx->local_name.str,
                    (icf_uint8_t *)p_to->pStr1);
        }
#else
    if (SIP_NULL != p_to->pDispName)
    {
        /* If the display name in To header is greater than ICF_MAX_STR_LEN ie
         * 128 character simply copy the first 127 character and NULL in the 
         * last position else copy the whole value.*/ 
        if (ICF_MAX_STR_LEN < icf_port_strlen((icf_uint8_t *)p_to->pDispName))
        {
            icf_port_strncpy(p_call_ctx->local_name.str,
                    (icf_uint8_t *)p_to->pDispName,
                    (ICF_PORT_SIZEOF(p_call_ctx->local_name.str) -1));
            p_call_ctx->local_name.str[ICF_MAX_STR_LEN - 1]='\0';             
        }
        else
        {
            icf_port_strcpy(p_call_ctx->local_name.str,
                p_to->pDispName);
        }
#endif    
        p_call_ctx->local_name.str_len =
            (icf_uint16_t )icf_port_strlen(p_call_ctx->local_name.str);
        /* 
         * Set the bit in common bitmask of call ctx
         * indicationg the presence of display name
         */
        p_call_ctx->common_bitmask |= 
            ICF_LOCAL_NAME_PRESENT;
    }
    /*
     * Now fetch the request URI from the SIP message
     */
    msg_val = sdf_ivk_uaValidateUri(
            p_call_obj,p_call_obj->pInitData,
            &resp_code,p_err);
    /*
     * The following are the resp codes returned by 
     * the above function.As users are not configured in
     * the profile,we will not fail our processing
     * if 404 (user not found ) resp code is returned
     * 400 resp code : invalid transport type
     * 416           : unsupported URI
     * 505           : invalid version
     * 400           : user not found
     */
    if ((Sdf_en_failed == msg_val) ||
            ((Sdf_en_invalid == msg_val) && (400 == resp_code)) ||
            ((Sdf_en_invalid == msg_val) && (416 == resp_code)) ||
            ((Sdf_en_invalid == msg_val) && (505 == resp_code))) 
    {
/*        ICF_SSA_TRACE(p_ssa_pdb,ICF_TRACE_VALIDATION_OF_REQ_URI_FAILURE)*/
        /*
         * Send appropiate error resp to nw.
         * Set SSA failure bitmask for the same
         */
        if (resp_code == 400)
        {
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_400;
        }
        else if (resp_code == 416)
        {
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_416;
        }
        else if (resp_code == 505)
        {
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_505;
        }
        else
        {
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_500;
        }
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == sip_getReqLineFromSipReqMsg(
                p_call_obj->pUasTransaction->pSipMsg,
                &p_req_line,&err))
    {
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == sip_getAddrSpecFromReqLine(
                p_req_line, &p_req_uri,&err))
    {
        ret_val = ICF_FAILURE;
    }
#ifdef SDF_PRES
    /* If the request is received with address type pres url
     * reject it with 416 response code (Unsupported Request URI).
     */
    else if (SipSuccess == sip_isPresUrl(p_req_uri,&err))
    {
       p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_416;
       ret_val = ICF_FAILURE;
    }
#endif

#ifdef SDF_IM
    /* If the request is received with address type im url
     * reject it with 416 response code (Unsupported Request URI).
     */
    else if(SipSuccess == sip_isImUrl(p_req_uri,&err))
    {
       p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_416;
       ret_val = ICF_FAILURE;   
    }
#endif
    /*
     * Now populate the local address on the basis
     * of the rquest URI
     */
    else if (ICF_FAILURE == 
            icf_ssa_populate_address_from_sip_addr_spec(
                p_ssa_pdb,p_req_uri,
                &(p_call_ctx->local_address)))
    {
        ret_val = ICF_FAILURE;
    }
   /*Check if sip:user@ip:port is present, remove port*/
    else if (ICF_FAILURE == icf_ssa_remove_port_from_address(
                            p_ssa_pdb, 
                            ((icf_uint8_t *)(p_call_ctx->local_address.addr_val.str))))
    {
        ret_val = ICF_FAILURE;
    }

#ifdef ICF_REQ_URI_CALLED_PARTY_ADDR_PARSING
    /*---------------------------------------------------------------------*/
    /*
     *      ++++ USER MATCHING FOR E.164 CONFIGURED NUMBER ++++
     * If the application has configured E.164 num 14083659220, then req-uri
     *      sip:+14083659220@20.20.20.20;user=phone                 -> matches
     *      sip:14083659220@20.20.20.20;user=phone                  -> No match
     *      sip:3659220;phone-context=+1408@20.20.20.20;user=phone  -> matches
     *      sip:3659220;phone-context=1408@20.20.20.20;user=phone   -> No match
     */
    /*---------------------------------------------------------------------*/
    /* In case the req-uri is of the form
     *      sip:3659220;phone-context=+1408@20.20.20.20;user=phone, or
     *      sip:+14083659220@20.20.20.20;user=phone
     * user search in local database should be done for both
     * (a) '3659220' - user part of address, and
     * (b) '14083659220' - phone-context dial string prefixed to user part
     *
     * For comparison (a) which will happen as per the original design, the
     * address will be stored in p_call_ctx->local_address.
     *
     * For comparison (b), the user address will be reconstructed and stored
     * in p_call_ctx->alternate_local_address.
     *
     * CC will check if any of these addresses are configured on any line.
     *
     * At this point, we have p_call_ctx->local_address. Now let's check if
     * phone-context param or '+' sign is present in req-uri and form the new
     * p_call_ctx->alternate_local_address
     */

    else if (((ICF_ADDRESS_PLAN_SIP_URI ==
                    p_call_ctx->local_address.addr_type) ||
             (ICF_ADDRESS_PLAN_SIPS_URI ==
                    p_call_ctx->local_address.addr_type)) &&
             (ICF_NULL != icf_port_strstr(
                                p_call_ctx->local_address.addr_val.str,
                                "user=phone")))
    {

        /*  ++++++++++++++++++ FIRST THE TOKENIZATION ++++++++++++++++++++++++++ */

        /* Get temp_old_addr =
         * '3659220;phone-context=+1408@20.20.20.20;user=phone'
         */
        icf_port_strcpy(temp, p_call_ctx->local_address.addr_val.str);
        icf_port_strcpy(temp_old_addr, p_call_ctx->local_address.addr_val.str);
        p_temp_old_addr = &temp_old_addr[0];

        /* Get p_user_part_full = '3659220;phone-context=+1408' */
        /* Get p_temp_old_addr = '@20.20.20.20;user=phone' */
        ICF_PRINT(("\n[SSA]: p_temp_old_addr before strtok = %s\n", \
                    p_temp_old_addr));
        p_user_part_full = icf_port_strtok(temp, "@");
        if(ICF_NULL != p_user_part_full)
        {
            p_temp_old_addr = p_temp_old_addr + icf_port_strlen(p_user_part_full);
        }
        ICF_PRINT(("\n[SSA]: p_temp_old_addr after strtok = %s\n", \
                    p_temp_old_addr));

        /* Get p_user_part_full = '3659220;phone-context=+1408' */
        /* Get p_user_part_pre = '3659220' */
        ICF_PRINT(("\n[SSA]: p_user_part_full before strtok = %s\n", \
                    p_user_part_full));
        icf_port_strcpy(temp, p_user_part_full);
        p_user_part_pre = icf_port_strtok(temp, ";");
        ICF_PRINT(("\n[SSA]: p_user_part_full after strtok = %s\n", \
                    p_user_part_full));
        ICF_PRINT(("\n[SSA]: p_user_part_pre = %s\n", p_user_part_pre));

        /* Get p_user_part_post = 'phone-context' */
        /* Get p_dial_string = '+1408' */
        p_user_part_post = &p_user_part_full[0];
        p_user_part_post = p_user_part_post + icf_port_strlen(p_user_part_pre) + 1;
        ICF_PRINT(("\n[SSA]: p_user_part_post before strtok = %s\n", \
                    p_user_part_post));
        p_dial_string = p_user_part_post + icf_port_strlen("phone-context") + 1;
        p_user_part_post = icf_port_strtok(p_user_part_post, "=");
        ICF_PRINT(("\n[SSA]: p_user_part_post after strtok = %s\n", \
                    p_user_part_post));

        /*  ++++++++++++++++++ THEN THE COMPARISON ++++++++++++++++++++++++++ */

        /* If phone-context param is present, prefix it to the userid
         *      3659220;phone-context=+1408@20.20.20.20;user=phone
         *          should match
         *      alternate_local_address = E164 number 14083659220
         */
        if ((ICF_NULL != p_user_part_pre) &&
                (ICF_NULL != p_user_part_post) &&
                (ICF_NULL == icf_port_strcmp(
                                             p_user_part_post, "phone-context")) &&
                ('+' == *p_dial_string))
        {
            ICF_PRINT(("\n[SSA]: Received req-uri contains phone-context param\n"));
            ICF_PRINT(("\n[SSA]: p_dial_string = %s\n", p_dial_string));

            /* Get temp_new_addr = '1408' */
            icf_port_strcpy(temp_new_addr, (p_dial_string + 1));
            /* Get temp_new_addr = '14083659220' */
            icf_port_strcat(temp_new_addr, p_user_part_pre);
#if 0
            /* Get temp_new_addr = '+14083659220@20.20.20.20;user=phone' */
            icf_port_strcat(temp_new_addr, p_temp_old_addr);
#endif

            /* Update the alternate local address in call ctxt */
            p_call_ctx->common_bitmask |= ICF_ALTERNATE_ADDR_FORMAT_POSSIBLE;
            p_call_ctx->alternate_local_address.addr_type = ICF_ADDRESS_PLAN_E164;
            icf_port_strcpy(
                    p_call_ctx->alternate_local_address.addr_val.str,
                    temp_new_addr);
            /* Update the string length of local address in call ctxt */
            p_call_ctx->alternate_local_address.addr_val.str_len =
                icf_port_strlen(p_call_ctx->alternate_local_address.addr_val.str);
        }
        /* If userid starts with '+', ignore it for comparison
         *      +14083659220@20.20.20.20;user=phone
         *          should match
         *      alternate_local_address = E164 number 14083659220
         */
        else if ((ICF_NULL != p_user_part_pre) && ('+' == *p_user_part_pre))
        {
            ICF_PRINT(("\n[SSA]: Received req-uri starts with + sign\n"));

            /* Update the alternate local address in call ctxt */
            p_call_ctx->common_bitmask |= ICF_ALTERNATE_ADDR_FORMAT_POSSIBLE;
            p_call_ctx->alternate_local_address.addr_type = ICF_ADDRESS_PLAN_E164;
            icf_port_strcpy(
                    p_call_ctx->alternate_local_address.addr_val.str,
                    (p_user_part_pre + 1));
            /* Update the string length of local address in call ctxt */
            p_call_ctx->alternate_local_address.addr_val.str_len =
                icf_port_strlen(p_call_ctx->alternate_local_address.addr_val.str);
        }
    else
    {
        ICF_PRINT(("\n[SSA]: No alternate address derived from req-uri\n"));
    }

    ICF_PRINT(("\n[SSA]: Received called party address = %s\n", \
            p_call_ctx->local_address.addr_val.str));

    ICF_PRINT(("\n[SSA]: Alternate called party address = %s\n", \
            p_call_ctx->alternate_local_address.addr_val.str));

    } /* if (p_call_ctx->local_address.addr_type) */
    /*---------------------------------------------------------------------*/

    if (ICF_FAILURE == ret_val)
    {
        /* do nothing */
        ret_val = ICF_FAILURE;
    }
#endif /* #ifdef ICF_REQ_URI_CALLED_PARTY_ADDR_PARSING */

    else if (ICF_FAILURE == 
            icf_ssa_update_contact_in_profile(
                p_ssa_pdb))
    {
        ret_val = ICF_FAILURE;
    }
    /* if some tag is present in local address, populate it in call context*/ 
    else if(ICF_NULL != icf_port_strchr(
            p_call_ctx->local_address.addr_val.str,
            ';'))
    {
        /* some tag value present in the request uri,
         * populate it in call ctxt*/
        icf_uint8_t *p_req_uri_tag = ICF_NULL ;
                                   
        p_req_uri_tag = icf_port_strchr(
                        p_call_ctx->local_address.addr_val.str,';');

        p_req_uri_tag++;
        if(ICF_NULL == p_call_ctx->p_req_uri_param)
        {
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        ICF_PORT_SIZEOF(icf_string_st),
                        ICF_MEM_COMMON, 
                        p_call_ctx->p_req_uri_param,
                        ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)
        }
        icf_port_strcpy(
            p_call_ctx->p_req_uri_param->str, p_req_uri_tag);
        p_call_ctx->p_req_uri_param->str_len=
                            icf_port_strlen(p_req_uri_tag);
    }

    /* Free the acquired memory */
    if (SIP_NULL != p_req_uri)
    {
        sip_freeSipAddrSpec(p_req_uri);
    }
    if (SIP_NULL != p_req_line)
    {
        sip_freeSipReqLine(p_req_line);
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_supp_header
 * DESCRIPTION:  1.Invoke the SDF API which returns the list
 *                 of entries present in the Supported header.
 *               2.Iterate through the list and check for the presence
 *                 of 100 rel.If present ,set the bit 
 *                 ICF_REL_PROV_RESP_SUPP_BY_PEER in common bitmask
 *                 of the call context
 *
 ***************************************************************************/
icf_return_t icf_ssa_parse_supp_header(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT    SipMessage          *p_sip_msg,
        INOUT  Sdf_st_error          *p_err)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_ty_slist            slSupportedList;
    Sdf_ty_u32bit           size = 0,iterator = 0;

    icf_call_ctx_st      *p_call_ctx = p_ssa_pdb->p_glb_pdb->p_call_ctx;
    icf_uint8_t          *p_list_element = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (Sdf_co_fail == sdf_ivk_uaReturnSupportedList (
                p_sip_msg,&slSupportedList,p_err))
    {
        ret_val = ICF_FAILURE;
    }
    /* Fetch the size of the list */
    else if (Sdf_co_fail == sdf_listSizeOf(
                &slSupportedList,&size,p_err))
    {
        ret_val = ICF_FAILURE;
    }
    /*If list contains elements*/
    else if(size !=0)
    {
        /*Fetch all the entries from the Supported header */
        for(iterator = 0; iterator < size; iterator++)
        {
            if(Sdf_co_fail == sdf_listGetAt(&slSupportedList,
                        iterator, (Sdf_ty_pvoid *)&p_list_element,p_err))
            {
                ret_val = ICF_FAILURE;
            }

            /* CSR-1-6974854: Parameter comparision in supported header
             * made case insensitive */
            else if (ICF_NULL == icf_port_strcmpi(
                        p_list_element,(icf_uint8_t *)"100rel"))
            {
                /* Set the bit in common bitmask
                 * of the call context indicating support
                 * for reliable provisional responses
                 */  
                 p_call_ctx->common_bitmask |=
                        ICF_REL_PROV_RESP_SUPP_BY_PEER;
/*                ICF_SSA_TRACE(p_ssa_pdb,*/
/*                        ICF_TRACE_SUPPORTED_100_REL_PRESENT)*/
                /* 
                 * We are not breaking out of the loop
                 * here as the same function can be used for 
                 * generic parsing of the Supported header
                 */
            }
#ifdef ICF_QOS_SUPPORT            
            else if(ICF_NULL == icf_port_strcmp(
                        p_list_element, (icf_uint8_t*)"precondition"))
            {
                /*Rel8.0: This flag will be used to check for precondition
                  rules. When this tag is present in supported header
                  and "mandatory" strength tags present in QOS 
                  precondition attribute lines, also the "require"
                  header does not have the "precondition" tag in that
                  case 580 needs to be send. So storing the flag*/
                p_ssa_pdb->precondition_in_supp_hdr = ICF_TRUE;
            }
#endif            
        }
    }
    sdf_listDeleteAll(&slSupportedList,p_err);
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 *
 * FUNCTION:     icf_ssa_insert_params_frm_address_st
 * DESCRIPTION:  1.This functions checks the presence flag
 *                 present in the p_address paramter and on the
 *                 basis of this inserts paramters into the
 *                 p_addr_spec paramter passed to it
 *
 ***************************************************************************/
icf_return_t icf_ssa_insert_params_frm_address_st(
        icf_ssa_pdb_st *p_ssa_pdb,
        SipAddrSpec       *p_addr_spec,
        icf_address_st *p_address)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_st_error         sdf_error = {0,0,0,"\0"};
    icf_uint8_t          index = ICF_NULL;
    icf_boolean_t        more_param = ICF_FALSE;
    /* CSR_1_7199359 Merged SPR 19672 Start */
    icf_uint8_t          param_name[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t          param_val[ICF_MAX_STR_LEN] = "\0";
    /* CSR_1_7199359 Merged SPR 19672 End */
    icf_string_st        temp_addr = {0,"\0"};
    icf_int8_t           *p_param_list = ICF_NULL;
    icf_uint8_t          *p_param_addr = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /* CSR_1_7199359 Merged SPR 19672 Start */
    icf_port_strncpy(
		(icf_int8_t *)(temp_addr.str),
		(const icf_int8_t *)(p_address->addr_val.str),
		(ICF_MAX_STR_LEN - 1));
    temp_addr.str[ICF_MAX_STR_LEN - 1] = '\0';
    temp_addr.str_len = icf_port_strlen(temp_addr.str);    
    /* CSR_1_7199359 Merged SPR 19672 End */
    p_param_addr = (icf_uint8_t *)icf_port_strtokr((icf_int8_t *)temp_addr.str,";", &p_param_list);

    if (ICF_NULL != p_param_list)
    {
        do
        {
            icf_port_strcpy(param_name, (icf_uint8_t *)"");
            icf_port_strcpy(param_val, (icf_uint8_t *)"");
            /*This function parses the unknown parameter string, here
            * index parameter always point to the next parameter or
            * pointed to NULL
            */
            more_param = icf_ssa_parse_unknown_param(p_ssa_pdb,
                (icf_uint8_t *)p_param_list, param_name, param_val,
                &index);
            
            /* Fix for SPR: 19886 (Merged CSR 1-7226823)*/
            if ((ICF_NULL != icf_port_strcmp(param_name,(icf_uint8_t *)"transport") &&
                ICF_NULL != icf_port_strcmp(param_name,(icf_uint8_t *)"Replaces")))            
            {
                if (ICF_FAILURE == 
                    icf_ssa_insert_param_in_addr_spec(
                    p_ssa_pdb,p_addr_spec,
                    param_name, param_val, &sdf_error))
                {
                    ret_val = ICF_FAILURE;
                    break;
                }
            }
            if (ICF_FALSE == more_param)
            {
                break;
            }
        }while (1);
    }
    


    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_unknown_param
 * DESCRIPTION:  Function is used to parse unknown parameters and return
 *               them as name value(if present) pair
 ***************************************************************************/
icf_boolean_t icf_ssa_parse_unknown_param(
        icf_ssa_pdb_st   *p_ssa_pdb,
        icf_uint8_t      *p_unk_str,
        icf_uint8_t      *p_param_name,
        icf_uint8_t      *p_param_val,
        icf_uint8_t      *p_index)
{
    icf_uint8_t    index = *p_index;
    p_ssa_pdb=p_ssa_pdb;
    
   if(ICF_NULL == p_ssa_pdb)
   {
       return ICF_FAILURE;
   }
    
   ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    p_unk_str = p_unk_str + index;

    while ((*p_unk_str != '=') && (*p_unk_str != ';') &&
            (*p_unk_str != ICF_NULL))
    {
        *p_param_name = *p_unk_str;
        index++;
        p_param_name++;
        p_unk_str++;
    }

    index++;
    *p_param_name = ICF_NULL;
    
    if (*p_unk_str == '=')
    {
        p_unk_str++;
        while ((*p_unk_str != ';') && (*p_unk_str != '?') && (*p_unk_str != ICF_NULL))
        {
            *p_param_val = *p_unk_str;
            index++;
            p_param_val++;
            p_unk_str++;
        }
        *p_param_val = ICF_NULL;
        index++;
    }

    *p_index = index;
    
    if (*p_unk_str != ICF_NULL)
        return ICF_TRUE;
    else
        return ICF_FALSE;

}


/***************************************************************************
 *
 * FUNCTION:     icf_ssa_init_pdb
 * DESCRIPTION:  1.This functions initialises the PDB
 *
 ***************************************************************************/
icf_return_t  icf_ssa_init_pdb(icf_ssa_pdb_st *p_ssa_pdb,
        icf_glb_pdb_st  *p_glb_pdb)
{
    
    icf_uint16_t   count = ICF_NULL;
    icf_return_t   ret_val = ICF_SUCCESS;
    if(ICF_NULL == p_glb_pdb)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Glb PDB is NULL"))
        return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_glb_pdb)
        
    icf_port_memset(p_ssa_pdb,0,sizeof(icf_ssa_pdb_st));

    p_ssa_pdb->p_glb_pdb = p_glb_pdb;
    p_ssa_pdb->p_line_data = ICF_NULL;
    p_ssa_pdb->p_ssa_glb_data = ICF_NULL;
    p_ssa_pdb->p_glb_cfg_data = ICF_NULL;
    p_ssa_pdb->p_internal_msg = ICF_NULL;

    /* SPR 18767: intialize the pointer and then set the ecode from
     * the calling function
     */
    p_ssa_pdb->p_ecode = ICF_NULL; 

    /*
     * Now we init the void pointer which will be used to store the
     * list of memory chunks that will be allocated in callbacks and
     * will be freed on return path (after invocation of destination 
     * module-CM, CFG etc.)
     */
    for ( count = 0; count < ICF_SSA_MAX_MMRY_CHUNK_LST;
            count++)
    {
        p_ssa_pdb->allocated_memory[count].p_mem_chunk = ICF_NULL;
        p_ssa_pdb->allocated_memory[count].ssa_mem_type = 0;
    }
    p_ssa_pdb->alloc_index = ICF_NULL;
    p_ssa_pdb->p_rgm_context = ICF_NULL;
    p_ssa_pdb->p_call_ctxt = ICF_NULL;
    p_ssa_pdb->p_sic_ctxt = ICF_NULL;
#ifdef ICF_IPSEC_ENABLED
    p_ssa_pdb->p_sa_context = ICF_NULL;
#endif
    p_ssa_pdb->p_app_conf = ICF_NULL;
#ifdef ICF_DNS_LOOKUP_ENABLED
    p_ssa_pdb->p_event_ctxt = Sdf_co_null;
#endif
    p_ssa_pdb->common_bitmask = ICF_NULL;
    p_ssa_pdb->line_recvd = ICF_NULL;    
    p_ssa_pdb->p_ssa_ctxt = Sdf_co_null;
    p_ssa_pdb->hash_index = 0;

#ifdef ICF_TRACE_ENABLE
   p_ssa_pdb->dialog_status = 0;
   p_ssa_pdb->sdp_present = ICF_FALSE;
   p_ssa_pdb->replace_header_present = ICF_FALSE;
   p_ssa_pdb->p_buf = ICF_NULL;
   p_ssa_pdb->len = 0;
   p_ssa_pdb->result = ICF_FALSE;
   ICF_CMN_INIT_ADDRESS(p_ssa_pdb->local_addr)
   ICF_CMN_INIT_ADDRESS(p_ssa_pdb->remote_addr)
   p_ssa_pdb->p_subs_state = Sdf_co_null;
   p_ssa_pdb->dns_query_type = ICF_NULL;
   p_ssa_pdb->notify_duration = ICF_NULL;
   p_ssa_pdb->reason_code[0] = '\0'; 
#endif
   p_ssa_pdb->send_trans_param = ICF_FALSE;
   p_ssa_pdb->bye_rejected = ICF_FALSE;
   p_ssa_pdb->is_otg_msg = ICF_FALSE;
   p_ssa_pdb->processed_bytes = ICF_NULL;
   p_ssa_pdb->p_method = ICF_NULL;
   p_ssa_pdb->p_glb_rgm_data = ICF_NULL;
   /*  In 8.0 fro KlocWorks Warning removeal */
   p_ssa_pdb->dest_module_id = ICF_INT_MODULE_INVALID;
   p_ssa_pdb->p_conn_table_entry = ICF_NULL;
   p_ssa_pdb->conn_type = ICF_NULL;
   p_ssa_pdb->warning_header_code = ICF_NULL;
   p_ssa_pdb->retrans_count = ICF_NULL;
   p_ssa_pdb->resp_code = ICF_NULL;
   p_ssa_pdb->dRespCode = ICF_NULL;
   p_ssa_pdb->call_direction = ICF_NULL;
   p_ssa_pdb->trans_param[0] = '\0';
   p_ssa_pdb->dMsgType = SipMessageAny;
   p_ssa_pdb->dest_port = ICF_NULL;
   p_ssa_pdb->dest_ip[0] = '\0';
   p_ssa_pdb->protocol = ICF_NULL;
   ICF_CMN_INIT_ADDRESS(p_ssa_pdb->conference_uri)
   ICF_CMN_INIT_STRING(p_ssa_pdb->warning_text)
   p_ssa_pdb->authorised_req = ICF_FALSE;
   p_ssa_pdb->notify_tag_mismatch = ICF_FALSE;
   p_ssa_pdb->addr_param_not_reqd = ICF_FALSE;
/*Rel 8.0 :precondition flags initialization */ 
   p_ssa_pdb->precondition_in_require_hdr = ICF_FALSE;
   p_ssa_pdb->precondition_in_supp_hdr = ICF_FALSE;
    p_ssa_pdb->rem_srv_cnt = ICF_NULL;
    p_ssa_pdb->p_app_ctxt = ICF_NULL;
    p_ssa_pdb->p_invalid_assoc_uri = ICF_NULL;
    p_ssa_pdb->p_call_obj_to_dealloc = ICF_NULL;
    p_ssa_pdb->mline_rcvd_w_app_profile = ICF_NULL;
    p_ssa_pdb->p_line_data= ICF_NULL;
    p_ssa_pdb->dest_module_id = ICF_INT_MODULE_INVALID;
    p_ssa_pdb->copy_msg_body_from_persitent_data = ICF_TRUE;
    p_ssa_pdb->reason_code_1 = ICF_NULL;
    /*  SPR 18064 Merge */
    p_ssa_pdb->auth_params_pres_in_chal = ICF_TRUE;
    p_ssa_pdb->common_bitmask = ICF_NULL;
    p_ssa_pdb->qos_call_check = ICF_FALSE;
    p_ssa_pdb->prack_reqd_for_qos = ICF_FALSE;
    /*SPR 18630 This will be set to true when 200OK 
     for QOS UPDATE is received from peer*/
    p_ssa_pdb->qos_update_succ_resp_recv = ICF_FALSE;
    p_ssa_pdb->p_stream_pdu = ICF_NULL;
    p_ssa_pdb->pdu_len = ICF_NULL; 
    /* CSR_1_6763883 Merged SPR 19672 Start */
#ifdef ICF_ERROR_ENABLE
    p_ssa_pdb->err_str[0] = '\0';
#endif
    /* CSR_1_6763883 Merged SPR 19672 End */
    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_populate_contact_addr
 * DESCRIPTION:  1.This functions populates the icf_address_st
 *                 on the basis of the Contact header (if any)
 *                 present in the SIP message passed to it
 *
 ***************************************************************************/
icf_return_t icf_ssa_populate_contact_addr(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT    SipMessage        *p_sip_msg,
        INOUT  icf_address_st **p_p_contact_addr,
        INOUT  Sdf_st_error      *p_err)  
{
    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_ty_u32bit           size;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        
    if (SipFail == sip_getHeaderCount(
                p_sip_msg, SipHdrTypeContactAny,
                &size,(SipError *)&(p_err->stkErrCode)))
    {
        ret_val = ICF_FAILURE; 
    }
    else if (size != 0)
    {
        /*
         * If multiple contacts are returned by peer,
         * currently we are picking only the fisrt
         */
        SipHeader dest_hdr;

        if (SipFail == sip_getHeaderAtIndex(
                    p_sip_msg, SipHdrTypeContactAny,&dest_hdr, 0,
                    (SipError *)&(p_err->stkErrCode)))
        {
            ret_val = ICF_FAILURE; 
        }
        else
        {
            /* Allocate memory for the contact addr */
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                    ICF_PORT_SIZEOF(icf_address_st),
                    ICF_MEM_COMMON, 
                    *p_p_contact_addr,
                    ICF_RET_ON_FAILURE, p_ssa_pdb->p_ecode, ret_val)

            /* Initialize the address strucute */
           icf_cmn_init_address(*p_p_contact_addr);
            /*
             * The ret_val is not captured here as the
             * following function returns failure only if the
             * user portion of the SIP URI is null.
             * Though this is not acceptable in 
             * the request URI of an incoming INVITE,
             * it is acceptable in the From and Contact header
             */
            icf_ssa_populate_address_from_sip_addr_spec(
                    p_ssa_pdb,
                    (SipAddrSpec *)
                    ((SipContactHeader *)(dest_hdr.pHeader))->pAddrSpec,
                    *p_p_contact_addr);
        }
        sip_freeSipHeader(&dest_hdr);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

#ifdef ICF_SSA_UT_NR_CODE

/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_phone_context_frm_sip_uri
 * 
 * DESCRIPTION:  1.This function parses the SIP URI to extract the
 *                 user part and phone-context parameter and updates
 *                 the icf_address_st structure accordingly
 *
 ***************************************************************************/
icf_return_t icf_ssa_parse_phone_context_frm_sip_uri(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT    SipAddrSpec       *p_sip_addr_spec,
        INOUT  icf_address_st *p_addr)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    icf_uint8_t          seps[] = ";=";
    icf_uint8_t          *p_token = ICF_NULL;
    Sdf_ty_s8bit            *p_rem = ICF_NULL;
    icf_uint8_t          temp[15]="\0";
    icf_string_st        temp1;
    p_ssa_pdb=p_ssa_pdb;

    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    icf_cmn_init_string(&temp1);
    /* Copy the user portion of SIP URI into a temporary string */
    icf_port_strcpy(temp1.str,p_sip_addr_spec->u.pSipUrl->pUser);
    /* 
     * NOTE : This is a temporary fix to
     * incorporate the wrong patch delivered 
     * by UATK team 
     */
    if (SIP_NULL != p_sip_addr_spec->u.pSipUrl->pHost)
    {
        icf_port_strcat(temp1.str,"@");
        icf_port_strcat(temp1.str,p_sip_addr_spec->u.pSipUrl->pHost);
    }
    /* First extract the user part from SIP URI */
    p_token = icf_port_strtokr(temp1.str,seps,&p_rem);

    if(ICF_NULL != p_token)
    {
    /* Copy the token into the addr_val of the address_st */
    icf_port_strcpy(p_addr->addr_val.str,p_token);
    }

    /* Now extract the phone-context parameter */
    while( ICF_NULL != p_token)
    {
        if(0 == icf_port_strcmp(temp,"phone-context"))
        {
/*            ICF_SSA_TRACE(p_ssa_pdb,ICF_TRACE_PHONE_CTXT_RECVD)*/
            icf_port_strcat(p_addr->addr_val.str, "phone-context");
            icf_port_strcat(p_addr->addr_val.str, "=");
            icf_port_strcat(p_addr->addr_val.str, (icf_uint8_t *)p_token);
            icf_port_strcat(p_addr->addr_val.str, ";");
            p_addr->addr_val.str_len = 
                icf_port_strlen(p_addr->addr_val.str);            
        }
        icf_port_strcpy(temp,p_token);
        /* Get next token: */
        if (ICF_NULL != p_rem)
        {
            p_token = icf_port_strtokr(p_rem,seps,&p_rem); 
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
#endif

#ifdef ICF_SSA_UT_NR_CODE
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_tel_url
 * 
 * DESCRIPTION:  1.This function parses the TEL URL and
 *               populates the icf_address_st structure with
 *               the required information(along with any paramters received)
 *               
 *
 ***************************************************************************/
icf_return_t icf_ssa_parse_tel_url(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT    SipAddrSpec       *p_sip_addr_spec,
        INOUT  icf_address_st *p_addr)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    SipError                err;
    SipList                 *p_sip_param_list = SIP_NULL;
    TelUrl                  *p_tel = SIP_NULL;
    p_ssa_pdb=p_ssa_pdb;


    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }   
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (SipFail == sip_getTelUrlFromAddrSpec (
                p_sip_addr_spec,&p_tel,&err))
    {
        ret_val = ICF_FAILURE;
    } /* p_sip_addr_spec,&p_tel,&sip_er... */
    else
    {
        if (SIP_NULL != p_tel->pGlobal)
        {
            icf_port_strcpy(p_addr->addr_val.str,
                    p_tel->pGlobal->pBaseNo);
            p_addr->addr_val.str_len = icf_port_strlen(p_addr->addr_val.str);
            p_addr->addr_type = ICF_ADDRESS_PLAN_TEL_URI;

            p_sip_param_list = &(p_tel->pGlobal->slParams);
        } /* if (SIP_NULL != p_tel->pGlobal... */
        else if (SIP_NULL != p_tel->pLocal)
        {
            icf_port_strcpy(p_addr->addr_val.str,
                    p_tel->pLocal->pLocalPhoneDigit);
            p_addr->addr_val.str_len = icf_port_strlen(p_addr->addr_val.str);
            p_addr->addr_type = ICF_ADDRESS_PLAN_TEL_URI;                    
            p_sip_param_list = &(p_tel->pLocal->slParams);
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
    }

    if( ICF_FAILURE != ret_val)
    {
        /*
         * Extract the phone - context and user parameters from
         * address spec
         */
        if(SipFail == sip_formSipParamList(
            /* SPR 19218 : UATK CSR_1-6613911 Change Start */SIP_NULL,
            /* SPR 19218 : UATK CSR_1-6613911 Change End */
            p_addr->addr_val.str,
            p_sip_param_list,
            (SIP_S8bit *)";",1,&err))
        {
            ret_val = ICF_FAILURE;
        }
        p_addr->addr_val.str_len = 
            icf_port_strlen(p_addr->addr_val.str);
    }

    if (SIP_NULL != p_tel)
    {
        sip_freeTelUrl(p_tel);
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
#endif

/*****************************************************************************
 * FUNCTION:        icf_ssa_check_for_reg_subs_trans_param
 *
 * DESCRIPTION:     Function to derive transport mode based on proxy mode
 *                  and mode received in remote party address in create call
 *
 *****************************************************************************/
icf_return_t icf_ssa_check_for_reg_subs_trans_param(
        icf_ssa_pdb_st        *p_ssa_pdb,
        icf_transport_mode_et reg_mode,
        icf_transport_mode_et self_mode)
{
    icf_return_t   ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if ((ICF_TRANSPORT_MODE_BOTH == reg_mode) &&
            (ICF_TRANSPORT_MODE_BOTH == self_mode))
    {
        p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_MODE_BOTH;
        p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_TRUE;
    }
    else if ((ICF_TRANSPORT_MODE_BOTH == reg_mode) &&
            (ICF_TRANSPORT_TYPE_TCP == self_mode))
    {
        p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
        p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
    }
    else if ((ICF_TRANSPORT_MODE_BOTH == reg_mode) &&
            (ICF_TRANSPORT_TYPE_UDP == self_mode))
    {
        p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
        p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
    }
    else if ((ICF_TRANSPORT_TYPE_TCP == reg_mode) &&
            (ICF_TRANSPORT_TYPE_UDP != self_mode))
    {
        p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
        p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
    }
    else if ((ICF_TRANSPORT_TYPE_UDP == reg_mode) &&
            (ICF_TRANSPORT_TYPE_TCP != self_mode))
    {
        p_ssa_pdb->p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
        p_ssa_pdb->p_ssa_ctxt->revert_mode = ICF_FALSE;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;
} /* icf_ssa_check_for_reg_subs_trans_param */
/*****************************************************************************
 * FUNCTION:        icf_ssa_flush_entry_frm_map
 *
 * DESCRIPTION:     This function flushes the entry in the map
 *                  between the context identifier and the SSA ctxt
 *                  and resets the bit ICF_SSA_OPTIONS_ONGOING
 *                  in the SSA ctxt
 * 
 *****************************************************************************/
icf_void_t icf_ssa_flush_entry_frm_map(
        icf_ssa_pdb_st  *p_ssa_pdb,
        icf_ssa_ctxt_st *p_ssa_ctxt)
{
    icf_ssa_glb_data_st  *p_ssa_glb_data = (icf_ssa_glb_data_st*)
        p_ssa_pdb->p_ssa_glb_data;
    icf_uint8_t          index = (icf_uint8_t) p_ssa_ctxt->options_map_index;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /*
     * Flush the entry in the map between the context identifier 
     * and the SSA ctxt
     */
    p_ssa_glb_data->options_map[index].p_ssa_ctxt = ICF_NULL;
    p_ssa_glb_data->options_map[index].context_identifier = ICF_NULL;

    /*
     * Reset the options index and the bit
     * indiacting that OPTIONS is ongoing
     */
    p_ssa_ctxt->options_map_index = ICF_SSA_MAX_OPTIONS_CALL_OBJ;
    p_ssa_ctxt->context_identifier = ICF_NULL;
    p_ssa_ctxt->options_timer_id = ICF_TIMER_ID_INVALID;
    p_ssa_ctxt->bitmask &= ~ICF_SSA_OPTIONS_ONGOING;
    /* This has been commented for SPR 17158*/
/*    p_ssa_ctxt->bitmask &= ~ICF_SSA_OPTIONS_RECVD_OUT_OF_DIALOG;*/
}

/*Message body header changes Start*/
/************************************************************************
 * FUNCTION:        icf_ssa_SetAllMsgBody
 * DESCRIPTION:     This function is used to Set the Message Body in SIP
 *                  Message.
 ***********************************************************************/
icf_return_t icf_ssa_SetAllMsgBody
    (Sdf_st_transaction     *pTransaction,
    Sdf_st_overlapTransInfo *pOverlapTransInfo,
    Sdf_ty_s8bit            *p_content_type,
    Sdf_st_error            *pError)
{
    Sdf_ty_slist *pSrcList = Sdf_co_null;
    SipMessage   *pSipMsg = Sdf_co_null;
#ifdef SDF_IM
    Sdf_st_msgInfo    dMessageInfo;
#endif

    if (pError == ICF_NULL)
    return ICF_FAILURE;
    /* Choose the MsgBodyList inside the call object if
     * overlapTransactionInfo is NULL
     */
    if ( pTransaction && (Sdf_co_null == pOverlapTransInfo))
    {
        pSrcList = &(pTransaction->slMsgBodyList);
        pSipMsg = pTransaction->pSipMsg;
    }
    else if (pOverlapTransInfo)
    {
        pSrcList = &(pOverlapTransInfo->slMsgBodyList);
        pSipMsg = pOverlapTransInfo->pSipMsg;
    }
#ifdef SDF_IM
    sdf_fn_uaGetMessageInfo(pSipMsg,  &dMessageInfo, pError);

    if( (dMessageInfo.dReqRespType == SipMessageResponse) && \
        (dMessageInfo.dMsgType == Sdf_en_message))
    {
        pError->errCode = Sdf_en_messageBodyNotAllowed;
        return ICF_FAILURE;
    }
#endif

    /* SipMessage now
     */
    if (icf_ssa_SetMsgBodyListInSipMessage(pSrcList, \
        pSipMsg, p_content_type,pError) == ICF_FAILURE)
    {
        pError->errCode=Sdf_en_sdpError;
        return ICF_FAILURE;
    }    

    pError->errCode = Sdf_en_noUaError;

    return ICF_SUCCESS;
}    

/************************************************************************
 ** FUNCTION:     icf_ssa_SetMsgBodyListInSipMessage
 **
 ** DESCRIPTION: This function sets the message bodies from the given 
 **         list into the outgoing SIP message.
 **         It first removes any previously present MsgBodies in
**               the SIP message, and then adds the new list.
 **
 ***********************************************************************/
static icf_return_t icf_ssa_SetMsgBodyListInSipMessage
    (Sdf_ty_slist *pMsgBodyList,
    SipMessage *pMsg,
    Sdf_ty_s8bit  *p_content_type,
    Sdf_st_error *pError)
{
    /* 
     * Parameter checks
     */
    if (pError == Sdf_co_null)
        return ICF_FAILURE;
    if (pMsg == Sdf_co_null)
    {
        pError->errCode=Sdf_en_sdpError;
        return ICF_FAILURE;
    }

    /* 
     * First delete the MsgBodys in the SIP message, then start 
     * appending new list.
     */
    if (sip_listDeleteAll(&(pMsg->slMessageBody),(SipError*)\
                &(pError->stkErrCode)) == SipFail)
    {
        pError->errCode=Sdf_en_sdpError;
        return ICF_FAILURE;
    }
    
    /* 
     * Now append the new MsgBodyList to this Sip Message
     */
    if (icf_ssa_AppendMsgBodyListToSipMessage(pMsgBodyList, pMsg,\
                p_content_type, pError) == Sdf_co_fail)
    {
        pError->errCode=Sdf_en_sdpError;
        return ICF_FAILURE;
    }
    pError->errCode = Sdf_en_noUaError;
    return ICF_SUCCESS;
}


/************************************************************************
 ** FUNCTION:      icf_ssa_AppendMsgBodyListToSipMessage
 **
 ** DESCRIPTION: This function appends the message bodies from the given 
 **         list into the SIP message. The MsgBodies already present
 **          in the SipMessage are left untouched.
 **
 ***********************************************************************/
static icf_return_t icf_ssa_AppendMsgBodyListToSipMessage
    (Sdf_ty_slist *pMsgBodyList,
    SipMessage    *pMsg,
    Sdf_ty_s8bit  *p_content_type,
    Sdf_st_error  *pError)
{
    Sdf_ty_u32bit    dSize=0;
    Sdf_ty_u32bit   index=0, dCount=0;
    SipHeader     *pMimeVersionHdr = Sdf_co_null;
    Sdf_ty_s8bit    *pTmpVal = Sdf_co_null;
    Sdf_ty_bool    dAddContentTypeHeader = Sdf_co_false;
    Sdf_ty_bool    dAddMimeHeader = Sdf_co_false;
    Sdf_ty_bool    dAddMimeVersionHeader = Sdf_co_false;
    icf_uint8_t  temp_buff[ICF_MAX_STR_LEN]="";
    icf_return_t ret_val = ICF_SUCCESS;
    icf_error_t  ecode = ICF_ERROR_NONE;
    
    sdf_listSizeOf(pMsgBodyList, &dSize, pError);
    
    if (dSize > 1)
    {
        Sdf_st_listIterator dListIterator;
        sdf_listInitIterator(pMsgBodyList, &dListIterator,pError);
        while (dListIterator.pCurrentElement != Sdf_co_null)
        {
            SipMsgBody       *pMsgBody = Sdf_co_null;
            SipMimeHeader *pMimeHdr = Sdf_co_null;
            Sdf_ty_s8bit  *pContentType = Sdf_co_null;
            SipHeader          *pHeader= SIP_NULL;
            pMsgBody = (SipMsgBody*)\
                (dListIterator.pCurrentElement->pData);
            
            /* Extract the message body type
            * IF message body type is application SDP then set the
            * content-type as application/sdp
            */
            if(SipSdpBody == pMsgBody->dType)
            {
                Sdf_mc_strdup(pContentType,"application/sdp");
                if(SipFail == sip_bcpt_initSipMimeHeader(&pMimeHdr,\
                    (SipError*)&(pError->stkErrCode)))
                {
                /* Failed to initialize SIP Mime Header
                    */
                    ret_val = ICF_FAILURE;
                } 
                
                /* Fill Content-Type header in MIME Header
                */
                else if(sip_initSipHeader(&pHeader,SipHdrTypeContentType,\
                    (SipError*)&(pError->stkErrCode))==SipFail)
                {
                    ret_val = ICF_FAILURE;
                }
                
                else if(sip_setMediaTypeInContentTypeHdr(pHeader, pContentType,\
                    (SipError*)&(pError->stkErrCode))==SipFail)
                {
                    ret_val = ICF_FAILURE;
                }
                else if(sip_bcpt_setContentTypeInMimeHdr(pMimeHdr,pHeader,\
                    (SipError*)&(pError->stkErrCode))==SipFail)
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    pMsgBody->pMimeHeader = pMimeHdr;
                }

                if(ICF_FAILURE == ret_val)
                {
                    /*Klocwork warning removal*/
                    sip_freeSipHeader(pHeader);
                    ICF_MEMFREE(
                           p_persistent_glb_pdb,
                           pHeader,
                           ICF_MEM_COMMON,
                           &ecode,
                           ret_val)
                    sip_bcpt_freeSipMimeHeader(pMimeHdr);
                    pError->errCode=Sdf_en_msgBodyError;
                    sdf_memfree(Sdf_mc_callHandlerMemId,
                        (Sdf_ty_pvoid *)pContentType,Sdf_co_null);
                    break;
                }

            }
            
            if (sip_insertMsgBodyAtIndex(pMsg, pMsgBody,\
                index, (SipError *)\
                &(pError->stkErrCode))\
                == SipFail)
            {
                sip_bcpt_freeSipMimeHeader(pMimeHdr);
                /*klockwork warning removal*/
                sip_freeSipHeader(pHeader);
                ICF_MEMFREE(
                       p_persistent_glb_pdb,
                       pHeader,
                       ICF_MEM_COMMON,
                       &ecode,
                       ret_val)
                pError->errCode=Sdf_en_sdpError;
                ret_val = ICF_FAILURE;
                break;
            }
            sdf_listNext(&dListIterator, pError);
            dAddMimeHeader = Sdf_co_true;
            index++;
            dCount++;

             sip_freeSipHeader(pHeader);
             ICF_MEMFREE(
                    p_persistent_glb_pdb,
                    pHeader,
                    ICF_MEM_COMMON,
                    &ecode,
                    ret_val)

        } /* End of loop inserting message bodies in the SIP
              *  message
        */

        dAddMimeVersionHeader = Sdf_co_true;
        dAddContentTypeHeader = Sdf_co_true;

    }
    else if(dSize == 1)
    {
        SipMsgBody *pMsgBody = Sdf_co_null;
        dAddContentTypeHeader = Sdf_co_true;
        
        if (sdf_listGetAt(pMsgBodyList, 0, (Sdf_ty_pvoid *)\
            &pMsgBody, pError) == Sdf_co_fail)
        {
            pError->errCode=Sdf_en_sdpError;
            ret_val = ICF_FAILURE;
        }
        else if(Sdf_co_null != pMsgBody->pMimeHeader)
        {
            
            /* If the user has added the content_type header in MIME 
            * Header, it can be removed at this stage, as it is not
            * required for a single message body.
            */

            if(ICF_NULL != pMsgBody->pMimeHeader->pContentType)
            {
                /* Only single message body received and we have
                 * filled the mime content type in the add_body_list
                 * So this contenttype should go on the SIP message
                 */
                SipHeader *pMimeContentTypeHdr = ICF_NULL;

                /* Spr 16408: Here SipHdrTypeContentType is replaced by 
                   SipHdrTypeAny in sip_initSipHeader function call to avoid
                   memory leak because we do not want any memory allocation
                   for pHeader because we assign pointer 
                 in sip_bcpt_getContentTypeFromMimeHdr pMimeHdr->pContentType*/

                if (SipFail == sip_initSipHeader(
                    &pMimeContentTypeHdr,SipHdrTypeAny,
                    ((SipError *)&(pError->stkErrCode))))
                {
                    sip_freeSipHeader(pMimeContentTypeHdr);
                    ret_val = ICF_FAILURE;
                }
                else if(SipFail == 
                    sip_bcpt_getContentTypeFromMimeHdr(pMsgBody->pMimeHeader,
                    &pMimeContentTypeHdr,(SipError *)&(pError->stkErrCode)))
                {
                    ret_val = ICF_FAILURE;
                }
                else if(SipFail == sip_setHeader(pMsg,pMimeContentTypeHdr,
                    (SipError *)&(pError->stkErrCode)))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    sip_freeSipContentTypeHeader(pMsgBody->pMimeHeader->pContentType);
                    pMsgBody->pMimeHeader->pContentType = Sdf_co_null;
                    dAddContentTypeHeader = Sdf_co_false;
                }

                if(ICF_NULL != pMimeContentTypeHdr)
                {
                    sip_freeSipHeader(pMimeContentTypeHdr);
                    sdf_memfree(Sdf_mc_callHandlerMemId,
                        (Sdf_ty_pvoid *)&pMimeContentTypeHdr,Sdf_co_null);
                }
                
            }
            if(ICF_FAILURE == ret_val)
            {
                
            }
            else if((ICF_NULL == pMsgBody->pMimeHeader->pContentDescription) &&
               (ICF_NULL == pMsgBody->pMimeHeader->pContentId) &&
               (ICF_NULL == pMsgBody->pMimeHeader->pContentTransEncoding) &&
               (ICF_NULL == pMsgBody->pMimeHeader->pContentDisposition) &&
               ( 0 == pMsgBody->pMimeHeader->slAdditionalMimeHeaders.size))
            {
                /* Free the Mime header and set to NULL*/
                sip_bcpt_freeSipMimeHeader(pMsgBody->pMimeHeader);
                pMsgBody->pMimeHeader = Sdf_co_null;
            }
            else
            {
                /* Some mime header is present so we will AddMimeVersionHeader*/
                dAddMimeVersionHeader = Sdf_co_true;
            }
        }
        if(ICF_FAILURE == ret_val)
        {
            
        }
        else if (sip_insertMsgBodyAtIndex(pMsg, pMsgBody, 0, \
            (SipError *)&(pError->stkErrCode)) == SipFail)
        {
            pError->errCode=Sdf_en_sdpError;
            ret_val = ICF_FAILURE;
        }
    }
    if(ICF_FAILURE == ret_val)
    {

    }
    if(Sdf_co_true == dAddContentTypeHeader)
    {
        /* Insert Content-Type header in the header list in case
        * of multiple message bodies
        */
        if(p_content_type && (0 != icf_port_strcmp((icf_uint8_t *)"",(icf_uint8_t *)p_content_type)))
        {
            sdf_fn_uaSprintf((Sdf_ty_s8bit *)temp_buff,"Content-Type:%s ",p_content_type);
        }
        else
        {
            Sdf_mc_strcpy(temp_buff,\
                (icf_uint8_t *)"Content-Type:multipart/mixed; boundary=ICFMsgBodyBoundary");
            dAddMimeVersionHeader = Sdf_co_true;
        }

        if(SipFail == sip_setHeaderFromStringAtIndex(pMsg,
            SipHdrTypeContentType,(Sdf_ty_s8bit *)
            &temp_buff,0, (SipError *)
            &(pError->stkErrCode)))
        {
            ICF_PRINT(((icf_uint8_t *)"Failed to insert "\
                "Content-Type header to Sip Msg\n"));
             ret_val = ICF_FAILURE;
        }
    }
    if(ICF_FAILURE == ret_val)
    {

    }
    /* Add a MIME-version and Content-Type header now */
    else if(Sdf_co_true == dAddMimeVersionHeader)
    {
        pTmpVal = Sdf_mc_strdupCallHandler("1.0");
        if (sip_initSipHeader(&pMimeVersionHdr,\
            SipHdrTypeMimeVersion, \
            (SipError *)&(pError->stkErrCode))\
            == SipFail)
        {
            sip_freeSipHeader(pMimeVersionHdr);
            ret_val = ICF_FAILURE;
        }
        
        else if (sip_bcpt_setVersionInMimeVersionHdr(pMimeVersionHdr,\
            pTmpVal, (SipError *)&(pError->\
            stkErrCode)) == SipFail)
        {
            ret_val = ICF_FAILURE;
        }
        else if (sip_setHeader(pMsg, pMimeVersionHdr, \
            (SipError *)&(pError->stkErrCode)) == SipFail)
        {
            ret_val = ICF_FAILURE;
        }
        
        /* Free local variable */
        if(ICF_NULL != pMimeVersionHdr)
        {
            sip_freeSipHeader(pMimeVersionHdr);
            sdf_memfree(Sdf_mc_callHandlerMemId, \
                (Sdf_ty_pvoid *)&pMimeVersionHdr, pError);
        }
        if(ICF_FAILURE == ret_val)
        {
            sdf_memfree(Sdf_mc_callHandlerMemId,
                        (Sdf_ty_pvoid *)pTmpVal,Sdf_co_null);
        }

        
    }
   return ret_val;
}

/************************************************************************
 ** FUNCTION:      icf_get_content_type_from_msg_body
 **
 ** DESCRIPTION: This function extracts the Content type from message
 ** body list
 **
 ***********************************************************************/
static icf_void_t icf_get_content_type_from_msg_body(
        INOUT  icf_ssa_pdb_st  *p_ssa_pdb,
        OUT icf_uint8_t     **p_p_content_type)
{
    icf_ssa_ctxt_st           *p_ssa_ctxt = ICF_NULL;

    icf_rgm_context_st        *p_rgm_context = ICF_NULL;
    icf_int8_t                *p_context = ICF_NULL;
    icf_uint16_t              loop_app = ICF_NULL;
    icf_return_t              ret_val = 0;
     
     /* Copy the ssa ctxt pointer locally */
     p_ssa_ctxt = (icf_ssa_ctxt_st *)p_ssa_pdb->p_ssa_ctxt->\
          p_call_obj->pAppData->pData;
     ret_val = ret_val;
     /*ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_ssa_ctxt)) */
     if (ICF_NULL == p_ssa_ctxt )
     {
         return;
     }
         
    /* Copy the rgm_context pointer locally */
    p_rgm_context = (icf_rgm_context_st *)(p_ssa_ctxt->p_rgm_ctxt);
         
    /*ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_rgm_context))*/
    if (ICF_NULL == p_rgm_context)
    {
        return;
    }        
    for (loop_app = 0; loop_app < p_ssa_pdb->p_glb_cfg_data->\
            max_applications ; loop_app++)
     {
       
         if (ICF_FALSE == p_rgm_context->p_app_data_list[
             loop_app].is_valid)
             continue;
    
     if (ICF_BODY_LIST_PRESENT & p_rgm_context->
             p_app_data_list[loop_app].bitmask)
         {
         if(ICF_NULL != p_rgm_context->p_app_data_list[loop_app].\
                 body_list.content_type.str)
         {
             Sdf_mc_strdup(p_context,(icf_int8_t *)p_rgm_context->\
                 p_app_data_list[loop_app].body_list.\
                 content_type.str);
             *p_p_content_type = (icf_uint8_t*)p_context;
                   break;
         }
     
            else 
        {
            Sdf_mc_strdup(p_context,(icf_int8_t *)"multipart/mixed;boundary=ICFMsgBodyBoundary");
            *p_p_content_type = (icf_uint8_t*)p_context;
            break;
        }
     }
         
     }/* for loop_app Ends */
    
}/* End of function*/

/*****************************************************************************
** FUNCTION: icf_ssa_IsSupportedMediaTypeInMsgBody
**
** DESCRIPTION: This function checks the following header in the receieved
**        message
**        1.      Checks the Media type present in the Content-Type
**            header against the List of Accepted Media present in the
**            Accept attribute of the user profile. 
**            If no match found with the Accepted Media then
**            it rejects with 415. 
**
******************************************************************************/
static icf_return_t icf_ssa_IsSupportedMediaTypeInMsgBody
(
        /*INOUT    Sdf_st_callObject *pObj,*/
        INOUT    en_SipMessageType dReqRespType,
        INOUT    Sdf_st_initData   *pInitData,
        INOUT    Sdf_ty_s8bit      *pMediaType,
        OUT   Sdf_st_error      *pErr)
{
    Sdf_st_configExtraHeaders     *pTemp =Sdf_co_null;
    Sdf_st_configExtraHeaders    *pAccept=Sdf_co_null;
    icf_uint32_t                    size2=0;
    icf_uint32_t                    IndicateAccept=0; 
    Sdf_st_listIterator             dListIterator;
    /*
    if (pObj == Sdf_co_null)
    {
             ICF_PRINT(("\n[SSA]:pObj param is Invalid "));    
        pErr->errCode=Sdf_en_invalidParamError;
        return ICF_FAILURE;
    }*/

    if (pInitData == Sdf_co_null)
    {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:pInitData param is Invalid "));
        pErr->errCode=Sdf_en_invalidParamError;
        return ICF_FAILURE;
    }

    /*
     * If a response has come in, avoid processing and return
     * ICF_SUCCESS
     */
     /*
    if (pObj->pUasTransaction->pSipMsg == Sdf_co_null && \
        pObj->pUacTransaction->pSipMsg != Sdf_co_null)
    {
        pErr->errCode = Sdf_en_noUaError;
        ICF_PRINT(("\n[SSA]:Exiting IsSupportedMediaType "));
        return ICF_SUCCESS;
    }
    */

    if(SipMessageResponse == dReqRespType)
    {
        pErr->errCode = Sdf_en_noUaError;
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Exiting IsSupportedMediaType "));
        return ICF_SUCCESS;
    }
    
    /*
     * Check if ACCEPT attribute 
     * had been set in the user profile and take those headers from the profile.
     */

    sdf_listSizeOf(&(pInitData->slExtraHeadersList), &size2, pErr);

    sdf_listInitIterator(&(pInitData->slExtraHeadersList),&dListIterator, pErr);

    while (dListIterator.pCurrentElement != Sdf_co_null)
    {
        pTemp = (Sdf_st_configExtraHeaders*)\
            (dListIterator.pCurrentElement->pData);

        if(pTemp->pParam->pName==Sdf_co_null)
        {
            sdf_listNext(&dListIterator, pErr);
            continue;
        }

        if(Sdf_mc_strcasecmp((Sdf_ty_s8bit*)"ACCEPT",(Sdf_ty_s8bit*)pTemp->pParam->pName)==0)
        {
            pAccept=pTemp;
            IndicateAccept = 1;
            break;
        }
        sdf_listNext(&dListIterator, pErr);
    }
    
    if(ICF_NULL != pMediaType)
    {
        icf_boolean_t dFound=ICF_FALSE;

        /* If ACCEPT attribute not present in the profile the check for default
         * media-types.
         */
        
        if((Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pMediaType,(Sdf_ty_s8bit*)"application/sdp")==0)
#ifdef SDF_REFER
            || (Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pMediaType,(Sdf_ty_s8bit*)"message/sipfrag")==0)
#endif
#ifdef SDF_IM
            || (Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pMediaType,(Sdf_ty_s8bit*)"text/plain")==0)
#endif
          )
        {
            dFound=ICF_TRUE;
        }
        else if(IndicateAccept != 0)
        {
            icf_uint32_t sizeval=0,ctr;

            if(sip_listSizeOf(&(pAccept->pParam->slValue),&sizeval, \
               (SipError*)&(pErr->stkErrCode)) ==SipFail)
            {
                                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failed to get the size of "\
                        "accepted media-type."));
                pErr->errCode=Sdf_en_initDataAccessError;
                return ICF_FAILURE;
            }
            for(ctr=0;ctr<sizeval;ctr++)
            {
                Sdf_ty_s8bit *pTempVal;

                if(sip_listGetAt(&(pAccept->pParam->slValue),  \
                    (Sdf_ty_u32bit) ctr,(Sdf_ty_pvoid *)&pTempVal,  \
                    (SipError*)&(pErr->stkErrCode)) == SipFail)
                {
                                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failed to get the Accept Parameter Value "));
                    pErr->errCode=Sdf_en_initDataAccessError;
                    return ICF_FAILURE;
                }
                if(Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pMediaType,(Sdf_ty_s8bit*)pTempVal)==0)
                {
                    dFound=ICF_TRUE;
                    break;
                }
                /*  If content type is ALL then allow 
                 *  the content type
                 */
                else if(0 ==
                        Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pTempVal,(Sdf_ty_s8bit*)"ALL"))
                {
                    dFound=ICF_TRUE;
                    break;
                }
            }
        }

        /* If no match found then form 415 response */
        if(ICF_TRUE != dFound)
        {/*
            if (sdf_ivk_uaRejectRequest(pObj,\
                    pInitData,415, &pOverlapTxn, pErr) == Sdf_co_fail)
            {
                                ICF_PRINT(("\n[SSA]:Failed to form 415 response "));
                return ICF_FAILURE;
            }
            if (pOverlapTxn != Sdf_co_null)
            {        

                if(pOverlapTxn != Sdf_co_null)
                {
                    if( pObj->pUasTransaction->pSipMsg != Sdf_co_null )
                        sip_freeSipMessage(pObj->pUasTransaction->pSipMsg);
                    pObj->pUasTransaction->pSipMsg=pOverlapTxn->pSipMsg;
                    HSS_LOCKEDINCREF(pObj->pUasTransaction->pSipMsg->dRefCount);
                }
            }    */
            return ICF_FAILURE;
        }
    }
    pErr->errCode = Sdf_en_noUaError;
    return ICF_SUCCESS;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_status_frm_notify_from_mime_body
 * DESCRIPTION:     This function checks the given SipMessage for Fragmented
 *                  Sip body and then checks it for the response code
 *                  It returns TRUE if a 200 OK is found, FALSE if any non 2xx
 *                  is found or no message body is found at all
 ******************************************************************************/
static icf_return_t icf_ssa_get_status_frm_notify_from_mime_body(
        INOUT    icf_ssa_pdb_st       *p_ssa_pdb,
        INOUT      SipMsgBody           *p_sip_msg_body,
        OUT     icf_boolean_t        *p_status)
{
    icf_return_t         ret_val = ICF_SUCCESS;

    Sdf_st_error            sdf_error;
    SipMessage      *p_sip_frag_message = SIP_NULL;
    Sdf_ty_u16bit   frag_resp_code;
    SipBool            sip_ret_val=SipSuccess;

    p_ssa_pdb=p_ssa_pdb;
    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    /*
     * Here I am setting the status as success, in the code below i will
     * check for presence of a non 2xx response in the sip message body.
     * if it is there then this status is changed to false.
     * In allother cases, that is when there is no sip message body ( there
     * could be otehr bodies), or the sip message body is there with 200 OK
     * we do not modify the status
     */
    *p_status = ICF_TRUE;
  
        /*
         * If message body is absent,SSA sets the status as FALSE
         */
        if (ICF_NULL == p_sip_msg_body)
        {
            *p_status = ICF_FALSE;
        }
   
        /*Now get the SipMessage Fragment from the SipMessageBody*/
        
        /* Changes start for SPR 10934
         */
        else
        {
            sip_ret_val=sip_getSipMessageFromMsgBody(p_sip_msg_body,
                            &p_sip_frag_message,
                            (SipError*)&(sdf_error.errCode));

            if (SipFail == sip_ret_val)
            {
                sip_freeSipMsgBody(p_sip_msg_body);
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sip_getSipMessageFromMsgBody"));
                 ret_val = ICF_FAILURE;
                *p_status = ICF_FALSE;
               
            }
            else
            {
                /* Set the message type for Sip Fragmented Body
                */
                p_sip_frag_message->dType = SipMessageResponse;
            }

            if(SipSuccess==sip_ret_val)
            {
                /*Now get the response code from SipMessage Fragment*/
                if (Sdf_co_fail == sdf_ivk_uaGetRespCodeFromSipMessage(
                         p_sip_frag_message,&frag_resp_code,&sdf_error))
                {
                    sip_freeSipMessage(p_sip_msg_body->u.pAppSipMessage);
                    sip_freeSipMsgBody(p_sip_msg_body);
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in sdf_ivk_uaGetRespCodeFromSipMessage"));
                    ret_val = ICF_FAILURE;
                    *p_status = ICF_FALSE;
              
                }
                else
                {
                    sip_freeSipMessage(p_sip_msg_body->u.pAppSipMessage);
                    sip_freeSipMsgBody(p_sip_msg_body);

                    if (( 200 > frag_resp_code)||(299 < frag_resp_code))
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Non200 response code in SipMessageFragment"));
                        *p_status = ICF_FALSE;
              
                    }
                }
            }
            /*Changes ends for SPR 10934*/
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*Message body header changes Ends*/

/*******************************************************************************
 * FUNCTION:        icf_ssa_check_for_param_in_sipurl
 * DESCRIPTION:     This function gets the parameters present in the referred-to
                    address.
 ******************************************************************************/

icf_return_t icf_ssa_check_for_param_in_sipurl( 
                INOUT               SipUrl        *pUrl, 
                INOUT            icf_uint8_t    *p_param_name, 
                INOUT           icf_uint8_t    *p_out_param_string, 
                INOUT           icf_error_t    *p_ecode)
{
    Sdf_st_error    SipErr;
    Sdf_ty_u32bit    dUrlParamCount = 0;
    icf_uint8_t        tot_len = 0;

    p_ecode=p_ecode;    
    *p_out_param_string = ICF_NULL;

    if (sip_getUrlParamCountFromUrl(pUrl, &dUrlParamCount, \
        (SipError*)&SipErr) == SipFail)
    {
        return ICF_FAILURE;
    }
    if (dUrlParamCount > 0)
    {
        Sdf_ty_u32bit dIndex;
        for (dIndex = 0; dIndex < dUrlParamCount; dIndex++)
        {
            SipParam *pUrlParam;
            Sdf_ty_s8bit *pName;
            
            if (sip_getUrlParamAtIndexFromUrl(pUrl, &pUrlParam,\
                dIndex, (SipError*)&(SipErr)) == SipFail)
            {
                return ICF_FAILURE;
            }
            
            if (sip_getNameFromSipParam(pUrlParam, &pName, \
                (SipError*)&(SipErr)) == SipFail)
            {
                return ICF_FAILURE;
            }
            
            if (Sdf_mc_strcmp((const icf_int8_t *)pName, (const icf_int8_t *)p_param_name) == 0)
            {
                Sdf_ty_s8bit *pTempCompType = Sdf_co_null;
                
                if (sip_getValueAtIndexFromSipParam(pUrlParam, \
                    &pTempCompType, 0, (SipError*) \
                    &(SipErr)) == SipFail)
                {
                    return ICF_FAILURE;
                }

                tot_len = (icf_uint8_t)(icf_port_strlen((icf_uint8_t *)p_param_name) + icf_port_strlen((icf_uint8_t *)pTempCompType) + 1);

                if (ICF_MAX_STR_LEN <= tot_len)
                {
                    return ICF_FAILURE;
                }
                else
                {
                    icf_port_strcpy(p_out_param_string, p_param_name);
                    icf_port_strcat(p_out_param_string, (icf_uint8_t *)"=");
                    icf_port_strcat(p_out_param_string, (icf_uint8_t *)pTempCompType);
                    sip_freeSipParam(pUrlParam);
                    break;
                }
            
            }
        }
    }
    return ICF_SUCCESS;
}


/*******************************************************************************************
 * FUNCTION           icf_ssa_add_param_in_uri_address
 *
 *
 * Description:  This function appends the SIP parameters in address string. 
 *
 * ***************************************************************************************/
icf_return_t icf_ssa_add_param_in_uri_address( 
                INOUT     SipUrl          *pUrl, 
                INOUT     icf_uint8_t  *p_address_string, 
                INOUT     icf_error_t     *p_ecode)
{
    Sdf_st_error    SipErr = {0,0,0,"\0"};
    Sdf_ty_u32bit    dUrlParamCount = 0;
    icf_uint8_t        tot_len = 0;
    icf_uint8_t			param_str[ICF_MAX_STR_LEN] = "\0";
    Sdf_ty_s8bit *pTempCompType = Sdf_co_null;
    
    p_ecode=p_ecode;    

    if (sip_getUrlParamCountFromUrl(pUrl, &dUrlParamCount, \
        (SipError*)&SipErr) == SipFail)
    {
        return ICF_FAILURE;
    }

    if (dUrlParamCount > 0)
    {
        Sdf_ty_u32bit dIndex;
        for (dIndex = 0; dIndex < dUrlParamCount; dIndex++)
        {
            SipParam *pUrlParam = Sdf_co_null;
            Sdf_ty_s8bit *pName = Sdf_co_null;
           
           /* Get each paramters present in the SIP Url and append it
            * in the address string 
            */ 
            if (sip_getUrlParamAtIndexFromUrl(pUrl, &pUrlParam,\
                dIndex, (SipError*)&(SipErr)) == SipFail)
            {
                sip_freeSipParam(pUrlParam);
                return ICF_FAILURE;
            }
            
            if (sip_getNameFromSipParam(pUrlParam, &pName, \
                (SipError*)&(SipErr)) == SipFail)
            {
                sip_freeSipParam(pUrlParam);
                return ICF_FAILURE;
            }
            
                
            if (sip_getValueAtIndexFromSipParam(pUrlParam, \
                    &pTempCompType, 0, (SipError*) \
                    &(SipErr)) == SipFail)
            {
                sip_freeSipParam(pUrlParam);
                return ICF_FAILURE;
            }

            tot_len = icf_port_strlen((icf_uint8_t*)pName) + icf_port_strlen((icf_uint8_t*)pTempCompType) + 1;

            if (ICF_MAX_STR_LEN <= tot_len)
            { 
                /* long string received , can not process */
                 sip_freeSipParam(pUrlParam);
                 /* Fix for SPR: 19886 (Merged CSR 1-7329950)*/
                 /* If max str length has been reached then also this function
                  * must returns success to proceed further for generating the 
                  * redirecting INVITE.*/
                 return ICF_SUCCESS;                 
            }
            else
            {
                /* append the paramter in address in name=value format */
                 icf_port_strcpy((icf_uint8_t*)param_str, (icf_uint8_t*)pName);
                 icf_port_strcat(param_str, (icf_uint8_t*)"=");
                 icf_port_strcat(param_str, (icf_uint8_t*)pTempCompType);

                 icf_port_strcat(p_address_string,(icf_uint8_t*)";");
			     icf_port_strcat(p_address_string,param_str);
            }
            sip_freeSipParam(pUrlParam);
            
        }
    }
    return ICF_SUCCESS;
}

/*NOTIFY_OUT_OF_DIALOG_START*/
/*******************************************************************************
 * FUNCTION:        icf_ssa_handle_notify_out_of_dialog
 *
 * DESCRIPTION:     This function parses NOTIFY req received out of dialog
 *
 ******************************************************************************/

icf_return_t   icf_ssa_handle_notify_out_of_dialog(
        icf_ssa_pdb_st              *p_ssa_pdb,
        icf_nw_inc_notify_ind_st    *p_notify_ind,
        Sdf_st_overlapTransInfo        *pOverlapTransInfo,
        SipMessage                     *pSipMsg)
{
    icf_return_t    ret_val = ICF_SUCCESS;
    icf_return_t    ret_value = ICF_SUCCESS;
    SipHeader          subs_header = {SipHdrTypeSubscriptionState, SIP_NULL};
    Sdf_st_error       sdf_error = {0,0,0,"\0"};
    SIP_S8bit          *p_subs_state = ICF_NULL;
    SIP_U32bit         param_count = 0;
    SipError           error = 0;
    SipParam           *p_param_list = ICF_NULL;
    SIP_U32bit         count = 0;
    icf_uint8_t     reason_code[15]="\0", *p_param_val = ICF_NULL;
    icf_uint16_t    retry_after = 0;
    icf_uint16_t    expires = 0;
    /*  Fix for spr 18882 */
    if ((ICF_NULL == p_ssa_pdb) || (ICF_NULL == p_ssa_pdb->p_glb_pdb))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Either SSA PDB or GLB PDB is null"));
        return ICF_FAILURE;
    }
    ICF_CHECK_IF_ANY_OF_TWO_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb, p_notify_ind,
            pOverlapTransInfo, ret_value)       
    if (ICF_FAILURE == ret_value)
    {
        return ICF_FAILURE;
    } 
    /*Fetch Subscription-State header*/
    if (SipFail != sip_getHeader(pSipMsg, 
                SipHdrTypeSubscriptionState,&subs_header, 
                (SipError*)&(sdf_error.stkErrCode)))
    {
    if (SipFail == 
            sip_impp_getSubStateFromSubscriptionStateHdr(
                &subs_header,&p_subs_state,
                (SipError*)&(sdf_error.stkErrCode)))
    {
        sip_freeSipHeader(&subs_header);
        return ICF_FAILURE;
    }
    else
    {
        ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                subs_header.pHeader,ret_value)
        if (ICF_FAILURE == ret_value)
        {
            return ret_value;
        }
        /*Get Parameters in Subscription Header*/
        param_count = 
                
#ifdef ICF_WITH_MUATK_2_2
            ((SipSubscriptionStateHeader*)(subs_header.pHeader))->slParam.size;
#else
            ((SipSubscriptionStateHeader*)(subs_header.pHeader))->slParams.size;
#endif                
               
        while (count < param_count)
        {
            if (SipSuccess == 
                    sip_impp_getParamAtIndexFromSubscriptionStateHdr(
                        &subs_header, &p_param_list, count, &error))
            {
                /*  Fix for spr 18882 */
                ICF_CHECK_IF_ANY_OF_TWO_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb, 
                        p_param_list, p_param_list->pName, ret_value)
                if(ICF_FAILURE == ret_value)
                {
                    return ret_value;
                }
                sip_listGetAt(&(p_param_list->slValue), 0, 
                        (SIP_Pvoid *)&p_param_val, &error);
                
                if ( 0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"reason"))
                {
                    icf_port_strcpy(reason_code, p_param_val);
                }
                else if (0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"retry-after"))
                {
                    retry_after = (icf_uint8_t)icf_port_atoi((const icf_int8_t *)p_param_val);
                }
                else  if (0 == icf_port_strcmp(
                            (icf_uint8_t *)p_param_list->pName, (icf_uint8_t *)"expires"))
                {
                    expires = (icf_uint8_t)icf_port_atoi((const icf_int8_t *)p_param_val);
                }
                sip_freeSipParam(p_param_list);
            }

            count++;
        } /* while (count < param_count) */
    } /* else */
    } /* If success of get sub state */


    if(ICF_NULL == p_subs_state)
    {
        /*If subscription-state is not present, take default as Active */
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureIn getting Subscription state frm MESSAGE"));
        p_notify_ind->subs_state = ICF_SUBS_STATE_ACTIVE;
        p_notify_ind->reason_code = ICF_NW_INC_SUBS_RESP_NO_RETRY;

    }
    else if ((0 == icf_port_strcmp((icf_uint8_t *)p_subs_state, (icf_uint8_t *)"active")) ||
            (0 == icf_port_strcmp((icf_uint8_t *)p_subs_state, (icf_uint8_t *)"pending")))
    {
        /*If subscription-state is active or pending then mark subs_state
         * = ICF_SUBS_STATE_ACTIVE*/
        p_notify_ind->subs_state = ICF_SUBS_STATE_ACTIVE;

        /*If expires parameter is present then copy to duration and mark
         * bitmask as duration_present*/
        if (0 != expires)
        {
            p_notify_ind->duration = expires * 1000;

            p_notify_ind->bitmask |= ICF_NW_INC_SUBS_DURATION_PRESENT;
        }
    } /* (0 == icf_port_strcmp(p_sub... */
    else
    {
        /*Otherwise mark subs_state = ICF_SUBS_STATE_TERMINATED*/
        p_notify_ind->subs_state = ICF_SUBS_STATE_TERMINATED;

        if ((0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"rejected")) ||
                (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"noresource")))
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_SUBS_RESP_NO_RETRY;
        }
        else if (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"giveup"))
        {
            if (0 != retry_after)
            {
                p_notify_ind->duration = retry_after;

                p_notify_ind->bitmask |= ICF_NW_INC_SUBS_DURATION_PRESENT;

                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_AFTER;
            }
            else
            {
                p_notify_ind->reason_code = 
                    ICF_NW_INC_NOTIFY_RETRY_IMM;
            }
        } /* else if (0 == icf_port_strc... */
        else if ((0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"deactivated")) ||
                (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"timeout")))
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_NOTIFY_RETRY_IMM;
        }
        else if (0 == icf_port_strcmp(reason_code, (icf_uint8_t *)"probation"))
        {
            if (0 != retry_after)
            {
                p_notify_ind->duration = retry_after;

                p_notify_ind->bitmask |= ICF_NW_INC_SUBS_DURATION_PRESENT;
            }

            p_notify_ind->reason_code = 
                ICF_NW_INC_NOTIFY_RETRY_AFTER;
        }
        else  
        {
            p_notify_ind->reason_code = 
                ICF_NW_INC_SUBS_RESP_NO_RETRY;
        }
    } /* else */

    p_notify_ind->bitmask |= ICF_NW_INC_NOTIFY_OUT_OF_DIALOG;

    if (ICF_SUCCESS == ret_val)
    {
        /* Free the local reference */
        if(ICF_NULL != p_subs_state)
        {
            /* We should free local refrence only if ret_val was success */
            sip_freeSipHeader(&subs_header);
        }

        /*Fetch Content-Type header from SIP message*/
        /*If Content-Type is application/simple-message-summary then
         * fetch message body*/
        if ((ICF_NULL == p_subs_state) && (ICF_NULL != p_notify_ind->p_sic_ctx))
        {
            p_notify_ind->p_sic_ctx->body_list.count=0;

            if (ICF_FAILURE == icf_ssa_get_msg_body_frm_sip_message(p_ssa_pdb, \
                        pOverlapTransInfo->pSipMsg,\
                        /**ppCallObj*/SipMessageRequest,
                        &(p_notify_ind->p_sic_ctx->body_list)))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInMsgBody retreival \
                            from MESSAGE"));
                p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
                    ICF_SSA_FAILURE_RESP_CODE_415;
                ret_val = ICF_FAILURE;
            }  
        }
    }/* end ICF_SUCCESS == ret_val */

    ICF_SIC_END
    if (ICF_FAILURE != ret_val)
    {
        ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                p_ssa_pdb->p_internal_msg, ret_value)
        if(ICF_FAILURE == ret_value)
        {
            return ret_value;
        }
        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = 
            ICF_NW_INC_NOTIFY_IND;
        
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length =
            ICF_PORT_SIZEOF(icf_nw_inc_notify_ind_st);
        
        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_SIC;
    }    

    return ret_val;
}

icf_return_t icf_ssa_get_replaces_header_from_referto(
     SipReferToHeader *pReferToHdr,
     SipReplacesHeader **ppReplacesHdr,
     Sdf_st_error *pErr)
{
    SipHeader         dSipHeaderReferTo;
    SipHeader         *pSipHeaderReplaces = Sdf_co_null;
    Sdf_ty_retVal     dRetVal = ICF_FAILURE;
    icf_uint32_t    param_count=0, i, j;
    icf_string_st     ReplacesStr;    
    SipList         *pList = SIP_NULL;

    /* DO not remove this as ={0}; causes warnings */
        
    dSipHeaderReferTo.dType=0;
    dSipHeaderReferTo.pHeader=SIP_NULL;
    ReplacesStr.str[0]='\0';
    ReplacesStr.str_len=0;

    if(pErr == Sdf_co_null)
    {
        return ICF_FAILURE;
    }
    if ((Sdf_co_null == pReferToHdr) || (Sdf_co_null == ppReplacesHdr))
    {
        pErr->errCode=Sdf_en_invalidParamError;
        return ICF_FAILURE;
    }
    
    *ppReplacesHdr = Sdf_co_null;
    dSipHeaderReferTo.dType = SipHdrTypeReferTo;
    dSipHeaderReferTo.pHeader = pReferToHdr;
    icf_port_strcpy(ReplacesStr.str,(icf_uint8_t *)"Replaces:");

    if((pReferToHdr->pAddrSpec->dType !=SipAddrSipUri) &&
        (pReferToHdr->pAddrSpec->dType !=SipAddrSipSUri))
    {
        icf_uint8_t *p_loc = ICF_NULL;
        /* For uris other then sip and sips */
        if ((ICF_NULL != pReferToHdr->pAddrSpec->u.pUri) &&
            (ICF_NULL != (p_loc = (icf_uint8_t *)icf_port_strstr(
            pReferToHdr->pAddrSpec->u.pUri, 
            (const icf_int8_t *)"Replaces="))))
        {
            icf_port_strcat(ReplacesStr.str, 
                p_loc+strlen("Replaces="));
            dRetVal = ICF_SUCCESS;
        }
    }
    /* Check whether Repleace cams as a header param */
    else if (ICF_NULL != pReferToHdr->pAddrSpec->u.pSipUrl)
    {
        icf_uint8_t *p_loc = ICF_NULL;
        if ((ICF_NULL != pReferToHdr->pAddrSpec->u.pSipUrl->pHeader) &&
            (ICF_NULL != (p_loc = (icf_uint8_t *)icf_port_strstr(
            (const icf_int8_t *)pReferToHdr->pAddrSpec->u.pSipUrl->pHeader, 
            (const icf_int8_t *)"Replaces="))))
        {
            icf_port_strcat(ReplacesStr.str, 
                p_loc+strlen("Replaces="));
            dRetVal = ICF_SUCCESS;
        }
        else
        {
            pList = &(pReferToHdr->pAddrSpec->u.pSipUrl->slParam);
            param_count = pList->size;
            if(0 == param_count)
            {
                /* Check for the slParam of the heder */
                pList = &(pReferToHdr->slParam);
                param_count = pList->size;
                
            }
        }
    }

    
    for (i=0; i<param_count; i++)
    {
        SipParam *pParam=Sdf_co_null;
        
        if (sip_listGetAt(pList, i, ((SIP_Pvoid *)&pParam), \
        (SipError *)&pErr->stkErrCode) == SipFail)
        return SipFail;        
        
        if (Sdf_co_null != pParam)
        {
            if (0 ==
                    Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pParam->pName,(Sdf_ty_s8bit*) "Replaces"))
            {
                Sdf_ty_s8bit *pParamStr = Sdf_co_null;
                Sdf_ty_u32bit dParamValueCount;
                
                sip_getValueCountFromSipParam(pParam, &dParamValueCount, 
                        (SipError *)&pErr->stkErrCode);
                if (dParamValueCount>=1)
                {
                    dRetVal = ICF_SUCCESS;
                    Sdf_mc_strcpy(ReplacesStr.str, "Replaces:");
                }
                for (j=0; j<dParamValueCount; j++)
                {
                    sip_getValueAtIndexFromSipParam(pParam, &pParamStr, j, 
                            (SipError *)&pErr->stkErrCode);
                    /* If there are any Header Params in "Replaces" header,
                     * append them to the header separated by semicolon (;) */
                    /* KLOCSWORK*/
                    if (j>0)
                    {
                      if (icf_port_strlen(ReplacesStr.str) < ICF_MAX_STR_LEN -2)
                        /* Max length - 2 
                         * (1 for NULL) +
                         * (1 for ";" to be appended) */
                      {
                        icf_port_strcat(ReplacesStr.str, (icf_uint8_t*)";");
                        ReplacesStr.str[icf_port_strlen(ReplacesStr.str)]='\0';
                      }
                    }
                    if (icf_port_strlen(ReplacesStr.str) < 
                           (ICF_MAX_STR_LEN - ICF_PORT_SIZEOF(pParamStr)))
                    {
                      icf_port_strcat(ReplacesStr.str, (icf_uint8_t*)pParamStr);
                      ReplacesStr.str[icf_port_strlen(ReplacesStr.str)]='\0';
                    }
                }
                sip_freeSipParam(pParam);
                break;
            }
            sip_freeSipParam(pParam);
        }
    }

    /* 
     * If "Replaces" param was found in "Refer-To" header, then 
     * 1. convert the String to SipReplacesHeader 
     * 2. Initialise a SipHeader
     * 3. Convert string to SipHeader (of type SipReplacesHeader)
     */
    if (ICF_SUCCESS == dRetVal)
    {
        
        sdf_fn_uaUnescapeCharacters((Sdf_ty_s8bit *)ReplacesStr.str, pErr);
        if (SipFail == sip_initSipHeader(&pSipHeaderReplaces, SipHdrTypeAny, \
                (SipError *)&pErr->stkErrCode))
        {
            pErr->errCode = pErr->stkErrCode;
            sip_freeSipHeader(pSipHeaderReplaces); 
            return ICF_FAILURE;
        }
        if (SipFail == sip_parseSingleHeader((icf_int8_t *)ReplacesStr.str, SipHdrTypeReplaces,
                pSipHeaderReplaces, (SipError *)&pErr->stkErrCode))
        {
            sip_freeSipHeader(pSipHeaderReplaces); 
            sdf_memfree(Sdf_mc_callHandlerMemId,(Sdf_ty_pvoid*)&pSipHeaderReplaces, \
                pErr);
            return ICF_FAILURE;
        }
        /* Store the "Replaces" Header in the return value */
        *ppReplacesHdr = (SipReplacesHeader *)pSipHeaderReplaces->pHeader;
        sip_freeSipHeader(pSipHeaderReplaces); 
        sdf_memfree(Sdf_mc_callHandlerMemId,(Sdf_ty_pvoid*)&pSipHeaderReplaces, \
                pErr);
    }
    return (icf_uint8_t)dRetVal;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_validate_mode_n_addr_type
 *
 * DESCRIPTION:     
 *
 ******************************************************************************/

icf_return_t   icf_ssa_validate_mode_n_addr_type(
        icf_ssa_pdb_st              *p_ssa_pdb)
{
    icf_return_t    ret_val = ICF_SUCCESS;
    /* 
     * If the transport mode stored in the ssa ctxt is TLS and the 
     * call is being initiated to a non-SIP URI, we fail, the call.
     */

    if ((ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport) &&
        (ICF_ADDRESS_PLAN_SIPS_URI != 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_type))
    {
        ret_val = ICF_FAILURE;
    }
    else if (((ICF_ADDRESS_PLAN_SIPS_URI == 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_type) &&
        (ICF_ADDRESS_PLAN_SIPS_URI != 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_type)) ||
        ((ICF_ADDRESS_PLAN_SIPS_URI == 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_type) &&
         (ICF_ADDRESS_PLAN_SIPS_URI != 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_type)))
    {
        ret_val = ICF_FAILURE;
    }
    else if ((ICF_NULL != (ICF_CFG_CC_CALL_THRU_SIP_PROXY &
             p_ssa_pdb->p_glb_cfg_data->default_settings)) &&
            (ICF_TRANSPORT_TYPE_INVALID != p_ssa_pdb->p_ssa_ctxt->transport) && 
          ((ICF_ADDRESS_PLAN_SIPS_URI == 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_type) &&
            (ICF_TRANSPORT_TYPE_TLS != p_ssa_pdb->p_line_data->transport_mode)))
    {
        ret_val = ICF_FAILURE;
    }
    else if ((ICF_NULL == (ICF_CFG_CC_CALL_THRU_SIP_PROXY &
             p_ssa_pdb->p_glb_cfg_data->default_settings)) &&
          ((ICF_ADDRESS_PLAN_SIPS_URI == 
        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr.addr_type) &&
            (ICF_TRANSPORT_TYPE_TLS != p_ssa_pdb->p_glb_cfg_data->self_mode)))
    {
        ret_val = ICF_FAILURE;
    }
    return ret_val;
}


/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_set_pending_in_ctxt
 * DESCRIPTION:  
 *         This function is written to be a generic function which
 * can be called from multiple places in SSA. It sets the bitmask to indicate
 *  what kind of method is pending on successful TCP COnnect completion
 *  so that approriate action could be taken when asynch response for TCP 
 *  connect is received
***************************************************************************/
icf_return_t    icf_ssa_set_pending_in_ctxt(icf_ssa_pdb_st    *p_ssa_pdb,
                Sdf_ty_s8bit    *p_method,
                icf_ssa_ctxt_st        *p_ssa_ctxt)
{
    icf_return_t    ret_val = ICF_SUCCESS;
    p_ssa_pdb=p_ssa_pdb;
    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"INVITE"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_INVITE_PENDING;
        }
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *) "REGISTER"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_REG_PENDING;
        }
#ifdef SIP_IMPP
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"SUBSCRIBE"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_SUBS_PENDING;
        }
#endif
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"PUBLISH"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_PUBLISH_PENDING;
        }
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"MESSAGE"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_MESSAGE_PENDING;
        }
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"REFER"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_REFER_PENDING;
        }
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *) "OPTIONS"))
        {
            p_ssa_ctxt->bitmask|=ICF_SSA_OPTION_PENDING;
        }
        else
        {
            ret_val = ICF_FAILURE;
        }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_attempt_out_of_uatk_connect
 * DESCRIPTION:  
 *         This function is written to be a generic function which
 * can be called from multiple places in SSA. Two kinds of usage scenarios
 *     1. DNS_LOOKUP_DISABLED: In this case, the message formation routine
 * invokes ssa_send_to_peer which checks ( just before invoking 
 * icf_ssa_initiate_dispatch_sequence) if a TCP/TLS connect is required. If
 * so, this function is invoked.
 *    2. DNS_LOOKUP_ENABLED: In this case, ssa_send_to_peer invokes UATK
 * API HandleLookup which launches asynch DNS query. On reception of response to 
 * that, SSA checks in the SSA CTXT if a bitmask is set indicating OUT_OF_UATK_
 * CONNECT_REQ ( this was set before invoking ssa_send_to_peer).If so, this is
 * done else initiate dispatch is invoked.

 * Returns: SUCCESS/FAILURE and flag that indicates whether msg can be sent
 *     or not ( i.e to invoke dispatch sequences or not..
 *    SUCCESS + TRUE = invoke dispatch routine
 *    SUCCESS + FALSE = do not invoke dispatch routine, (asynch conn. pending)
 *    FAILURE + - = do not invoke dispatch routine, return failure
 *
 * Things which should be present in  contexts:
 * 1. peer address and port number: if DNS off, then message forming routine will
 * do this, else the DNS resp handler callback will get it from dest info in 
 * transaction data - to be filled in SSA PDB
 * 2. pointer to transaction or to message formed
 * 3, TRANSPOT_MODE bitmask in ssa context
 * 5. NON ALOCATION of ssa conn DB node
 * 6. p_ssa_ctxt->transport should be set correctly in the calling routine

 * Things done by this routine
 * 1. allocates a conn db node and populates it
 * 2. attempts TCP connect,
 *         if a synch failure, resp pending. should store all the info and return with 
 *         indication to not send the message
 *         if synch failure, checks if reversion can be done ( based on transport mode
 *         in line data and optionally also on INITIAL_REQ bitmask) if so, returns
 *         indication to send the message
 *         if synch success, stores data and returns indication to send the message
 ***************************************************************************/
icf_return_t icf_ssa_attempt_out_of_uatk_connect(
        icf_ssa_pdb_st            *p_ssa_pdb,
        Sdf_st_callObject        *p_call_obj,
        Sdf_st_transaction        *p_txn,
        Sdf_st_overlapTransInfo        *p_overlap_txn,
    icf_boolean_t            *p_ready_to_send)
{
    icf_return_t         ret_val = ICF_SUCCESS, sm_ret_val = ICF_FAILURE;
    icf_ssa_ctxt_st        *p_ssa_ctxt = (icf_ssa_ctxt_st*)
        (p_call_obj->pAppData->pData);
#ifdef ICF_DNS_LOOKUP_ENABLED
    icf_boolean_t            to_loop = ICF_TRUE;
    Sdf_st_transportInfo    *pDestInfo      = Sdf_co_null; 
    Sdf_st_error             Err;
#endif

    SipMessage        *p_sip_msg = SIP_NULL;
    Sdf_st_error        sdf_error;
    Sdf_ty_s8bit        *p_method = Sdf_co_null;
    Sdf_st_socket        *p_socket = Sdf_co_null;
    en_SipMessageType    dMsgType; 
    icf_ssa_tcpm_conn_data_st  **p_p_temp_conn = ICF_NULL;
    icf_ssa_tcpm_conn_data_st  *p_conn = ICF_NULL;
    

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt; /*Just in case*/
    *p_ready_to_send = ICF_TRUE;

    /*Get the message pointer*/
    if ( p_txn && ( Sdf_co_null == p_overlap_txn)) 
    {
        p_sip_msg = p_txn->pSipMsg;
        p_socket = &(p_txn->dSocket);
        p_ssa_ctxt->p_pending_txn = (icf_void_t*)p_txn;
    }
    else if ( p_overlap_txn && ( Sdf_co_null == p_txn))
    {
        p_sip_msg = p_overlap_txn->pSipMsg;
        p_socket = &(p_overlap_txn->dSocket);
        p_ssa_ctxt->p_pending_txn = (icf_void_t*)p_overlap_txn;
    }
    else
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:NullTxnPointer,returning Failure"));
        ICF_SSA_RESET_COMMON_BITMASK(p_ssa_ctxt->bitmask, 
                ICF_SSA_EXPLICIT_CONNECT_REQ)
        return ICF_FAILURE;
    }

    dMsgType = icf_ssa_get_msg_type(p_ssa_pdb, p_call_obj);

#ifdef ICF_DNS_LOOKUP_ENABLED
    /* code added here to support the DNS retries */
   /* In case of TCP the destination IP address is was not picked from the p_dest_info of the stack
    * SO  Will pick the  value from the stack here and fill it from p_dest_info*/
    if (sdf_ivk_uaGetDestInfoFromTransaction(p_txn,\
                p_overlap_txn,&pDestInfo, &Err) == Sdf_co_success)

    {
        if(ICF_NULL != pDestInfo->pIp)
        {
            icf_port_strcpy((icf_uint8_t *)p_ssa_pdb->dest_ip, (icf_uint8_t *)pDestInfo->pIp);
        }

        if(pDestInfo->dPort != 0) 
        {
            p_ssa_pdb->dest_port = (icf_uint16_t)pDestInfo->dPort;
        }
        
        if(ICF_NULL != p_txn)
        {
            (void)sdf_ivk_uaFreeTransportInfo(p_txn->pDestInfo);
        }
        else if(ICF_NULL != p_overlap_txn )
        {
            (void)sdf_ivk_uaFreeTransportInfo(p_overlap_txn->pDestInfo);
        }


    }
#else
    {
        /*Since node was not allocated earlier, we need to 
          populate the peer address into it. This is set in PDB by the callinig  fn.*/
        icf_return_t    dummy_retval = ICF_SUCCESS;
        icf_uint8_t    *p_ip_addr = ICF_NULL;
        /*get the destination IP address and port from
         * proxy configuration*/
        if ( ICF_FAILURE == icf_port_get_host_ip(
                    (icf_int8_t *)p_ssa_pdb->dest_ip,
                    (icf_int8_t **)&p_ip_addr))
        {
            ICF_PRINT(("[SSA]:FailureInProxyAddrResolution"));
            ret_val = ICF_FAILURE;
        }
        else if(ICF_NULL != p_ip_addr)
        {
            icf_port_strcpy(p_ssa_pdb->dest_ip, p_ip_addr);

            ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_ip_addr,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    dummy_retval)
        }
    }

#endif

    if (dMsgType == SipMessageRequest)
    {
        p_p_temp_conn = &(p_ssa_ctxt->p_conn_table_req_entry);
        p_ssa_pdb->conn_type = ICF_CONN_TYPE_REQUEST;
    } 
    else
    {
        p_p_temp_conn = &(p_ssa_ctxt->p_conn_table_resp_entry);
        p_ssa_pdb->conn_type = ICF_CONN_TYPE_RESPONSE;
    } 

    if (p_ssa_pdb->p_conn_table_entry !=  ICF_NULL)
    {
        ICF_PRINT(((icf_uint8_t *)"PDB is containing the connection information. So reusint it\n"));
        *p_p_temp_conn = p_ssa_pdb->p_conn_table_entry;
        return ICF_SUCCESS;
    }
    /*then allocate a conn db node is not allocated already*/
#if 0
    if ( ICF_NULL == *p_p_temp_conn)
    {
#endif
#ifdef ICF_SECURE_SUPPORT
        if (p_ssa_ctxt->transport == ICF_TRANSPORT_TYPE_TLS)
        {
            p_ssa_pdb->protocol = ICF_TRANSPORT_TLS;
            p_ssa_pdb->conn_type = ICF_CONN_TYPE_BOTH;
        }
        else
#endif
        {
            p_ssa_pdb->protocol = ICF_TRANSPORT_TCP;
        }
        if(0 != ICF_MAX_PURGE_TIMER_DURATION)
        { 
            if (ICF_NULL != (p_conn = icf_ssa_get_conn_db_by_ip(p_ssa_pdb,
                       p_ssa_pdb->p_ssa_glb_data->p_ssa_tcpm_conn_db )))
            {
                ICF_PRINT(((icf_uint8_t *)"Connection already exists. Reusing it\n")); 
                if (dMsgType == SipMessageRequest)
                {
                    ICF_SSA_INC_CONN_REF_COUNT(p_conn);
                    p_ssa_ctxt->p_conn_table_req_entry = p_conn;
#ifdef ICF_SECURE_SUPPORT
                    if (p_ssa_ctxt->transport == ICF_TRANSPORT_TYPE_TLS)
                        p_ssa_ctxt->p_conn_table_resp_entry = p_conn;
#endif
                }
                else
                {
                    p_ssa_ctxt->p_conn_table_resp_entry = p_conn;
#ifdef ICF_SECURE_SUPPORT
                    if (p_ssa_ctxt->transport == ICF_TRANSPORT_TYPE_TLS)
                        p_ssa_ctxt->p_conn_table_req_entry = p_conn;
#endif
                }
                ICF_PRINT(((icf_uint8_t *)"Total %d calls are on this connection\n", p_conn->ref_count));
                *p_ready_to_send = ICF_TRUE;
                ICF_SSA_RESET_COMMON_BITMASK(p_ssa_ctxt->bitmask, 
                        ICF_SSA_EXPLICIT_CONNECT_REQ)
                    return ICF_SUCCESS;
            }
        }
        p_conn = icf_ssa_add_conn_entry(p_ssa_pdb->p_ssa_glb_data->p_ssa_tcpm_conn_db);

        if (ICF_NULL== p_conn)
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInConnDbNode Allocation,returning Failure"));
            ret_val =  ICF_FAILURE;
        }
    if ( ICF_FAILURE == ret_val)
    {
        ICF_SSA_RESET_COMMON_BITMASK(p_ssa_ctxt->bitmask, 
                ICF_SSA_EXPLICIT_CONNECT_REQ)
        *p_ready_to_send = ICF_FALSE;
        return ICF_FAILURE;
    }

    /*Get the method*/
    if ( Sdf_co_fail == sdf_ivk_uaGetMethodFromSipMessage(
                p_sip_msg,&p_method,&sdf_error))
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInGettingMethodFromSipMessage"));
        ret_val = ICF_FAILURE;
    }
    else
    {/*Invoking TCP SM*/

#ifdef ICF_DNS_LOOKUP_ENABLED
        do
        {
#endif
            /* the following action on conn db node are 
             being done here as we may loop if 
            sm returns failure and there are more DNS records
            (assuming DNS_LOOKUP enabled). then we need to 
            fill up the conn db node etc. again as SM failure
            leg would have reset it all*/
           
            /* In case of TCP the destination IP address is not picked from the p_dest_info of the stack
             * which was filled by dns buffer so we are again filling the same here */
            if (dMsgType == SipMessageRequest)
            {
                ICF_SSA_INC_CONN_REF_COUNT(p_conn);
                p_ssa_ctxt->p_conn_table_req_entry = p_conn;
#ifdef ICF_SECURE_SUPPORT
                if (p_ssa_ctxt->transport == ICF_TRANSPORT_TYPE_TLS)
                    p_ssa_ctxt->p_conn_table_resp_entry = p_conn;
#endif
            }
            else
            {
                ICF_SSA_INC_CONN_REF_COUNT(p_conn);
                p_ssa_ctxt->p_conn_table_resp_entry = p_conn;
#ifdef ICF_SECURE_SUPPORT
                if (p_ssa_ctxt->transport == ICF_TRANSPORT_TYPE_TLS)
                    p_ssa_ctxt->p_conn_table_req_entry = p_conn;
#endif
            }
            p_ssa_pdb->p_conn_table_entry = p_conn;
            icf_port_strcpy(p_ssa_pdb->p_conn_table_entry->peer_ip,(icf_uint8_t *)p_ssa_pdb->dest_ip);
            p_ssa_pdb->p_conn_table_entry->peer_port_num = p_ssa_pdb->dest_port;
            /*p_ssa_pdb->p_conn_table_entry->p_ssa_ctxt =
             * p_ssa_pdb->p_ssa_ctxt;*/
            p_ssa_pdb->p_conn_table_entry->conn_fd = ICF_INVALID_SOCKFD;
            p_ssa_pdb->p_conn_table_entry->tcpm_sm_state = ICF_SSA_TCPM_IDLE;
            p_ssa_pdb->p_conn_table_entry->ref_count = 1;
            p_ssa_pdb->p_conn_table_entry->timer_count = 0;
            p_ssa_pdb->p_conn_table_entry->prot_conn_bitmask = (icf_uint8_t)(p_ssa_pdb->conn_type |
                p_ssa_pdb->protocol);
            ICF_SSA_PRINT_CONN_DB(p_ssa_pdb->p_conn_table_entry)
            if (0 != ICF_PURGE_TIMER_DURATION)
                            p_ssa_pdb->p_conn_table_entry->is_persistent = ICF_TRUE;

            ICF_SSA_IVK_TCPSM(p_ssa_pdb, 
                    ICF_SSA_TCPM_OPEN_CONN_REQ, sm_ret_val)

            if ( ICF_SUCCESS == sm_ret_val)
            {
                if (ICF_SSA_TCPM_AWT_CON_RESP ==
                        p_ssa_pdb->p_conn_table_entry->tcpm_sm_state)
                {
                    if ( ICF_FAILURE == icf_ssa_set_pending_in_ctxt(
                                p_ssa_pdb, p_method,p_ssa_ctxt))
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:UnKnownMethodType!!"));
                        ret_val = ICF_FAILURE;
                    }
                    /* this is used to judge for revert in case
                       of failure in asynch connect*/
                    p_ssa_ctxt->bitmask |= ICF_SSA_TCP_TRANSPORT;
                    *p_ready_to_send = ICF_FALSE;
                }
                if ( ICF_SUCCESS == ret_val)
                {
                    p_socket->dSockfd = 
                        p_ssa_pdb->p_conn_table_entry->conn_fd;
#ifdef ICF_SECURE_SUPPORT
                    if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport)
                    {
                        p_socket->dProtocol = Sdf_en_protoTls;
                    }
                    else
                    {
#endif
                        p_socket->dProtocol = Sdf_en_protoTcp;
#ifdef ICF_SECURE_SUPPORT
                    }
#endif
                }
#ifdef ICF_DNS_LOOKUP_ENABLED
                to_loop = ICF_FALSE;
                /*No loop required now as SM has returned success*/
#endif
            }/*StateMachine success leg end*/
#ifdef ICF_DNS_LOOKUP_ENABLED
            else
            {
                ICF_SSA_SET_TXN_DNS_STATE(p_txn, p_overlap_txn, Sdf_en_dnsIpUsed)

                /*Connect has failed to the current IP, so we attempt to move to the next IP*/

                if ( ICF_FAILURE ==  icf_ssa_get_next_dest_from_list(
                            p_ssa_pdb, p_call_obj, p_txn, p_overlap_txn))
                {
                    if (ICF_SUCCESS == icf_ssa_resend_on_sec_address(p_ssa_ctxt->p_call_obj,
                        p_overlap_txn, p_ssa_ctxt, &sdf_error))
                    {
                        *p_ready_to_send = ICF_FALSE;
                        return ICF_SUCCESS;
                    }
                    to_loop = ICF_FALSE;
                    /*sm_ret_val is ICF_FAILURE;*/
                }
            }
        }while(ICF_TRUE == to_loop);/*End of DO*/
#endif 
        if ( ICF_FAILURE == sm_ret_val)
        {
            /*Failure from SM, now we check if reversion is possible/
              allowed. C riteria: TRANSPORT mode should be BOTH*/
            if ((ICF_TRUE == p_ssa_ctxt->revert_mode) ||
                (ICF_TRANSPORT_MODE_BOTH == p_ssa_ctxt->transport))
            {
                if ( ICF_FAILURE == icf_ssa_revert_to_udp(
                            p_ssa_pdb, p_call_obj, &p_overlap_txn,
                            (icf_uint8_t *)p_method, &sdf_error))
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInRevertingToUdp\n"));
                    *p_ready_to_send = ICF_FALSE;
                    ret_val = ICF_FAILURE;
                }
                /* this is to tell that for subsequent requests
                 * we will not change the transport mode 
                 */
                else
                {
#ifdef ICF_DNS_LOOKUP_ENABLED
                    /*Code to be added to launch a new DNS query
                      for UDP, prior to that remove the DNS records from 
                      transaction structure*/

                    ICF_SSA_SET_TXN_DNS_STATE(p_txn, p_overlap_txn, Sdf_en_Idle)

                        if ( Sdf_co_fail == sdf_ivk_uaHandleLookup(p_call_obj,
                                    p_overlap_txn, p_sip_msg,
                                    p_ssa_pdb->p_event_ctxt,&sdf_error))
                        {
                            if ( Sdf_en_dnsInvState != sdf_error.errCode)
                            {
                                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureIn HandleLookUp API"));
                                ret_val = ICF_FAILURE;
                            }
                            else
                            {
                                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Sdf_en_dnsInvState, Continuing"));
                            }
                        }
                        else if (Sdf_co_false != sdf_ivk_uaIsDnsQueryState(p_call_obj,
                                    p_overlap_txn, &sdf_error))
                        {
                            *p_ready_to_send = ICF_FALSE;/*ret_val is Success*/
                        }
#endif
                    ICF_SSA_RESET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask, \
                            ICF_SSA_TCP_TRANSPORT);
                    ICF_SSA_RESET_COMMON_BITMASK(p_ssa_pdb->p_ssa_ctxt->bitmask, \
                            ICF_SSA_TLS_TRANSPORT);
                    p_ssa_pdb->p_ssa_ctxt->trans_mode_reverted = ICF_TRUE;
                }
            }
            else
            {
                ret_val = ICF_FAILURE;
            }
        }/*StateMachine failure leg end*/
    }

    if ( ICF_FAILURE == ret_val)
    {
        p_ssa_ctxt->p_pending_txn = ICF_NULL;
        *p_ready_to_send = ICF_FALSE;
    }

    /*resetting the bitmask. this bitmask was set only to indicate to the calling
    function that the invocation is for a dialog-estbalishing request processing.
    so anb out of dialog connect is required 
    Further, when we move to asynchronous, this should be reset whenever we 
    receive a final response for the tcp connect - in TCPSM funcs*/
        ICF_SSA_RESET_COMMON_BITMASK(p_ssa_ctxt->bitmask, 
                ICF_SSA_EXPLICIT_CONNECT_REQ)

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}



/*******************************************************************************
 * FUNCTION:        icf_ssa_modify_callobj_profile_after_call_accept
 * DESCRIPTION:     This function updates the call object profile for the supported
 *                  and require headers.
 *                  Also this function will add unsupported header in the call
 *                  object profile.
 ******************************************************************************/

icf_return_t icf_ssa_modify_callobj_profile_after_call_accept
(
 INOUT   icf_ssa_pdb_st       *p_ssa_pdb,
 INOUT   Sdf_st_initData      *pInitData,
 OUT     Sdf_st_error         *p_error)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    Sdf_st_listIterator dListIterator;
    Sdf_st_error        Err;
    /*To remove warning*/
    p_error=p_error;
     
    p_ssa_pdb=p_ssa_pdb;
    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        
        sdf_listInitIterator(&(pInitData->slExtraHeadersList),\
        &dListIterator, &Err);
    
    while (dListIterator.pCurrentElement != Sdf_co_null)
    {
        Sdf_st_configExtraHeaders *pTemp = Sdf_co_null;
        en_HeaderType pType;
        Sdf_ty_s8bit dTempType[Sdf_co_characterBufferSize]="";
        
        pTemp = (Sdf_st_configExtraHeaders*)\
            (dListIterator.pCurrentElement->pData);
    
        Sdf_mc_strcpy(dTempType,pTemp->pParam->pName);
        if (icf_port_strlen((icf_uint8_t *)dTempType) <
                             Sdf_co_characterBufferSize - 2)
        {
            /* Max length - 2 
             * (1 for NULL) +
             * (1 for ":" to be appended) */
            icf_port_strcat((icf_uint8_t*)dTempType,(icf_uint8_t*)":");
            dTempType[icf_port_strlen((icf_uint8_t*)dTempType)] = '\0';
        }
        /*
        * Invoke stack API to convert the Header name into the stacks
        * en_HeaderType enumeration
        */
        if(sip_getTypeFromString(dTempType,&pType, \
            (SipError*)&(Err.stkErrCode)) == SipFail)
        {
            Err.errCode = Sdf_en_headerManipulationError;
            ret_val = ICF_FAILURE;
        }
        if(pType == SipHdrTypeSupported || pType == SipHdrTypeRequire)
        {
            Sdf_ty_u32bit size,index;
            
            sip_listSizeOf(&(pTemp->pParam->slValue), &size, \
                (SipError*)&(Err.stkErrCode));
            
            for (index = 0; index < size; index++)
            {
                Sdf_ty_s8bit *pTempVal;
                
                if (sip_listGetAt(&(pTemp->pParam->slValue),  \
                    (Sdf_ty_u32bit) index,(Sdf_ty_pvoid *)&pTempVal,  \
                    (SipError*)&(Err.stkErrCode)) == SipFail)
                {
                    Err.errCode=Sdf_en_extraHeaderAccessError;
                    ret_val = ICF_FAILURE;
                }
                
                if(Sdf_mc_strcmp(pTempVal,"100rel")==0)
                {
                    /* Remove this parameter from the header list
                     */
                    sip_listDeleteAt (&(pTemp->pParam->slValue),\
                                        index, (SipError*)&(Err.stkErrCode));
                    ret_val = ICF_SUCCESS;
                    break;
                }
            }/* End of for loop of supported/require header values.*/
    }

    sdf_listNext(&dListIterator, &Err);
    }/* End of while */
        
    /* Add Unsupported 100rel header in the call object profile
    */
    if(ICF_FAILURE != ret_val)
    {
        if(Sdf_co_fail == icf_ssa_addDefaultHeader(
            pInitData,"UnSupported","100rel",Sdf_co_true,&Err))
        {
            ret_val = ICF_FAILURE;
        }
    }
        
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}



icf_return_t icf_ssa_clear_header_from_profile(Sdf_st_initData *pInitData,
                                              icf_uint8_t *pName,
                                              icf_error_t *p_ecode)
{
    icf_uint8_t *current_name = Sdf_co_null;
    Sdf_st_configExtraHeaders *pConfHdr = Sdf_co_null;
    icf_uint8_t curr_pos = 0;
    Sdf_st_error err;
    Sdf_st_error *pErr = &err;
    /* To remove warnings */
    p_ecode=p_ecode;

    for(curr_pos = 0;curr_pos < pInitData->slExtraHeadersList.size;curr_pos ++)
    {
        if(ICF_FAILURE == sdf_listGetAt (&(pInitData->slExtraHeadersList),
            curr_pos, (Sdf_ty_pvoid *)&pConfHdr,pErr))
        {
            return ICF_FAILURE;
        }

        if(pConfHdr->pParam == Sdf_co_null)
        {    
            pErr->errCode=Sdf_en_invalidParamError;
            return ICF_FAILURE;
        }

        if(sip_getNameFromSipParam(pConfHdr->pParam,((Sdf_ty_s8bit ** )&current_name),\
                (SipError*)&(pErr->stkErrCode)) == SipFail)
        {
            pErr->errCode=Sdf_en_headerManipulationError;
            return ICF_FAILURE;
        }
        if(Sdf_mc_strcasecmp((Sdf_ty_s8bit*)current_name,(Sdf_ty_s8bit*)pName) ==0)
        {
            if (Sdf_co_fail == sdf_listDeleteAt (&(pInitData->slExtraHeadersList),
                curr_pos, pErr))
            {
                return ICF_FAILURE;
            }
            curr_pos --;
        }
    }

    return ICF_SUCCESS;
} 

/*****************************************************************************
 ** FUNCTION:           icf_ssa_refresh_supported_content_and_events
 **
 ** DESCRIPTION:        This function refreshes the supported and accept headers 
 **                     in the callobject profile from the header list passed as
 **                     a parameter. The accept and supported headers are removed
 **                     from the header list passed and put in the callobjects 
 **                     profile
 **
 *****************************************************************************/
icf_return_t icf_ssa_refresh_supported_content_and_events(icf_ssa_pdb_st *p_ssa_pdb,
                                                          icf_header_list_st *p_hdr_list,
                                                          icf_error_t *p_ecode)
{
    icf_string_list_st               *p_supported_events = ICF_NULL;
    icf_string_list_st               *p_supported_content = ICF_NULL;
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_return_t                     dummy_ret_val = ICF_SUCCESS;
    Sdf_st_callObject               *p_call_obj = ((icf_ssa_ctxt_st *)(p_ssa_pdb->p_glb_pdb->p_call_ctx->p_sip_ctx))->p_call_obj;

    if (ICF_FAILURE == icf_cmn_get_strlist_from_hdrlist(
        p_ssa_pdb->p_glb_pdb,
        p_hdr_list,
        (icf_uint8_t *)"Supported",
        &p_supported_events))
    {
        ret_val = ICF_FAILURE;
    }
    else if (ICF_FAILURE == icf_cmn_get_strlist_from_hdrlist(
        p_ssa_pdb->p_glb_pdb,
        p_hdr_list,
        (icf_uint8_t *)"Accept",
        &p_supported_content))
    {
       /*Klocwork warning removal*/
       ICF_MEMFREE(
           p_ssa_pdb->p_glb_pdb, 
           p_supported_events,
           ICF_MEM_COMMON,
           p_ecode, 
           ret_val)
       ret_val = ICF_FAILURE;
    }
    
    else
    {
        if(ICF_NULL != p_supported_events)
        {
            /* Clear the previous accept list */
            if (ICF_NULL != p_supported_events->count)
            {
                ret_val = icf_ssa_clear_header_from_profile(
                    p_call_obj->pInitData,
                    (icf_uint8_t *)"Supported", 
                    p_ecode);
                
                if(ICF_SUCCESS == ret_val)
                {
                    ret_val = icf_ssa_add_string_list_in_default_header(
                        p_call_obj->pInitData,
                        (icf_uint8_t *)"Supported", 
                        p_supported_events,
                        Sdf_co_true,
                        p_ecode);
                    
                }
                /* free the memory allocated to p_supported_events */
                icf_cmn_free_string_list(
                    p_ssa_pdb->p_glb_pdb,
                    p_supported_events,
                    p_ecode);
                
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb, 
                    p_supported_events,
                    ICF_MEM_COMMON,
                    p_ecode, 
                    dummy_ret_val)
                    
            }
        }
        if((ICF_SUCCESS == ret_val ) &&
            (ICF_NULL != p_supported_content))
        {
            /* Clear the previous accept list */
            if (ICF_NULL != p_supported_content->count)
            {
                /* Clear the previous supported list */
                ret_val = icf_ssa_clear_header_from_profile(
                    p_call_obj->pInitData,
                    (icf_uint8_t *)"Accept", 
                    p_ecode);
                if(ICF_SUCCESS == ret_val)
                {
                    ret_val = icf_ssa_add_string_list_in_default_header(
                        p_call_obj->pInitData,
                        (icf_uint8_t *)"Accept", 
                        p_supported_content,
                        Sdf_co_true,
                        p_ecode);
                    
                }
                /* free the memory allocated to p_supported_events */
                icf_cmn_free_string_list(
                    p_ssa_pdb->p_glb_pdb,
                    p_supported_content,
                    p_ecode);
                
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb, 
                    p_supported_content,
                    ICF_MEM_COMMON,
                    p_ecode, 
                    dummy_ret_val)
            }
        }
        /*Klocwork Warning removal*/
        else
        {
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb, 
                    p_supported_content,
                    ICF_MEM_COMMON,
                    p_ecode, 
                    dummy_ret_val)
         }
             
    }
    /*Klocwork Warning removal*/
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_supported_content)
    ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,p_supported_events)

    return ret_val;
}

/***************************************************************************
 *
 * FUNCTION:     icf_ssa_parse_require_header
 * DESCRIPTION:  1.Invoke the SDF API which returns the list
 *                 of entries present in the Require header.
 *               2.Iterate through the list and check for the presence
 *                 of 100 rel.If present and config doesn't support 
 *           PRACK ,retun FAILURE
 *
 ***************************************************************************/

icf_return_t icf_ssa_parse_require_header(
        INOUT icf_ssa_pdb_st   *p_ssa_pdb,
        INOUT    SipMessage          *p_sip_msg,
    INOUT  Sdf_st_error          *p_err)
{
    icf_return_t         ret_val = ICF_SUCCESS;
    Sdf_ty_slist            slRequiredList;
    Sdf_ty_u32bit           size = 0,iterator = 0;
    icf_uint8_t          *p_list_element = ICF_NULL;
#ifdef ICF_QOS_SUPPORT
    icf_boolean_t            rel_present = ICF_FALSE;
#endif
    icf_uint8_t   supported_list[ICF_SSA_MAX_SIZE_SUPP_EXTN][ICF_SSA_MAX_SIZE_SHORT_STR]=
                 {"100rel", "replaces", "timer", "precondition"};
    icf_uint8_t          j = 0;
    icf_boolean_t        found = ICF_FALSE;
    Sdf_ty_s8bit         *p_method = Sdf_co_null;
    Sdf_ty_s8bit         *p_temp_method = Sdf_co_null;
    en_SipMessageType   dMsgType = SipMessageAny;
    Sdf_st_transaction 			*pTransaction = Sdf_co_null;
    Sdf_st_overlapTransInfo 	*pOverlapTransaction = Sdf_co_null;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (Sdf_co_fail == sdf_ivk_uaReturnRequiredList (
                p_sip_msg,&slRequiredList,p_err))
    {
        ret_val = ICF_FAILURE;
    }
    /* Fetch the size of the list */
    else if (Sdf_co_fail == sdf_listSizeOf(
                &slRequiredList,&size,p_err))
    {
        ret_val = ICF_FAILURE;
    }
    /*If list contains elements*/
    else if(size !=0)
    {
        /*Fetch all the entries from the Supported header */
        for(iterator = 0; iterator < size; iterator++)
        {
            if(Sdf_co_fail == sdf_listGetAt(&slRequiredList,
                        iterator, (Sdf_ty_pvoid *)&p_list_element,p_err))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                /*Check if value in require header present in local supported list*/
                for (j = 0; j < ICF_SSA_MAX_SIZE_SUPP_EXTN; j++)
                {
                    /* CSR-1-6974854: Parameter comparision in supported header
                     * made case insensitive */
                    if (0 == icf_port_strcmpi(p_list_element, supported_list[j]))
                    {
                        found = ICF_TRUE;
                        break;
                    }
                }
                if (ICF_FALSE == found)
                {
                    icf_string_list_node_st *p_cur_node = ICF_NULL;

                    /* SPR 20097 : Fetch the app conf on the basis of the app ID
                       before accessing the same.
                    */   
                    if(ICF_NULL == p_ssa_pdb->p_app_conf)
                    {
                        icf_app_id_t app_id = ICF_INVALID_APP_ID;
                        if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt)
                        {
                            app_id = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt->app_id;
                        }
                        else
                        {
                            app_id = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->app_id;
                        }

                        ret_val = icf_cfg_fetch_app_conf(
			               		      p_ssa_pdb->p_glb_pdb,
                    				  app_id,
   				                	  &(p_ssa_pdb->p_app_conf),
                					  p_ssa_pdb->p_ecode);

                        if(ICF_FAILURE == ret_val)
                        {
                            /* If app conf fetching fails, break from the loop */
                            break;
                        }
                    }/* End SPR 20097 fix */
                    
                    /*Compare with app_conf support_events list*/
                    for (j = (icf_uint8_t)p_ssa_pdb->p_app_conf->app_profile.supported_events.count,
                         p_cur_node = p_ssa_pdb->p_app_conf->app_profile.supported_events.p_list;
                         j--; 
                         p_cur_node = p_cur_node->p_next)
                    {
                        /* Fix for CSR 1-6896295 */
                        /* String comparision between the received extensions the 
                           locally supported extension should be case insensitive */
                        if (0 == icf_port_strcmpi(p_list_element, p_cur_node->str.str))
                        {
                            found = ICF_TRUE;
                            break;
                        }
                    }
                }
                if (ICF_FALSE == found)
                {
                    p_ssa_pdb->common_bitmask |= ICF_SSA_REQUIRE_VALUE_IS_NOT_SUPPORTED;

                    ret_val = ICF_FAILURE;
                }
            }
            if (ICF_FAILURE == ret_val)
            {
                   /*In case of failure do not iterate further
                    * require list, break*/
                    break;
		    
            }
            /* CSR-1-6974854: Parameter comparision in supported header
             * made case insensitive */
            else if (ICF_NULL == icf_port_strcmpi(
                        p_list_element,(icf_uint8_t *)"100rel"))
            {
#ifdef ICF_QOS_SUPPORT
                rel_present = ICF_TRUE;
#endif 
                /*CSR1-5546505
                 * Set the bit in common bitmask
                 * of the call context indicating support
                 * for reliable provisional responses
                 */
                p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask |=
                        ICF_REL_PROV_RESP_SUPP_BY_PEER;
               /*  REl 8.2 changes start */
               /*  set the bitmask for Require header so that
                *  later on if Prack is not supported then call 
                *  can be cleared 
                */
                p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask_2 |=
                        ICF_REL_PROV_RESP_REQUIRED_BY_PEER;
                /*  Rel 8.2 changes End */
            }
            /* CSR-1-6974854: Parameter comparision in supported header
             * made case insensitive */
            else if (ICF_NULL == icf_port_strcmpi(
                        p_list_element,(icf_uint8_t *)"precondition"))
            {
#ifdef ICF_QOS_SUPPORT
                icf_config_data_st*        p_config_data = ICF_NULL;
                /* Get pointer to config data from DBM */
                ret_val = icf_dbm_get_module_glb_data(
                    p_ssa_pdb->p_glb_pdb,
                    (icf_int_module_id_t)ICF_INT_MODULE_CFG,
                    (icf_void_t *)&p_config_data, p_ssa_pdb->p_ecode);

				ICF_ASSERT(p_ssa_pdb->p_glb_pdb, (ICF_NULL != p_config_data));
                /* Rel8.0 This flag will be used to handle the "precondition"
                   tag in the RE-INVITE/UPDATE case when system supports QOS*/
                p_ssa_pdb->precondition_in_require_hdr = ICF_TRUE;

                if (ICF_SUCCESS == ret_val)
                {
                    if (ICF_TRUE == p_config_data->precondition_required)
                    {
                        /* set the bitmask in call context */
                        p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask_2 |=
                             ICF_PRECONDITION_REQD;
                    }    
                    else
                    {
                        /*Rel8.0 This leg will be used when the QOS is OFF system
                          wide but the incoming INVITE does have
                          "precondition" in the "require" header */
                        p_ssa_pdb->common_bitmask |=
                            ICF_SSA_REQUIRE_VALUE_IS_NOT_SUPPORTED;
                        ret_val = ICF_FAILURE;
                        break;
                    }
                }
#else            
                { 
                    p_ssa_pdb->common_bitmask |=
                            ICF_SSA_REQUIRE_VALUE_IS_NOT_SUPPORTED;
                    ret_val = ICF_FAILURE;
                    break;
                }    
#endif
            }
        }
    }

    /* SPR 18580: When the incoming message is a request message and it has 
     * REQUIRE header and this value is not supported by IPTK and also not
     * specified by application then form the 420 response and insert the
     * unsupported header populating it with the value which is not supported.
     */ 
    if(ICF_SSA_REQUIRE_VALUE_IS_NOT_SUPPORTED & p_ssa_pdb->common_bitmask)
    {
        if(Sdf_co_fail == sdf_ivk_uaGetMethodFromSipMessage(
                         p_sip_msg, &p_method, p_err))
        {
           ret_val = ICF_FAILURE;
        }   
        else if(Sdf_co_fail == sip_getMessageType(p_sip_msg, &dMsgType, \
                            (SipError*)p_err))
        {
           ret_val = ICF_FAILURE;
        }
        else if(SipMessageRequest == dMsgType)
        {
           if (Sdf_co_fail == sdf_ivk_uaGetTransactionForSipMsg(
                        p_ssa_pdb->p_ssa_ctxt->p_call_obj,p_sip_msg,
                        &pTransaction, &pOverlapTransaction, p_err))
           {
              ret_val = ICF_FAILURE;
           }
           else
           {
               /*SPR19491 Store the p_method variable  p_temp_method so that
                after sdf_ivk_uaFormResponse when p_method is not available 
                we do have the method in p_temp_method.*/
               Sdf_mc_strdup(p_temp_method, p_method);
               if (Sdf_co_fail == sdf_ivk_uaFormResponse(420, p_method, 
				        p_ssa_pdb->p_ssa_ctxt->p_call_obj,
				        pOverlapTransaction,
				        Sdf_co_false,
				        p_err))
                {
                       ret_val = ICF_FAILURE;
                }
				else if(p_list_element && (Sdf_co_null != p_temp_method) &&
                        ((0 == icf_port_strcmp((icf_uint8_t*)p_temp_method,(icf_uint8_t*)"INVITE")) ||
					(0 == icf_port_strcmp((icf_uint8_t*)p_temp_method,(icf_uint8_t*)"BYE"))))
			    {
                    if (ICF_FAILURE == icf_ssa_form_and_insert_unknown_hdr(p_ssa_pdb,
                           (icf_uint8_t *)"Unsupported",
                           (icf_uint8_t *)p_list_element,
                           pTransaction->pSipMsg))
                    {
                        ret_val = ICF_FAILURE;
                    }
			   }
			   else if(p_list_element && (Sdf_co_null != p_temp_method)
                       && (0 == icf_port_strcmp((icf_uint8_t*)p_temp_method,(icf_uint8_t*)"UPDATE")))
			   {
                 if (ICF_FAILURE == icf_ssa_form_and_insert_unknown_hdr(p_ssa_pdb,
                           (icf_uint8_t *)"Unsupported",
                           (icf_uint8_t *)p_list_element,
                           pOverlapTransaction->pSipMsg))
                  {
                      ret_val = ICF_FAILURE;
                  }
			   }
          
	   		   sdf_ivk_uaFreeTransaction(pTransaction);
               sdf_ivk_uaFreeOverlapTransInfo( \
                              pOverlapTransaction);
           }
        }
    }

#ifdef ICF_QOS_SUPPORT
ICF_CHECK_QOS_SUPPORT_START(p_ssa_pdb->p_glb_pdb, ICF_TRUE)
    if((ICF_FALSE == rel_present)&&
        (ICF_SUCCESS == ret_val))
    {
        /*Rel8.0 :rejection of INVITE with "precondition" 
          in the "require" header but 100rel missing in
          require header*/
        p_ssa_pdb->p_ssa_ctxt->bitmask_1 |=
            ICF_SSA_PRECONDITION_PROV_WITHOUT_100REL;
    }
ICF_CHECK_QOS_SUPPORT_END
#endif 
    if(Sdf_co_null != p_temp_method)
    {    
        sdf_memfree(0, (Sdf_ty_pvoid *)&p_temp_method, p_err);
    }  
    sdf_listDeleteAll(&slRequiredList,p_err);
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_transport_mode 
 ** DESCRIPTION:  This function check the paremeter and returns the mode 
 **                 basis on some condition
 **
 ***************************************************************************/
icf_uint8_t icf_ssa_get_transport_mode(Sdf_st_callObject *pCallObj,
                    icf_boolean_t tls_present,
                    icf_boolean_t tcp_present,
                    icf_boolean_t udp_present)
{
    icf_ssa_ctxt_st         *p_ssa_ctxt = 
                            (icf_ssa_ctxt_st *)(pCallObj->pAppData->pData);
    icf_config_data_st      *p_config_data = ICF_NULL;
    icf_line_data_st        *p_line_data = ICF_NULL;
    icf_transport_mode_t    effective_self_mode = 0; 
    icf_error_t             ecode = 0;

    /*Validate transport received from NAPTR with self transport*/
    /*If self address per line then fetch line data and compare transport mode*/
    if(ICF_FAILURE == icf_dbm_get_module_glb_data(
                    p_ssa_ctxt->p_glb_pdb,
                    (icf_int_module_id_t)ICF_INT_MODULE_CFG,
                    (icf_void_t *)&p_config_data, &ecode))
    {
        return ICF_TRANSPORT_MODE_UDP;
    }
    if (ICF_CFG_SELF_ADDR_PER_LINE ==
                         p_config_data->self_addr_per_line)
    {
         if(ICF_SUCCESS == icf_dbm_fetch_line_cntxt_blk(
                p_persistent_glb_pdb, p_ssa_ctxt->line_id,
                &p_line_data, &ecode))    
         {
              effective_self_mode = p_line_data->self_mode;
         }
    }
    else
    {
         /*When self address is system_wide then get mode from config_data*/
         effective_self_mode = p_config_data->self_mode;
    }

    /*If none of known transport is available then return self transport
     *mode*/
    if ((ICF_FALSE == tls_present) &&
        (ICF_FALSE == tcp_present) &&
        (ICF_FALSE == udp_present))
    {
            p_ssa_ctxt->transport = effective_self_mode;
    }
    /*If Self mode is TLS then only TLS is acceptable in DNS-NAPTR response
     *otherwise return failure*/
    else if (ICF_TRANSPORT_TYPE_TLS == effective_self_mode)
    {
        if (ICF_TRUE == tls_present)
        {
            p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TLS;
        }
        else
        {
            p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_INVALID;
            
        }
    }
    /*If self mode is BOTH then either TCP or UDP or BOTH
     *are acceptable transport mode*/
    else if (ICF_TRANSPORT_MODE_BOTH == effective_self_mode)
    {
        if(ICF_TRUE == tcp_present && ICF_TRUE == udp_present)
        {
            p_ssa_ctxt->transport = ICF_TRANSPORT_MODE_BOTH;
            p_ssa_ctxt->revert_mode  = ICF_TRUE;
        }
        else if(ICF_TRUE == tcp_present)
        {
            p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
        }
        /*  If only udp_present then return ICF_TRANSPORT_TYPE_UDP  */
        else if(ICF_TRUE == udp_present)
        {
            p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
        }
        else
        {
            p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_INVALID;
        }
    }
    /*If self mode is TCP then only TCP mode is acceptable in
     *DNS NAPTR response*/
    else if (ICF_TRANSPORT_TYPE_TCP == effective_self_mode)
    {
        if(ICF_TRUE == tcp_present)
        {
            p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_TCP;
        }
        else
        {
            p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_INVALID;
        }
    }
    /*If self mode is UDP then only UDP mode is acceptable in
     *DNS NAPTR response*/
    else
    {
        if(ICF_TRUE == udp_present)
        {
            p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_UDP;
        }
        else
        {
            p_ssa_ctxt->transport = ICF_TRANSPORT_TYPE_INVALID;
        }
    }
    
    return p_ssa_ctxt->transport;
    
}

#ifdef ICF_DNS_LOOKUP_ENABLED
Sdf_ty_retVal icf_ssa_cbk_FillDestInfoFromUnknownDnsRec (
        Sdf_st_callObject *pCallObj,
        Sdf_st_overlapTransInfo *pOverlapTransaction,
        Sdf_ty_slist *pslDnsRecords,
        Sdf_st_transportInfo *pDestInfo,
        Sdf_st_error            *pErr)
{
    if (sdf_ivk_uaFillDestInfoFromSrvRec (pCallObj, pOverlapTransaction,
                    pslDnsRecords, pDestInfo, pErr) == Sdf_co_fail)
        {
        return Sdf_co_fail;
    }

/*    if (sdf_ivk_uaFillDestInfoFromIpRec (pslDnsRecords, pDestInfo,pErr) \
            == Sdf_co_fail)
    {
        (Sdf_ty_void)sdf_ivk_uaFreeTransportInfo(pDestInfo);
        return Sdf_co_fail;
    }*/


    return Sdf_co_success;
}    

Sdf_ty_retVal icf_ssa_FreeUnknownDnsList (
        Sdf_st_DnsRecord        *pDnsRecord)
{
#ifdef ICF_DNS_LOOKUP_ENABLED
    pDnsRecord = pDnsRecord;
#endif
    return Sdf_co_success;
}
#endif

#ifdef ICF_SSA_UT_NR_CODE
#ifdef ICF_LOOPBACK_SUPPORT
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_util_map_addresses
 *
 * DESCRIPTION:     This function is used by SSA for mapping local and remote
 *                  address with the address received in message.
 *
 ******************************************************************************/
icf_return_t icf_ssa_util_map_addresses(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT  Sdf_st_callObject       *p_call_obj,
        INOUT  SipHeader      *pFrom,
        INOUT  SipHeader      *pTo,
        OUT   icf_ssa_ctxt_st    *p_mapped_ssa_ctxt,
        OUT   Sdf_st_error            *p_sdf_error,
        OUT   icf_error_t    *p_ecode)
{
        icf_return_t             ret_val = ICF_FAILURE;
        SipMessage              *p_temp_msg = Sdf_co_null;
        en_SipMessageType   dMsgType;
        Sdf_ty_s8bit                *p_method = Sdf_co_null;

        ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        (void)p_ecode;

        if (p_call_obj->pUacTransaction->pSipMsg != Sdf_co_null)
                p_temp_msg = p_call_obj->pUacTransaction->pSipMsg;
        else
                p_temp_msg = p_call_obj->pUasTransaction->pSipMsg;
     
        sip_getMessageType(p_temp_msg, &dMsgType, \
                  (SipError*)    &(p_sdf_error->stkErrCode)) ;

        /* Call dialog is matched as follows:
         * If it is request, then
         *   Call id, From, To should map with call id, To and From.
         *   Note that the order of From and To are changed as requests 
         *   have the To and From reversed. 
         * If the message is a response, then
         *    Call id, From and To should map with the call id, From
         *    and To of the original call object.
         */

        if(Sdf_co_fail == 
                  sdf_ivk_uaGetMethodFromSipMessage(
                  p_temp_msg,
                  &p_method, p_sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
        else if ( (SipMessageRequest == dMsgType) && 
            (ICF_FALSE == p_ssa_pdb->is_otg_msg))
        {
             if ( (ICF_SUCCESS == icf_ssa_util_cmp_address(
                        p_ssa_pdb,
                        p_mapped_ssa_ctxt->
                        p_call_obj->pCommonInfo->pKey->pLocalAddr,
                        pTo,
                        p_ecode)) &&
                  (ICF_SUCCESS == icf_ssa_util_cmp_address(
                        p_ssa_pdb,
                        p_mapped_ssa_ctxt->
                        p_call_obj->pCommonInfo->pKey->pRemoteAddr,
                        pFrom,
                        p_ecode)))
               {
                   ret_val = ICF_SUCCESS;
               }
        }
        else
        {
             if ( (ICF_SUCCESS == icf_ssa_util_cmp_address(
                        p_ssa_pdb,
                        p_mapped_ssa_ctxt->
                        p_call_obj->pCommonInfo->pKey->pRemoteAddr,
                        pTo,
                        p_ecode)) &&
                  (ICF_SUCCESS == icf_ssa_util_cmp_address(
                        p_ssa_pdb,
                        p_mapped_ssa_ctxt->
                        p_call_obj->pCommonInfo->pKey->pLocalAddr,
                        pFrom,
                        p_ecode)))
            {
                   ret_val = ICF_SUCCESS;
            }
        }
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
} /* End of Fn icf_ssa_util_map_addresses */
#endif

/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_util_cmp_address
 *
 * DESCRIPTION:     This function is used by SSA for comparing ny two address
 *                  specs.
 *
 ******************************************************************************/
icf_return_t icf_ssa_util_cmp_address(
        INOUT  icf_ssa_pdb_st *p_ssa_pdb,
        INOUT  SipHeader      *pAddr1,
        INOUT  SipHeader      *pAddr2,
        OUT   icf_error_t    *p_ecode)
{
        icf_return_t           ret_val = ICF_FAILURE,
                               ret_val2 = ICF_FAILURE;
        SipAddrSpec            *p_addr_spec1 = ICF_NULL, 
                               *p_addr_spec2 = ICF_NULL;
        icf_address_st         *p_addr_str1 = ICF_NULL, 
                               *p_addr_str2 = ICF_NULL;

        ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
        (void)p_ecode;
        /*((SipToHeader*)p_to->pHeader)->pAddrSpec;*/
        p_addr_spec1 = (SipAddrSpec *)(((SipCommonHeader *)pAddr1->pHeader)->pAddrSpec);
        p_addr_spec2 = (SipAddrSpec *)(((SipCommonHeader *)pAddr2->pHeader)->pAddrSpec);

        ICF_MEMGET(
                                    p_ssa_pdb->p_glb_pdb,
                                    sizeof(icf_address_st),
                                    ICF_MEM_COMMON,
                                    p_addr_str1,
                                    ICF_RET_ON_FAILURE,
                                    p_ssa_pdb->p_ecode,
                                    ret_val)

        if (ICF_SUCCESS == ret_val)
        {
           ICF_MEMGET(
                                    p_ssa_pdb->p_glb_pdb,
                                    sizeof(icf_address_st),
                                    ICF_MEM_COMMON,
                                    p_addr_str2,
                                    ICF_RET_ON_FAILURE,
                                    p_ssa_pdb->p_ecode,
                                    ret_val)

           if (ICF_SUCCESS == ret_val)
           {
             if (ICF_FAILURE == icf_ssa_populate_address_from_sip_addr_spec(
                   p_ssa_pdb,
                   p_addr_spec1,
                   p_addr_str1))
             {
                ret_val = ICF_FAILURE;
             }
             else if (ICF_FAILURE == 
                       icf_ssa_populate_address_from_sip_addr_spec(
                   p_ssa_pdb,
                   p_addr_spec2,
                   p_addr_str2))
             {
                ret_val = ICF_FAILURE;
             }
             else if (p_addr_str1->addr_type != p_addr_str2->addr_type)
             {
                ret_val = ICF_FAILURE;
             }
             else if (p_addr_str1->addr_val.str_len != p_addr_str2->addr_val.str_len)
             {
                ret_val = ICF_FAILURE;
             }
             else if (0 != icf_port_strcmp(p_addr_str1->addr_val.str, 
                                           p_addr_str2->addr_val.str))
             {
                ret_val = ICF_FAILURE;
             }
             ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_addr_str1,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val2)
             ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_addr_str2,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val2)
           } /* end of if second memget for addr_str2 is success */
           else
           {
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_addr_str1,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val2)
           }
        } /* end of if the first memget is a success for addr_str1 */
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
} /* End of Fn icf_ssa_util_cmp_address */
#endif




/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_validate_expires
 ** DESCRIPTION:  This function validates the Expires header value in an 
 **               incoming request.
 **
 ******************************************************************************/
icf_return_t icf_ssa_validate_expires(
        INOUT  icf_ssa_pdb_st            *p_ssa_pdb,
        INOUT  Sdf_st_callObject         *p_call_obj,
        OUT   Sdf_ty_messageValidity    *p_validity,
        OUT   Sdf_st_error              *pErr)
{
    icf_return_t                    ret_val = ICF_SUCCESS;
    Sdf_ty_slist                    slMatchedHeadersList;
    SipHeader                       *pExpiresHeader = Sdf_co_null;
    Sdf_st_headerList               *pExpiresHeaderList = Sdf_co_null;
    icf_duration_t                  expires_duration = ICF_NULL;
    Sdf_ty_u32bit                   size = 0;
    p_ssa_pdb=p_ssa_pdb;  

    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_FAILURE;
    }    

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Get the list of Expires headers received in INVITE */
    if (Sdf_co_fail == sdf_ivk_uaGetHeaderListByType(
                          p_call_obj->pUasTransaction->slUnprocessedHeaders,
                          SipHdrTypeExpiresSec,
                          &slMatchedHeadersList,
                          pErr))
    {
        ret_val = ICF_FAILURE;
    }
    else if(Sdf_co_fail == sdf_listSizeOf(&slMatchedHeadersList,&size, pErr))
    {
        sdf_listDeleteAll(&slMatchedHeadersList,pErr);
        ret_val = ICF_FAILURE;
    }
    else if (ICF_NULL != size)
    {
        /* Get HeaderList at index 0. stack will fail the decode for request 
         * carrying more than one Expires header
         */
        if (Sdf_co_fail == sdf_listGetAt(
                          &slMatchedHeadersList,
                          0,
                          (Sdf_ty_pvoid *)&pExpiresHeaderList,
                          pErr))
        {
            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_listGetAt(
                          &(pExpiresHeaderList)->slHeaders,
                          0,
                          (Sdf_ty_pvoid *)&pExpiresHeader,
                          pErr))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            expires_duration = (((SipExpiresHeader *)
                                  (pExpiresHeader->pHeader))->u).dSec;

            /* If expires duration is 0 then set errCode and return failure */
            if (ICF_NULL == expires_duration)
            {
                *p_validity = Sdf_en_invalid;
                ret_val = ICF_FAILURE;
            }
      }
      sdf_listDeleteAll(&slMatchedHeadersList,pErr);
    }/* size != 0 */

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} /* End function icf_ssa_validate_expires() */

/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_set_param_in_Via
 ** DESCRIPTION:  This function sets the Via header parameters for the outgoing
 **               the SipMessage.
 **
 ******************************************************************************/
icf_return_t    icf_ssa_set_param_in_Via(
                 INOUT     SipMessage          *p_sip_msg,
                 INOUT  icf_ssa_pdb_st      *p_ssa_pdb,
                 INOUT     SipParam            *p_param,
                 OUT    SipError            sip_error
                 )
{
    icf_return_t    ret_val = ICF_SUCCESS;
    SipHeader       hdr;
    icf_uint32_t     count = ICF_NULL;
    Sdf_st_error     sdf_error; 


   if(ICF_NULL == p_ssa_pdb)
   {
       return ICF_FAILURE;
   }

   ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
   p_ssa_pdb=p_ssa_pdb;




    /* Get the Via Header from SIP message
     */
     if(SipFail != sip_getHeaderAtIndex(p_sip_msg,SipHdrTypeVia,&hdr,\
         0,(SipError*)&(sip_error)))     
     {
         if(SipFail == sip_getViaParamCountFromViaHdr(&hdr, &count,\
                    (SipError*)&(sdf_error.stkErrCode)))
         {
#ifdef SDF_ERROR
             sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                 (Sdf_ty_s8bit *)"icf_ssa_set_param_in_Via(): "
                 "Failed to get the Via Param count from Via header of SIP message",\
                 &sdf_error);
#endif
             sdf_error.stkErrCode=Sdf_en_headerManipulationError;
             sip_freeSipHeader(&hdr);
             ret_val = ICF_FAILURE;
         }
         else if(SipFail == sip_insertParamAtIndexInCommonHdr(&hdr,p_param,\
             count,(SipError*)&(sdf_error.stkErrCode)))
         {
#ifdef SDF_ERROR
             sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                 (Sdf_ty_s8bit *)"icf_ssa_set_param_in_Via(): "
                 "Failed to insert the Via params in Via header of SIP message",\
                 &sdf_error);
#endif
             sip_error=Sdf_en_headerManipulationError;
             sip_freeSipHeader(&hdr);
             ret_val = ICF_FAILURE;
         }
         else
         {
             sip_freeSipHeader(&hdr);
             ret_val = ICF_SUCCESS;

         }

     }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)    
    return ret_val;

}


#ifdef ICF_NAT_RPORT_SUPPORT
/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_get_params_from_Via
 ** DESCRIPTION:  This function extracts the Via header parameters from the Sip
 **               Message and set the various flags for rport status as received 
 **               request/response.
 **
 ******************************************************************************/
icf_return_t    icf_ssa_get_params_from_Via(
                 INOUT  SipMessage          *p_sip_msg,
                 INOUT  icf_ssa_pdb_st      *p_ssa_pdb,
                 IN     en_SipMessageType   dMsgType,
                 OUT    SipError            *sip_error
                 )
{
    icf_return_t                 ret_val = ICF_SUCCESS;    
    icf_uint32_t                  count = 0;
    icf_uint8_t                  index = 0;
    SipParam                     *p_sip_param = SIP_NULL;
    Sdf_ty_s8bit                 *pParamName = SIP_NULL;
    SipHeader                    hdr;
    Sdf_st_error                 sdf_error;
    icf_boolean_t                is_recvd_param_present = ICF_FALSE;    
    icf_boolean_t                is_rport_param_present = ICF_FALSE;    
    icf_line_data_st             *p_line_data = ICF_NULL;
    icf_rport_config_data_st     *p_rport_config_data = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (ICF_CFG_SELF_ADDR_PER_LINE ==
            p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                    p_ssa_pdb->p_glb_pdb, p_ssa_pdb->p_ssa_ctxt->line_id,
                    &p_line_data, p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            p_rport_config_data = p_line_data->p_rport_config_data;
        }
    
    }
    else
    {
        p_rport_config_data = &(p_ssa_pdb->p_glb_cfg_data->rport_config_data);
    }

    if (ICF_NULL == p_rport_config_data)
    {
       return ICF_FAILURE; 
    }  
 
    if(SipFail != sip_getHeaderAtIndex(p_sip_msg,SipHdrTypeVia,&hdr,0,\
        sip_error))
    {
        if(SipFail == sip_getViaParamCountFromViaHdr(&hdr, &count, \
                    (SipError*)&(sdf_error.stkErrCode)))
        {
#ifdef SDF_ERROR
            sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                "Failed to get the Via Param count from Via header of SIP message",\
               &(sdf_error));
#endif
            sdf_error.stkErrCode=Sdf_en_headerManipulationError;
            sip_freeSipHeader(&hdr);
            ret_val = ICF_FAILURE;
        }
        else
        {
            /*for(;index < count; index++)*/
            while(index < count)
            {
               /* get the parameters from Via Header 
                */
                if(SipFail == sip_getViaParamAtIndexFromViaHdr(&hdr,&p_sip_param,\
                    index,(SipError*)&(sdf_error.stkErrCode)))
                {
#ifdef SDF_ERROR
                    sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                        (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                        "Failed to get the Via Param from Via header from SIP message",&sdf_error);
#endif
                    sdf_error.stkErrCode=Sdf_en_headerManipulationError;
                    sip_freeSipHeader(&hdr);
                    return ICF_FAILURE;
                    
                }
                else if(SipFail == sip_getNameFromSipParam(p_sip_param, &pParamName,\
                    (SipError*)&(sdf_error.stkErrCode)))
                {
#ifdef SDF_ERROR
                    sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                        (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                        "Failed to get name from via param of SIP message",&sdf_error);
#endif
                    sdf_error.stkErrCode = Sdf_en_headerManipulationError;
                    sip_freeSipParam(p_sip_param);
                    sip_freeSipHeader(&hdr);
                    return ICF_FAILURE;
                }
                
                else
                {
                    if(0 == icf_port_strcmp((icf_uint8_t*)pParamName,(icf_uint8_t*)"received"))
                    {
                        if(SipMessageResponse == dMsgType)
                        {                 
                            /* Store the received param value in received address
                             * of global config 
                             */
                            icf_ssa_convert_to_tran_addr((icf_uint8_t*)\
                                    (p_sip_param->slValue.head->pData),\
                                    &(p_rport_config_data->received_addr));
                            is_recvd_param_present = ICF_TRUE;

                        }
                    }
                    else if(0 == icf_port_strcmp((icf_uint8_t*)pParamName,(icf_uint8_t*)"rport"))
                    {
                        if(SipMessageResponse == dMsgType)
                        {
                            /* Store the rport value in the received address of 
                             * global config data.
                             */
                            if (ICF_NULL != p_sip_param->slValue.head)
                            {
                                p_rport_config_data->received_addr.port_num =
                                    icf_port_atoi((const icf_int8_t *)(p_sip_param->\
                                                slValue.head->pData));
                                is_rport_param_present = ICF_TRUE;
                            }
                        }
                        else if(SipMessageRequest == dMsgType)
                        {
                            /* Set the bitmask in the ssa context to indicate
                             * that the rport is received in the request message
                             */
                            p_ssa_pdb->p_ssa_ctxt->rport_bitmask|=\
                                                                  ICF_RPORT_RECEIVED;
                            /* Delete the rport parameter from the Via Header
                             */

                            if(SipFail == sip_deleteParamAtIndexInCommonHdr(\
                                        &hdr,index,(SipError*)&(sdf_error.\
                                            stkErrCode)))
                            {
                                return ICF_FAILURE;

                            }
                            else
                            {
                                sip_freeSipParam(p_sip_param);
                                count--;
                                continue;
                            }
                        }
                    }
                }
                sip_freeSipParam(p_sip_param);
                index ++;
            }
       /* Check whether rport and received parameters are received in the response Via Header
        */    
       if(SipMessageResponse == dMsgType)
       {
        if(ICF_FALSE == is_recvd_param_present && ICF_FALSE == is_rport_param_present)
        {
            icf_port_memcpy((icf_void_t*)&(p_rport_config_data->received_addr),\
                (icf_void_t*)&(p_rport_config_data->contact_ip_addr),\
                (icf_uint32_t)ICF_PORT_SIZEOF(icf_transport_address_st));
        }         
        else if(ICF_TRUE == is_recvd_param_present && ICF_FALSE == is_rport_param_present)
        {/* Fix for CSR-1-5140139 */
         icf_port_memcpy((icf_void_t*)&(p_ssa_pdb->p_glb_cfg_data->rport_config_data.received_addr),\
				(icf_void_t*)&(p_ssa_pdb->p_glb_cfg_data->rport_config_data.contact_ip_addr),\
				(icf_uint32_t)ICF_PORT_SIZEOF(icf_transport_address_st));
        }
        else if(ICF_FALSE == is_recvd_param_present && ICF_TRUE == is_rport_param_present)
        {/* Fix for CSR-1-5140139 */
         icf_port_memcpy((icf_void_t*)&(p_ssa_pdb->p_glb_cfg_data->rport_config_data.received_addr),\
				(icf_void_t*)&(p_ssa_pdb->p_glb_cfg_data->rport_config_data.contact_ip_addr),\
				(icf_uint32_t)ICF_PORT_SIZEOF(icf_transport_address_st));    
        }
       }
    }
    }

    sip_freeSipHeader(&hdr);

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;

}





/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_compare_transport_addr
 ** DESCRIPTION:  This function compares the contact address and 
 **               the address received in the Via Hdrs Parameters.
 **
 ******************************************************************************/
icf_boolean_t icf_ssa_compare_transport_addr(
         INOUT icf_ssa_pdb_st              *p_ssa_pdb,
         INOUT icf_transport_address_st    *p_contact_addr,
         INOUT icf_transport_address_st    *p_received_addr
         )
{
    icf_boolean_t               match_found = ICF_FALSE;
    icf_string_st               contact_ip = {0,{'\0'}};
    icf_string_st               received_ip = {0,{'\0'}};

#ifdef ICF_TRACE_ENABLE
     icf_return_t    ret_val = ICF_SUCCESS;
#endif

    if(ICF_NULL == p_ssa_pdb)
    {
       ICF_PRINT(((icf_uint8_t*)"p_ssa_pdb is null"));
       return ICF_SUCCESS;

    }

        
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Convert the Ip address to the string format*/
    
    if (ICF_SUCCESS == icf_ssa_convert_to_IP_addr(
                    p_contact_addr, (icf_uint8_t*)&(contact_ip.str)))
    {
        contact_ip.str_len = icf_port_strlen(contact_ip.str);
    
        if(ICF_SUCCESS == icf_ssa_convert_to_IP_addr(
                    p_received_addr, (icf_uint8_t*)&(received_ip.str)))
        {
    
         received_ip.str_len = icf_port_strlen(received_ip.str);
           /* Compare the ip address strings
            */
            if( 0 == icf_port_strcmp(contact_ip.str,received_ip.str))
            {
                /* IP matched, now compare the port numbers */
                if(p_contact_addr->port_num == p_received_addr->port_num)
                {
                    match_found = ICF_TRUE;
                }
                else
                {
                    /* Port number mismatch*/
                    match_found = ICF_FALSE;
                }
            }
            else
            {
                /* IP Mismatch */
                match_found = ICF_FALSE;
            }
        }
    }   
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return (match_found);
}


/*******************************************************************************
 * FUNCTION:        icf_ssa_start_binding_refresh_timer
 * DESCRIPTION:    This routine is used for starting the binding refresh timer
 ******************************************************************************/
icf_return_t icf_ssa_start_binding_refresh_timer(
        INOUT icf_ssa_pdb_st*    p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_timer_id_t           timer_id = ICF_TIMER_ID_INVALID;
    icf_timer_data_st        *p_timer_data = ICF_NULL;
    icf_rgm_context_st       *p_rgm_context = ICF_NULL;
    icf_rport_config_data_st *p_rport_config_data = ICF_NULL;   
    icf_boolean_t            match_found= ICF_FALSE;
    icf_line_data_st         *p_line_data = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    
    if (ICF_CFG_SELF_ADDR_PER_LINE ==
            p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                    p_ssa_pdb->p_glb_pdb,p_ssa_pdb->p_ssa_ctxt->line_id,
                    &p_line_data, p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            p_rport_config_data = p_line_data->p_rport_config_data;
        }
    
    }
    else
    {
        p_rport_config_data = &(p_ssa_pdb->p_glb_cfg_data->rport_config_data);
    }

    if (ICF_NULL == p_rport_config_data)
    {
        return ICF_FAILURE;
    }

    /* Fix for SPR 18285 start*/
    /* If binding refresh timer is not null i.e some timer is already running then
     * we are stopping the already running timer & freeing the memory allocated to 
     * p_timer_data before starting the new timer. */

    if(ICF_NULL != p_rport_config_data->p_binding_refresh_timer)
    {
        ICF_STOP_TIMER(p_ssa_pdb->p_glb_pdb,p_rport_config_data->binding_refresh_timer_id,
                       p_ssa_pdb->p_ecode,ret_val)
   
         ICF_PRINT(((icf_uint8_t*)"[SSA] Timer Id=%d stopped \n",
                    p_rport_config_data->binding_refresh_timer_id));
  
         /* SPR 19858 : Incorrect pointer was being passed to the function 
            icf_dbm_ret_mem_to_pool to free the timer block.Changed the pointer passed to
            the function from p_timer_data to p_rport_config_data->p_binding_refresh_timer.
            Since the timer block acquired for p_rport_config_data->p_binding_refresh_timer 
            was not getting freed, it was overwritten every time in the subsequent 
            code leg. Thus the DBM timer block pools got exhausted in a NAT SOAK scenario
            leading to ABRs,FMRs and crash.
         */    
         icf_dbm_ret_mem_to_pool(p_ssa_pdb->p_glb_pdb,
                              ICF_MEM_TIMER,p_rport_config_data->p_binding_refresh_timer,  
                             p_ssa_pdb->p_ecode);
         /* End of fix for SPR 19858 */ 
   
         p_rport_config_data->binding_refresh_timer_id = ICF_TIMER_ID_INVALID;
   
         p_rport_config_data->p_binding_refresh_timer = ICF_NULL;
   }/*if*/
  /* Fix for SPR 18285 end*/
    if ( ICF_FAILURE == icf_dbm_get_mem_from_pool(
                p_ssa_pdb->p_glb_pdb, ICF_MEM_TIMER,
                (icf_void_t **)&p_timer_data, 
                p_ssa_pdb->p_ecode))
    {
        ICF_SSA_DEBUG(("\[SSA]:FailureInAllocatingTimerBlockForBindingRefreshTimer\n"));
        ret_val = ICF_FAILURE;
    }
    else
    {
           if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt)
           {
               p_rgm_context = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt;
               if (ICF_TRUE == icf_dbm_util_cmp_addr(p_ssa_pdb->p_glb_pdb,\
                           &(p_rport_config_data->user_address),\
                    &(p_rgm_context->rgm_user_address)))
               {
                   match_found = ICF_TRUE;

               }
           }
           if(ICF_FALSE == match_found)
           {
             /* Fetch the rgm context for the user address stored in the
              * rport config data.
              */
             ret_val = icf_rgm_get_ctxt_for_pub_uri(p_ssa_pdb->p_glb_pdb,\
                    p_rport_config_data->line_id,&(p_rport_config_data->\
                   user_address),&p_rgm_context,p_ssa_pdb->p_ecode);
             if(ICF_FAILURE == ret_val)
             {
                 ICF_PRINT(((icf_uint8_t*)"\n Unable to fetch rgm context for line id %d.",\
                          p_rport_config_data->line_id));
                 /*Free the allocated timer block here*/
                 icf_dbm_ret_mem_to_pool(p_ssa_pdb->p_glb_pdb, ICF_MEM_TIMER,
                   p_timer_data, p_ssa_pdb->p_ecode);
                 return ret_val;
             }
           }
        /* fill the timer data structure */
        p_timer_data->timer_type = ICF_BINDING_REFRESH_TIMER_TYPE;
        p_timer_data->module_id = ICF_INT_MODULE_CFG;

        /*
         * In case of timer expiry, eshell will pass the p_timer_data
         * to SSA.SSA will then get the p_ssa_timer_data and invoke
         * UATK callback
         */
        p_timer_data->p_timer_buffer = (icf_void_t*)p_rgm_context;
        p_timer_data->p_glb_pdb = p_ssa_pdb->p_glb_pdb;

        ICF_START_TIMER(p_ssa_pdb->p_glb_pdb, 
                p_timer_data, timer_id,
                p_rport_config_data->binding_refresh_timer,
                p_ssa_pdb->p_ecode, ret_val)

        if ( ICF_FAILURE == ret_val)
        {
            ICF_SSA_DEBUG(("\n[SSA]:Failure!!InStartingBindingRefreshTimer"));
            /*Free the allocated timer block here*/
            icf_dbm_ret_mem_to_pool(p_ssa_pdb->p_glb_pdb, ICF_MEM_TIMER,
                    p_timer_data, p_ssa_pdb->p_ecode);
        }
        else
        {
            p_rport_config_data->binding_refresh_timer_id = timer_id;
            p_rport_config_data->p_binding_refresh_timer = p_timer_data;
        } /* else */
     }/* else */
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/*******************************************************************************
 * FUNCTION:        icf_ssa_handle_register_response_for_rport
 * DESCRIPTION:     This routine is used for checking the rport and received 
 *                  parameters in the register response. If the values are 
 *                  different from the contact address then set the binding 
 *                  change boolean flag in the global config data and set the
 *                  rport status bitmask to initial-pending.
 * RETURN Types:    ICF_SUCCESS/ICF_FAILURE                  
 ******************************************************************************/
icf_return_t    icf_ssa_handle_register_response_for_rport
(
 INOUT icf_ssa_pdb_st     *p_ssa_pdb)
{

    icf_return_t                ret_val = ICF_SUCCESS;
    icf_boolean_t               match_found= ICF_FALSE;
    icf_rport_config_data_st    *p_rport_config_data=ICF_NULL;
    icf_line_data_st            *p_line_data = ICF_NULL;
    icf_rgm_context_st          *p_rgm_context = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    p_rgm_context = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt;        

    if (ICF_CFG_SELF_ADDR_PER_LINE ==
            p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                    p_ssa_pdb->p_glb_pdb, p_ssa_pdb->p_ssa_ctxt->line_id,
                    &p_line_data, p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            p_rport_config_data = p_line_data->p_rport_config_data;
        }
    
    }
    else
    {
        p_rport_config_data = &(p_ssa_pdb->p_glb_cfg_data->rport_config_data);
    }

    if (ICF_NULL == p_rport_config_data)
    {
       return ICF_FAILURE;
    }

    /* Reset nat_binding_change flag to FALSE.*/
    p_rport_config_data->nat_binding_chng = ICF_FALSE;
    p_rgm_context->line_id =  p_ssa_pdb->p_ssa_ctxt->line_id;

    /* Compare the received and contact transport address stored in the rport
     * config data.
     */

    if(p_rgm_context->ong_dereg_counter)
    {
       match_found = icf_ssa_compare_transport_addr(p_ssa_pdb,\
            &(p_rport_config_data->temp_contact_ip_addr),&(p_rport_config_data->\
            received_addr));
    }
    else
    {
       match_found = icf_ssa_compare_transport_addr(p_ssa_pdb,\
            &(p_rport_config_data->contact_ip_addr),&(p_rport_config_data->\
            received_addr));
    }

    if(ICF_TRUE == match_found)
    {
        /* Set the rport required flag to FALSE. Set rport status as
         * complete. Donot start the binding refresh timer.
         */
        if(ICF_INITIAL_RPORT_INITIAL == p_rgm_context->rport_status)
        {
             if (ICF_CFG_SELF_ADDR_PER_LINE ==
                p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
            {
               p_rport_config_data->is_rport_reqd = ICF_FALSE;
               p_rport_config_data->is_nat_resolved_sys = ICF_TRUE;
            }
            else if(ICF_FALSE == p_rport_config_data->is_nat_resolved_sys &&
               ICF_TRUE == p_rport_config_data->is_rport_reqd)
            {
               p_rport_config_data->is_rport_reqd = ICF_FALSE;
               p_rport_config_data->is_nat_resolved_sys = ICF_TRUE;
            }


            /* CSR-1-6797427 */
            /* The above elseif condition can fail in following scenarios:
             * is_nat_resolved_sys = TRUE
             * is_rport_reqd = TRUE - This should not be changed
             * is_rport_reqd = FALSE - This should not be changed
             *
             * is_nat_resolved_sys = FALSE && is_rport_reqd = FALSE
             * This is possible in case of non-UDP transport, 
             * so is_rport_reqd should not be changed.
             */
            p_ssa_pdb->p_glb_cfg_data->rport_config_data.is_rport_completed= ICF_TRUE;
            p_rgm_context->rport_status =ICF_INITIAL_RPORT_COMPLETED;
            p_rport_config_data->nat_binding_chng = ICF_FALSE;
        }
        else if(ICF_INITIAL_RPORT_PENDING == p_rgm_context->rport_status\
                || ICF_INITIAL_RPORT_ONGOING == p_rgm_context->rport_status)
        {
            p_rport_config_data->is_rport_reqd = ICF_TRUE;
            if(ICF_INITIAL_RPORT_ONGOING == p_rgm_context->rport_status)
            {
                  /* SPR 20174: No need to stop timer here as the following
                   * function takes care of the same.
                   */
                   icf_ssa_start_binding_refresh_timer(p_ssa_pdb);
            }
            p_rport_config_data->is_nat_resolved_sys = ICF_TRUE;

        }
        else
        {
            p_rport_config_data->nat_binding_chng = ICF_FALSE;
            p_rport_config_data->is_nat_resolved_sys = ICF_TRUE;
        }
    }
    else
    {
        /* Set nat_binding_change flag to TRUE.*/
        p_rport_config_data->nat_binding_chng = ICF_TRUE;
    }

  /*  ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)*/
    return ret_val;
}

#endif
/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_del_params_in_Via
 ** DESCRIPTION:  This function deletes the Via header parameters from the Sip
 **               Message.
 **
 ******************************************************************************/
icf_return_t    icf_ssa_del_params_in_Via(
                 INOUT  SipMessage          *p_sip_msg,
                 INOUT  icf_ssa_pdb_st      *p_ssa_pdb,
                 OUT    SipError            *sip_error
                 )
{
    icf_return_t                 ret_val = ICF_SUCCESS;    
    icf_uint32_t                  count = 0;
    icf_uint8_t                  index = 0;
    SipParam                     *p_sip_param = SIP_NULL;
    Sdf_ty_s8bit                 *pParamName = SIP_NULL;
    SipHeader                    hdr;
    Sdf_st_error                 sdf_error;

    if(ICF_NULL == p_ssa_pdb)
    {
       return ICF_SUCCESS;
    }
  
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    p_ssa_pdb=p_ssa_pdb;

    if(SipFail != sip_getHeaderAtIndex(p_sip_msg,SipHdrTypeVia,&hdr,0,\
        sip_error))
    {
        if(SipFail == sip_getViaParamCountFromViaHdr(&hdr, &count, \
                    (SipError*)&(sdf_error.stkErrCode)))
        {
#ifdef SDF_ERROR
            sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                "Failed to get the Via Param count from Via header of SIP message",\
               &(sdf_error));
#endif
            sdf_error.stkErrCode=Sdf_en_headerManipulationError;
            sip_freeSipHeader(&hdr);
            ret_val = ICF_FAILURE;
        }
        else
        {
            for(index = (icf_uint8_t)count ;index > 0; index--)
            {
               /* get the parameters from Via Header 
                */
                if(SipFail == sip_getViaParamAtIndexFromViaHdr(&hdr,&p_sip_param,\
                    index-1,(SipError*)&(sdf_error.stkErrCode)))
                {
#ifdef SDF_ERROR
                    sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                        (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                        "Failed to get the Via Param from Via header from SIP message",&sdf_error);
#endif
                    sdf_error.stkErrCode=Sdf_en_headerManipulationError;
                    sip_freeSipHeader(&hdr);
                    ret_val = ICF_FAILURE;
                    
                }
                else if(SipFail == sip_getNameFromSipParam(p_sip_param, &pParamName,\
                    (SipError*)&(sdf_error.stkErrCode)))
                {
#ifdef SDF_ERROR
                    sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                        (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                        "Failed to get name from via param of SIP message",&sdf_error);
#endif
                    sdf_error.stkErrCode = Sdf_en_headerManipulationError;
                    sip_freeSipParam(p_sip_param);
                    sip_freeSipHeader(&hdr);
                    ret_val =  ICF_FAILURE;
                }
                
                else
                {
                    if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)pParamName,(icf_uint8_t *)"received")||\
                            ICF_NULL == icf_port_strcmp((icf_uint8_t *)pParamName,(icf_uint8_t *)"rport") ||
                            ICF_NULL == icf_port_strcmp((icf_uint8_t *)pParamName,(icf_uint8_t *)"alias"))
                    {
                        /* Delete the parameter from the header
                         */

                            if(SipFail == sip_deleteParamAtIndexInCommonHdr(\
                                        &hdr,index-1,(SipError*)&(sdf_error.\
                                            stkErrCode)))
                            {
                                
                                sdf_error.stkErrCode = Sdf_en_headerManipulationError;
                                sip_freeSipParam(p_sip_param);
                                sip_freeSipHeader(&hdr);
                                ret_val = ICF_FAILURE;

                            }
                    }
                    if (ICF_FAILURE != ret_val)
                    {
                       sip_freeSipParam(p_sip_param);
                    }  
                }
                if(ICF_FAILURE == ret_val)
                    break;
            }
            if (ICF_SUCCESS == ret_val)
            {
                sip_freeSipHeader(&hdr);
            }
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
#ifdef ICF_DNS_LOOKUP_ENABLED
/***************************************************************************
 **
 ** FUNCTION:     icf_ssa_send_to_peer_no_dns_lookup
 * DESCRIPTION:  1.This function internally calls sdf_ivk_uaSendCallToPeer
 *               after initialising an Event Context and setting the 
 *               SSA ctxt into it.
 *               2.In the case of TCP as transport,
 *               we are populating the current transactions' SockFd
 *               with the one in the ConnDb,  if there is one,if not
 *               we reset it to an invalid value so that UATK attempts a 
 *               connect by itself
 *             
 *               The functionality of this function is similar to function 
 *               icf_ssa_send_to_peer except that is would not do DNS query 
 ***************************************************************************/
icf_return_t icf_ssa_send_to_peer_no_dns_lookup(
        icf_ssa_pdb_st *p_ssa_pdb,
        Sdf_st_callObject *p_call_obj,
        SipMessage *p_sip_msg,
        SipOptions *p_options,
        Sdf_st_error *p_sdf_error)
{
    icf_return_t ret_val = ICF_SUCCESS;
    icf_uint32_t count = 0;
    icf_ssa_ctxt_st  *p_ssa_ctxt =
        (icf_ssa_ctxt_st*)(p_call_obj->pAppData->pData);
    icf_error_t      local_ecode={0};


    SipError                SipErr;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    p_ssa_ctxt->p_ssa_pdb = (struct icf_ssa_pdb_st*)p_ssa_pdb;
    p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;
    p_options = p_options;

    if(ICF_FAILURE == ret_val)
    {
    }
    /*  check for presence of allow header and populate it with only the methods
        which the application supports */
    else if (SipFail == sip_getHeaderCount(p_sip_msg, SipHdrTypeAllow, &count, \
        &SipErr) )
    {
        /*ICF_SSA_TRACE(("\nFailed to get Header Count "))*/
        ret_val = ICF_FAILURE;
    }
    /* Allow header present */
    else if(0 < count )
    {
        SipHeader               *p_allow_hdr = ICF_NULL;
        icf_uint8_t *p_method=ICF_NULL;
        icf_uint32_t index;

        if ((ICF_NULL == p_ssa_pdb->p_app_conf) &&
            ((ICF_SSA_USER_ADDR_FRM_SIC & p_ssa_pdb->common_bitmask) ||
             (
              (ICF_NULL != p_ssa_ctxt->p_sic_ctxt) &&
              (ICF_DUMMY_APP_ID == p_ssa_ctxt->p_sic_ctxt->app_id)
             )
            )
           )
        {
            /* Internal Subscribe */
            if(ICF_FAILURE == icf_ssa_make_allow_hdr_for_int_subscribe(p_ssa_pdb,&p_allow_hdr))
            {
                ret_val = ICF_FAILURE;
            }
        }
        else if(ICF_FAILURE == sdf_ivk_uaGetMethodFromSipMessage(p_sip_msg,
                        (Sdf_ty_s8bit**)&p_method,p_sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
        else if((0 == icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER")) &&
                (ICF_NULL != p_ssa_ctxt->p_rgm_ctxt))
        {
            if(ICF_FAILURE == icf_ssa_make_allow_hdr_for_reg(p_ssa_pdb,&p_allow_hdr))
            {
                /*Klocwork warning removal*/
                sip_freeSipHeader(p_allow_hdr);
                ret_val = ICF_FAILURE;
            }
        }
        else if(ICF_NULL!= p_ssa_pdb->p_app_conf)
        {
            if(ICF_FAILURE == icf_ssa_make_allow_hdr_from_app_profile(p_ssa_pdb,&p_allow_hdr))
            {
                /*Klocwork warning removal*/
                sip_freeSipHeader(p_allow_hdr);
                ret_val = ICF_FAILURE;
            }
        }
        else
            p_allow_hdr = ICF_NULL;

        /* Set new Allow header */
        if(ICF_FAILURE != ret_val)
        {
            /* Delete all allow headers */
            for(index = 0; index < count; index++)
            {
                if(SipFail == sip_deleteHeaderAtIndex (p_sip_msg,SipHdrTypeAllow, 0, &SipErr))
                {
                    ret_val = ICF_FAILURE;
                    break;
                }
            }
            if(ICF_FAILURE == ret_val)
            {
            }
            else if(ICF_NULL != p_allow_hdr)
            {
                /* Insert header in sip message */
                if(SipFail == sip_insertHeaderAtIndex (p_sip_msg, p_allow_hdr, 0, &SipErr))
                {
                    ret_val = ICF_FAILURE;
                }
            }
        }
        /*Klocwork warning removal*/
        sip_freeSipHeader(p_allow_hdr);
        if(ICF_NULL != p_allow_hdr)
        {
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_allow_hdr,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
        }
    }

    if ( ICF_FAILURE != ret_val)
    {
        Sdf_st_eventContext *p_event_context = Sdf_co_null;
        if (Sdf_co_fail ==
                sdf_ivk_uaInitEventContext(&p_event_context, p_sdf_error))
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInInitEventCtxt in SSASendToPeer"));
            ret_val = ICF_FAILURE;
        }
        else
        {
            

            Sdf_st_transaction          *p_txn = Sdf_co_null;
            Sdf_st_overlapTransInfo     *p_overlap_txn = Sdf_co_null;
            p_event_context->pData = p_call_obj->pAppData->pData;

            if (Sdf_co_fail == sdf_ivk_uaGetTransactionForSipMsg(
                        p_call_obj, p_sip_msg,
                        &p_txn, &p_overlap_txn, p_sdf_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Can'tGetTxnFromMsg!!!"));
                ret_val = ICF_FAILURE;
            }
                if (ICF_FAILURE != ret_val)
                {
                    /*this flag is used to identify whether a connection
                      has been made fully or not. Tjus is it to be used for
                      TCP/TLS cases only*/
                    icf_boolean_t    ready_to_send = ICF_TRUE;
                    if (ICF_NULL != 
                            (ICF_SSA_EXPLICIT_CONNECT_REQ & p_ssa_ctxt->bitmask))
                    {
                        if (ICF_FAILURE == icf_ssa_attempt_out_of_uatk_connect(
                                    p_ssa_pdb, p_call_obj, p_txn, 
                                    p_overlap_txn, &ready_to_send))
                        {
                            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureFrom AttemptOutOfDlgConnect"));
                            ret_val = ICF_FAILURE;
                        }
                    }/*out of UATK connect*/
                    if ((ICF_TRUE == ready_to_send) &&
                            (Sdf_co_fail == 
                             icf_ssa_initiate_dispatch_sequence(
                                 p_ssa_pdb, p_call_obj,
                                 p_txn, p_overlap_txn, p_event_context,
                                 &local_ecode)))
                    {
                        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in InitiateDispatchSeq!!!"));
                        ret_val = ICF_FAILURE;
                    }
                }/*retval FIALURE check*/
        if ( Sdf_co_null != p_txn)
        {
            sdf_ivk_uaFreeTransaction(p_txn);
        }
        if ( Sdf_co_null != p_overlap_txn)
        {
            sdf_ivk_uaFreeOverlapTransInfo(p_overlap_txn);
        }
        }/*InitEventContext Success leg*/
        sdf_ivk_uaFreeEventContext(p_event_context);
    }/*ret_val != FAILURE*/

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
#endif

/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_validate_content_disp
 ** DESCRIPTION:  This function validates the Content Disposition header value in an 
 **               incoming request.
 **
 ******************************************************************************/
icf_return_t icf_ssa_validate_content_disp(
        INOUT icf_ssa_pdb_st            *p_ssa_pdb,
        INOUT Sdf_st_callObject         *p_call_obj,
        OUT   Sdf_st_error              *p_err)
{
    icf_return_t                    ret_val = ICF_SUCCESS;
    Sdf_ty_slist                    slMatchedHeadersList;
    SipHeader                       *p_content_disp_hdr = Sdf_co_null;
    Sdf_st_headerList               *p_content_disp_hdr_list = Sdf_co_null;
    Sdf_ty_u32bit                   size = 0;
    SIP_S8bit                       *p_disp_type = SIP_NULL;
    icf_boolean_t                   content_type_supported = ICF_FALSE;
  	SIP_S8bit 	                    *p_param_value = SIP_NULL;
	SIP_S8bit  		                *p_param_name = ICF_NULL;
    SipParam                        *p_sip_param = SIP_NULL;
    Sdf_ty_u32bit                   content_type_size = 0;
    Sdf_ty_s8bit                    *pMediaType = Sdf_co_null; 
/* Start: For content Encoding Header Validation */
    Sdf_st_configExtraHeaders 	*pTemp = Sdf_co_null;
    Sdf_st_configExtraHeaders	*pAcceptEnc = Sdf_co_null;
    Sdf_ty_u32bit               IndicateAcceptEnc = 0; 
    Sdf_ty_u32bit               size2=0,dConEncSize=0,dIndex=0;
	Sdf_st_listIterator         dListIterator;
/* End: For content Encoding Header Validation */

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* First we will extract the Content Type header(if any)
     * from the SIP message.Then we will check it against the
     * supported types in the app profile.If a supported content-type
     * is not found we will set failure bitmask to send a 415.Else
     * we will apply the handling of Content-Disposition header handling
     * only in the case of "application/sdp" Content-Type.
     */

    if(SipFail == sip_getHeaderCount(
                      p_call_obj->pUasTransaction->pSipMsg,
                      SipHdrTypeContentType,
                      &content_type_size,
                      (SipError*)&(p_err->stkErrCode)))
    {
        ret_val = ICF_FAILURE;
    }
    if((0 != content_type_size) && (ICF_SUCCESS == ret_val))
    {
        SipHeader               dHdr;
		icf_string_list_node_st *p_list = ICF_NULL;
        icf_app_conf_st         *p_app_conf = ICF_NULL;
        icf_uint8_t             iterator = 0;

        if(SipFail == sip_getHeader(
                        p_call_obj->pUasTransaction->pSipMsg,
                        SipHdrTypeContentType,
                        &dHdr,
                        (SipError*)&(p_err->stkErrCode)))
        {
            ret_val = ICF_FAILURE;
        }
      else if (SipFail == sip_getMediaTypeFromContentTypeHdr(
                        &dHdr,
                        &pMediaType,
                        (SipError*)&(p_err->stkErrCode)))
        {
            sip_freeSipHeader(&dHdr);
            ret_val = ICF_FAILURE;
        }
        sip_freeSipHeader(&dHdr);
        /* Now checking the accepted content types from the profile*/
        if (ICF_FAILURE == icf_cfg_fetch_app_conf(
                              p_ssa_pdb->p_glb_pdb,
                              p_ssa_pdb->p_app_conf->app_id,
                              &(p_ssa_pdb->p_app_conf),
                              p_ssa_pdb->p_ecode))
        {
            ret_val = ICF_FAILURE;
        }
        p_app_conf = p_ssa_pdb->p_app_conf;
        p_list = p_app_conf->app_profile.supported_content_types.p_list;
        for(iterator = 0; 
            iterator <
            p_app_conf->app_profile.supported_content_types.count &&
            p_list != ICF_NULL;
                iterator++)
        {
            /* Rel 8.1 
             * if user has give ALL then do not fail
             * content type validation, because 
             * application supports all content types 
             */
            if((ICF_NULL != p_list->str.str) &&
              (ICF_NULL == icf_port_strcasecmp((const icf_int8_t *)p_list->str.str,"ALL")))
            {
                content_type_supported = ICF_TRUE;
                 break;
            }
            /* Compare the Content Type received with each 
             * supported content type in app profile
             */
            /* Added null check for klocwork warning removal */    
             else if((ICF_NULL != pMediaType) &&
                    (ICF_NULL != p_list->str.str) &&     
                (ICF_NULL == icf_port_strcasecmp((const icf_int8_t *)p_list->str.str,(const icf_int8_t *)pMediaType)))
             {
                  content_type_supported = ICF_TRUE;
                  break;
             }
             p_list = p_list->p_next;
        }
     
        if(ICF_FALSE == content_type_supported)
        {
            /* setting the failure bitmask*/
            p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
    		    ICF_SSA_FAILURE_RESP_CODE_415;
    		ret_val = ICF_FAILURE;
        }
    /* Content type is supported.Proceed with handling of Content-Disposition
     * only in the case of "application/sdp'
     */
    /* Added null check for klocwork warning removal */    
    else if((ICF_NULL != pMediaType) && 
            (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pMediaType,(icf_uint8_t *)"application/sdp")))
    { 
        /* Now extract the content disposition */
        if (Sdf_co_fail == sdf_ivk_uaGetHeaderListByType(
                          p_call_obj->pUasTransaction->slUnprocessedHeaders,
                          SipHdrTypeContentDisposition,
                          &slMatchedHeadersList,
                          p_err))
    {
        ret_val = ICF_FAILURE;
    }
    else if(Sdf_co_fail == sdf_listSizeOf(&slMatchedHeadersList,&size, p_err))
    {
        sdf_listDeleteAll(&slMatchedHeadersList,p_err);
        ret_val = ICF_FAILURE;
    }
    else if (ICF_NULL != size)
    {
        /* Get HeaderList at index 0. Current fix is not handling
         * MIME message bodies where multiple message bodies shall be
         * received along with multiple COntent-Disposition headers
         */
        icf_uint8_t                iterator=0;
        size = 0;/* so that we can re-use this variable */
        if (Sdf_co_fail == sdf_listGetAt(
                          &slMatchedHeadersList,
                          0,
                          (Sdf_ty_pvoid *)&p_content_disp_hdr_list,
                          p_err))
        {
            ret_val = ICF_FAILURE;
        }
        else if (Sdf_co_fail == sdf_listGetAt(
                          &(p_content_disp_hdr_list)->slHeaders,
                          0,
                          (Sdf_ty_pvoid *)&p_content_disp_hdr,
                          p_err))
        {
            ret_val = ICF_FAILURE;
        }
        /* 
         * First extract the display type from the Content Disposition header 
         * Then extract the parameter count 
         */ 
        else if (SipFail == sip_getDispTypeFromContentDispositionHdr(
                p_content_disp_hdr,&p_disp_type,(SipError *)&(p_err->stkErrCode)))
        {
            ret_val = ICF_FAILURE;
        }
        else if (SipFail == sip_getParamCountFromContentDispositionHdr(
                p_content_disp_hdr,&size,(SipError *)&(p_err->stkErrCode)))
        {
            ret_val = ICF_FAILURE;
        }
        else
        {
            /* Now we have the content disposition type and 
             * the parameter count.
             */

            /* Now extract the handling parameter*/
            for (iterator = 0;iterator < size; iterator++)
            {
                if (SipSuccess == sip_getParamAtIndexFromContentDispositionHdr(
                            p_content_disp_hdr,&p_sip_param,iterator,
                            (SipError *)&(p_err->stkErrCode)))
                {
                    if (SipFail == sip_getNameFromSipParam(
                        p_sip_param,&p_param_name,(SipError *)&(p_err->stkErrCode)))
                    {
                        ret_val = ICF_FAILURE;
                        sip_freeSipParam(p_sip_param);
                        /*SPR 18815:Protective initialization*/
                        p_sip_param = Sdf_co_null;
                        break;
                    }
                    else if (ICF_NULL != icf_port_strcmp((icf_uint8_t *)p_param_name,(icf_uint8_t *)"handling"))
                    {
                        sip_freeSipParam(p_sip_param);
                        /*SPR 18815:Protective initialization*/
                        p_sip_param = Sdf_co_null;
                        continue;
                    }
                    else
                    {

                        /* Only 1 paramter value is expected to be received for this
                         * parameter according to RFC 3261.
                         * Hence,accessing the first value only
                         */
                        if (SipFail == sip_getValueAtIndexFromSipParam(
                                    p_sip_param,&p_param_value,
                                    0,(SipError *)&(p_err->stkErrCode))) 
                        {
                            ret_val = ICF_FAILURE;
                            sip_freeSipParam(p_sip_param);
                            /*SPR 18115: The value of sip_param is free here
                             * and not initialised to null. Again later in
                             * program we try to free same memory giving FMR*/
                            p_sip_param = Sdf_co_null;
                            break;
                        }
                    }
                }     
                else
                {
                     ret_val = ICF_FAILURE;
                     break;
                } 
            }

           /* If content disposition is not null and not "session"*/
                if (ICF_NULL == p_disp_type)
                {
                    /*do nothing*/
                }
                else if(ICF_NULL != icf_port_strcasecmp(p_disp_type,"session"))
                {
                    /* Check the handling parameter */
                    /* If it is "required" or Null(by default "required" is 
                     * assumed acc to RFC 3261), then respond with 488
                     */
					if ((ICF_NULL == p_param_value) ||
                       (ICF_NULL == icf_port_strcasecmp(p_param_value,"required")))
                     {
                                    p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
                                        ICF_SSA_FAILURE_RESP_CODE_488;
                                    ret_val = ICF_FAILURE;
                                    sip_freeSipParam(p_sip_param);
                                    p_sip_param = Sdf_co_null;
                      }
                    /* If it is optional,we will ignore the SDP and indicate the 
                     * same to the calling function so that this can be now treated
                     * as a Non Fast Call.
                     */
                    else if (ICF_NULL == icf_port_strcasecmp(p_param_value,"optional"))
                    {
                        p_ssa_pdb->common_bitmask |= ICF_SSA_SDP_TO_BE_IGNORED;
                    }
                    /*SPR 18815*/
                    if(Sdf_co_null != p_sip_param)
                    {   
                       sip_freeSipParam(p_sip_param);
                       p_sip_param = Sdf_co_null;
                    }   
				}/* end of content disposition is not "session"*/
                /* If content disposition is "session"*/
else if (ICF_NULL == icf_port_strcasecmp(p_disp_type,"session"))
                {
                    /* Now check the content language.If it is English or 
                     * NULL(in such a case it is assumed to be English acc 
                     * to RFC 3261) or one of the supported languages in our
                     * profile, we proceed normally */
                    
                    icf_uint32_t            iterator = 0,
                                            iterator2 = 0,
                                            count = 0;
                    SipHeader               dHeader;
                    SIP_S8bit               *p_unk_hdr_name = SIP_NULL,
                                            *pBuffer = SIP_NULL ;
                    Sdf_ty_u32bit           buf_count = 0;
                    icf_string_list_node_st *p_list = ICF_NULL;
                    icf_app_conf_st         *p_app_conf;
                    icf_boolean_t           language_supported = ICF_FALSE;
                    SipError                err;
                    
                    /* First extracting the Content Language header */

                    /* get the unknown header count */
                    if(SipFail == sip_getHeaderCount(
                           p_call_obj->pUasTransaction->pSipMsg,
                           SipHdrTypeUnknown,&count,
                           (SipError *)&(p_err->stkErrCode)))
                    {
                        ret_val = ICF_FAILURE ;
                    }
                    /* Iterate through all the unknown headers*/
                    for(iterator=0 ; iterator<count ; iterator++)
                    {
                        if(SipFail == sip_getHeaderAtIndex(
                               p_call_obj->pUasTransaction->pSipMsg,
                               SipHdrTypeUnknown, &dHeader,
                               iterator,&err))
                        {
                            /*In this case we continue to try to fetch other unknown headers*/
                            continue;
                        }
                        if(SipFail == sip_getNameFromUnknownHdr(
                                &dHeader,&p_unk_hdr_name,&err))
                        {
                            /*In this case we continue to try to fetch other unknown headers*/
                            sip_freeSipHeader(&dHeader);
                            continue;
                        }
                        if(ICF_NULL == icf_port_strcasecmp(p_unk_hdr_name,"Content-Language"))
                        {
                            /*Content-Language header processing begins*/
#ifdef ICF_WITH_MUATK_2_2
                            buf_count=icf_port_strlen((icf_uint8_t *)(
							    (SipUnknownHeader *)
							    (dHeader.pHeader))->pStr2);
                            pBuffer = (((SipUnknownHeader *)
							    (dHeader.pHeader))->pStr2);
#else
                            buf_count=icf_port_strlen((
		    					(SipUnknownHeader *)
			    				(dHeader.pHeader))->pBody);            
                            pBuffer = (((SipUnknownHeader *)
					    		(dHeader.pHeader))->pBody);
#endif
                            /*Null terminating the Content-Language Header value*/
                            /* Added null check for klocworks warning removal
                             */
                           if(ICF_NULL != pBuffer)
                           {   
						      pBuffer[buf_count] = '\0';
                           }  
                            sip_freeSipHeader(&dHeader);

						    /* Now we have the header value in pbuffer*/
                        
                            /* Compare the Content-Language received with the languages
                            * added in the app profile
                            */
                           if(ICF_NULL != pBuffer)
                           {
                                if(ICF_FAILURE == icf_cfg_fetch_app_conf(
                                       p_ssa_pdb->p_glb_pdb,
                                       p_ssa_pdb->p_app_conf->app_id,
                                       &(p_ssa_pdb->p_app_conf),
                                       p_ssa_pdb->p_ecode))
                                {
                                    ret_val = ICF_FAILURE;
                                }
                                p_app_conf = p_ssa_pdb->p_app_conf;
                                p_list = p_app_conf->app_profile.supported_languages.p_list;
                                for(iterator2 = 0; 
                                    iterator2 <
                                    p_app_conf->app_profile.supported_languages.count &&
                                    p_list != ICF_NULL;
                                    iterator2++)
                                {
                                    /* Compare the Content Language received with each 
                                     * supported langauge in app profile
                                     */
                                    if(ICF_NULL == icf_port_strcasecmp((const icf_int8_t *)p_list->str.str,(const icf_int8_t *)pBuffer))
                                    {
                                        language_supported = ICF_TRUE;
                                        break;
                                    }
                                    p_list = p_list->p_next;
                                }
                            }/* end of fetching supported languages from profile*/
                        }/* end Content-Language handling*/
                    }/* end of iterating through unknown headers*/
 
                    /* If Content-Language header is not found,by default it is assumed 
                     * to be English acc to RFC 3261
                     */
                    if(ICF_NULL == pBuffer)
                    {
                        language_supported = ICF_TRUE;
                    }

                    if(ICF_TRUE == language_supported)
                    {    
                        p_ssa_pdb->common_bitmask |= ICF_SSA_SESSION_HANDLING_REQUIRED;
                    }
                    /* If none of the above scenario is satisfied, we would 
                     * now check the handling parameter.If it is "required" or NULL
                     * (in that case it is assumed to be "required" by default acc to RFC 3261)
                     * we will send 415 anf if it is "optional" we will ignore
                     * the SDP and indicate the same to the calling function so that 
                     * this can be treated as a Non Fast Start Call.
                     */
                    else
                    {    
                        if((ICF_NULL == p_param_value) ||
                           (ICF_NULL == icf_port_strcasecmp(p_param_value,"required")))
                        {
                            p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
					    	    	ICF_SSA_FAILURE_RESP_CODE_415;
					        ret_val = ICF_FAILURE;
                        }
                        else if(ICF_NULL == icf_port_strcasecmp(p_param_value,"optional"))
                        {
                            p_ssa_pdb->common_bitmask |= ICF_SSA_SDP_TO_BE_IGNORED;
                        }
                    }/* end of language_supported is false*/
                    /*SPR 18815: Free memory only if not already done*/
                    if(Sdf_co_null != p_sip_param)
                    {   
                      sip_freeSipParam(p_sip_param);
                      p_sip_param = Sdf_co_null;
                    }  
                }/* end of content-disp is "session"*/
            }/* end of handling of Content-Disposition header*/
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
        }/* end if(size != 0)*/
      }/*end if content type is "application/sdp"*/
    }/* end of content type size != 0*/

    /*SPR 18724 Start
	 * Check if ACCEPT ACCEPT-ENCODING and ACCEPT-LANGUAGE attribute 
	 * had been set in the user profile and take those headers from the profile.
	 */
	if(Sdf_co_fail == sdf_listSizeOf(&(p_call_obj->pInitData->slExtraHeadersList),
                       &size2,
                       p_err))
    {   
	    return ICF_FAILURE;
    }    
	(void)sdf_listInitIterator(&(p_call_obj->pInitData->slExtraHeadersList),
            &dListIterator,p_err);

	while(Sdf_co_null != dListIterator.pCurrentElement)
	{
		pTemp = (Sdf_st_configExtraHeaders*)\
			(dListIterator.pCurrentElement->pData);
		
        if(Sdf_co_null == pTemp->pParam->pName)
		{
			(void)sdf_listNext(&dListIterator, p_err);
			continue;
		}
		if(0 ==
                Sdf_mc_strcasecmp((Sdf_ty_s8bit*)"ACCEPT-ENCODING",(Sdf_ty_s8bit*)pTemp->pParam->pName))
		{
			pAcceptEnc = pTemp;
			IndicateAcceptEnc = 1;
		}
		(void)sdf_listNext(&dListIterator, p_err);
	}
   	/*
	 * Check if the SipMessage Has a Content-Encoding Header
	 */
	if(SipFail == sip_getHeaderCount(p_call_obj->pUasTransaction->pSipMsg,
                          SipHdrTypeContentEncoding, 
		                  &dConEncSize, 
                          (SipError*)&(p_err->stkErrCode)))
    {
        return ICF_FAILURE;
    }

	/* If  Content-Encoding Header is present then check for vailidity against
	 * the ACCEPT-ENCODING attribute of the profile
	 */
	if(dConEncSize !=0)
	{
		Sdf_ty_u32bit ctr=0;

		/* If no Accept-Encoding attribute present then form 415 */
		if(IndicateAcceptEnc !=1)
		{
		    p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
    		    ICF_SSA_FAILURE_RESP_CODE_415;

    		ret_val = ICF_FAILURE;
		}

		for(ctr=0;ctr<dConEncSize;ctr++)
		{
			SipHeader dHdr;
			Sdf_ty_s8bit *pEncoding=Sdf_co_null;
			Sdf_ty_u32bit matched=0,sizeval=0;
		
			/*
			 * Extract the Coding value present in the CONTENT-ENCODING header.
			 */
			if (SipFail == sip_getHeaderAtIndex(p_call_obj->pUasTransaction->pSipMsg,
                        SipHdrTypeContentEncoding, &dHdr,\
				(Sdf_ty_u32bit)ctr, (SipError *)&(p_err->stkErrCode)))
			{
    		    return ICF_FAILURE;
			}
            if(SipFail == sip_getEncodingFromContentEncodingHdr(&dHdr,&pEncoding, \
				(SipError*)&(p_err->stkErrCode)))
			{
    		    return ICF_FAILURE;
			}
			sip_freeSipHeader(&dHdr);
			/*
			 * Check the EnCoding in the Content-Encoding against the list of
			 * Codings  set in the
			 * Accept-encoding attribute of the user profile.
			 */
            if((Sdf_co_null != pAcceptEnc) &&
               (Sdf_co_null != pAcceptEnc->pParam))
            {   
               if(SipFail == sip_listSizeOf(&(pAcceptEnc->pParam->slValue),&sizeval, \
			      (SipError*)&(p_err->stkErrCode)))
			   {
    		      return ICF_FAILURE;
			   }
            }   
			for(dIndex=0;dIndex<sizeval;dIndex++)
			{
				Sdf_ty_s8bit *pTempVal=Sdf_co_null;

				if(SipFail == sip_listGetAt(&(pAcceptEnc->pParam->slValue),  \
					(Sdf_ty_u32bit) dIndex,(Sdf_ty_pvoid *)&pTempVal,  \
					(SipError*)&(p_err->stkErrCode)))
				{
    		        return ICF_FAILURE;
				}
				if(Sdf_mc_strcasecmp((Sdf_ty_s8bit*)pEncoding,(Sdf_ty_s8bit*)pTempVal)==0)
				{
					matched=1;
					break;
				}
			}
			if(matched !=1)
			{
                p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
    		             ICF_SSA_FAILURE_RESP_CODE_415;
    		    ret_val = ICF_FAILURE;
			}
			matched=0;
		} /* End of for loop iterating through list of Conent-encoding header */
	}/*End SPR 18724 */
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} 

/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_is_contact_present_in_hdr_list
 ** DESCRIPTION:  This function checks if Contact header present in header_list
 **               and if present then return its header value
 **
 ******************************************************************************/
icf_boolean_t  icf_ssa_is_contact_present_in_hdr_list(
                    icf_ssa_pdb_st   *p_ssa_pdb,
                    icf_uint8_t      **p_p_str,
                    icf_uint8_t      *p_disp_name,
                    icf_uint8_t      *p_tpt_scheme)
{
    icf_header_list_st      *p_header_list = ICF_NULL;
    icf_header_st           *p_hdr = ICF_NULL,*p_prev = ICF_NULL;
    icf_boolean_t           contact_present = ICF_FALSE;
    icf_return_t            ret_val = ICF_SUCCESS;
    icf_list_st             *p_temp_list_node = ICF_NULL;
   
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /*Fetch header list from call context*/
    if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt)
    {
        /*SPR 19590 change start*/
         ret_val = icf_cmn_fetch_curr_hdr_list_node_from_call_ctx(
                    p_ssa_pdb->p_glb_pdb,
                    &p_temp_list_node);
         if((ICF_NULL != p_temp_list_node) && (ICF_NULL != p_temp_list_node->p_data))
         {    
            p_header_list = &(((icf_header_link_list_st*) \
                        (p_temp_list_node->p_data))->header_list);
         }  
        /*SPR 19590 change end*/
    }
    else
    {
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return contact_present;
    }
    if(ICF_NULL != p_header_list)
    {    
       p_hdr = p_header_list->hdr;
       p_prev = p_header_list->hdr;
    }   

    /*Initialize Contact value string*/
    *p_p_str = ICF_NULL;

    while (ICF_NULL != p_hdr)
    {
        /*If contact header is present then return TRUE and the header value*/
        if (0 == sip_strcasecmp((const icf_int8_t *)p_hdr->hdr_name.str, (const icf_int8_t *)"Contact"))
        {
            *p_p_str = icf_port_strdup(p_hdr->hdr_value.str);
            contact_present = ICF_TRUE;
            /*Delete the Contact header node*/
            if (p_hdr == p_prev)
                p_header_list->hdr = p_hdr->next;
            else
                p_prev->next = p_hdr->next;
             p_header_list->count--;

            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, p_hdr, ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)

           /*Parse Contact address*/
             icf_ssa_parse_contact_in_hdr_list(p_ssa_pdb, *p_p_str, p_disp_name, *p_p_str, p_tpt_scheme);

            break;
        }
        p_prev = p_hdr;
        p_hdr = p_hdr->next;
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return contact_present;
}

/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_parse_contact_in_hdr_list
 ** DESCRIPTION:  This function parses contact header value string and fetches
 **               display name and contact address from it
 **
 ******************************************************************************/
icf_return_t  icf_ssa_parse_contact_in_hdr_list(
                      icf_ssa_pdb_st     *p_ssa_pdb, 
                      icf_uint8_t        *p_contact_str,
                      icf_uint8_t        *p_disp_name, 
                      icf_uint8_t        *p_cont_addr,
                      icf_uint8_t        *p_tpt_scheme)
{
     icf_return_t   ret_val = ICF_SUCCESS;
     icf_int8_t    *p_rem_str = ICF_NULL;
     icf_uint8_t    *p_str = ICF_NULL;
     /* CSR_1_7113244 Merged SPR 19672 Start */
     icf_uint8_t    temp_str[ICF_MAX_STR_LEN] = {0};
     /* CSR_1_7113244 Merged SPR 19672 End */
     p_ssa_pdb=p_ssa_pdb;

     if(ICF_NULL == p_ssa_pdb)
     {
        return ICF_FAILURE;
     }    
     ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

     if ((ICF_NULL == p_contact_str) || (ICF_NULL == p_cont_addr))
     {
         ret_val = ICF_FAILURE;
     }
     else
     {
          p_str = icf_port_strchr(p_contact_str, '<');
          
          if (ICF_NULL != p_str) 
          {
              p_rem_str = (icf_int8_t *)(p_str + 1);
              if ('<' == *p_contact_str)
                  p_str = ICF_NULL;
              else
                  *p_str = '\0';
          } 
 
          if (ICF_NULL == p_rem_str)
          {
             /*This case means URI does not contain display name and <> are not present
              *now extract scheme from URI*/
              icf_port_strcpy(temp_str, p_contact_str);

              p_str = (icf_uint8_t *)icf_port_strtokr((icf_int8_t *)temp_str, ":", (char**)&p_rem_str);
              
          if (ICF_NULL == p_rem_str)
              {
                      /*This case means scheme is not present in URI*/
              icf_port_strcpy(p_cont_addr, p_contact_str);
                      icf_port_strcpy(p_tpt_scheme, (icf_uint8_t *)"sip");
              }
              else  if(ICF_NULL == p_str)
              {
                 /* klocwork possible crash removal */
              }
              else if ((0 == icf_port_strcasecmp((const icf_int8_t *)"sip", (const icf_int8_t *)p_str)) ||
                       (0 == icf_port_strcasecmp((const icf_int8_t *)"sips", (const icf_int8_t *)p_str)) ||
                       (0 == icf_port_strcasecmp((const icf_int8_t *)"tel", (const icf_int8_t *)p_str)))
              {
                      /*This case means transport scheme present in URI then copy tpt_scheme and
                       *contact address*/
                      icf_port_strcpy(p_tpt_scheme, p_str);
              icf_port_strcpy((icf_uint8_t *)p_cont_addr, (icf_uint8_t *)p_rem_str);
              }
              else
              {
                      /*This case means port is present in URI*/
              icf_port_strcpy(p_cont_addr, p_contact_str);
                      icf_port_strcpy(p_tpt_scheme, (icf_uint8_t *)"sip");
              }
          }
          else if (ICF_NULL != p_str)
          {
              /*This case means display name is present in URI*/
              /*Copy display name and fetch contact address*/
              icf_port_strcpy(p_disp_name, p_contact_str);
 
              /*Extract URI between < URI >*/
          p_str = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)p_rem_str, (const icf_int8_t *)">");
              
              /*Now extract Scheme from URI*/
              icf_port_strcpy((icf_uint8_t *)temp_str, (icf_uint8_t *)p_rem_str);
              icf_port_strcpy((icf_uint8_t *)p_contact_str, (icf_uint8_t *)p_rem_str);
              
          p_str = (icf_uint8_t *)icf_port_strtokr((icf_int8_t *)temp_str, ":", (char**)&p_rem_str);
              
          if (ICF_NULL == p_rem_str)
              {
                      /*This case means scheme is not present in URI*/
              icf_port_strcpy(p_cont_addr, p_contact_str);
                      icf_port_strcpy(p_tpt_scheme, (icf_uint8_t *)"sip");
              }
             else  if(ICF_NULL == p_str)
             {
                /* klocwork possible crash removal */
             }    
              else if ((0 == icf_port_strcasecmp((const icf_int8_t *)"sip", (const icf_int8_t *)p_str)) ||
                       (0 == icf_port_strcasecmp((const icf_int8_t *)"sips",(const icf_int8_t *)p_str)) ||
                       (0 == icf_port_strcasecmp((const icf_int8_t *)"tel", (const icf_int8_t *)p_str)))
              {
                      /*This case means transport scheme present in URI then copy tpt_scheme and
                       *contact address*/
                      icf_port_strcpy(p_tpt_scheme, p_str);
              icf_port_strcpy(p_cont_addr, p_contact_str);
              }
              else
              {
                      /*This case means port is present in URI*/
              icf_port_strcpy(p_cont_addr, p_contact_str);
                      icf_port_strcpy(p_tpt_scheme, (icf_uint8_t *)"sip");
              }
          }
          else
          {
          p_str = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)p_rem_str, (const icf_int8_t *)">");
              /*Now extract Scheme from URI*/
              icf_port_strcpy((icf_uint8_t *)temp_str, (icf_uint8_t *)p_rem_str);
              icf_port_strcpy((icf_uint8_t *)p_contact_str, (icf_uint8_t *)p_rem_str);
              p_str = (icf_uint8_t *)icf_port_strtokr((icf_int8_t *)temp_str, ":", (char**)&p_rem_str);

              if (ICF_NULL == p_rem_str)
              {
                      /*This case means scheme is not present in URI*/
              icf_port_strcpy(p_cont_addr, p_contact_str);
                      icf_port_strcpy(p_tpt_scheme, (icf_uint8_t *)"sip");
              }
              else  if(ICF_NULL == p_str)
              {
                /* klocwork possible crash removal */
              }
              else if ((0 == icf_port_strcasecmp((const icf_int8_t *)"sip", (const icf_int8_t *)p_str)) ||
                       (0 == icf_port_strcasecmp((const icf_int8_t *)"sips", (const icf_int8_t *)p_str)) ||
                       (0 == icf_port_strcasecmp((const icf_int8_t *)"tel", (const icf_int8_t *)p_str)))
              {
                      /*This case means transport scheme present in URI then copy tpt_scheme and
                       *contact address*/
                      icf_port_strcpy(p_tpt_scheme, p_str);
                      icf_port_strcpy((icf_uint8_t *)p_cont_addr, (icf_uint8_t *)p_rem_str);
              }
              else
              {
                      /*This case means port is present in URI*/
              icf_port_strcpy(p_cont_addr, p_contact_str);
                      icf_port_strcpy(p_tpt_scheme, (icf_uint8_t *)"sip");
              }
          }
     }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;
}

/* Start for DSCP parameter */
icf_return_t  icf_ssa_get_line_id_from_glb_pdb( INOUT   icf_glb_pdb_st   *p_glb_pdb,
                                                INOUT   icf_ssa_ctxt_st       *p_ssa_ctxt,
                                                OUT     icf_line_id_t   * p_line_id,
                                                OUT     icf_error_t      *p_ecode )
{
    icf_return_t           ret_val = ICF_SUCCESS;
    p_glb_pdb = p_glb_pdb;
    p_ecode = p_ecode;
    /* Extract line id from cc call ctxt/sic ctxt/regm ctxt */
    if(ICF_NULL != p_ssa_ctxt->p_call_ctxt)
    {
      *p_line_id = p_ssa_ctxt->p_call_ctxt->line_id;
    }
    else if((ICF_NULL != p_ssa_ctxt->p_rgm_ctxt) && ((p_ssa_ctxt->p_rgm_ctxt->num_of_lines -1) < ICF_MAX_NUM_OF_LINES) && ((p_ssa_ctxt->p_rgm_ctxt->num_of_lines -1) >= 0))
    {
      /* The last line configured for the user under same regm ctx 
         shall be used*/
      *p_line_id =
          p_ssa_ctxt->p_rgm_ctxt->rgm_list_of_lines[p_ssa_ctxt->p_rgm_ctxt->num_of_lines -
          1];
    }
    else if(ICF_NULL != p_ssa_ctxt->p_sic_ctxt)
    {
      *p_line_id = p_ssa_ctxt->p_sic_ctxt->line_id;
    }
    else
    {
      ret_val = ICF_FAILURE;
    }
    return ret_val;
}
/* End for DSCP parameter */
                                               
/*******************************************************************************
 **
 ** FUNCTION:     icf_ssa_del_all_other_call_obj
 ** DESCRIPTION:  This function finds all other call object except for one which is 
 **                passed as paramter. And then forcefully deletes all of them
 ******************************************************************************/
  icf_return_t    icf_ssa_del_all_other_call_obj(
                 INOUT  icf_ssa_pdb_st      *p_ssa_pdb
                 )  
{
    icf_ssa_ctxt_st       *p_ssa_temp_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st  *p_ssa_ret_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st  *p_temp = ICF_NULL;
    Sdf_st_callObject     *p_call_obj = ICF_NULL;
    icf_error_t           p_ecode = 0;
    icf_return_t          ret_val = ICF_SUCCESS;

    if((ICF_NULL == p_ssa_pdb) || (ICF_NULL == p_ssa_pdb->p_ssa_ctxt))
    {
        ICF_PRINT(((icf_uint8_t*)"\[SSA]:SSA PDB/CTX is NULL\n"));
        return ret_val;
    }
    else if(ICF_NULL == p_ssa_pdb->p_glb_pdb)
    {
        ICF_PRINT(((icf_uint8_t *)"\n GLB Pdb is Null \n")); 
        return ICF_FAILURE;
    }
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* CSR 1-6223345: SPR :18865 check if forked_resp_counter is NULL in call context
	 * then don't invoke function to delete other call objects. As more then
	 * one call object will be present in case of forked call
	 */
	if((ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt) && 
				(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->forked_resp_counter))
	{
        /* Keep orignal ssa context */
        p_ssa_temp_ctxt = p_ssa_pdb->p_ssa_ctxt;
        p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;
        p_ssa_pdb->hash_index = 0;
        /* Find the call object need to be deleted*/
        ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(
                      p_ssa_pdb->p_glb_pdb, p_ssa_pdb->p_ssa_ctxt->p_hash_key,
                      (icf_void_t **)&p_ssa_ret_ctxt,&p_ecode);
        if (ICF_SUCCESS == ret_val)
        {
            for (p_temp = p_ssa_ret_ctxt; p_temp != ICF_NULL;)
            {
                if (p_ssa_pdb->p_ssa_ctxt != p_temp->p_ssa_ctxt)
                {
                    p_ssa_pdb->p_ssa_ctxt = p_temp->p_ssa_ctxt;
                    p_temp = p_temp->p_next;
                    icf_ssa_process_forceful_call_clear(p_ssa_pdb);
                    p_ssa_pdb->p_ssa_ctxt = p_ssa_temp_ctxt;
                }
                else
                {
                    p_temp = p_temp->p_next;
                }
            }
        }
    	p_ssa_temp_ctxt = ICF_NULL;

        icf_ssa_remove_ctxt_list_entry(p_ssa_pdb->p_glb_pdb,
                   p_ssa_pdb->p_ssa_ctxt);

	    if ( ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_hash_key)
	    {
	    	ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_ssa_pdb->p_ssa_ctxt->p_hash_key,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
		    p_ssa_pdb->p_ssa_ctxt->p_hash_key = ICF_NULL;
	    }

	    icf_ssa_add_callid_callobj_map(p_ssa_pdb,p_ssa_pdb->p_ssa_ctxt,p_ssa_pdb->p_ecode);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
	return ret_val;
}


/******************************************************************
** FUNCTION: icf_ssa_get_reason_string_from_sip_message
**
** DESCRIPTION:  This function retrives the status code from the
** Sip message
**
******************************************************************/
icf_return_t icf_ssa_get_reason_string_from_sip_message
                                            (SipMessage *pMsg,
                                             SIP_S8bit  **p_reason)
{
        SipStatusLine *pLine = Sdf_co_null;
        en_SipMessageType dType;
        Sdf_st_error      err;
        SIP_S8bit *p_code = ICF_NULL;

        if (sip_getMessageType(pMsg, &dType, (SipError*)&(err.stkErrCode)) \
                ==  SipFail)

       {        err.errCode=Sdf_en_headerManipulationError;
                return Sdf_co_fail;
        }

        if (dType == SipMessageRequest)
        {
                err.errCode=Sdf_en_invalidParamError;
                return Sdf_co_fail;
        }

        /*
         * Extract the status code from the Status line
         */
        if (sip_getStatusLineFromSipRespMsg(pMsg,&pLine,(SipError*)\
                &(err.stkErrCode)) ==  SipFail)
        {
                err.errCode=Sdf_en_headerManipulationError;
                return Sdf_co_fail;
        }
        if (sip_getReasonFromStatusLine(pLine,&p_code,(SipError*)\
                &(err.stkErrCode))  == SipFail)
        {
                sip_freeSipStatusLine(pLine);
                err.errCode=Sdf_en_headerManipulationError;
                return Sdf_co_fail;
        }
      
       *p_reason = p_code;
        
       sip_freeSipStatusLine(pLine);

        err.errCode = Sdf_en_noUaError;
         
        return Sdf_co_success;
}


#ifdef ICF_STAT_ENABLE

/******************************************************************
** FUNCTION: icf_ssa_invite_resp_stats
**
** DESCRIPTION: This function takes the response code and increments
**              the related stats for INBOUND/OUTBOUND INVITE.
**              The direction variable is used to identify the 
**              direction of the request.
**               - direction = 0 for OUTBOUND
**               - direction = 1 for INBOUND
**
******************************************************************/


icf_void_t icf_ssa_invite_resp_stats(INOUT  icf_ssa_pdb_st      *p_ssa_pdb,
                                    IN  icf_uint32_t         response,
                                    IN  icf_boolean_t        direction)
{


    /* direction = 0 for OUTBOUND
       direction = 1 for INBOUND */
     
    if(direction == 0)
    {
            if(response == 100)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                     stat_outbound_invite_resp.stats_100);
            }

            else if(response == 180)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                     stat_outbound_invite_resp.stats_180);
            }
            else if(response == 181)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                     stat_outbound_invite_resp.stats_181);
            }

	    else if(response == 182)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                     stat_outbound_invite_resp.stats_182);
            }
            else if(response == 183)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                     stat_outbound_invite_resp.stats_183);
            }

            else if(response >= 200 &&  response < 300)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                     stat_outbound_invite_resp.stats_2xx);
            }
            /*Fix merged for CSR_1_5417045*/
            else if(response == 300)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_300);
            }

            else if(response == 301)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_301);
            }
            
            else if(response == 302)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_302);
            }

            else if(response == 305)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_305);
            }

            else if(response == 380)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_380);
            }
            else if(response >= 300 && response < 400)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_3xx);
            }

            else if(response == 486)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_486);
            }

            else if(response == 404)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_404);
            }

            else if(response == 415)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_415);
            }

            else if(response == 407)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_407);
            }

            else if(response == 401)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_401);
            }

            else if(response == 491)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_491);
            }

            else if(response == 481)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_481);
            }

            else if(response == 503)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_outbound_invite_resp.stats_503);
            }

            else if(response == 488)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_488);
            }
            
            else if(response == 480)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_480);
            }

            else if(response == 500)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_500);
            }

            else if(response == 403)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_403);
            }

            else if(response == 487)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_487);
            }

            else if(response == 400)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_400);
            }

            else if(response == 420)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_420);
            }

            else if(response == 423)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_423);
            }

            else if(response == 484)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_484);
            }

            else if(response == 485)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_485);
            }
            else if(response == 402)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_402);
            } 
	    
            else if(response == 406)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_406);
            } 

            else if(response == 408)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_408);
            } 

	    else if(response == 409)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_409);
            } 

	    else if(response == 410)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_410);
            } 

	    else if(response == 413)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_413);
            } 

	    else if(response == 482)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_482);
            } 

	    else if(response == 483)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_483);
            } 
	
	    else if(response == 489)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_489);
            }

            else if(response == 501)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_501);
            }

            else if(response == 502)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_502);
            }

            else if(response == 504)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_504);
            }

            else if(response == 505)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_505);
            }

            else if(response == 580)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                      stat_outbound_invite_resp.stats_580);
            }

            else if(response == 600)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_600);
            }

            	    else if(response == 603)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_603);
            }

	    else if(response == 604)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_604);
            }

	    else if(response == 606)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_outbound_invite_resp.stats_606);
            }
            else if(response > 400 && response < 500)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                  stat_outbound_invite_resp.stats_rest_4xx);
            }

            else if(response >500 && response <600)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                 stat_outbound_invite_resp.stats_rest_5xx);
            }

            else if(response >600)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                 stat_outbound_invite_resp.stats_rest_6xx);
            }
    }

    else if(direction == 1)
    {
            if(response == 100)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_100);
            }

            else if(response == 180)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_180);
            }
            else if(response == 181)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_181);
            }

	    else if(response == 182)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_182);
            }
            else if(response == 183)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_183);
            }

            else if(response >= 200 &&  response < 300)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_2xx);
            }

            else if(response >= 300 && response < 400)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_3xx);
            }
            else if(response == 400)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_400);
            }
            else if(response == 486)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_486);
            }

            else if(response == 404)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_404);
            }

            else if(response == 415)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_415);
            }

            else if(response == 407)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_407);
            }

            else if(response == 401)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_401);
            }

            else if(response == 491)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_491);
            }

            else if(response == 481)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_481);
            }

            else if(response == 503)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_503);
            }

            else if(response == 488)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_488);
            }
            
            else if(response == 480)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_480);
            }

            else if(response == 500)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_500);
            }

            else if(response == 403)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_403);
            }

            else if(response == 487)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_487);
            }

            else if(response == 420)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_420);
            }

            else if(response == 423)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_423);
            }

            else if(response == 484)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_484);
            }

            else if(response == 485)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_485);
            }

             	    else if(response == 402)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_402);
            }

 	    else if(response == 406)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_406);
            }

 	    else if(response == 408)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_408);
            }

 	    else if(response == 409)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_409);
            }

 	    else if(response == 410)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_410);
            }

 	    else if(response == 413)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_413);
            }

 	    else if(response == 482)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_482);
            }

 	    else if(response == 483)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_483);
            }

 	    else if(response == 489)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                         stat_inbound_invite_resp.stats_489);
            }

            else if(response == 501)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_501);
            }

            else if(response == 502)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_502);
            }

            else if(response == 504)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_504);
            }

            else if(response == 505)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                        stat_inbound_invite_resp.stats_505);
            }

            else if(response == 580)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_580);
            }

            else if(response == 600)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_600);
            }

      	    else if(response == 603)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_603);
            }

	    else if(response == 604)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_604);
            }

            else if(response == 606)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                       stat_inbound_invite_resp.stats_606);
            }

           

            else if(response >= 400 && response < 500)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                    stat_inbound_invite_resp.stats_rest_4xx);
            }

            else if(response >500 && response <600)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                   stat_inbound_invite_resp.stats_rest_5xx);
            }

            else if(response > 600)
            {
               ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->stat_responses.
                                   stat_inbound_invite_resp.stats_rest_6xx);
            }
    }


}


/******************************************************************
** FUNCTION: icf_ssa_resp_stats
**
** DESCRIPTION: This function takes the response code and increments
**              the related stats for related INBOUND/OUTBOUND 
**              requests except INVITE.
**              The direction variable is used to identify the 
**              direction of the request.
**               - direction = 0 for OUTBOUND
**               - direction = 1 for INBOUND
**
******************************************************************/




icf_void_t icf_ssa_resp_stats(INOUT  icf_ssa_pdb_st      *p_ssa_pdb,
                IN  icf_uint8_t         *p_method,
                            IN  icf_uint32_t         response_code,
                            IN  icf_boolean_t        direction)
{

    if(p_method == ICF_NULL)
     {
         return;
     }
        
    switch(response_code)
    {
        
        case 200: 
                
            if( direction == 0)
        
             {
                    
                if (icf_port_strcmp(p_method,(icf_uint8_t *)"CANCEL") == 0)
                 {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_cancel_resp.stats_200);
                 }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"UPDATE") == 0)
                 {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_update_resp.stats_200);
                  }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                 {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_prack_resp.stats_200);
                 }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_subscribe_resp.stats_200);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"INFO") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                       stat_responses.stat_outbound_info_resp.stats_200);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"BYE") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_outbound_bye_resp.stats_200);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_register_resp.stats_200);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_options_resp.stats_200);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"NOTIFY") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_notify_resp.stats_200);
                }
                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"PUBLISH") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_publish_resp.stats_200);
                }
                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"MESSAGE") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_message_resp.stats_200);
                }
		


            }
            else 
            {
                if (icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"CANCEL") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_cancel_resp.stats_200);
                }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"UPDATE") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_update_resp.stats_200);
                 }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"PRACK") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                         stat_responses.stat_inbound_prack_resp.stats_200);
                }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"NOTIFY") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_notify_resp.stats_200);
                }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"INFO") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                          stat_responses.stat_inbound_info_resp.stats_200);
                }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"BYE") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                          stat_responses.stat_inbound_bye_resp.stats_200);
                }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"OPTIONS") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_options_resp.stats_200);
                }

                else if(icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"MESSAGE") == 0)
                {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_message_resp.stats_200);
                }
		
            }

                break;

        case 202:

                    
            if(direction == 0)

            {
                if (icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                {
                  ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_refer_resp.stats_202);
                }
            }
            else
            {
                if (icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_inbound_refer_resp.stats_202);
                }
            }

            break;

        case 400:

            if(direction == 0)
            {
                if(icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                 {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_refer_resp.stats_400);
                  }
            }

            else

            {
                if (icf_port_strcmp(p_method,(icf_uint8_t *)"CANCEL") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                       stat_responses.stat_inbound_cancel_resp.stats_400);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_prack_resp.stats_400);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_refer_resp.stats_400);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"NOTIFY") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                       stat_responses.stat_inbound_notify_resp.stats_400);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"INFO") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                         stat_responses.stat_inbound_info_resp.stats_400);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"BYE") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                          stat_responses.stat_inbound_bye_resp.stats_400);
                }
                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"MESSAGE") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                          stat_responses.stat_inbound_message_resp.stats_400);
                }
		

            }

            break;

        case 401:

            if(direction == 0)

            {
                if (icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                   stat_responses.stat_outbound_subscribe_resp.stats_401);
                }

                else if (icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_register_resp.stats_401);
                }
            }

            break;

        case 403:

            if(direction == 1)
            {
                if(icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                 {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                       stat_responses.stat_inbound_refer_resp.stats_403);
                 }
            }

            break;

	case 405:
	   if(direction == 1)
	   {
		  ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                                   misc_stats.inbound_req_405);
	   }
	   
	   break;


        case 407:

            if(direction == 0)

              {
                 if (icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_subscribe_resp.stats_407);
                  }

                 else if (icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_register_resp.stats_407);
                   }
                }

                break;

        case 489:

              if(direction == 0)

                {
                    if (icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                     {
                       ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_subscribe_resp.stats_489);
                      }
                }

                break;
                
        case 481:

            if(direction == 0)
            {
                if(icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_refer_resp.stats_481);
                 }
                else if (icf_port_strcmp(p_method,(icf_uint8_t *)"CANCEL") == 0)
                 {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_cancel_resp.stats_other_resp);
                 }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"UPDATE") == 0)
                 {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                 stat_responses.stat_outbound_update_resp.stats_other_resp);
                 }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                 {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                 stat_responses.stat_outbound_prack_resp.stats_other_resp);
                 }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                 {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                 stat_responses.stat_outbound_subscribe_resp.stats_other_resp);
                 }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"INFO") == 0)
                 {
                  ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_info_resp.stats_other_resp);
                 }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"BYE") == 0)
                 {
                  ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_bye_resp.stats_other_resp);
                 }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") == 0)
                  {
                   ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_register_resp.stats_other_resp);
                  }

                 else if(icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_options_resp.stats_other_resp);
                  }
                 
                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PUBLISH") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_publish_resp.stats_other_resp);
                  }
                 
                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"MESSAGE") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_message_resp.stats_other_resp);
                  }
		 

            }

            else

            {
                 if (icf_port_strcmp(p_method,(icf_uint8_t *)"CANCEL") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_inbound_cancel_resp.stats_481);
                  }

                  else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_prack_resp.stats_481);
                   }

                  else if(icf_port_strcmp(p_method,(icf_uint8_t *)"REFER") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                         stat_responses.stat_inbound_refer_resp.stats_481);
                   }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"NOTIFY") == 0)
                    {
                      ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                         stat_responses.stat_inbound_notify_resp.stats_481);
                    }

                    else if(icf_port_strcmp(p_method,(icf_uint8_t *)"INFO") == 0)
                    {
                      ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                           stat_responses.stat_inbound_info_resp.stats_481);
                    }

                    else if(icf_port_strcmp(p_method,(icf_uint8_t *)"BYE") == 0)
                    {
                      ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                             stat_responses.stat_inbound_bye_resp.stats_481);
                     }

                    else if(icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                     {
                       ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_options_resp.stats_481);
                     }
                    else if(icf_port_strcmp(p_method,(icf_uint8_t *)"UPDATE") == 0)
                     {
                       ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_update_resp.stats_481);
                     }
                    else if(icf_port_strcmp(p_method,(icf_uint8_t *)"MESSAGE") == 0)
                     {
                       ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_message_resp.stats_481);
                     }
                    

               }

               break;

        case 500:

            if(direction == 1)

            {
                /* SPR17862 Corrected the method name from PRRACK to PRACK */
                 if (icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                 {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_inbound_prack_resp.stats_500);
                  }
                
                  else if (icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                   stat_responses.stat_inbound_options_resp.stats_other_resp);
                  }
                  /*  CSR 1-5385147 Merge */
                  else if (icf_port_strcmp(p_method,(icf_uint8_t *)"UPDATE") == 0)
                  {
                      ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_inbound_update_resp.stats_500);
                  }
                  else if (icf_port_strcmp(p_method,(icf_uint8_t *)"MESSAGE") == 0)
                  {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                   stat_responses.stat_inbound_message_resp.stats_500);
                   }
                  /* Added for asynchronous NOTIFY support */
                  else if(icf_port_strcmp(p_method,(icf_uint8_t *)"NOTIFY") == 0)
                  {
                      ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                         stat_responses.stat_inbound_notify_resp.stats_500);
                  }
		    }

            else
            {
                  if (icf_port_strcmp(p_method,(icf_uint8_t *)"CANCEL") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_cancel_resp.stats_other_resp);
                    }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_prack_resp.stats_other_resp);
                   }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                        stat_responses.stat_outbound_subscribe_resp.
                                                      stats_other_resp);
                   }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"INFO") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_info_resp.stats_other_resp);
                    }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"BYE") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                      stat_responses.stat_outbound_bye_resp.stats_other_resp);
                   }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                           stat_responses.stat_outbound_register_resp.
                                                        stats_other_resp);
                    }

                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                             stat_responses.stat_outbound_options_resp.
                                                       stats_other_resp);
                   }
                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PUBLISH") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                             stat_responses.stat_outbound_publish_resp.
                                                       stats_other_resp);
                   }
                   else if(icf_port_strcmp(p_method,(icf_uint8_t *)"MESSAGE") == 0)
                   {
                     ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                             stat_responses.stat_outbound_message_resp.
                                                       stats_other_resp);
                   }
            }


                break;

        default:

            if( direction == 0)

             {

                if (icf_port_strcmp(p_method,(icf_uint8_t *)"CANCEL") == 0)
                 {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                   stat_responses.stat_outbound_cancel_resp.stats_other_resp);
                  }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PRACK") == 0)
                 {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                    stat_responses.stat_outbound_prack_resp.stats_other_resp);
                  }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"SUBSCRIBE") == 0)
                 {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                          stat_responses.stat_outbound_subscribe_resp.
                                                        stats_other_resp);
                  }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"INFO") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_info_resp.stats_other_resp);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"BYE") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                     stat_responses.stat_outbound_bye_resp.stats_other_resp);
                 }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"REGISTER") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                           stat_responses.stat_outbound_register_resp.
                                                         stats_other_resp);
                }

                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_options_resp.stats_other_resp);
                 }
                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"PUBLISH") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_publish_resp.stats_other_resp);
                }
                else if(icf_port_strcmp(p_method,(icf_uint8_t *)"MESSAGE") == 0)
                {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                  stat_responses.stat_outbound_message_resp.stats_other_resp);
                }
		
           }

          else
             {
                if (icf_port_strcmp(p_method,(icf_uint8_t *)"OPTIONS") == 0)
                 {
                    ICF_STATS(p_ssa_pdb->p_glb_pdb->p_stats_info->
                   stat_responses.stat_inbound_options_resp.stats_other_resp);
                  }
             }
    }


}

/******************************************************************
** FUNCTION: icf_ssa_stat_dns_type
**
** DESCRIPTION: This function takes the dns query type and increments
**              the stats of related dns query.
**
******************************************************************/


icf_void_t icf_ssa_stat_dns_type(
                      IN     icf_uint32_t       dns_query_type)
{
    switch(dns_query_type)
    {
        case Sdf_en_NAPTRrecord:
              ICF_STATS(p_persistent_glb_pdb->p_stats_info->
                  misc_stats.stats_NAPTR_DNS_QUERY)
        break;

        case Sdf_en_SRVrecord:
              ICF_STATS(p_persistent_glb_pdb->p_stats_info->
                  misc_stats.stats_SRV_DNS_QUERY)
        break;

        case Sdf_en_IPv4Address:
              ICF_STATS(p_persistent_glb_pdb->p_stats_info->
                  misc_stats.stats_AAA_DNS_QUERY)
        break;
    }
}

/******************************************************************
** FUNCTION: icf_ssa_stat_dns_resp_type
**
** DESCRIPTION: This function takes the dns query type and increments
**              the stats of related dns query response. This function
**              is called from sdf_fn_uaProcessQueryRespFromDnsClient
**              for DNS Success or failure response and 
**              icf_ssa_process_timer_expiry in case no response
**              received.
******************************************************************/
icf_void_t icf_ssa_stat_dns_resp_type(
                      IN     icf_uint32_t       dns_query_type,
                      IN     icf_boolean_t      dns_query_resp)
{
    switch(dns_query_type)
    {
        case Sdf_en_NAPTRrecord:
        {
            /*Increment DNS NAPTR response for SUCCESS/FAILURE response*/
            if (ICF_TRUE == dns_query_resp)
            {
                ICF_STATS(p_persistent_glb_pdb->p_stats_info->
                    misc_stats.stats_NAPTR_DNS_SUCCESS_QUERY)
            }
            else
            {
                ICF_STATS(p_persistent_glb_pdb->p_stats_info->
                    misc_stats.stats_NAPTR_DNS_FAILURE_QUERY)
            }
        }
        break;

        case Sdf_en_SRVrecord:
        {
            /*Increment DNS SRV response for SUCCESS/FAILURE response*/
            if (ICF_TRUE == dns_query_resp)
            {
                ICF_STATS(p_persistent_glb_pdb->p_stats_info->
                    misc_stats.stats_SRV_DNS_SUCCESS_RESP)
            }
            else
            {
                ICF_STATS(p_persistent_glb_pdb->p_stats_info->
                    misc_stats.stats_SRV_DNS_FAILURE_RESP)
            }
        }
        break;

        case Sdf_en_IPv4Address:
        {
            /*Increment DNS AA response for SUCCESS/FAILURE response*/
            if (ICF_TRUE == dns_query_resp)
            {
                ICF_STATS(p_persistent_glb_pdb->p_stats_info->
                    misc_stats.stats_AAA_DNS_QUERY_SUCCESS_RESP)
            }
            else
            {
                ICF_STATS(p_persistent_glb_pdb->p_stats_info->
                    misc_stats.stats_AAA_DNS_QUERY_FAILURE_RESP)
            }
        }
        break;
    }
}
#endif



#ifdef ICF_TRACE_ENABLE

/******************************************************************************
 *
 * FUNCTION:        icf_ssa_create_criteria_data
 *
 * DESCRIPTION:     This function is invoked to populate criteria data
 *
 *****************************************************************************/
icf_return_t icf_ssa_create_criteria_data(
        INOUT icf_ssa_pdb_st *p_ssa_pdb)
{
    icf_return_t ret_val = ICF_SUCCESS;
    icf_config_data_st *p_config_data =ICF_NULL;
    icf_trace_criteria_data_st *p_trace_data = ICF_NULL;
    icf_uint32_t     status = ICF_STATUS_CONTINUE;

        ret_val = icf_dbm_get_module_glb_data(
                   p_ssa_pdb->p_glb_pdb,
                   (icf_int_module_id_t)ICF_INT_MODULE_CFG,
                   (icf_void_t *)&p_config_data, p_ssa_pdb->p_ecode);

    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
          ICF_PORT_SIZEOF(icf_trace_criteria_data_st),
          ICF_MEM_COMMON,
          p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_trace_criteria_data,
          ICF_RET_ON_FAILURE,
          p_ssa_pdb->p_ecode,
          ret_val)

    p_trace_data = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_trace_criteria_data;

    p_trace_data->p_calling_party_address =
                &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->remote_party_addr);
   p_trace_data->bitmask |= ICF_TRACE_CALLING_PARTY_ADDR_PRESENT;

    p_trace_data->p_called_party_address =
                &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address);
    p_trace_data->bitmask |= ICF_TRACE_CALLED_PARTY_ADDR_PRESENT;

        p_trace_data->p_local_sip_ip_address =
                                &(p_config_data->self_ip_address);
    p_trace_data->bitmask |= ICF_TRACE_LOCAL_SIP_IP_PRESENT;
    p_trace_data->bitmask |= ICF_TRACE_LOCAL_SIP_PORT_PRESENT;

    icf_dbm_get_line_for_inc_call(
	p_ssa_pdb->p_glb_pdb,
        (icf_boolean_t)(ICF_FALSE),
        &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address),
        &(p_trace_data->line_id),
        &status,
        p_ssa_pdb->p_ecode);	
    p_trace_data->bitmask |= ICF_TRACE_LINE_ID_PRESENT;

    if(ICF_TRANSPORT_TYPE_UDP == p_ssa_pdb->p_ssa_ctxt->transport)
    {
          p_trace_data->call_transport_mode =
                               ICF_CALL_TRANSPORT_MODE_UDP;
    }
    else if(ICF_TRANSPORT_TYPE_TCP == p_ssa_pdb->p_ssa_ctxt->transport)
    {
          p_trace_data->call_transport_mode =
                                 ICF_CALL_TRANSPORT_MODE_TCP;
    }
    else if(ICF_TRANSPORT_TYPE_TLS == p_ssa_pdb->p_ssa_ctxt->transport)
    {
          p_trace_data->call_transport_mode =
                                ICF_CALL_TRANSPORT_MODE_TLS;
    }
    else
    {
          p_trace_data->call_transport_mode =
                                ICF_CALL_TRANSPORT_MODE_UDP;
    }

    p_trace_data->call_direction = ICF_CALL_DIRECTION_INCOMING;
    p_trace_data->bitmask |= ICF_TRACE_CALL_DIR_PRESENT;
    p_trace_data->bitmask |= ICF_TRACE_TRANSPORT_MODE_PRESENT;

    return ret_val;
}

#endif


icf_return_t icf_ssa_append_to_ssa_ctxt_list(icf_ssa_ctxt_list_st *p_source,
        icf_ssa_ctxt_list_st * p_dest)
{
    icf_ssa_ctxt_list_st *p_temp;

    if (p_source == ICF_NULL)
        return ICF_FAILURE;

    for (p_temp = p_source; p_temp->p_next != ICF_NULL;  p_temp = p_temp->p_next);
    p_temp->p_next = p_dest;
    return ICF_SUCCESS;
}


/******************************************************************
** FUNCTION: icf_ssa_cmp_replaces_tags
**
** DESCRIPTION: Compares the to and from tags to identiy a matching 
**              transaction 
**
******************************************************************/
icf_return_t icf_ssa_cmp_replaces_tags(
    icf_ssa_pdb_st *p_ssa_pdb,
    Sdf_st_callObject *pNewCallObject, 
    icf_uint8_t       *p_from_tag,
    icf_uint8_t       *p_to_tag,
    Sdf_st_error *p_sdf_error)
{
    icf_return_t ret_val = ICF_FAILURE;
    SipMessage     *p_temp_msg = Sdf_co_null;
    Sdf_st_commonInfo *pNewCommonInfo = ICF_NULL;
    Sdf_st_callObjectKey *pNewKey = ICF_NULL;
    en_SipMessageType   dMsgType;

    SipHeader *pNewHeaderFrom = Sdf_co_null, 
              *pNewHeaderTo = Sdf_co_null; 

    Sdf_ty_s8bit *pNewTagFrom=Sdf_co_null, 
                 *pNewTagTo=Sdf_co_null; 
    p_ssa_pdb = p_ssa_pdb;


    if (pNewCallObject->pUacTransaction->pSipMsg != Sdf_co_null)
        p_temp_msg = pNewCallObject->pUacTransaction->pSipMsg;
    else
        p_temp_msg = pNewCallObject->pUasTransaction->pSipMsg;


    if(Sdf_co_fail == sdf_ivk_uaGetCommonInfoFromCallObject(pNewCallObject, 
                &pNewCommonInfo,p_sdf_error))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        pNewKey = pNewCommonInfo->pKey;

        pNewHeaderFrom = pNewKey->pLocalAddr;
        pNewHeaderTo = pNewKey->pRemoteAddr;

        if (sip_getTagAtIndexFromFromHdr(pNewHeaderFrom, &pNewTagFrom, 0, \
                    (SipError *)&(p_sdf_error->stkErrCode)) == SipFail)
        {
            ret_val = ICF_FAILURE;
        }
        else if (sip_getTagAtIndexFromFromHdr(pNewHeaderTo, &pNewTagTo, 0, \
                    (SipError *)&(p_sdf_error->stkErrCode)) == SipFail)
        {
            ret_val = ICF_FAILURE;
        }

        sip_getMessageType(p_temp_msg, &dMsgType, 
                (SipError*)&(p_sdf_error->stkErrCode)) ;

        if(((ICF_NULL != pNewTagTo) && (ICF_NULL != p_from_tag)&&
                    (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagTo, (icf_uint8_t *)p_from_tag))) &&
                ((ICF_NULL != p_to_tag) && (ICF_NULL != pNewTagFrom)&&
                 (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagFrom,(icf_uint8_t *) p_to_tag))))
        {
            ret_val = ICF_SUCCESS;
        }
        /*  SPR 19999 - Fix for CSR 1-7473533: SPR 19823
         *  The code has been removed as if replaces header 
         *  is received in INVITE the IPTK must compare the
         *  To tag with Local tag and From tag with Remote tag
         */ 
        
    }/* else... */
    if(pNewCommonInfo)
    {
        sdf_ivk_uaFreeCommonInfo(pNewCommonInfo);
    }
    return ret_val;
}



#ifdef ICF_LOOPBACK_SUPPORT
/******************************************************************
** FUNCTION: icf_ssa_util_cmp_tags
**
** DESCRIPTION: Compares the to and from tags to identiy a matching 
**              transaction 
**
******************************************************************/
icf_return_t icf_ssa_util_cmp_tags(
    icf_ssa_pdb_st *p_ssa_pdb,
    Sdf_st_callObject *pNewCallObject, 
    Sdf_st_callObject *pExistingCallObject, 
    Sdf_st_error *p_sdf_error)
{
  icf_return_t ret_val = ICF_FAILURE;
  SipMessage     *p_temp_msg = Sdf_co_null;
    Sdf_ty_s8bit *p_method = ICF_NULL;
  Sdf_st_commonInfo *pNewCommonInfo = ICF_NULL, 
                    *pExistingCommonInfo = ICF_NULL;
  Sdf_st_callObjectKey *pNewKey = ICF_NULL;
  Sdf_st_callObjectKey *pExistingKey = ICF_NULL;
  en_SipMessageType   dMsgType;

  SipHeader *pNewHeaderFrom = Sdf_co_null, 
            *pExistHeaderFrom = Sdf_co_null,
            *pNewHeaderTo = Sdf_co_null, 
            *pExistHeaderTo = Sdf_co_null;

  Sdf_ty_s8bit *pNewTagFrom=Sdf_co_null, 
               *pExistingTagFrom=Sdf_co_null,
               *pNewTagTo=Sdf_co_null, 
               *pExistingTagTo=Sdf_co_null;
  
  icf_ssa_ctxt_st   *p_ssa_ctxt = ICF_NULL;  

  if (pNewCallObject->pUacTransaction->pSipMsg != Sdf_co_null)
    p_temp_msg = pNewCallObject->pUacTransaction->pSipMsg;
  else
    p_temp_msg = pNewCallObject->pUasTransaction->pSipMsg;

  p_ssa_pdb = p_ssa_pdb;

  if(Sdf_co_fail == sdf_ivk_uaGetCommonInfoFromCallObject(pNewCallObject, 
        &pNewCommonInfo,p_sdf_error))
  {
    ret_val = ICF_FAILURE;
  }
  else if(Sdf_co_fail == sdf_ivk_uaGetCommonInfoFromCallObject(
        pExistingCallObject, 
        &pExistingCommonInfo, p_sdf_error))
  {
    ret_val = ICF_FAILURE;
  }
  else
  {
    pNewKey = pNewCommonInfo->pKey;
    pExistingKey = pExistingCommonInfo->pKey;

    pNewHeaderFrom = pNewKey->pLocalAddr;
    pExistHeaderFrom = pExistingKey->pLocalAddr;
    pNewHeaderTo = pNewKey->pRemoteAddr;
    pExistHeaderTo = pExistingKey->pRemoteAddr;
    sip_getMessageType(p_temp_msg, &dMsgType, 
        (SipError*)&(p_sdf_error->stkErrCode)) ;
/* For backward compatibility of older SIP RFC */

    if (sip_getTagAtIndexFromFromHdr(pNewHeaderFrom, &pNewTagFrom, 0, \
          (SipError *)&(p_sdf_error->stkErrCode)) == SipFail)
    {
      ret_val = ICF_FAILURE;
    }
    else if (sip_getTagAtIndexFromFromHdr(pExistHeaderFrom, 
          &pExistingTagFrom, 0, 
          (SipError *)&(p_sdf_error->stkErrCode)) == SipFail)
    {
      ret_val = ICF_FAILURE;
    }
    else if (sip_getTagAtIndexFromFromHdr(pNewHeaderTo, &pNewTagTo, 0, \
          (SipError *)&(p_sdf_error->stkErrCode)) == SipFail)
    {
      ret_val = ICF_FAILURE;
    }
    else if (sip_getTagAtIndexFromFromHdr(pExistHeaderTo, &pExistingTagTo, 0, \
          (SipError *)&(p_sdf_error->stkErrCode)) == SipFail)
    {
      ret_val = ICF_FAILURE;
    }
    /* Fix for SPR: 19999(Merged CSR 1-7605218: SPR-19997 fixed)*/
    else if ((SipMessageRequest == dMsgType) &&
            ((pExistingTagTo == ICF_NULL) && (pNewTagTo == ICF_NULL)))
    {
        ret_val = ICF_SUCCESS;
    }
    else if ((SipMessageRequest == dMsgType) &&
            ((pExistingTagFrom == ICF_NULL) && (pNewTagFrom == ICF_NULL)))
    {
        p_ssa_ctxt = (icf_ssa_ctxt_st *)(pExistingCallObject->pAppData->pData);
        ret_val = icf_ssa_compare_request_uri(p_ssa_pdb, p_temp_msg,
                p_ssa_ctxt);
    }    
    else if((ICF_NULL != pExistingTagTo) && (ICF_NULL != pNewTagTo))
    {
        if ((ICF_NULL != pExistingTagFrom) && (ICF_NULL != pNewTagFrom))
        {
            if (((ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagTo, (icf_uint8_t *)pExistingTagTo))) &&
                 (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagFrom, (icf_uint8_t *)pExistingTagFrom)))
            {
                ret_val = ICF_SUCCESS;
            }
            else
                ret_val = ICF_FAILURE;
        }
        else if (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagTo, (icf_uint8_t *)pExistingTagTo))
        {
            /* Fix for SPR: 19999(Merged CSR 1-7605218: SPR-19997 fixed)*/
            /*  If it is a request without local tag(To tag) then compare the
             *  Requets-URI of incoming message with the request URI of
             *  outgoing request message. If match found the return SUCCESS
             *  else return FAILURE. */
            if (SipMessageRequest == dMsgType)
            {
                if (ICF_NULL == pNewTagFrom)
                {
                    p_ssa_ctxt = 
                        (icf_ssa_ctxt_st *)(pExistingCallObject->pAppData->pData);
                    ret_val = icf_ssa_compare_request_uri(p_ssa_pdb, p_temp_msg,
                            p_ssa_ctxt);
                }
                else
                {
                    ret_val = ICF_SUCCESS;
                }
            }
            else
            {
                ret_val = ICF_SUCCESS;
            }
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
    }  
    else if((SipMessageResponse == dMsgType)&&
    ((ICF_NULL != pExistingTagFrom) && (ICF_NULL != pNewTagFrom)&&
      ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagFrom, (icf_uint8_t *)pExistingTagFrom)))
    {
      ret_val = ICF_SUCCESS;
    }
    /*special handling for early notify*/
    else if(Sdf_co_success == 
           sdf_ivk_uaGetMethodFromSipMessage(
           p_temp_msg, &p_method, p_sdf_error))
    {
        if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"NOTIFY"))
        {
            /*SPR17542 Added the NULL check for parameters passed into 
              icf_port_strcmp function */
            if ((ICF_NULL != pExistingTagFrom) && (ICF_NULL != pNewTagFrom))
            {   
               if((ICF_NULL == pExistingTagTo) && (ICF_NULL != pNewTagTo)&&
                 (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagFrom, (icf_uint8_t *)pExistingTagFrom)))
                {
                   ret_val = ICF_SUCCESS;
                }
            }  
        }/* if(ICF_NULL == icf_p... */
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"CANCEL"))
        {
            if((ICF_NULL != pExistingTagTo) && (ICF_NULL != pNewTagTo)&&
              (ICF_NULL == icf_port_strcmp((icf_uint8_t *)pNewTagTo,(icf_uint8_t *) pExistingTagTo)))
            {
                ret_val = ICF_SUCCESS;
            }
        }
        else if(ICF_NULL == icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"ACK"))
        {
            if(((ICF_NULL == pExistingTagTo) && (ICF_NULL == pNewTagTo))||
            ((ICF_NULL == pExistingTagFrom) && (ICF_NULL == pNewTagFrom)))
            {
                ret_val = ICF_SUCCESS;
            }
        }
    }/* else if(Sdf_co_success == ... */
  }/* else... */
  if(pNewCommonInfo)
  {
    sdf_ivk_uaFreeCommonInfo(pNewCommonInfo);
  }
  if(pExistingCommonInfo)
  {
    sdf_ivk_uaFreeCommonInfo(pExistingCommonInfo);
  }
  return ret_val;
}/*End icf_ssa_util_cmp_tags*/
#endif


icf_return_t icf_ssa_remove_ctxt_list_entry(icf_glb_pdb_st *p_glb_pdb,
                   icf_ssa_ctxt_st *p_ssa_ctxt)
{
    icf_ssa_ctxt_list_st *p_temp_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st *p_ret_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st *p_hold_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st *p_prev_ctxt = ICF_NULL;
    icf_uint8_t           flag = ICF_FALSE;
    icf_ssa_ctxt_st       *p_tmp_ssa_ctxt = ICF_NULL;
    icf_error_t          ecode;
    icf_return_t         ret_val = ICF_FAILURE;

    ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(p_glb_pdb,
            p_ssa_ctxt->p_hash_key,
            (icf_void_t **)&p_ret_ctxt,&ecode);
    if (ICF_FAILURE == ret_val)
    {
        return ICF_FAILURE;
    }
    for (p_temp_ctxt = p_ret_ctxt; p_temp_ctxt != ICF_NULL; p_temp_ctxt = p_temp_ctxt->p_next)
    {
        if (p_temp_ctxt->p_ssa_ctxt == p_ssa_ctxt)
        {
            flag = ICF_TRUE;
            break;
        }
        p_prev_ctxt = p_temp_ctxt;
    }
    if ((ICF_TRUE == flag) && (ICF_NULL != p_temp_ctxt))
    {
        ICF_PRINT(((icf_uint8_t *)"Got the list context to be deleted." 
                    "Searchin whether any linked node is present"));
        p_hold_ctxt = p_temp_ctxt->p_next;

        if (p_temp_ctxt == p_ret_ctxt)
        {
#ifdef ICF_LOAD_DEBUG
    printf("\nSSA CTXT DE-Allocated: %x %s\n", p_ssa_ctxt,p_ssa_ctxt->p_hash_key);
#endif
            icf_dbm_hash_remove_ssa_ctxt(p_glb_pdb,
                    p_ssa_ctxt->p_hash_key,
                    p_tmp_ssa_ctxt,&ecode);
            if (ICF_NULL != p_hold_ctxt)
            {
                ICF_PRINT(((icf_uint8_t *)"There is another entry present so adding this entry"));
                icf_dbm_hash_add_ssa_ctxt(p_glb_pdb,
                        p_ssa_ctxt->p_hash_key,
                        (icf_void_t *)p_hold_ctxt,&ecode);
            }

            else
            {
                ICF_PRINT(((icf_uint8_t *)"Only one context is there so removing it"));
            }

        }
        else
        {
            ICF_PRINT(((icf_uint8_t *)"Removing only link as it is not the first entry"));
            if (ICF_NULL != p_prev_ctxt)
                p_prev_ctxt->p_next = p_hold_ctxt;
        }
        ICF_MEMFREE(
                p_glb_pdb,
                p_temp_ctxt,
                ICF_MEM_COMMON,
                &ecode,
                ret_val);
    }

    return ret_val;

}


/*****************************************************************************
 * FUNCTION:        icf_ssa_is_update_present_in_allow_hdr
 *
 * DESCRIPTION:     This function checks that whether update
 *                  method is present in the ALLOW header of 
 *                  a received SIP message.
 *
 *****************************************************************************/
Sdf_ty_retVal icf_ssa_is_update_present_in_allow_hdr(SipMessage *p_message,
                                                     icf_glb_pdb_st *p_glb_pdb,
                                                     icf_ssa_ctxt_st **p_ssa_ctxt,
                                                     Sdf_st_error *pErr)
{
    /* CSR 1-6223345: SPR 18865: Initialize allow header*/
    SipHeader dAllowHeader={SipHdrTypeAny,SIP_NULL};
    SIP_S8bit *p_allow_value;
    Sdf_ty_u32bit no_of_allow_headers = 0;
    Sdf_ty_u32bit index =0;
    /* CSR_1_7027627 Merged SPR 19672 Start */
    icf_return_t    ret_val = Sdf_co_fail;
    /* CSR_1_7027627 Merged SPR 19672 End */
    icf_boolean_t	is_update_rcvd = ICF_FALSE;

    if(ICF_NULL == p_glb_pdb)
    {
       ICF_PRINT(((icf_uint8_t *)"p_glb_pdb is null"));
       return ICF_FAILURE; 
    }

    ICF_FUNCTION_ENTER(p_glb_pdb);


    /* Get the Allow headers count and find for UPDATE method in all headers. if 
     * UPDATE method is present in Allow Header then set the flag allowed_value
     * in call context to ICF_UPDATE_ALLOWED_IN_200OK  */
      
    if(sip_getHeader(p_message,
        SipHdrTypeAllow, &dAllowHeader,(SipError*)&(pErr->stkErrCode)) != SipFail)
    {
        /* CSR 1-6188936: SPR : Set the allow header bit
		 * in call context.
		 */
		(*p_ssa_ctxt)->p_call_ctxt->allowed_value |= ICF_ALLOW_HDR_RECEIVED;

        if(sip_getHeaderCount(p_message,SipHdrTypeAllow,
            &no_of_allow_headers,(SipError*)&(pErr->stkErrCode)) != SipFail)
        {
            sip_freeSipHeader(&dAllowHeader);
            for(index = 0;index < no_of_allow_headers;index++)
            {
                if(sip_getHeaderAtIndex(p_message,
                    SipHdrTypeAllow, &dAllowHeader,
                    index, (SipError*)&(pErr->stkErrCode)) != SipFail)
                {
                    if(sip_getMethodFromAllowHdr(&dAllowHeader,&p_allow_value,
                        (SipError*)&(pErr->stkErrCode)) != Sdf_co_fail)
                    {
                        if(strcmp(p_allow_value,"UPDATE") == 0)
                        {
                             /* Setting value of allowed_value to ICF_UPDATE_PRESENT_IN_ALLOW_HDR  */
                             (*p_ssa_ctxt)->p_call_ctxt->allowed_value |= ICF_UPDATE_PRESENT_IN_ALLOW_HDR ; 
                             is_update_rcvd = ICF_TRUE;
                             /* CSR_1_7027627 Merged SPR 19672 Start */
                             ret_val = Sdf_co_success;
                             /* CSR_1_7027627 Merged SPR 19672 End */
                             break;
                        }
                    }
                    sip_freeSipHeader(&dAllowHeader);
                }
            }
        }
        else
        {
            sip_freeSipHeader(&dAllowHeader);
        }
        /* CSR 1-6188936:SPR: Check if update is not present in allow header
	     * then set allow wo update bitmask
         */
	    if(ICF_FALSE == is_update_rcvd)
	    {
		    (*p_ssa_ctxt)->p_call_ctxt->allowed_value |= ICF_ALLOW_HDR_RCVD_WO_UPDATE;
            }
    }

    /* CSR 1-6223345: SPR 18865: If an 'Allow' header is received, the above
	   'for' loop breaks and the memory acquired for it is never freed.
       Thus freeing the memory here.
    */
	if(ICF_TRUE == is_update_rcvd)
	{
		sip_freeSipHeader(&dAllowHeader);
	}

    ICF_FUNCTION_EXIT(p_glb_pdb);
    /* CSR_1_7027627 Merged SPR 19672 Start */
    return ret_val;
   /* CSR_1_7027627 Merged SPR 19672 End */
}


/*****************************************************************************
 * FUNCTION:       icf_ssa_validate_challenge 
 *
 * DESCRIPTION:    This function first checks the nonce value.It returns failure
 * if the new nonce value received is similar to the previous nonce value.
 * 
 * It then checks the ICF_IGNORE_STALE_PARAM_IN_CHALLENGE, if it is set it ignores 
 * the stale parameter.
 *
 * If the bit is not set,it checks if the stale parameter is true in
 * the authentication header, if yes then it returns success else it returns
 * failure.
 *  
 *
 *****************************************************************************/



icf_return_t
icf_ssa_validate_challenge( Sdf_st_callObject               **ppCallObj,
    Sdf_st_overlapTransInfo         *pOverlapTransInfo,
    Sdf_ty_u16bit	             resp_code,
    icf_ssa_pdb_st                   *p_ssa_pdb,
    Sdf_st_error                    *pErr,
    icf_uint8_t                     *p_method)
{
  Sdf_ty_slist                          *p_auth_params_list = ICF_NULL;
  icf_return_t                           ret_val = ICF_FAILURE;
  icf_return_t                           dummy_ret_val = ICF_SUCCESS;
  icf_uint32_t                           loop_list = 0 ;
  en_HeaderType                          header_type=0;
  icf_uint32_t                           list_size = 0;
  Sdf_ty_pvoid                           p_list_member  = ICF_NULL;
  icf_boolean_t                          list_to_be_deleted = ICF_TRUE;
  icf_uint8_t                            *p_temp_unq_string = ICF_NULL,
                                         *p_temp_string = ICF_NULL;
  icf_uint32_t                           temp_len = 0;
  
  /* This field is used as a generic pointer which points to
   * either ssa_ctxt->auth_data_sent or rgm_context->auth_data_sent
   */
  icf_cmn_auth_data_st *p_auth_data_sent = ICF_NULL;

  if((ICF_NULL == ppCallObj) ||
    ((0 != icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"INVITE")) &&
     (0 != icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t *)"BYE")) &&
     (ICF_NULL == pOverlapTransInfo)))
  {
    return ICF_FAILURE;
  }
  /*Changes for CSR_1-5671948*/
  if (ICF_NULL == p_ssa_pdb->p_line_data)
  {
     if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
        p_ssa_pdb->p_glb_pdb, p_ssa_pdb->p_ssa_ctxt->line_id,
        &(p_ssa_pdb->p_line_data), p_ssa_pdb->p_ecode))
     {
         ICF_PRINT(((icf_uint8_t*)"\[SSA]:Failure in fetching line data\n"));
         return ret_val;
     }
  }
/*Changes for CSR_1-5671948*/

  if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt)
  {
      p_auth_data_sent = &(p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt->auth_data_sent); 
  }
  else
  {
      p_auth_data_sent = &(p_ssa_pdb->p_ssa_ctxt->auth_data_sent); 
  }

  /*If the old nonce value in p_auth_data_sent is NULL that means this is the first time
    this request is being challenged. So process it w/o checking nonce/stale values*/

  if(ICF_NULL == p_auth_data_sent->p_nonce)
  {
    return ICF_SUCCESS;
  }

  if(resp_code == 401)
  {
    header_type =  SipHdrTypeWwwAuthenticate;
  }
  else
  {
    header_type = SipHdrTypeProxyAuthenticate;
  }

  ICF_MEMGET(
      p_ssa_pdb->p_glb_pdb,
      ICF_PORT_SIZEOF(Sdf_ty_slist),
      ICF_MEM_COMMON,
      p_auth_params_list,
      ICF_RET_ON_FAILURE,
      p_ssa_pdb->p_ecode,
      dummy_ret_val)
  if(ICF_FAILURE == dummy_ret_val)
  {
      return ICF_FAILURE;
  }

  if (Sdf_co_fail == sdf_listInit(
        p_auth_params_list,
        __sdf_fn_uaFreeAuthenticationParams,
        Sdf_co_false,
        pErr))
  {
    list_to_be_deleted = ICF_FALSE;
  }

  else if (Sdf_co_fail == sdf_ivk_uaGetAuthParams(
        *ppCallObj,
        pOverlapTransInfo,
        p_auth_params_list,
        pErr))
  {
    list_to_be_deleted = ICF_FALSE;
  }

  else 
  {
    sdf_listSizeOf(p_auth_params_list, &list_size, pErr);
    
    /*  SPR 18064 Merge */
    /* 
     * Check if the list_size is 0 which means no 
     * authentication parameters received from peer.
     * In such cases set the bitmask in ssa_pdb for
     * sending response to application indicating 
     * absence of authentication params.
     */
    if(ICF_NULL == list_size)
    {
        p_ssa_pdb->auth_params_pres_in_chal = ICF_FALSE;
        /* Fix for CSR 1-5792548 : SPR 18464 , set the reason code
		   for failure as auth params not received so that correct error
		   cause goes to the application */
        p_ssa_pdb->reason_code_1 = ICF_CAUSE_AUTH_PARAM_NOT_RCVD;
    }
    else
    {
        for (loop_list = 0; loop_list < list_size; loop_list++ )
        {
          /* for loop: begin processing */
          if (Sdf_co_fail == sdf_listGetAt (p_auth_params_list,
                loop_list,
                &p_list_member, 
                pErr))
          {
            continue;
          }
          else
          {
            /* else: auth_params member read safely: processing begins */
    
            if(((Sdf_st_authenticationParams*)(p_list_member))->dHdrType == header_type)
            {
              /* We have found the header type we were looking for:
               * Now copy the challenge and run out of the loop */
          
              /* Compare the new and old nonce values, if same return FAILURE */
    
              if (ICF_NULL != 
                        ((Sdf_st_authenticationParams *)(p_list_member))->pNonce) 
              {
                  p_temp_string =  
                       (icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pNonce;
                        
                  temp_len = icf_port_strlen(p_temp_string);
                  ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                      temp_len+1,
                      ICF_MEM_COMMON, p_temp_unq_string,
                      ICF_DONOT_RET_ON_FAILURE, 
                      p_ssa_pdb->p_ecode, dummy_ret_val)
                  /* Klocwork warning removal*/
                  if(ICF_FAILURE == dummy_ret_val)
                   {
                        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                                    p_auth_params_list,
                                    ICF_MEM_COMMON,
                                    p_ssa_pdb->p_ecode,
                                    dummy_ret_val)
                        return ICF_FAILURE;
                   }
                  else
                   {
                        ICF_KLOCWORK_FALSE_POSITIVE(p_ssa_pdb->p_glb_pdb,
                                                             p_temp_unq_string)
                   }
                  /* unqouting the nonce string */
              sdf_fn_uaUnq((Sdf_ty_s8bit *)p_temp_string,(Sdf_ty_s8bit *) p_temp_unq_string);
    
                  /* Comparing the old and new nonce values */
                  
                  if(0 == icf_port_strcmp(p_temp_unq_string,
                           p_auth_data_sent->p_nonce))
                  {
                          ret_val = ICF_FAILURE;
                  }
                 
                  /* different nonce value received,proceed to check the bit */
                  /*Changes for CSR_1-5671948*/
                   else if(ICF_TRUE != 
                            p_ssa_pdb->p_line_data->ignore_stale_param)
		   {
                      /*Changes for CSR_1-5671948*/
                      /* stale parameter not to be ignored.*/
                      if(ICF_NULL != 
                          ((Sdf_st_authenticationParams *)(p_list_member))->pStale) 
                      {
                      if(icf_port_strcmpi((icf_uint8_t *)((Sdf_st_authenticationParams *)(p_list_member))->pStale,
                             (icf_uint8_t *)"true")==0)
                          {
                              ret_val = ICF_SUCCESS;
                          }
                      }
                  }
                  else
                  {
                      /* nonce is different,stale parameter to be ignored */
                      ret_val = ICF_SUCCESS;
                  }
              }
            }/* if(((Sdf_st_authenticationParams* ....*/
          }/*else for if(Sdf_co_fail == sdf_listGetAt (p_auth_params_list ... */ 
        }
    }
  }
  if(list_to_be_deleted == ICF_TRUE)
  {
    sdf_listDeleteAll(
        p_auth_params_list,
        pErr);
  }
  ICF_MEMFREE(
      p_ssa_pdb->p_glb_pdb,
      p_auth_params_list,
      ICF_MEM_COMMON,
      p_ssa_pdb->p_ecode,
      dummy_ret_val)

  ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
      p_temp_unq_string, 
      ICF_MEM_COMMON, p_ssa_pdb->p_ecode, dummy_ret_val)
 
  return ret_val;
}

/***********************************************************************************
* FUNCTION    :  icf_ssa_validate_join_header_and_get_call_id
*  
* IN          :  icf_ssa_pdb  *p_ssa_pdb
* 	         icf_uint8_t  *join_call_id
*                icf_uint8_t  orig_call_id
* 
* OUTPUT      :  ICF_SUCCESS/ICF_FAILURE
*
* DESCRIPTION :  This function validates whether or not join header can be applied 
*                or not on this call.If any error is found, error is returned else, 
*                internal call id to be joined is returned
************************************************************************************/
icf_return_t  icf_ssa_validate_join_header_and_get_call_id(
                    icf_ssa_pdb_st  *p_ssa_pdb,  icf_call_id_t  *join_call_id,
                    icf_call_id_t orig_call_id )
{

    icf_return_t             ret_val = ICF_SUCCESS;
    Sdf_ty_slist             slMatchedHeadersList, slMatchedHeadersList1;
    Sdf_ty_u32bit            size = 0;
    Sdf_ty_u32bit            size1 = 0;
    SipError                 err = E_NO_ERROR;
    Sdf_ty_s8bit             *p_replaces_call_id = Sdf_co_null;
    Sdf_ty_s8bit             *p_from_tag = Sdf_co_null;
    Sdf_ty_s8bit             *p_to_tag = Sdf_co_null;

    icf_error_t              *p_ecode = p_ssa_pdb->p_ecode;
    icf_ssa_ctxt_st          *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    icf_ssa_ctxt_list_st     *p_ssa_list = ICF_NULL;
    icf_ssa_ctxt_list_st     *p_ssa_temp = ICF_NULL;
    icf_ssa_ctxt_st          *p_mapped_ssa_ctxt = ICF_NULL;
    Sdf_st_callObject        *p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    Sdf_st_error             sdf_err ;
    Sdf_st_error             *p_err = &sdf_err ;
    icf_uint16_t             count=0; 

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    *join_call_id = ICF_INVALID_CALL_ID;
        /* Extract Join header */
        if(Sdf_co_fail == sdf_ivk_uaGetHeaderListByType(p_call_obj->
                    pUasTransaction->slUnprocessedHeaders,SipHdrTypeJoin,
                    &slMatchedHeadersList,&sdf_err))
        {
            /*Remove all elements from the list and free the node data of each node*/
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            return ICF_SUCCESS;
        }/*if(Sdf_co_fail == sdf_ivk_uaGetHeader... */


    /* If replace header too is found, return error as both join and replaces should not be supported */
        else if(Sdf_co_fail == sdf_ivk_uaGetHeaderListByType(p_call_obj->
                    pUasTransaction->slUnprocessedHeaders, SipHdrTypeReplaces,
                    &slMatchedHeadersList1,p_err))
        {
            /*Remove all elements from the list and free the node data of each node*/
            sdf_listDeleteAll(&slMatchedHeadersList1,p_err);                 
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_400;
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        }/*if(Sdf_co_fail != sdf_ivk_uaGetHeader... */

    /* Extract the size of the matched header list */
        else if(Sdf_co_fail == sdf_listSizeOf (&slMatchedHeadersList,
                    &size, p_err))
        {
            /*Remove all elements from the list and free the node data of each node*/
            ICF_PRINT(((icf_uint8_t *)"No Join header found\n"))
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_400;
            ret_val = ICF_FAILURE;
        }/*if(Sdf_co_fail == sdf_listSizeOf... */
        else if(Sdf_co_fail == sdf_listSizeOf (&slMatchedHeadersList1,
                    &size1, p_err))
        {
            /*Remove all elements from the list and free the node data of each node*/
            ICF_PRINT(((icf_uint8_t *)"Join header found\n"))
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_400;
            ret_val = ICF_FAILURE;
        }/*if(Sdf_co_fail == sdf_listSizeOf... */
        else if (size1 >0)
        {
            /*Remove all elements from the list and free the node data of each node*/
            ICF_PRINT(((icf_uint8_t *)"Join header found\n"))
            sdf_listDeleteAll(&slMatchedHeadersList,p_err);
            /*SPR18452 Free above allocated memory slMatchedHeadersList1*/
            sdf_listDeleteAll(&slMatchedHeadersList1,p_err);                 
            p_ssa_ctxt->failure_bitmask |= 
                ICF_SSA_FAILURE_RESP_CODE_400;
            ret_val = ICF_FAILURE;
        }/*if(Sdf_co_fail == sdf_listSizeOf... */

    /* Join header present */
        else if(size > 0)
        {
            SipHeader *p_replaces_hdr;
            Sdf_st_headerList *p_replaces_hdr_list = Sdf_co_null;

            /* Get HeaderList at index 0*/
            if (size > 1)
            {
                /*Remove all elements from the list and free the node data of each node*/
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                *join_call_id = ICF_INVALID_CALL_ID;
                ret_val = ICF_SUCCESS;
            }/*if(Sdf_co_fail != sdf_listGetAt....*/ 
            else if( Sdf_co_fail == sdf_listGetAt(
                        &slMatchedHeadersList,0
                        ,(Sdf_ty_pvoid)&p_replaces_hdr_list,p_err))
            {
                /*Join header has a call ID  which matches with more than one dialog
                  Set the failure bitmask which will send 481 on the network */

                p_ssa_ctxt->failure_bitmask |= 
                    ICF_SSA_FAILURE_RESP_CODE_400;
                ret_val = ICF_FAILURE;
                ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                    return ret_val;
            }/*if( Sdf_co_fail == sdf_listGetAt... */

            /* Extarct the first Join header */
            else if(Sdf_co_fail == sdf_listGetAt(
                        &(p_replaces_hdr_list)->slHeaders,0,
                        (Sdf_ty_pvoid *)&p_replaces_hdr,
                        p_err))
            {
                /*Remove all elements from the list and free the node data of each node*/
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                p_ssa_ctxt->failure_bitmask |= 
                    ICF_SSA_FAILURE_RESP_CODE_400;
                ret_val = ICF_FAILURE;
            }/*if(Sdf_co_fail == sdf_listGetAt... */


            /* Extract the Replaces Call ID from the Join header */
            else if(SipFail == sip_getCallidFromJoinHdr(
                        p_replaces_hdr,
                        &p_replaces_call_id,
                        &err))
            {
                /*Remove all elements from the list and free the node data of each node*/
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                *join_call_id = ICF_INVALID_CALL_ID;
                ret_val = ICF_SUCCESS;
            }/*else if(SipFail == sip_getCallidFromJoinHdr....*/
            else if(SipFail == sip_getFromTagFromReplacesHdr(
                        p_replaces_hdr,
                        &p_from_tag,
                        &err))
            {
                /*Remove all elements from the list and free the node data of each node*/
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                *join_call_id = ICF_INVALID_CALL_ID;
                ret_val = ICF_SUCCESS;
            }/*else if(SipFail == sip_getFromTagFromReplacesHdr...*/
            else if(SipFail == sip_getToTagFromReplacesHdr(
                        p_replaces_hdr,
                        &p_to_tag,
                        &err))
            {
                /*Remove all elements from the list and free the node data of each node*/
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);
                *join_call_id = ICF_INVALID_CALL_ID;
                ret_val = ICF_SUCCESS;
            }/*else if(SipFail == sip_getToTagFromReplacesHdr...*/
            else 
            {
                /*Remove all elements from the list and free the node data of each node*/
                sdf_listDeleteAll(&slMatchedHeadersList,p_err);

                /*Search for a matching SSA context corresponding to the Replaces call ID
                  in the global map between the SSA contexts and network call ID's     */ 

                ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(
                        p_ssa_pdb->p_glb_pdb,(icf_uint8_t *)p_replaces_call_id,
                        (icf_void_t **)&p_ssa_list,p_ecode);
                /*Now checking whether more than one dialog matches or not */
                if(ICF_SUCCESS == ret_val)
                {
#ifdef ICF_LOOPBACK_SUPPORT
                    count = 0;
                    for(p_ssa_temp = p_ssa_list;p_ssa_temp != ICF_NULL; p_ssa_temp = p_ssa_temp->p_next)
                    {
                        if(ICF_SUCCESS == icf_ssa_cmp_replaces_tags(p_ssa_pdb, 
                                    p_ssa_temp->p_ssa_ctxt->p_call_obj, 
                                    (icf_uint8_t *)p_from_tag,(icf_uint8_t *)p_to_tag,p_err))
                        {
                            p_mapped_ssa_ctxt = p_ssa_temp->p_ssa_ctxt;
                            ret_val =  ICF_SUCCESS;
                        }/*if(ICF_SUCCESS == icf_ssa_cmp_replaces_tags....*/
                        count ++;
                    }
                    if(0 == count)
                    {
                        ret_val = ICF_FAILURE;
                    }/*if(ICF_NULL == p_ssa_temp)*/
#else
                    p_mapped_ssa_ctxt = p_ssa_list->p_ssa_ctxt;
                    ret_val =  ICF_SUCCESS;
                    count = 1;
#endif
                }/*if(ICF_SUCCESS == ret_val)*/
                if(ICF_FAILURE == ret_val)
                {
                    /*Treat it as normal call */
                    ICF_PRINT(((icf_uint8_t *)"No matching cotext found\n"))
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_from_tag),p_err);
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_to_tag),p_err);
                    return ICF_SUCCESS;
                }/*if(ICF_FAILURE == ret_val)*/
                else if (ICF_NULL == p_mapped_ssa_ctxt)
                {
                    ICF_PRINT(((icf_uint8_t *)"No matching cotext found\n"))
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_from_tag),p_err);
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_to_tag),p_err);
                    return ICF_SUCCESS;
                }/*if(ICF_FAILURE == ret_val)*/
                else if(count > 1)
                {  
                    /*Join header has a call ID  which matches with more than one dialog
                      Set the failure bitmask which will send 481 on the network      */
#if 0                
                    p_ssa_ctxt->failure_bitmask |= 
                        ICF_SSA_FAILURE_RESP_CODE_481;
                    ret_val = ICF_FAILURE;
#endif
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_from_tag),p_err);
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_to_tag),p_err);
                    ICF_PRINT(((icf_uint8_t *)"More than one contexts found. Treating it as normal call\n"))
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                        return ICF_SUCCESS;
                }/*else if(count > 1)*/
                else if(p_mapped_ssa_ctxt->p_call_ctxt == ICF_NULL)
                {
                    /*Join header has a call ID  which matches with more than one dialog
                      Set the failure bitmask which will send 481 on the network      */
                    p_ssa_ctxt->failure_bitmask |= 
                        ICF_SSA_FAILURE_RESP_CODE_481;
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_from_tag),p_err);
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_to_tag),p_err);
                    ICF_PRINT(((icf_uint8_t *)"This call is not of INVITE. Nothing to be done\n"))
                    ret_val = ICF_FAILURE;
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                    return ret_val;
                }/*else if(p_mapped_ssa_ctxt->p_call_ctxt....*/
                else if(p_mapped_ssa_ctxt->p_call_ctxt-> release_type != ICF_REL_CAUSE_INVALID)
                {
                    /*Join header has a call ID which is in terminated state
                      Set the failure bitmask which will send 603 on the network      */
                    ICF_PRINT(((icf_uint8_t *)"Call is getting released. Failure\n"))

                    p_ssa_ctxt->failure_bitmask |=
                        ICF_SSA_FAILURE_RESP_CODE_603;
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_from_tag),p_err);
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_to_tag),p_err);
                    ret_val = ICF_FAILURE;
                    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                        return ret_val;
                }/*else if(p_mapped_ssa_ctxt->p_call_ctxt->.......*/
                else
                {
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_from_tag),p_err);
                    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_to_tag),p_err);
                    ICF_PRINT(((icf_uint8_t *)"Passed all the cases.\n"))
                    ret_val = ICF_SUCCESS;
                    *join_call_id = p_mapped_ssa_ctxt->p_call_ctxt->call_id;
                    p_mapped_ssa_ctxt->p_call_ctxt->call_to_be_joined = orig_call_id; 

                }/*else */
            }/*if(ICF_FAILURE != ret_val)*/
        }/* else if(size > 0) */
        else
        {
            ret_val = ICF_SUCCESS;
        }
    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_from_tag),p_err);
    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(p_to_tag),p_err);
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
}


/**************************************************************************
FUNCTION   icf_ssa_get_conn_db
Input:  int fd , icf_ssa_tcpm_conn_data_st *
Output: pointer to the table entry if found else NULL

Description:  This is a utility function for searching a connection table entry on key as connection fd
****************************************************************************/


icf_ssa_tcpm_conn_data_st * icf_ssa_get_conn_db (icf_uint32_t fd ,
                                     icf_ssa_tcpm_conn_data_st * p_table)
/* Shall return pointer to connection db */
{
    icf_uint16_t i;
    icf_ssa_tcpm_conn_data_st  *p_ret = ICF_NULL;
    if (ICF_INVALID_SOCKFD == (icf_int16_t)fd)
        return ICF_NULL;
    for (i = 0; i < ICF_MAX_NO_OF_PERSISTENT_CONNECTIONS; i++)
    {
        if (p_table[i].conn_fd == (icf_int16_t)fd)
        {
                /* SPR 19999: In case connection data is found out
                 * the loop should break.
                 */
                p_ret =  &p_table[i];
                break;
        }
    }
    return p_ret;
}

/**************************************************************************
FUNCTION   icf_ssa_get_conn_db_by_ip
Input:  icf_ssa_pdb_st * , icf_ssa_tcpm_conn_data_st *
Output: pointer to the table entry if found else NULL

Description:  This is a utility function for searching a connection table entry on key as destinatioin IP, port and protocol
****************************************************************************/

icf_ssa_tcpm_conn_data_st * icf_ssa_get_conn_db_by_ip (icf_ssa_pdb_st * p_ssa_pdb,
                              icf_ssa_tcpm_conn_data_st * p_table)
{
		/* Returns table entry by matching IP, port and protocol*/
		icf_uint16_t i;
		icf_ssa_tcpm_conn_data_st  *p_ret = ICF_NULL;
		ICF_PRINT(((icf_uint8_t *)"Entering function icf_ssa_get_conn_db_by_ip"));
		for (i = 0; i < ICF_MAX_NO_OF_PERSISTENT_CONNECTIONS; i++)
		{
				if ((strcmp((const icf_int8_t *)p_table[i].peer_ip, p_ssa_pdb->dest_ip) == 0) &&
								(p_table[i].peer_port_num == p_ssa_pdb->dest_port) && 
								(p_table[i].prot_conn_bitmask & p_ssa_pdb->protocol))
				{
						if (p_ssa_pdb->conn_type == ICF_CONN_TYPE_BOTH)
						{
								p_ret =  &p_table[i];
								break;
						}
						else if (p_table[i].prot_conn_bitmask & p_ssa_pdb->conn_type)
						{
								p_ret =  &p_table[i];
								break;
						}
				}
		}
        /*Initialize the bitmask here*/
		if(ICF_NULL != p_ret)
		{
				p_ret->bitmap = ICF_NULL;
		}
		ICF_PRINT(((icf_uint8_t *)"Returning pointer %lu", p_ret));
		return p_ret;
}

/**************************************************************************
FUNCTION   icf_ssa_add_conn_entry
Input:  int fd , icf_ssa_tcpm_conn_data_st *
Output: pointer to the table entry if found else NULL

Description:  This is a utility function for adding a connection table entry on connection fd
****************************************************************************/
icf_ssa_tcpm_conn_data_st *  icf_ssa_add_conn_entry (
        icf_ssa_tcpm_conn_data_st *p_table )/* Shall add entry to connection db table */
{
    icf_uint16_t i;
    icf_ssa_tcpm_conn_data_st  *p_ret = ICF_NULL;

    for (i = 0; i < ICF_MAX_NO_OF_PERSISTENT_CONNECTIONS; i++)
    {
        if (p_table[i].conn_fd == ICF_INVALID_SOCKFD)
        {
            icf_ssa_init_conn_db (&p_table[i]);
            p_ret = &p_table[i];
            break;
        }
    }
    return p_ret;
}
/**************************************************************************
FUNCTION   icf_ssa_remove_conn_entry
Input:  int fd , icf_ssa_tcpm_conn_data_st *
Output: pointer to the table entry if found else NULL

Description:  This is a utility function for adding a connection table entry on connection fd
****************************************************************************/
icf_return_t  icf_ssa_remove_conn_entry ( icf_ssa_pdb_st  *p_ssa_pdb,
        icf_uint32_t fd)/* Shall add entry to connection db table */
{
    icf_uint16_t i;
    icf_return_t ret_val = ICF_FAILURE;
    icf_ssa_tcpm_conn_data_st *p_table =ICF_NULL; 
    p_table = p_ssa_pdb->p_ssa_glb_data->p_ssa_tcpm_conn_db;
    if (ICF_INVALID_SOCKFD == (icf_int16_t)fd)
        return ret_val;
    for (i = 0; i < ICF_MAX_NO_OF_PERSISTENT_CONNECTIONS; i++)
    {
        if (p_table[i].conn_fd == (icf_int16_t)fd)
        {
#ifdef ICF_SECURE_SUPPORT
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_table[i].p_peer_name,
                    ICF_MEM_COMMON, 
                    p_ssa_pdb->p_ecode, ret_val)
#endif
            /* Free memory allocated to p_pending_pdu in function
               icf_ssa_process_nw_msg for buffering the 
               incomplete message received on network.*/

            if (ICF_NULL != p_table[i].p_pending_pdu)
            {
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                     p_table[i].p_pending_pdu,
                     ICF_MEM_COMMON, 
                     p_ssa_pdb->p_ecode, ret_val)
            }
            /*Reinit pending_pdu_length*/
            p_table[i].pending_pdu_length = 0;

            icf_ssa_init_conn_db(&p_table[i]);
            ret_val = ICF_SUCCESS;
            break;
        }
    }
    ICF_SSA_PRINT_ALL_CONNECTION(p_ssa_pdb)
    return ret_val;
}


/**************************************************************************
FUNCTION   icf_ssa_get_msg_type
Input:  Sdf_st_callObject  *
Output: Message type (SipMessageRequest or SipMessageResponse)

Description:  This is a utility function for getting message type from sip message
****************************************************************************/

en_SipMessageType icf_ssa_get_msg_type(icf_ssa_pdb_st *p_ssa_pdb,Sdf_st_callObject  *p_call_obj)
{
    /* Returns msg type of the incoming message */
    en_SipMessageType   dMsgType;
    SipMessage              *p_temp_msg = Sdf_co_null;
    icf_uint8_t      method[ICF_MAX_SIZE_INT_USAGE_STR];
    Sdf_st_error            sdf_error;
    Sdf_st_overlapTransInfo     *p_overlap_trans_info = Sdf_co_null;
    
    /*precondition: check first for Overlap transaction and then UAC ,this is required 
     for precondition UPDATE being recognised as Request and not response because of 
     INVITE transaction. */ 
         
    if((Sdf_co_null != p_ssa_pdb->p_ssa_ctxt->p_call_obj->slOverlapTransInfo.head) &&
       (Sdf_co_null != p_ssa_pdb->p_ssa_ctxt->p_call_obj->slOverlapTransInfo.head->pData)) 
     {
        icf_ssa_get_method_name(p_ssa_pdb->p_ssa_ctxt->bitmask,
                method);
        if (ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_pending_txn)
        {
            p_overlap_trans_info = (Sdf_st_overlapTransInfo*)
                (p_ssa_pdb->p_ssa_ctxt->p_pending_txn);
        }
        else
        {
            p_overlap_trans_info =
           (Sdf_st_overlapTransInfo*)p_ssa_pdb->p_ssa_ctxt->p_call_obj->slOverlapTransInfo.head->pData;
        }
        p_temp_msg = p_overlap_trans_info->pSipMsg;
    }
    else if (p_call_obj->pUacTransaction->pSipMsg != Sdf_co_null)
        p_temp_msg = p_call_obj->pUacTransaction->pSipMsg;
    else if (p_call_obj->pUasTransaction->pSipMsg != Sdf_co_null)
        p_temp_msg = p_call_obj->pUasTransaction->pSipMsg;
    else
    {
    }
    sip_getMessageType(p_temp_msg, &dMsgType, \
            (SipError*)    &(sdf_error.stkErrCode)) ;
    return dMsgType;
}

/**************************************************************************
FUNCTION   icf_ssa_fill_conn_info_from_Via


Description:  This function is used get connection information from VIA header sent by field 
 ****************************************************************************/
 icf_return_t  icf_ssa_fill_conn_info_from_Via(icf_ssa_pdb_st *p_ssa_pdb,
         Sdf_st_callObject  *p_call_obj,
         icf_ssa_tcpm_conn_data_st *p_conn)
{
    /* Function is used to fill port and host address from Via headers sent by field */
    SipHeader dTempHeader;
    icf_return_t ret_val = ICF_SUCCESS;
    Sdf_ty_s8bit *pRemoteIp = Sdf_co_null, *pSentBy = Sdf_co_null;
    Sdf_ty_s8bit *pHostAddress = Sdf_co_null, *pHostPort = Sdf_co_null;
    Sdf_ty_u16bit dPort;
    Sdf_ty_s8bit dTempSentby[Sdf_co_mediumBufferSize]={'\0'};
    Sdf_st_error            err;
    SipMessage      *p_temp_msg = ICF_NULL;
#ifdef ICF_SECURE_SUPPORT
    icf_return_t   dummy_ret_val = ICF_SUCCESS;
#endif
    
    /* Fix For SPR : 19188 (Warning Removal when LOAD_STAT flag in ext_if is ON )*/
    /* In Such scenario ICF_TRACE_ENABLE is false because of which p_ssa_pdb
     * will not be used in FUNCTION_ENTER  or FUNCTION_EXIT*/
    p_ssa_pdb = p_ssa_pdb;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)    
    /* SPR 18803: The function prototype is changed to pass the relevant call object. Earlier
     * the call object present in the ssa context was accessed which was not correctly updated 
     * at the point of calling this function as the function sdf_ivk_uaUpdateCallDetails has
     * been called at later point
     */ 
    ICF_PRINT(((icf_uint8_t *)"Entering function icf_ssa_fill_conn_info_from_Via"));
    /* 
     * If the topmost Via header of the incoming request has the IP/port 
     * set in this profile, the message should be discarded. Else, this 
     * user agent would end up sending a response to itself.
     */
    if (p_call_obj->pUacTransaction->pSipMsg != Sdf_co_null)
        p_temp_msg = p_call_obj->pUacTransaction->pSipMsg;
    else if (p_call_obj->pUasTransaction->pSipMsg != Sdf_co_null)
        p_temp_msg = p_call_obj->pUasTransaction->pSipMsg;
    else
    {
        ICF_PRINT(((icf_uint8_t *)"Neither sip message is in Uac nor in Uas transaction\n"))
        return ICF_FAILURE;
    }

    if(Sdf_co_null == p_temp_msg)
    {
        ICF_PRINT(((icf_uint8_t *)"Neither sip message is in Uac nor in Uas transaction\n"))
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)    
        return ICF_FAILURE;
    }
    else if (SipFail == sip_getHeaderAtIndex(
                p_temp_msg, SipHdrTypeVia,
                &dTempHeader, 0, (SipError*)&(err.stkErrCode)))
    {
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }
    else
    {
        ret_val = ICF_SUCCESS;
    }    

    if (ICF_SUCCESS == ret_val)
    {
        if (SipFail == sip_getSentByFromViaHdr(
                    &dTempHeader, &pSentBy, (SipError*)&(err.stkErrCode)))
        {        
            sip_freeSipHeader(&dTempHeader);
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return ret_val; /*SPR fix 17569*/ 
        }
        else
        {
            ret_val = ICF_SUCCESS;
        }
    }    

    Sdf_mc_strcpy(dTempSentby, pSentBy);

    pHostAddress = Sdf_mc_strtokr(dTempSentby, ":",&pHostPort);

    if (Sdf_co_null == pHostAddress)
    {
         sip_freeSipHeader(&dTempHeader);
         ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
         return ICF_FAILURE;       
    }
    /* resolve the hostname into ip addr */
    if (ICF_SUCCESS == ret_val)
    {
        if (Sdf_co_fail == 
                (sdf_fn_uaGetHostIp(pHostAddress, &pRemoteIp, &err)))
        {
            sip_freeSipHeader(&dTempHeader);
            ret_val = ICF_FAILURE;
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        }
        else
        {
            ret_val = ICF_SUCCESS;
        }
    }
    /* resolve the local hostname into ip addr */
#if 0
    if (ICF_SUCCESS == ret_val)
    {
        if (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME == 
                p_ssa_pdb->p_glb_cfg_data->self_ip_address.addr.addr_type)
        {
            if (Sdf_co_fail == (sdf_fn_uaGetHostIp(
                            p_ssa_pdb->p_glb_cfg_data->self_ip_address.
                            addr.addr.domain.str, 
                            &p_local_ip, 
                            &err)))
            {
                ICF_PRINT(("Error in getting Host IP"));
                sip_freeSipHeader(&dTempHeader);
                ret_val = ICF_FAILURE;
                ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
            }
            else
            {
                ret_val = ICF_SUCCESS;
            }
            icf_port_strcpy(pLocal, p_local_ip);
            sdf_memfree(Sdf_mc_callHandlerMemId, 
                    (Sdf_ty_pvoid*)&(p_local_ip),&err);
        }
        else 
        {
            icf_ssa_convert_to_IP_addr(
                    &(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                    pLocal);
        }
    }
    /* Setting the default port incase port is not found in request */
#endif
    if (pHostPort != NULL)
        dPort = (icf_uint16_t)icf_port_atoi(pHostPort);
    else
        dPort = 5060;
    /* 
     * If the IP/port in the topmost Via header matches with that in the 
     * user profile's transport information, the message should be 
     * discarded 
     */

    /* Free the local reference */
    if (ICF_SUCCESS == ret_val)
    {
        p_conn->peer_port_num = dPort;
#ifdef ICF_SECURE_SUPPORT
        if (ICF_NULL == p_conn->p_peer_name)
    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            (icf_port_strlen((icf_uint8_t *)pHostAddress) + 1),
            ICF_MEM_COMMON,
            p_conn->p_peer_name,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            dummy_ret_val)
        icf_port_strcpy((icf_uint8_t *)p_conn->p_peer_name,
               (icf_uint8_t*) pHostAddress);
#endif
        if (pRemoteIp) icf_port_strcpy(p_conn->peer_ip, (icf_uint8_t *)pRemoteIp);
        ICF_PRINT(((icf_uint8_t *)"IP is %s", p_conn->peer_ip));
        ICF_PRINT(((icf_uint8_t *)"Port is %d", p_conn->peer_port_num));
#ifdef ICF_SECURE_SUPPORT
        if (ICF_NULL != p_conn->p_peer_name)
        ICF_PRINT(((icf_uint8_t *)"Destination name is %s", p_conn->p_peer_name));
#endif
    }
    sip_freeSipHeader(&dTempHeader);
    sdf_memfree(Sdf_mc_callHandlerMemId, (Sdf_ty_pvoid*)&(pRemoteIp),&err);
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*********************************************************************************
 * FUNCTION   icf_ssa_check_isfocus_in_contact_header
 *
 * Description: It checks whether isfocus is present in contact or not.
 *              The function returns ICF_FAILURE if isfocus is absent 
 *              else it returns ICF_SUCCESS.  
 *
 * *****************************************************************************/

icf_return_t  icf_ssa_check_isfocus_in_contact_header(
        icf_ssa_pdb_st    *p_ssa_pdb)
{
    en_HeaderType                 dType = SipHdrTypeAny;
    icf_return_t                  ret_val = ICF_FAILURE;
    icf_uint8_t                   index = 0;
    icf_uint32_t                  dCount = 0;
    SipMessage                    *pSipMsg = ICF_NULL;
    SipError                      sip_err = 0 ;
    /* Rel 8.2 Klocworks fix */
    Sdf_st_error                  sip_err_1 = {0,0,0,"\0"};
    /* Rel 8.2 Klocworks fix end */
    icf_uint8_t                   *p_temp_buff = ICF_NULL;
    icf_uint8_t                   *p_colon_ind = ICF_NULL;
    icf_uint8_t                   is_focus[10] = "isfocus";
    icf_address_st                *p_addr = ICF_NULL;
    Sdf_st_overlapTransInfo       *p_ovtxn = Sdf_co_null;

    if (p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUasTransaction->pSipMsg != 
            Sdf_co_null)
    {
        /* This is for RE-INVITE */
        pSipMsg = p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUasTransaction->pSipMsg;
    }
    else if(ICF_SUCCESS == icf_ssa_fetch_matching_overlap_txn(
                p_ssa_pdb,Sdf_en_update,Sdf_en_transactionReceived,
                p_ssa_pdb->p_ssa_ctxt->p_call_obj,&p_ovtxn))
    {
        /* this leg is for UPDATE method */
        if(p_ovtxn->pSipMsg != Sdf_co_null)
        {   
           pSipMsg = p_ovtxn->pSipMsg;
        }   
    }
    else
    {
        /* This is for 200OK */
        pSipMsg = p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUacTransaction->pSipMsg;
    }

    icf_ssa_get_hdr_type_from_name((icf_uint8_t *)"contact", 
                                   &dType, 
                                   &sip_err);


    /* There can be multiple hdrs for that type */
    if (sip_getHeaderCount(pSipMsg, dType, &dCount, \
                &sip_err) == SipFail)
    {
        return ICF_FAILURE;
    }
    /* Iterate through the list to get all headers of type dType*/
    /* Construct Header from SipMessage */
    if (dCount == 0)
    {
        return ICF_FAILURE;
    }
    /* Codenomicon fixes: CSR 1-7132323: SPR 19484 */
	/* p_temp_buff will be null if this function fails */
    if (SipFail == sip_getHeaderAsStringAtIndex(
						pSipMsg,dType,((SIP_S8bit **)&p_temp_buff), index, &sip_err))
    {
        return ICF_FAILURE;
    }
    if (p_temp_buff != ICF_NULL)
    {
        p_colon_ind = (icf_uint8_t *)icf_port_strstr((const icf_int8_t *)p_temp_buff, (const icf_int8_t *)";");
        if (p_colon_ind != ICF_NULL)
        {
            if (ICF_NULL != icf_port_strstr((icf_int8_t *)p_colon_ind, (icf_int8_t *)is_focus))
            {
                ret_val = ICF_SUCCESS;
            }
            else
            {
                ret_val = ICF_FAILURE;
            }
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
        fast_memfree(0, p_temp_buff, &sip_err);
    }
    else
    {
        ret_val = ICF_FAILURE;
    }
    if (ICF_SUCCESS == ret_val)
    {

        ret_val = icf_ssa_populate_contact_addr(
                p_ssa_pdb,
                pSipMsg,
                &p_addr,
                &sip_err_1) ;
        if (ICF_NULL != p_addr)
        {
            icf_port_memcpy((void *)&p_ssa_pdb->conference_uri,
                    (void *)p_addr, sizeof (p_ssa_pdb->conference_uri));
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_addr,
                    ICF_MEM_COMMON, 
                    p_ssa_pdb->p_ecode, ret_val)
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
    } 
    return ret_val;
}



icf_return_t    icf_ssa_is_alias_present_in_Via(
                 INOUT  SipMessage          *p_sip_msg
                 )
{
    icf_return_t                 ret_val = ICF_FAILURE;    
    icf_uint32_t                 count = 0;
    icf_uint8_t                  index = 0;
    SipParam                     *p_sip_param = SIP_NULL;
    Sdf_ty_s8bit                 *pParamName = SIP_NULL;
    /* Fix for SPR 19933 */
    SipHeader                    hdr = {SipHdrTypeAny,SIP_NULL};
    Sdf_st_error                 sdf_error = {0,0,0,"\0"};
    SipError                     sip_error = E_NO_ERROR;
    /* End of fix for SPR 19933 */
   
    if(SipFail != sip_getHeaderAtIndex(p_sip_msg,SipHdrTypeVia,&hdr,0,\
        &sip_error))
    {
        if(SipFail == sip_getViaParamCountFromViaHdr(&hdr, &count, \
                    (SipError*)&(sdf_error.stkErrCode)))
        {
#ifdef SDF_ERROR
            sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                "Failed to get the Via Param count from Via header of SIP message",\
               &(sdf_error));
#endif
            sdf_error.stkErrCode=Sdf_en_headerManipulationError;
            sip_freeSipHeader(&hdr);
            ret_val = ICF_FAILURE;
        }
        else
        {
            for(;index < count; index++)
            {
                /* get the parameters from Via Header 
                 */
                if(SipFail == sip_getViaParamAtIndexFromViaHdr(&hdr,&p_sip_param,\
                            index,(SipError*)&(sdf_error.stkErrCode)))
                {
#ifdef SDF_ERROR
                    sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                            (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                            "Failed to get the Via Param from Via header from SIP message",&sdf_error);
#endif
                    sdf_error.stkErrCode=Sdf_en_headerManipulationError;
                    sip_freeSipHeader(&hdr);
                    return ICF_FAILURE;

                }
                else if(SipFail == sip_getNameFromSipParam(p_sip_param, &pParamName,\
                            (SipError*)&(sdf_error.stkErrCode)))
                {
#ifdef SDF_ERROR
                    sdf_fn_setError(Sdf_en_majorErrors, Sdf_en_headerManipulationError,\
                            (Sdf_ty_s8bit *)"icf_ssa_get_params_from_Via(): "
                            "Failed to get name from via param of SIP message",&sdf_error);
#endif
                    sdf_error.stkErrCode = Sdf_en_headerManipulationError;
                    sip_freeSipParam(p_sip_param);
                    sip_freeSipHeader(&hdr);
                    return ICF_FAILURE;
                }

                else
                {
                    if(0 == icf_port_strcmp((icf_uint8_t *)pParamName,(icf_uint8_t *)"alias"))
                    {
                        ret_val = ICF_SUCCESS;
                        sip_freeSipParam(p_sip_param);
                        break;
                    }
                }
                sip_freeSipParam(p_sip_param);
            }
        }

    }
    sip_freeSipHeader(&hdr);

    return ret_val;

}

/*******************************************************************************************
 * FUNCTION           icf_ssa_free_list
 *
 *
 * Description:  It frees the entire linked list
 *
 * ***************************************************************************************/

icf_void_t      icf_ssa_free_list(icf_ssa_pdb_st  *p_ssa_pdb, 
        icf_list_st  *p_root)
{
    icf_list_st  *p_temp = ICF_NULL;
    icf_error_t  dummy_ret_val;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    for (; ICF_NULL != p_root; )
    {
        p_temp = p_root;
        p_root = p_root->p_next;
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_temp,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val);
    }
    ICF_PRINT(((icf_uint8_t *)"Exiting icf_ssa_free_list\n"))
}

/*****************************************************************************
 * FUNCTION: 		icf_ssa_form_and_insert_warning_hdr
 *
 * DESCRIPTION:    	This function forms and inserts a warning 
 *                  header into the SIP message passed  to it.
 *****************************************************************************/
icf_return_t icf_ssa_form_and_insert_warning_hdr (
         icf_ssa_pdb_st  *p_ssa_pdb,
         SipMessage 	  *p_sip_msg)
{
    icf_return_t 	         ret_val = ICF_SUCCESS;
    icf_return_t 	         dummy_ret_val = ICF_SUCCESS;
    SipHeader	                 *p_sip_header = SIP_NULL;
    SipError	                 sip_error;
    icf_transport_address_st     self_addr = {{0,{{0,"\0"}}},0};
    icf_uint8_t                  host_name[ICF_MAX_STR_LEN], *p_host_name = ICF_NULL;
    icf_uint8_t                  *p_warning_text = ICF_NULL; 

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
   /* 
    * If the p_warning_text is a blank string,do not 
    * insert the warning header,just return ICF_SUCCESS
    */
    if (0 == p_ssa_pdb->warning_text.str_len || ICF_NULL == p_ssa_pdb->warning_header_code)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Warning Text in Warning Header is not there.\n"));
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }

    icf_port_memset(
            (icf_void_t*)&host_name,
            '\0',
            (icf_uint32_t) ICF_PORT_SIZEOF(ICF_MAX_STR_LEN));

    /* Get glb cfg data, if it is null.*/
    if (ICF_NULL == p_ssa_pdb->p_glb_cfg_data)
    {
       if (ICF_FAILURE == icf_dbm_get_module_glb_data(
                            p_ssa_pdb->p_glb_pdb,
                            ICF_INT_MODULE_CFG,
                            (icf_void_t **)&(p_ssa_pdb->p_glb_cfg_data),
                            p_ssa_pdb->p_ecode))
       {
          ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in fetching glb cfg data for Warning Header.\n"));
          return ret_val;
       }
    }
    /* Get line data, if it is null.*/
    if (ICF_NULL == p_ssa_pdb->p_line_data)
    {
       if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                p_ssa_pdb->p_glb_pdb, p_ssa_pdb->p_ssa_ctxt->line_id,
                &(p_ssa_pdb->p_line_data), p_ssa_pdb->p_ecode))	
       {
          ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure in fetching line data for Warning Header.\n"));
          return ret_val;
       }
    } 
      
    /*If per line self transport then copy address from line_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE == p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_line_data->self_addr),
                        sizeof(icf_transport_address_st));
    }
    else
    {
        icf_port_memcpy(&self_addr, &(p_ssa_pdb->p_glb_cfg_data->self_ip_address),
                        sizeof(icf_transport_address_st));
    }

    if (ICF_FAILURE == icf_cmn_convert_transport_addr_to_string(
                &(self_addr.addr),
                host_name))
    {
        ICF_PRINT(((icf_uint8_t *)"\nFailure in converting IP Addr to String.\n"));
        return ret_val;
    }
    /* 
     * If the p_host_name is a blank string,do not 
     * insert the warning header,just return ICF_SUCCESS
     */
    if ((ICF_NULL == icf_port_strlen(host_name)) 
        ||(ICF_NULL == icf_port_strlen(p_ssa_pdb->warning_text.str)) )
    {
        ICF_SSA_DEBUG(("\[SSA]:Unable to get Host Name or Warning text for Warning Header.\n"));
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }
    else
    {
        ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            icf_port_strlen(host_name) + 1,
            ICF_MEM_COMMON,
            p_host_name,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val)

         ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            icf_port_strlen(p_ssa_pdb->warning_text.str) + 1,
            ICF_MEM_COMMON,
            p_warning_text,
            ICF_DONOT_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val)

        if (ICF_FAILURE == ret_val)
        {
           ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_host_name,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
           return ICF_FAILURE;
        }

        icf_port_strcpy(p_host_name, host_name);
        icf_port_strcpy(p_warning_text,p_ssa_pdb->warning_text.str);
    }
   
    /* Init the unknown hdr */
    if (SipFail == sip_initSipHeader(
                &p_sip_header,SipHdrTypeWarning,&sip_error))
    {
        sip_freeSipHeader(p_sip_header);
        p_sip_header = SIP_NULL;
        ret_val = ICF_FAILURE;
    }
    /* Set the Code in the warning hdr */
    else if (SipFail == sip_setCodeInWarningHdr(
                p_sip_header,p_ssa_pdb->warning_header_code,&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Set the Host into the warning hdr */
    else if (SipFail == sip_setAgentInWarningHdr(
            p_sip_header,(icf_int8_t *)p_host_name,&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Set the Text into the warning hdr */
    else if (SipFail == sip_setTextInWarningHdr(
            p_sip_header,(icf_int8_t *)p_warning_text,&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Insert the warning hdr into the SIP message */
    else if (SipFail == sip_insertHeaderAtIndex(
            p_sip_msg, p_sip_header,0,&sip_error))
    {
        ret_val = ICF_FAILURE;
    }
    /* Free the header memoryr  */
    if (SIP_NULL != p_sip_header)
    {
        sip_freeSipHeader(p_sip_header);
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_sip_header,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
    }
    /*klocwork warning removal*/
    if(ICF_FAILURE == ret_val)
    { 
           ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_host_name,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
           ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_warning_text,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)

           ret_val = ICF_FAILURE;
     }


/* No need to free p_host_name and p_warning_text here, these will be freed by stack.*/
/* 
    if (ICF_NULL != p_host_name)
    {
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_host_name,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
    }

    if (ICF_NULL != p_warning_text)
    {
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_warning_text,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
    }
*/  
  
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}



/*****************************************************************************
 * FUNCTION:        icf_ssa_parse_p_early_media_hdr
 *
 * DESCRIPTION:     This function will parse the Header list present in the  
 *                  sip message for header P-Early-Media.It then parses that 
 *                  header and populates the corresponding value in the call ctxt.
 *****************************************************************************/
icf_boolean_t icf_ssa_parse_p_early_media_hdr(
        icf_ssa_pdb_st   *p_ssa_pdb,
        SipMessage       *p_sip_msg,
        icf_internal_sdp_stream_st *p_int_sdp)
{
    icf_boolean_t         ret_val = ICF_FALSE;

    Sdf_ty_u32bit           iterator=0,count=0;
    SipError                err = 0;
    SipHeader               dHeader = {SipHdrTypeAny,SIP_NULL};
    SIP_S8bit                *p_unk_hdr_name = ICF_NULL;
    icf_config_data_st		*p_config_data = ICF_NULL;
    icf_error_t		   ecode = ICF_ERROR_NONE;
    p_ssa_pdb=p_ssa_pdb;   

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    
    if(ICF_FAILURE == icf_dbm_get_module_glb_data(
                        p_ssa_pdb->p_glb_pdb,
                        (icf_int_module_id_t)ICF_INT_MODULE_CFG,
                        (icf_void_t *)&p_config_data, &ecode))
     {
          return ret_val;
     }

    /*If the P-Early-Media Hdr is already been received, then donot process
     * next P-Early-Media Hdr and if IPTK does not support it also
     */ 
    if((ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx) && 
        (!(ICF_EARLY_MEDIA_HDR_SUPPORTED & 
          p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask_2) && 
          (ICF_CALL_CONFIG_EARLY_MEDIA_HDR_SUPPORTED & p_config_data->default_settings)))
    { 
    /* get the unknown header count */
    if(SipFail == sip_getHeaderCount(
                p_sip_msg,
                SipHdrTypeUnknown,&count,
                &err))
    {
        return ret_val;
    }
    /* Iterate through all the unknown headers*/
    for(iterator=0 ; iterator<count ; iterator++)
    {
        SIP_S8bit  *p_buffer = SIP_NULL ;

        if(SipFail == sip_getHeaderAtIndex(
                    p_sip_msg,
                    SipHdrTypeUnknown, &dHeader,
                    iterator,&err))
        {
            /*In this case we continue to try to fetch other unknown headers*/
            continue;
        }
        if(SipFail == sip_getNameFromUnknownHdr(
                    &dHeader,&p_unk_hdr_name,&err))
        {
            /*In this case we continue to try to fetch other unknown headers*/
            sip_freeSipHeader(&dHeader);
            continue;
        }
        /* Check for the unknown header */
        if(ICF_NULL == sip_strcasecmp(p_unk_hdr_name,"P-Early-Media"))
        {
            icf_uint8_t  *p_token = ICF_NULL;
#ifdef ICF_WITH_MUATK_2_2
            p_buffer = (((SipUnknownHeader *)
                        (dHeader.pHeader))->pStr2);
#else
            p_buffer = (((SipUnknownHeader *)
                        (dHeader.pHeader))->pBody);
#endif
 
            p_token = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)p_buffer,(const icf_int8_t *)",");
            if (ICF_NULL != p_token)
            {

              /* On encountering an id parameter we return SUCCESS */
              if (ICF_NULL == icf_port_strcmp(p_token, (icf_uint8_t *)"sendrecv")) 
              {
                 p_int_sdp->media_mode = ICF_MEDIA_MODE_SEND_RECV;
              }
              else if (ICF_NULL == icf_port_strcmp(p_token, (icf_uint8_t *)"sendonly")) 
              {
                  p_int_sdp->media_mode = ICF_MEDIA_MODE_SEND_ONLY;
              }
              else if (ICF_NULL == icf_port_strcmp(p_token, (icf_uint8_t *)"recvonly")) 
              {
                  p_int_sdp->media_mode = ICF_MEDIA_MODE_RECV_ONLY;
              }
              else if (ICF_NULL == icf_port_strcmp(p_token, (icf_uint8_t *)"inactive")) 
              {
                 p_int_sdp->media_mode = ICF_MEDIA_MODE_INACTIVE;
              }
              else if(ICF_NULL == icf_port_strcmp(p_token, (icf_uint8_t *)"invalid"))
              {
                  p_int_sdp->media_mode = ICF_MEDIA_MODE_INVALID;
              }
              sip_freeSipHeader(&dHeader);
              p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask_2 |= 
                                        ICF_EARLY_MEDIA_HDR_SUPPORTED; 
              
              p_ssa_pdb->common_bitmask |= ICF_SSA_MEDIA_MODE_RECEIVED;
              ret_val = ICF_TRUE;
              break;
            } 

        } 
        sip_freeSipHeader(&dHeader);
    }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


/*****************************************************************************
 * FUNCTION: 	    icf_ssa_form_and_insert_p_early_media_hdr 
 *
 * DESCRIPTION:     This function forms and inserts an P-Early-Media
 *                  header into the SIP message passed  to it
 * 
 *****************************************************************************/
 icf_return_t icf_ssa_form_and_insert_p_early_media_hdr(
         icf_ssa_pdb_st  *p_ssa_pdb,
         SipMessage 	    *p_sip_msg)
{
    icf_return_t 	ret_val = ICF_SUCCESS;
    icf_return_t 	dummy_ret_val = ICF_SUCCESS;
    SipHeader	        *p_sip_header = SIP_NULL;
    SipError	        sip_error;
    icf_internal_list_st	*p_stream_sdp_info_node= p_ssa_pdb->p_glb_pdb->
						p_call_ctx->p_stream_sdp_info;
    icf_stream_sdp_info_st	*p_stream_sdp_info_data = ICF_NULL;
    icf_uint8_t         mode_str[10] = {"\0"}, 
                        media_mode[10] = {"\0"} ;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    while(p_stream_sdp_info_node != NULL)
    {
       	p_stream_sdp_info_data = (icf_stream_sdp_info_st *)
   					(p_stream_sdp_info_node->p_payload);
        
	if(ICF_MEDIA_MODE_INACTIVE == p_stream_sdp_info_data->mm_applied_mode)
	{
	    icf_port_strcpy(media_mode,(icf_uint8_t *)"inactive");
	}
	else if (ICF_MEDIA_MODE_SEND_ONLY == p_stream_sdp_info_data->mm_applied_mode)
	{
            icf_port_strcpy(media_mode,(icf_uint8_t *)"sendonly");
	}
	else if(ICF_MEDIA_MODE_RECV_ONLY ==p_stream_sdp_info_data->mm_applied_mode)
	{
    	    icf_port_strcpy(media_mode,(icf_uint8_t *)"recvonly");
	}
	else if(ICF_MEDIA_MODE_SEND_RECV ==p_stream_sdp_info_data->mm_applied_mode)
	{                
    	    icf_port_strcpy(media_mode,(icf_uint8_t *)"sendrecv");
        }	
	else if(ICF_MEDIA_MODE_INVALID ==p_stream_sdp_info_data->mm_applied_mode)
	{                
    	    icf_port_strcpy(media_mode,(icf_uint8_t *)"invalid");
        }	
        
        if(ICF_NULL != icf_port_strcmp(mode_str, media_mode))
        {
           /* Init the unknown hdr */
          if (SipFail == sip_initSipHeader(
                &p_sip_header,SipHdrTypeUnknown,&sip_error))
          {
             sip_freeSipHeader(p_sip_header);
             ret_val = ICF_FAILURE;
          }
         /* Set the name into the unknown hdr */
          else if (SipFail == sip_setNameInUnknownHdr(
                p_sip_header,(icf_int8_t *)icf_port_strdup((icf_uint8_t*)"P-Early-Media"),&sip_error))
          {
              ret_val = ICF_FAILURE;
          }
         /* Set the contents into the unknown hdr */
          else if (SipFail == sip_setBodyInUnknownHdr(
              p_sip_header, (icf_int8_t *)icf_port_strdup(media_mode),&sip_error))
         {
            ret_val = ICF_FAILURE;
         }
         /* Insert the unknown hdr into the SIP message */
         else if (SipFail == sip_insertHeaderAtIndex(
                 p_sip_msg, p_sip_header,0,&sip_error))
        { 
             ret_val = ICF_FAILURE;
        }
        /* Free the header memoryr  */
        if (SIP_NULL != p_sip_header)
        {
            sip_freeSipHeader(p_sip_header);
            ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                p_sip_header,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                dummy_ret_val)
        }
          p_stream_sdp_info_node = (icf_internal_list_st *)(p_stream_sdp_info_node->p_next);
 
          /*In case the next mode for m-line is same,
           * then donot form the header otherwise form it.
           */ 
          icf_port_strcpy(mode_str, media_mode);
      }
    }
     
    /*Reset the bitmask*/
    p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask_2 &= 
                                         ~(ICF_EARLY_MEDIA_HDR_SUPPORTED); 

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/*****************************************************************************
* Function    : icf_ssa_delete_param_from_addr_spec
*
* Description : This function is a utility function which deletes any parameter
*               from Sip Address Specification.It takes the parameter to be
*               deleted as an argument.
*
******************************************************************************/

icf_return_t icf_ssa_delete_param_from_addr_spec(
    SipAddrSpec *p_addr_spec,
    icf_uint8_t *param)
{
    SipList      *p_list = ICF_NULL;
    icf_uint8_t  index = 0;
    SipError     error;
    icf_uint8_t  param_to_del[ICF_MAX_STR_LEN] = "\0";
    icf_uint8_t  temp_param[ICF_MAX_STR_LEN] = "\0";
    icf_return_t ret_val = ICF_SUCCESS;
    SipListElement *p_temp = ICF_NULL; /*This parameter is used to iterate SipList*/
   
    if(p_addr_spec)
    {
        icf_port_strcpy(param_to_del,param);

        /*if the address if of type SIP or SIPS URI*/ 
        if(SipAddrSipUri == p_addr_spec->dType ||
           SipAddrSipSUri == p_addr_spec->dType)
        {
            p_list = &(p_addr_spec->u.pSipUrl->slParam); 

            /* Fix for SPR:19886 (Merged CSR-1-7329950)*/
            if(ICF_NULL != p_list)
            {            
                /*Initialize p_temp with SipList Head node*/
                p_temp = p_list->head;

                /*iterating through the list, while list node is not NULL or
                 *size is reached*/
                while((ICF_NULL != p_temp) && (index < p_list->size))
                {
                    icf_port_strcpy(temp_param,
                            (icf_uint8_t *)((SipParam*)(p_list->head->pData))->pName);

                    if(0 == icf_port_strcmp(temp_param,param_to_del)) 
                    {
                        /*deleting the parameter*/
                        if(SipFail == sip_listDeleteAt(p_list,index,&error))
                        {
                            ICF_PRINT(((icf_uint8_t *)"[SSA]:Failure In Deleting Paramter\n"));
                            ret_val = ICF_FAILURE;
                            return ret_val;
                        }
                        /*Break the loop when parameter to be deleted is found and 
                         *successfully deleted, it is assumed that parameter of same name
                         *can be found only once in the list, so there is no need to 
                         *iterate further*/
                        break;
                    }
                    /*Increment the index and p_temp to next node when required parameter
                     *is not found yet*/
                    index ++;
                    p_temp = p_temp->next;
                }
            }
        }/*end if SipAddrSipUri == p_addr_spec->dType*/
    }/*end if(p_addr_spec)*/
    else
    {
        /*SipAddrSpec received is Null*/
        ret_val = ICF_FAILURE;
    }
    return ret_val;
}/*end of icf_ssa_delete_param_from_addr_spec */


#ifdef ICF_SESSION_TIMER
/*****************************************************************************
 * FUNCTION: 	 icf_ssa_chk_n_insert_timer_in_supp_hdr
 *
 * DESCRIPTION:  The function checks if the negotiated rerfesher is none for 
 *               incoming INVITE/UPDATE requests (that is the refresher
 *               received from network and the one set by application is
 *               none). In such cases no session timer needs to be started and
 *               hence no session timer related (expiry, refresh method etc) 
 *               information is provided to UATK. UATK if it doesn't
 *               have session timer related information does not send timer in 
 *               supported header so this would be inserted here.
 *                  
 *****************************************************************************/
icf_return_t icf_ssa_chk_n_insert_timer_in_supp_hdr(icf_ssa_pdb_st *p_ssa_pdb)
{
    Sdf_st_callObject      *pCallObj = Sdf_co_null;
    Sdf_ty_refresher       refresher;
    icf_return_t           ret_val = ICF_SUCCESS;
    icf_line_data_st       *p_line_data = ICF_NULL;  
	icf_boolean_t			is_timer_present = ICF_FALSE;
	Sdf_ty_slist            slSupportedList;
	Sdf_ty_u32bit           size = 0,iterator = 0;
	icf_uint8_t             *p_list_element = ICF_NULL;
	Sdf_st_error			sdf_err = {0,0,0,"\0"};    

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if((p_ssa_pdb->p_ssa_ctxt != ICF_NULL) && 
       (p_ssa_pdb->p_ssa_ctxt->p_call_ctxt != ICF_NULL))
    {       
        pCallObj = p_ssa_pdb->p_ssa_ctxt->p_call_obj ;

        icf_dbm_fetch_line_cntxt_blk(p_ssa_pdb->p_glb_pdb,
                         p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->line_id,
                         &p_line_data,
                         p_ssa_pdb->p_ecode);

		/* CSR 1-6250701: Check is Supported header with "timer" is already present in 
		 * Sip Message then don't insert the timer in Supported */
		if (Sdf_co_fail == sdf_ivk_uaReturnSupportedList (
								pCallObj->pUasTransaction->pSipMsg,
								&slSupportedList,&sdf_err))
		{
				ret_val = ICF_FAILURE;
		}
		/* Fetch the size of the list */
		else if (Sdf_co_fail == sdf_listSizeOf(
							&slSupportedList,&size,&sdf_err))
		{
            /* Fix for SPR : 19066*/
            /* Deleting the fetched supportedlist only in the scenario when
             * success is returned by function sdf_ivk_uaReturnSupportedList
             * indicating that supported list is populated by stack correctly*/
            sdf_listDeleteAll(&slSupportedList,&sdf_err);            
			ret_val = ICF_FAILURE;
		}
		/*If list contains elements*/
		else if(size !=0)
		{
			/*Fetch all the entries from the Supported header */
			for(iterator = 0; iterator < size; iterator++)
			{
				if(Sdf_co_fail == sdf_listGetAt(&slSupportedList,
										iterator, (Sdf_ty_pvoid *)&p_list_element,
										&sdf_err))
				{
					ret_val = ICF_FAILURE;
				}
				else
				{
					/*Check if value in "timer" is present in supported list*/
					if (0 == icf_port_strcmp(p_list_element, (icf_uint8_t*)"timer"))
					{
						is_timer_present = ICF_TRUE;
						break;
					}
				}
			}
            /* Fix for SPR : 19066*/
            /* Deleting the fetched supportedlist only in the scenario when
             * success is returned by function sdf_ivk_uaReturnSupportedList
             * indicating that supported list is populated by stack correctly*/
            sdf_listDeleteAll(&slSupportedList,&sdf_err);            
		}
		else
		{
            /* Fix for SPR : 19066*/
            /* Deleting the fetched supportedlist only in the scenario when
             * success is returned by function sdf_ivk_uaReturnSupportedList
             * indicating that supported list is populated by stack correctly*/
            sdf_listDeleteAll(&slSupportedList,&sdf_err);            
			is_timer_present = ICF_FALSE;
		}

        if(ICF_FALSE == is_timer_present)
        {
            if(Sdf_co_success == sdf_ivk_uaGetRefresher(pCallObj,&refresher,
                        (Sdf_st_error*)p_ssa_pdb->p_ecode))
            {
                /* 
                 * If the refresher value is not received from network in
                 * incoming request (INVITE/UPDATE) and 
                 * application has also locally set the refresher to be
                 * none, IPTK would not set an refresher value in the
                 * 200 OK response. In such cases UATK doesn't send "timer" in
                 * supported list of headers. To overcome this issue add "timer" in
                 * header_list present in call context so it would be inserted 
                 * in outgoing message
                 */   
                /* CSR 1-6250701: If configured refresher is None then send "timer" in Supported */
                if(ICF_SESSION_REFRESHER_NONE == 
                        p_line_data->session_timer_refresher)
                {               
#ifdef ICF_SESSION_TIMER

                    SipHeader       *pSupportedHeader = Sdf_co_null;
                    SipError        SipErr;
                    SIP_U32bit      count=0;
                    if (sip_initSipHeader(&pSupportedHeader,SipHdrTypeSupported,\
                                &(SipErr)) == SipFail)
                    {
                        sip_freeSipHeader(pSupportedHeader); 
                        ret_val = ICF_FAILURE;
                    }
                    else if(sip_setOptionInSupportedHdr(pSupportedHeader,
                                sip_strdup("timer",Sdf_mc_initMemId), \
                                &SipErr)==SipFail)
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else if(SipFail == 
			       sip_getHeaderCount(
                       p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUasTransaction->pSipMsg,
                       SipHdrTypeSupported,&count,&SipErr))
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else if (sip_insertHeaderAtIndex(
                                p_ssa_pdb->p_ssa_ctxt->p_call_obj->pUasTransaction->pSipMsg,
                                pSupportedHeader,count, \
                                &(SipErr)) == SipFail)
                    {
                        ret_val = ICF_FAILURE;
                    }
                    /* Freeing the Local reference */

                    /* purify */
                    if(ICF_NULL != pSupportedHeader)
                    {
                        sip_freeSipHeader(pSupportedHeader); 
                        sdf_memfree(Sdf_mc_callHandlerMemId,(Sdf_ty_pvoid *)\
                                &pSupportedHeader, Sdf_co_null); 
                    }
#endif
                }
            }
            else
            {
                ret_val = Sdf_co_fail;
            }
        }
    }
    else
    {
        ret_val = Sdf_co_fail;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
    return ret_val;
}
#endif

/*****************************************************************************
 * FUNCTION:     icf_ssa_remove_port_from_address
 *
 * DESCRIPTION:  The function checks if the port is attached in the address 
 *               it strips the port.
 *                  
 *****************************************************************************/
icf_return_t icf_ssa_remove_port_from_address(
               icf_ssa_pdb_st   *p_ssa_pdb,
               icf_uint8_t      *p_address)
{
     icf_return_t    ret_val = ICF_SUCCESS;
     /* This variable will be used to store the position of 
        pointer */ 
     icf_uint8_t     temp_pos = 0;
     /* This pointer is pointing the initial address of remaining
        string after performing the strchr operation.*/   
     icf_uint8_t     *p_remain_str = ICF_NULL;
     /* Rel 8.2 Klocworks fix */
     icf_string_st   temp_str = {0,"\0"};
     /* Rel 8.2 Klocworks fix end */
     /*SPR18535*/
     p_ssa_pdb = p_ssa_pdb;

     ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

     icf_port_strcpy(temp_str.str,p_address);

     temp_str.str_len = (icf_uint16_t )icf_port_strlen(p_address);

     /* Gets the position of last occurence of the character ':' */ 
     do
     {
         if ( temp_pos < ICF_MAX_STR_LEN)
         {
             p_remain_str = icf_port_strchr(&(temp_str.str[temp_pos]), ':');

             if (ICF_NULL != p_remain_str)
             {
                 temp_pos += (icf_uint16_t)(icf_port_strlen(&(temp_str.str[temp_pos])) -
                         icf_port_strlen(p_remain_str)) + 1;
             }
         }
     } while (ICF_NULL != p_remain_str);

    /* Check that if the substring is numeric then strip it*/
    /* Klockwork warning removal*/
    if (0 != temp_pos && temp_pos < ICF_MAX_STR_LEN)
    {
        if (ICF_TRUE == icf_port_isnumeric(&(temp_str.str[temp_pos])))
        {
            *(p_address + (temp_pos - 1)) = '\0';
        }
    }
    /*If the last position of ":" is larger than 128 bytes return failure*/
    if (temp_pos > ICF_MAX_STR_LEN)
    {
        ret_val = ICF_FAILURE;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
    return ret_val;
}


/*****************************************************************************
 * FUNCTION:        icf_ssa_parse_AcceptHdr_for_supported_Msgbody
 *
 * DESCRIPTION:     This function parse the Accept header of incoming
 *                  SIP message and determines whether the msg body
 *                  present in Accept header is supported by application
 *                  or not.
 *
 *****************************************************************************/
Sdf_ty_retVal icf_ssa_parse_AcceptHdr_for_supported_Msgbody(SipMessage *p_message,
                                                     icf_glb_pdb_st *p_glb_pdb,
                                                     Sdf_st_error *pErr)
{

    SipHeader dAcceptHeader;
    SIP_S8bit *p_accepted_value = ICF_NULL;
    Sdf_ty_u32bit no_of_accept_headers = 0;
    Sdf_ty_u32bit index =0;
    Sdf_ty_retVal retval = Sdf_co_fail;


#ifdef ICF_TRACE_ENABLE
        icf_return_t    ret_val = 0;
#endif


    if(ICF_NULL == p_glb_pdb)
    {
       ICF_PRINT(((icf_uint8_t *)"p_glb_pdb is null"));
       return Sdf_co_fail;
    }
    ICF_FUNCTION_ENTER(p_glb_pdb);

    /* Get the Accept headers count and find for application/sdp content type 
     *  in all the Accept headers.If found in any Accept header,stop the search 
     * and return success fron the function */
      
    if(sip_getHeader(p_message,
        SipHdrTypeAccept, &dAcceptHeader,(SipError*)&(pErr->stkErrCode)) != SipFail)
     {

        if(sip_getHeaderCount(p_message,SipHdrTypeAccept,
            &no_of_accept_headers,(SipError*)&(pErr->stkErrCode)) != SipFail)
           {
             
            sip_freeSipHeader(&dAcceptHeader);

            for(index = 0;index < no_of_accept_headers;index++)
            {

                if(sip_getHeaderAtIndex(p_message,
                    SipHdrTypeAccept, &dAcceptHeader,
                    index, (SipError*)&(pErr->stkErrCode)) != SipFail)
                  {

                    if(sip_getStr1FromCommonHdr(&dAcceptHeader,&p_accepted_value,
                        (SipError*)&(pErr->stkErrCode)) != Sdf_co_fail)
                     {
                                  
                                  if(icf_port_strcmp((icf_uint8_t *)p_accepted_value,(icf_uint8_t *)"application/sdp") == 0)                              
                                    {
                                      retval = Sdf_co_success;
                                      sip_freeSipHeader(&dAcceptHeader);
                                      break;
                                    }                             
		     } 
                     sip_freeSipHeader(&dAcceptHeader);
                }
            }
           }
           else
            {
                sip_freeSipHeader(&dAcceptHeader);
            }
    }
    else /*incoming call getting failed when incoming invite does not contain accept header */
    {
         retval = Sdf_co_success;
    }

    ICF_FUNCTION_EXIT(p_glb_pdb);
    return retval;
}

/*****************************************************************************
 * FUNCTION:        icf_ssa_parse_p_called_party_id_hdr
 *
 * DESCRIPTION:     This function parse the P-Called-Party-Id header of incoming
 *                  SIP message and populates the called party address in call 
 *                  context.
 *                  It also parses any user parameter present and populates the 
 *                  same in call context.
 *
 *****************************************************************************/
icf_return_t  icf_ssa_parse_p_called_party_id_hdr( icf_ssa_pdb_st   *p_ssa_pdb,
				SipMessage       *pSipMessage)

{
	icf_return_t       ret_val = ICF_SUCCESS;
	Sdf_st_error       sdf_error = {0,0,0,"\0"};
	SipHeader          dSipHdr;
	SipCommonHeader    *p_temp = ICF_NULL;

	ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
	/*Call UATK function to get the parsed information in dSipHdr.*/ 
	if(SipFail == sip_getHeader(pSipMessage,
			            SipHdrTypePCalledPartyId,
                        &dSipHdr,
                        (SipError*)&(sdf_error.stkErrCode)))
	{
           ret_val = ICF_FAILURE;
	}
    else
    {
	    p_temp = ((SipCommonHeader *)(dSipHdr.pHeader));

	    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
	        	   ICF_PORT_SIZEOF(icf_address_st),
		           ICF_MEM_COMMON, 
		           p_ssa_pdb->p_glb_pdb->p_call_ctx->p_called_party_id,
		           ICF_DONOT_RET_ON_FAILURE,
                   p_ssa_pdb->p_ecode,
                   ret_val)

 	/*This function populates the p_called_party_id 
	  from the SipAddrSpec structure passed to it.*/
        if(ICF_FAILURE ==
	           icf_ssa_populate_address_from_sip_addr_spec(
                       p_ssa_pdb,
                       p_temp->pAddrSpec,
		               &(p_ssa_pdb->p_glb_pdb->p_call_ctx->local_address)))
        {
		     ret_val = ICF_FAILURE;
        }
        icf_port_memcpy(p_ssa_pdb->p_glb_pdb->p_call_ctx->p_called_party_id,
                        &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address),
                        sizeof(icf_address_st));

        /* This change is being done as part of feature interaction 
         * of User Param Support Enhancement and P-Called-Party-ID support
         * feature.If the incoming INVITE has a P-Called-Party-ID header with
         * a parameter,it will be given to the application in incoming_call_ind.
         * Any such parameter in the Request URI will be overwritten.This is so
         * because P-Called-Party-ID is being given priority over Request URI 
         * and the application is presented with the URI present in this header.
         */

        if(ICF_NULL != icf_port_strchr(
                p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_val.str,
                ';'))
        {
            /* some tag value present in the P-Called-Party-ID header,
             * populate it in call ctxt*/
            icf_uint8_t *p_req_uri_tag = ICF_NULL ;

            p_req_uri_tag = icf_port_strchr(
                        p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->local_address.addr_val.str,';');

            p_req_uri_tag++;
            if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_req_uri_param)
            {
                icf_port_strcpy(
                    p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_req_uri_param->str, p_req_uri_tag);
                    p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_req_uri_param->str_len =
                                icf_port_strlen(p_req_uri_tag);
            }
        }
        /* If no parameter is present in the P-Called-Party-ID header,the parameter
         * present in the Request URI(if present) will be freed and set to ICF_NULL and
         * not given to the application.
         */
        else
        {
            if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_req_uri_param)
            {
                /* Free the param which has been already filled from the Request URI
                 */
                ICF_MEMFREE(
                    p_ssa_pdb->p_glb_pdb,
                    p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_req_uri_param,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
                p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_req_uri_param = ICF_NULL;
            }
        }
        sip_freeSipHeader(&dSipHdr);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb);
    return ret_val;
}

/*****************************************************************************
 * FUNCTION:        icf_ssa_update_dialog_for_sec_addr
 *
 * DESCRIPTION:     This function clears existing dialog and call API handler
 *                  finction to send message again with new call object
 *
 *****************************************************************************/      
icf_return_t    icf_ssa_update_dialog_for_sec_addr(
         icf_ssa_pdb_st      *p_ssa_pdb,
         SipMessage          *p_sip_msg)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st     *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    icf_call_ctx_st     *p_call_ctxt = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt;
    icf_sic_ctx_st      *p_sic_ctxt =  p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt;
    icf_rgm_context_st  *p_regm_ctxt = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt;
    Sdf_ty_s8bit        *p_method = Sdf_co_null, *p_temp_method = ICF_NULL;
    Sdf_st_error        sdf_error  = {0,0,0,"\0"};

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /*Copy rem_servers_tried to ssa pdb so that it can be copied back
     *to new ssa context*/
    p_ssa_pdb->rem_srv_cnt = p_ssa_ctxt->rem_servers_tried;

    /*Mark in p_ssa_pdb to use inactive rem server from ssa context*/
    p_ssa_pdb->common_bitmask |= ICF_SSA_USE_REM_SERVER_INACTIVE;

    if ( ICF_FAILURE == 
        icf_dbm_fetch_line_cntxt_blk(
           p_ssa_pdb->p_glb_pdb, 
           p_ssa_pdb->p_ssa_ctxt->line_id,
           (icf_void_t *)&(p_ssa_pdb->p_line_data),
           p_ssa_pdb->p_ecode))
    {
        ret_val = ICF_FAILURE;
    }
    else if ((ICF_NULL != p_ssa_ctxt->p_rgm_ctxt) &&
        (ICF_FALSE == p_ssa_pdb->p_glb_cfg_data->ims_oprn_flag))
    {
        /*This code part wil be used when REGISTER request is sent directly to
         * registrar not thru proxy
         * 1. If secondary server active is TRUE and this function is called
         * means secondary is not responding as it was found in DNS buffer
         * and not reachable now
         * 2. If it is false means primary was active and not reachable now*/
        if (ICF_TRUE == p_ssa_pdb->p_line_data->sec_registrar_active)
        {
            ICF_SSA_APP_TRACE(p_ssa_pdb,
               ICF_TRACE_SECONDARY_REGISTRAR_NOT_RESPONDING)
        }
        else
        {
            /* Primary registrar was active and has been tried, so 
              * trace for primary registrar not responding */
             ICF_SSA_APP_TRACE(p_ssa_pdb,
               ICF_TRACE_PRIMARY_REGISTRAR_NOT_RESPONDING)

             /*Mark in p_ssa_pdb to use inactive rem server from ssa context*/
             p_ssa_pdb->common_bitmask |= ICF_SSA_USE_REM_SERVER_INACTIVE;
        }
    }
    else if (ICF_NULL != p_ssa_pdb->p_glb_cfg_data->p_dhcp_resp)
    {
        /*This code part wil be used when proxy server address is fetched 
         * from DHCP response, following condition will be true:
         * 1. If secondary server active is TRUE and this function is called
         * means secondary is not responding as it was found in DNS buffer
         * and not reachable now
         * 2. If it is false means primary was active and not reachable now*/
        if (ICF_TRUE == p_ssa_pdb->p_glb_cfg_data->sec_proxy_server_active)
        {
            ICF_SSA_APP_TRACE(p_ssa_pdb,
               ICF_TRACE_SECONDARY_PROXY_NOT_RESPONDING)
        }
        else
        {
            /* Primary proxy was active and has been tried, so 
              * trace for primary proxy not responding */
             ICF_SSA_APP_TRACE(p_ssa_pdb,
               ICF_TRACE_PRIMARY_PROXY_NOT_RESPONDING)

             /*Mark in p_ssa_pdb to use inactive rem server from ssa context*/
             p_ssa_pdb->common_bitmask |= ICF_SSA_USE_REM_SERVER_INACTIVE;
        }
    }
    else
    {
        /*This code part wil be used when request is sent thru proxy which 
         * is configured by application
         * 1. If secondary server active is TRUE and this function is called
         * means secondary is not responding as it was found in DNS buffer
         * and not reachable now
         * 2. If it is false means primary was active and not reachable now*/
        if (ICF_TRUE == p_ssa_pdb->p_line_data->sec_proxy_server_active)
        {
            ICF_SSA_APP_TRACE(p_ssa_pdb,
               ICF_TRACE_SECONDARY_PROXY_NOT_RESPONDING)
        }
        else
        {
            /* Primary proxy was active and has been tried, so 
              * trace for primary proxy not responding */
             ICF_SSA_APP_TRACE(p_ssa_pdb,
               ICF_TRACE_PRIMARY_PROXY_NOT_RESPONDING)

             /*Mark in p_ssa_pdb to use inactive rem server from ssa context*/
             p_ssa_pdb->common_bitmask |= ICF_SSA_USE_REM_SERVER_INACTIVE;
        }
    }
    if (ICF_FAILURE == ret_val)
    { 
        /*Do nothing*/
    }
    else if ( Sdf_co_fail == sdf_ivk_uaGetMethodFromSipMessage(
                p_sip_msg,&p_temp_method,&sdf_error))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        Sdf_mc_strdup(p_method, p_temp_method);

        /*Call forceful call clear on current SSA context as primary is not responding
         *This function will call same process function to create new SSA Context which
         *will send request on secondary server.
         *Here RefCount of Call object is incremented by 1, as its reference is taken in
         *ssa_pdb, which will be freed when this SSA pdb is removed, Also set a bit in 
         *common_bitmask that cal object reference is taken*/

        HSS_LOCKEDINCREF(p_ssa_pdb->p_ssa_ctxt->p_call_obj->dRefCount);

        p_ssa_pdb->p_call_obj_to_dealloc = p_ssa_pdb->p_ssa_ctxt->p_call_obj;

        /*Clear existing dialog with forceful call clear*/
        if (ICF_FAILURE == icf_ssa_process_forceful_call_clear(p_ssa_pdb))
        {
            ret_val = ICF_FAILURE;
        }
        else if (ICF_NULL !=  p_call_ctxt)
        {
             /* SPR 19436: When the call object will be released,
             * it will reset the cross reference of SSA context 
             * inside Call context which is not desired, therefore
             * set the Call context in SSA context as NULL
             */
            p_ssa_pdb->p_ssa_ctxt->p_call_ctxt = ICF_NULL;
            p_ssa_pdb->p_ssa_ctxt = ICF_NULL;
            p_ssa_pdb->p_app_ctxt = p_call_ctxt;
            p_call_ctxt->p_sip_ctx = ICF_NULL;
            /*If it was a call then send INVITE again*/
            ret_val = icf_ssa_process_call_setup(p_ssa_pdb);
        }
        else if (ICF_NULL !=  p_regm_ctxt)
        {
            /* SPR 19436: When the call object will be released,
             * it will reset the cross reference of SSA context 
             * inside Reg context which is not desired, therefore
             * set the Reg context in SSA context as NULL
             */
            p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt = ICF_NULL;
            p_ssa_pdb->p_ssa_ctxt = ICF_NULL;
            p_ssa_pdb->p_app_ctxt = p_regm_ctxt;
            p_regm_ctxt->p_ssa_ctxt = ICF_NULL;
            /*If it was a call then send INVITE again*/
            ret_val = icf_ssa_process_otg_reg_req(p_ssa_pdb);
        }
        else if (ICF_NULL != p_method)
        {
            /* SPR 19436: When the call object will be released,
             * it will reset the cross reference of SSA context 
             * inside SIC context which is not desired, therefore
             * set the SIC context in SSA context as NULL
             */
            p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt = ICF_NULL;
            p_ssa_pdb->p_ssa_ctxt = ICF_NULL;
            p_ssa_pdb->p_app_ctxt = p_sic_ctxt;
            p_sic_ctxt->p_ssa_ctx = ICF_NULL;

             if (0 == icf_port_strcmp((icf_uint8_t*)p_method, (icf_uint8_t*)"SUBSCRIBE"))
             {
                  ret_val = icf_ssa_process_otg_subs_req(p_ssa_pdb);
             }
             else if (0 == icf_port_strcmp((icf_uint8_t*)p_method, (icf_uint8_t*)"MESSAGE"))
             {
                  ret_val = icf_ssa_process_otg_msg_req(p_ssa_pdb);
             }
             else if (0 == icf_port_strcmp((icf_uint8_t*)p_method, (icf_uint8_t*)"PUBLISH"))
             {
                  ret_val = icf_ssa_process_otg_publish_req(p_ssa_pdb);
             }
             else if (0 == icf_port_strcmp((icf_uint8_t*)p_method, (icf_uint8_t*)"OPTIONS"))
             {
                  ret_val = icf_ssa_process_otg_options_req(p_ssa_pdb);
             }
             else
             {
                  ret_val = ICF_FAILURE;
             }
        }
        else
        {
            ret_val = ICF_FAILURE;
        }    
        sdf_memfree(0, (Sdf_ty_pvoid *)&p_method, &sdf_error);
        p_ssa_pdb->common_bitmask |= ICF_SSA_DEALLOCATE_CALL_OBJECT;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)

    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_modify_callobj_profile_for_precondition
 * DESCRIPTION:     This function updates the call object profile for the 
 *                  supported header. The function checks for presence of 
 *                  precondition in the supported header list and deletes the
 *                  same.
 * RETURN VALUE     ICF_SUCCESS or ICF_FAILURE
 ******************************************************************************/

icf_return_t icf_ssa_modify_callobj_profile_for_precondition
(
 INOUT   icf_ssa_pdb_st       *p_ssa_pdb,
 INOUT   Sdf_st_initData      *pInitData,
 OUT     Sdf_st_error         *p_error)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    Sdf_st_listIterator dListIterator;
    /* Rel 8.2 Klocworks fix */
    Sdf_st_error        Err = {0,0,0,"\0"};
    /* Rel 8.2 Klocworks fix end */
    /*To remove warning*/
    p_error = p_error;
    /*SPR18535*/
    p_ssa_pdb = p_ssa_pdb;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    
    /*set list iterator to first element */    
    sdf_listInitIterator(&(pInitData->slExtraHeadersList),
                         &dListIterator,
                         &Err);
    while (Sdf_co_null != dListIterator.pCurrentElement)
    {
        Sdf_st_configExtraHeaders *pTemp = Sdf_co_null;
        en_HeaderType pType = SipHdrTypeAny;
        Sdf_ty_s8bit dTempType[Sdf_co_characterBufferSize]="";
        
        pTemp = (Sdf_st_configExtraHeaders*)\
            (dListIterator.pCurrentElement->pData);
    
        Sdf_mc_strcpy(dTempType,pTemp->pParam->pName);
        if (icf_port_strlen((icf_uint8_t*)dTempType) < Sdf_co_characterBufferSize - 2)
        {
            /* Max length - 2 
             * (1 for NULL) +
             * (1 for ":" to be appended) */
            icf_port_strcat((icf_uint8_t*)dTempType,(icf_uint8_t*)":");
            dTempType[icf_port_strlen((icf_uint8_t*)dTempType)] = '\0';
        }
        /*
        * Invoke stack API to convert the Header name into the stacks
        * en_HeaderType enumeration
        */
        if(SipFail == sip_getTypeFromString(dTempType,
                                            &pType, 
                                            (SipError*)&(Err.stkErrCode)))
        {
            Err.errCode = Sdf_en_headerManipulationError;
            ret_val = ICF_FAILURE;
        }
        /*If header type is "supported" then check for
          presence of "precondition" in it. If present
          then delete the same from list */
        if(pType == SipHdrTypeSupported)
        {
            Sdf_ty_u32bit size,index;
            
            sip_listSizeOf(&(pTemp->pParam->slValue),
                           &size, 
                           (SipError*)&(Err.stkErrCode));
            
            for (index = 0; index < size; index++)
            {
                Sdf_ty_s8bit *pTempVal = Sdf_co_null;
                
                if (SipFail == sip_listGetAt(&(pTemp->pParam->slValue), 
                                  (Sdf_ty_u32bit) index,
                                  (Sdf_ty_pvoid *)&pTempVal,
                                  (SipError*)&(Err.stkErrCode)))
                {
                    Err.errCode=Sdf_en_extraHeaderAccessError;
                    ret_val = ICF_FAILURE;
                }
                
                if(Sdf_mc_strcmp(pTempVal,"precondition") == 0)
                {
                    /* Remove this parameter from the header list
                     */
                    sip_listDeleteAt (&(pTemp->pParam->slValue),
                                      index, 
                                      (SipError*)&(Err.stkErrCode));
                    ret_val = ICF_SUCCESS;
                    break;
                }
            }/* End of for loop of supported/require header values.*/
        }

        sdf_listNext(&dListIterator, &Err);
    }/* End of while */
        
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/*********************************************************
** FUNCTION: icf_ssa_handle_chal_resp
**
** DESCRIPTION: This Function handles Challange response for
**              the request origionated in call 
**              
**
**********************************************************/
Sdf_ty_retVal icf_ssa_handle_chal_resp(
        Sdf_st_callObject               **ppCallObj,
        Sdf_st_eventContext             *pEventContext, 
        Sdf_st_overlapTransInfo         *pOverlapTransInfo,
        Sdf_ty_u16bit                    dRespCode, 
        Sdf_st_error                    *pErr)
{
    icf_ssa_pdb_st       *p_ssa_pdb = ICF_NULL;
    icf_boolean_t    authenticate_req = ICF_TRUE;
    icf_ssa_ctxt_st  *p_ssa_ctxt = ICF_NULL;
    icf_return_t      ret_val = ICF_SUCCESS;
    en_HeaderType       header_type = 0; 

    /* Extract the pointer to SSA CTXT from the event context */
    p_ssa_ctxt = (icf_ssa_ctxt_st *)(pEventContext->pData);
    /* Extract the pointer to SSA PDB from the event context */
    p_ssa_pdb = (icf_ssa_pdb_st*)(p_ssa_ctxt->p_ssa_pdb);
    p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) /* function entry trace */
    
    if(ICF_FAILURE == icf_ssa_validate_challenge(ppCallObj,
                             pOverlapTransInfo,
                             dRespCode,p_ssa_pdb,pErr,p_ssa_pdb->p_method))
    {
        authenticate_req = ICF_FALSE;
    }
    /*  SPR 19999 : CSR 1-7618644
     *  If NOTIFY has already been challenged the fail  the successive
     *  authentication request to avoid the loop of NOTIFY:401/407.
     */
    else if(ICF_NULL != (ICF_NOTIFY_AUTHENTICATION_REQ & 
	   p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask_2))
    {
        authenticate_req = ICF_FALSE;
        /* Fix for SPR:20110*/
        /* Do not set the value of ret_val as failure. For handling the
         * multiple challenge of NOTIFY request we have set the value of
         * authenticate_req variable as FALSE. As a result of this we will not
         * enter the code leg where we have called the function
         * icf_ssa_send_authorized_req. As a result authorised_req variable in
         * ssa_pdb will false which is used by the calling function
         * sdf_cbk_uaTransactionCompleted to handle this scenario.*/
        /*ret_val = ICF_FAILURE;*/
    }
     
    if(dRespCode == 401)
    { 
        header_type =  SipHdrTypeWwwAuthenticate;
    }
    else
    {  
        header_type = SipHdrTypeProxyAuthenticate;
    } 

    if(ICF_TRUE == authenticate_req)
    {
	 icf_ssa_fetch_auth_param_list(p_ssa_pdb,
			 ppCallObj,pOverlapTransInfo);

	 /* If list is not null and auth param are configured on line
	  * send bye with auth params else clear the call */
	 if(ICF_NULL != p_ssa_ctxt->auth_params_list_size )
	 {
            /* Fetch Line data from DBM */
	    if (ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
				    p_ssa_pdb->p_glb_pdb,
				    p_ssa_ctxt->line_id,
				    &(p_ssa_pdb->p_line_data),
				    p_ssa_pdb->p_ecode))
	    {
		ret_val = ICF_FAILURE;
	    }
	    else if((p_ssa_pdb->p_line_data->line_data_received &
				    ICF_CFG_LINE_DATA_AUTH_KEY_RECD) &&
			    (p_ssa_pdb->p_line_data->line_data_received &
			     ICF_CFG_LINE_DATA_AUTH_PASSWD_RECD))
	    {
		if(ICF_TRUE == ICF_IS_BIT_SET(
			    p_ssa_pdb->p_line_data->line_data_received, 
			    ICF_CFG_LINE_DATA_REALM_RECD))
		{
		    /* We have to compare the received realm with configured
		     * one */
		    Sdf_st_authenticationParams *pAuthenticationParams = 
				    Sdf_co_null;
		    if(Sdf_co_success == sdf_listGetAt(
					p_ssa_ctxt->p_auth_params_list, 0, 
					(Sdf_ty_pvoid *)&pAuthenticationParams, 
					pErr))
		    {
		        if(Sdf_co_null != pAuthenticationParams->pRealm)
			{
                            /* Rel 8.2 Klocworks fix */
			    icf_string_st temp_unq_realm = {0,"\0"};
                            /* Rel 8.2 Klocworks fix end*/
			    temp_unq_realm.str[0]='\0';
			    temp_unq_realm.str_len=0;
			    sdf_fn_uaUnq(pAuthenticationParams->pRealm,(icf_int8_t*)temp_unq_realm.str);
			    if(0 != icf_port_strcmp(p_ssa_pdb->p_line_data->configured_realm.str, 
							temp_unq_realm.str))
			    {
				authenticate_req = ICF_FALSE;
				/*ICF_RESET_BIT(p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask,
						ICF_CALL_AUTHENTICATION_REQ)*/
                                p_ssa_pdb->reason_code_1 =
					ICF_CAUSE_REALM_MISMATCH;
			    }
			}/*if(Sdf_co_null != pAuthenticationPa...*/
		    }/*if(Sdf_co_success == sdf_listGetAt( ...*/
		}/*if(ICF_TRUE == ICF_IS_BIT_SET( ...*/
	    }/*else if((p_ssa_pdb->p_line_data->line_data ...*/
	 }/* ICF_NULL != p_ssa_ctxt->auth_para ...*/ 
	 else
	 {
	     p_ssa_pdb->auth_params_pres_in_chal = ICF_FALSE;     
             p_ssa_pdb->reason_code_1 = ICF_CAUSE_AUTH_PARAM_NOT_RCVD;
             authenticate_req = ICF_FALSE;
	 }
    }/*if(ICF_TRUE == authentica ...*/
    
   if(ICF_FAILURE != ret_val &&
		   ICF_TRUE == authenticate_req)
   {
       /* Fetch and store the old nonce in the ssa context */

       if(ICF_FAILURE == icf_ssa_extract_challenge(
			       p_ssa_pdb,
			       header_type))
       {
	   ret_val = ICF_FAILURE;
       }
       /*  CSR 1-5685130 Merge */
       /* 
        * If p_app_conf is NULL in SSA PDB then retreive the same.
        * The app_conf would be used to form the allow header for 
        * the new request being generated.
        */
       else if(ICF_NULL == p_ssa_pdb->p_app_conf)
       {
           icf_app_id_t app_id = ICF_INVALID_APP_ID;
           if(ICF_NULL != p_ssa_ctxt->p_sic_ctxt)
           {
               app_id = p_ssa_ctxt->p_sic_ctxt->app_id;
           }
           else
           {
               app_id = p_ssa_ctxt->p_call_ctxt->app_id;
           }

           /* retreive app_conf corresponding to the app_id */
           ret_val = icf_cfg_fetch_app_conf(
					p_ssa_pdb->p_glb_pdb,
					app_id,
					&(p_ssa_pdb->p_app_conf),
					p_ssa_pdb->p_ecode);
       }
       if(ICF_FAILURE != ret_val)
       {
           ret_val = icf_ssa_send_authorized_req(p_ssa_pdb);
       }
   }/* ICF_TRUE == authenti ...*/

   return ret_val;
}/* end Function icf_ssa_handle_chal_resp*/
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_insert_hdr_in_persistent_list_in_call_obj
 *
 * DESCRIPTION:     The function inserts an the header into persistent
 *                  header list in call objects with the passed correlation
 *
 ******************************************************************************/
icf_return_t icf_ssa_insert_hdr_in_persistent_list_in_call_obj(
		Sdf_st_callObject	*pCallObject,
		SipHeader	        *pHeader,
		en_HeaderType	        dType,
		Sdf_ty_s8bit 	        *pCorrelation,
		Sdf_st_error	        *pErr)
{
    Sdf_st_headerList 			*pHeaderList = Sdf_co_null;
    icf_return_t ret_val=ICF_SUCCESS;
       
    /* Initialise a headerlist of */
    if(Sdf_co_fail == sdf_ivk_uaInitHeaderList(&pHeaderList, 
			    dType,pCorrelation, pErr))
    {
        /*Klocwork warning removal*/
        (void)sdf_ivk_uaFreeHeaderList(pHeaderList);
        ret_val = ICF_FAILURE;
    }
    /* Add the header into the 	list */
    else if(Sdf_co_fail == sdf_listAppend(&(pHeaderList->slHeaders),
			    (Sdf_ty_pvoid)pHeader,pErr))
    {
	(void)sdf_ivk_uaFreeHeaderList(pHeaderList);
        ret_val = ICF_FAILURE;
    }
    /* 
     * Append the pHeaderList to the slPersistentHeaders 
     * header list structures in the call object
     */
    else if ((sdf_listAppend(&(pCallObject->slPersistentHeaders), 
			(Sdf_ty_pvoid)pHeaderList, pErr)) == Sdf_co_fail)
    {
        (void)sdf_ivk_uaFreeHeaderList(pHeaderList);
	ICF_PRINT(((icf_uint8_t*)"Failed to add the header list of headers to the PersistentHeaders list of callObject"));
	ret_val = ICF_FAILURE;
    }

    return ret_val;
}

/*  CSR 1-5385208 Merge */
#ifdef ICF_TRACE_ENABLE
/*****************************************************************************
* Function    : icf_ssa_make_criteria_data_from_msg
*
* Description : This function is a utility function which makes the creteria
*               data from the msg whose decode is failed,the transaction exists
*               for the sip message whose decode is failed.
*
******************************************************************************/
icf_return_t icf_ssa_make_criteria_data_from_msg(
              INOUT    icf_ssa_pdb_st         *p_ssa_pdb,
              INOUT    Sdf_st_callObject      *p_call_obj,
              INOUT    Sdf_st_error           *p_sdf_error)
{
    icf_return_t                        ret_val = ICF_SUCCESS;
    SipFromHeader                       *p_from = ICF_NULL;
    SipToHeader                         *p_to = ICF_NULL;
    SipHeader                           *p_assert_hdr = SIP_NULL;
    SipMessage                          *pSipMsg = SIP_NULL;
    Sdf_st_transaction                  *pTransaction = Sdf_co_null;
    Sdf_st_overlapTransInfo             *pTransInfo = Sdf_co_null;
    SipHeader                           dTempHeader;
    Sdf_ty_s8bit                        *pSentProtocol = Sdf_co_null;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if(ICF_NULL != ((SipFromHeader *)(p_call_obj)->pCommonInfo->pFrom))
    {
        p_from = ((SipFromHeader *)(p_call_obj)->pCommonInfo->pFrom->pHeader);
    }
    if(ICF_NULL != ((SipFromHeader *)(p_call_obj)->pCommonInfo->pTo))
    {
        p_to = ((SipFromHeader *)(p_call_obj)->pCommonInfo->pTo->pHeader);
    }

    if (p_call_obj->pUacTransaction->pSipMsg != Sdf_co_null)
     {
         pSipMsg = p_call_obj->pUacTransaction->pSipMsg;
     }
     else
     {
         pSipMsg = p_call_obj->pUasTransaction->pSipMsg;
     }

     if(sdf_ivk_uaGetTransactionForSipMsg(\
                               (p_call_obj), pSipMsg, &pTransaction, \
                               &pTransInfo, p_sdf_error) == Sdf_co_success)
     {
         if(pTransInfo == Sdf_co_null)
          {
              pSipMsg = pTransaction->pSipMsg;
              sdf_ivk_uaFreeTransaction(pTransaction);
          }
          else
          {
              pSipMsg = pTransInfo->pSipMsg;
              sdf_ivk_uaFreeOverlapTransInfo( \
                         pTransInfo);
          }                     
     }
     else 
     {
         ICF_PRINT(((icf_uint8_t*)"\n[SSA]:Can'tGetTxnFromMsg!!!"));
         ret_val = ICF_FAILURE;
     }
 
     if(ICF_FAILURE == ret_val)
     {
         /*Do nothing*/
     }
     /* Get the Via header from SIP message,transport 
      * mode would be extracted from it.*/
     else if ((SipFail == sip_getHeaderAtIndex(
                pSipMsg, SipHdrTypeVia,
                &dTempHeader, 0, (SipError*)&(p_sdf_error->stkErrCode))))
     {
        ret_val = ICF_FAILURE;
     }
     else
     {
         
         ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
         ICF_PORT_SIZEOF(icf_trace_criteria_data_st),
         ICF_MEM_COMMON,
         p_ssa_pdb->p_ssa_ctxt->p_criteria_data,
         ICF_DONOT_RET_ON_FAILURE,
         p_ssa_pdb->p_ecode,
         ret_val)

        /*
         * If calling party address cannot be
         * ascertained from the p-asserted identity header
         * extract the same from From header
         */
         if (ICF_FAILURE ==
                            icf_ssa_parse_unknown_header_like_from_hdr(
                                       p_ssa_pdb,
                                       pSipMsg,
                                       "P-Asserted-Identity",
                                       &p_assert_hdr))

          {
              ret_val = ICF_FAILURE;
          }
          else
          {
               ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
               ICF_PORT_SIZEOF(icf_address_st),
               ICF_MEM_COMMON,
               p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_calling_party_address,
               ICF_DONOT_RET_ON_FAILURE,
               p_ssa_pdb->p_ecode,
               ret_val)
 
              /*
               * If p_assert_header is not NULL,
               * it means that the p-asserted identity header
               * was present and successfully parsed.
               * In this case IPTK re-assign the pointer p_from
               * to p_asserted as both are of the same type.
               * Otherwise IPTK proceed to extract the calling
               * party address from From header
               */
               if (SIP_NULL != p_assert_hdr)
                {
                    p_from = (SipFromHeader *)
                        (p_assert_hdr->pHeader);

                    icf_ssa_populate_address_from_sip_addr_spec(
                        p_ssa_pdb,p_from->pAddrSpec,
                        p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_calling_party_address);
                    p_ssa_pdb->p_ssa_ctxt->p_criteria_data->bitmask |= ICF_TRACE_CALLING_PARTY_ADDR_PRESENT;

                    sip_freeSipHeader(p_assert_hdr);
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_assert_hdr,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                }
                else
                {
                   /*
                    * Now populate the remote address
                    * Here we are not checking the retval as
                    * it is acceptable to receive a SIP URI
                    * of the form sip:131349314 in the
                    * From/p-asserted identity header
                    * wheras it is not acceptable in the case
                    * of the Request URI
                    */

                   if(ICF_NULL != p_from)
                   {
                       icf_ssa_populate_address_from_sip_addr_spec(
                           p_ssa_pdb,p_from->pAddrSpec,
                           p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_calling_party_address);
                       p_ssa_pdb->p_ssa_ctxt->p_criteria_data->bitmask |= ICF_TRACE_CALLING_PARTY_ADDR_PRESENT;
                   }
                } 
           }
      
          if(ICF_FAILURE != ret_val)
           {   
               ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
               ICF_PORT_SIZEOF(icf_address_st),
               ICF_MEM_COMMON,
               p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_called_party_address,
               ICF_DONOT_RET_ON_FAILURE,
               p_ssa_pdb->p_ecode,
               ret_val)
 
               /* Populating the called party address from
                * the To Header received in SIP message */
               if(ICF_NULL != p_to)
               {
                   icf_ssa_populate_address_from_sip_addr_spec(
                       p_ssa_pdb,p_to->pAddrSpec,
                       p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_called_party_address);
                   p_ssa_pdb->p_ssa_ctxt->p_criteria_data->bitmask |= ICF_TRACE_CALLED_PARTY_ADDR_PRESENT;
               }

               /* Extracting the transport mode from Via header and
                * based upon it populating the transport mode of
                * criteria data */
               if(SipFail == sip_getSentProtocolFromViaHdr(
                           &dTempHeader,&pSentProtocol,(SipError*)&(p_sdf_error->stkErrCode)))
                {
                    sip_freeSipHeader(&dTempHeader);
                    ret_val = ICF_FAILURE;
                }
               else
                {
                    if(ICF_NULL == icf_port_strcmp((icf_uint8_t*)pSentProtocol,(icf_uint8_t*)"SIP/2.0/UDP"))
                     { 
                         p_ssa_pdb->p_ssa_ctxt->p_criteria_data->call_transport_mode = 
                                                                   ICF_CALL_TRANSPORT_MODE_UDP;
                         p_ssa_pdb->p_ssa_ctxt->p_criteria_data->bitmask |= ICF_TRACE_TRANSPORT_MODE_PRESENT;
                     }
                    else if(ICF_NULL == icf_port_strcmp((icf_uint8_t*)pSentProtocol,(icf_uint8_t*)"SIP/2.0/TCP"))
                     {
                         p_ssa_pdb->p_ssa_ctxt->p_criteria_data->call_transport_mode = 
                                                                   ICF_CALL_TRANSPORT_MODE_TCP;
                         p_ssa_pdb->p_ssa_ctxt->p_criteria_data->bitmask |= ICF_TRACE_TRANSPORT_MODE_PRESENT;
                     }
                    else if(ICF_NULL == icf_port_strcmp((icf_uint8_t*)pSentProtocol,(icf_uint8_t*)"SIP/2.0/TLS"))
                     {
                         p_ssa_pdb->p_ssa_ctxt->p_criteria_data->call_transport_mode = 
                                                                   ICF_CALL_TRANSPORT_MODE_TLS;
                         p_ssa_pdb->p_ssa_ctxt->p_criteria_data->bitmask |= ICF_TRACE_TRANSPORT_MODE_PRESENT;
                     }   
                
                    sip_freeSipHeader(&dTempHeader);                  
                }    
           }
     }

     if(ICF_FAILURE == ret_val)
      {
          if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_criteria_data)
           {
               if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_calling_party_address)
                {
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_calling_party_address,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                }

               if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_called_party_address)
                {
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_called_party_address,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                }

               ICF_MEMFREE(
                   p_ssa_pdb->p_glb_pdb,
                   p_ssa_pdb->p_ssa_ctxt->p_criteria_data,
                   ICF_MEM_COMMON,
                   p_ssa_pdb->p_ecode,
                   ret_val)
           }
      }


     ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;

}

/*****************************************************************************
* Function    : icf_ssa_make_criteria_data_for_undecoded_msgs
*
* Description : This function is a utility function which makes the creteria
*               data from the msg whose decode is failed.But no transaction 
*               info can be found at the time of decode failure of this sip
*               msg.
******************************************************************************/
icf_return_t icf_ssa_make_criteria_data_for_undecoded_msgs(
              INOUT    icf_ssa_pdb_st         *p_ssa_pdb,
              INOUT    Sdf_st_callObject      *p_call_obj,
              INOUT    Sdf_st_error           *p_sdf_error)
{
    icf_return_t                        ret_val = ICF_SUCCESS;
    SipFromHeader                       *p_from = ICF_NULL;
    SipToHeader                         *p_to = ICF_NULL;
    SipHeader                           *p_assert_hdr = SIP_NULL;
    SipMessage                          *pSipMsg = SIP_NULL;
    SipHeader                           dTempHeader;
    Sdf_ty_s8bit                        *pSentProtocol = Sdf_co_null;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if(ICF_NULL != ((SipFromHeader *)(p_call_obj)->pCommonInfo->pFrom))
    {
        p_from = ((SipFromHeader *)(p_call_obj)->pCommonInfo->pFrom->pHeader);
    }
    if(ICF_NULL != ((SipFromHeader *)(p_call_obj)->pCommonInfo->pTo))
    {
        p_to = ((SipFromHeader *)(p_call_obj)->pCommonInfo->pTo->pHeader);
    }

    if (p_call_obj->pUacTransaction->pSipMsg != Sdf_co_null)
     {
         pSipMsg = p_call_obj->pUacTransaction->pSipMsg;
     }
     else
     {
         pSipMsg = p_call_obj->pUasTransaction->pSipMsg;
     }
   
     /* Get the Via header from SIP message,transport
      * mode would be extracted from it.*/
     if ((SipFail == sip_getHeaderAtIndex(
                pSipMsg, SipHdrTypeVia,
                &dTempHeader, 0, (SipError*)&(p_sdf_error->stkErrCode))))
     {
        ret_val = ICF_FAILURE;
     }
     else
     {

         ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
         ICF_PORT_SIZEOF(icf_trace_criteria_data_st),
         ICF_MEM_COMMON,
         p_ssa_pdb->p_ssa_ctxt->p_criteria_data,
         ICF_DONOT_RET_ON_FAILURE,
         p_ssa_pdb->p_ecode,
         ret_val)

        /*
         * If calling party address cannot be
         * ascertained from the p-asserted identity header
         * extract the same from From header
         */
         if (ICF_FAILURE ==
                            icf_ssa_parse_unknown_header_like_from_hdr(
                                       p_ssa_pdb,
                                       pSipMsg,
                                       "P-Asserted-Identity",
                                       &p_assert_hdr))

          {
              ret_val = ICF_FAILURE;
              /* Fix For SPR: 19315*/
              /* If the failure is return by function
                 icf_ssa_parse_unknown_header_like_from_hdr free the local
                 reference for via header.Otherwise this leads to memory leak.*/
              sip_freeSipHeader(&dTempHeader);
          }
          else
          {
               ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
               ICF_PORT_SIZEOF(icf_address_st),
               ICF_MEM_COMMON,
               p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_calling_party_address,
               ICF_DONOT_RET_ON_FAILURE,
               p_ssa_pdb->p_ecode,
               ret_val)

              /*
               * If p_assert_header is not NULL,
               * it means that the p-asserted identity header
               * was present and successfully parsed.
               * In this case IPTK re-assign the pointer p_from
               * to p_asserted as both are of the same type.
               * Otherwise IPTK proceed to extract the calling
               * party address from From header
               */
               if (SIP_NULL != p_assert_hdr)
                {
                    p_from = (SipFromHeader *)
                        (p_assert_hdr->pHeader);

                    icf_ssa_populate_address_from_sip_addr_spec(
                        p_ssa_pdb,p_from->pAddrSpec,
                        p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_calling_party_address);
                    p_ssa_pdb->p_ssa_ctxt->p_criteria_data->bitmask |= ICF_TRACE_CALLING_PARTY_ADDR_PRESENT;

                    sip_freeSipHeader(p_assert_hdr);
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_assert_hdr,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                }
                else
                {
                   /*
                    * Now populate the remote address
                    * Here we are not checking the retval as
                    * it is acceptable to receive a SIP URI
                    * of the form sip:131349314 in the
                    * From/p-asserted identity header
                    * wheras it is not acceptable in the case
                    * of the Request URI
                    */

                   if(ICF_NULL != p_from)
                   {
                       icf_ssa_populate_address_from_sip_addr_spec(
                           p_ssa_pdb,p_from->pAddrSpec,
                           p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_calling_party_address);
                       p_ssa_pdb->p_ssa_ctxt->p_criteria_data->bitmask |= ICF_TRACE_CALLING_PARTY_ADDR_PRESENT;
                   }
                }
           }

          if(ICF_FAILURE != ret_val)
           {
               ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
               ICF_PORT_SIZEOF(icf_address_st),
               ICF_MEM_COMMON,
               p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_called_party_address,
               ICF_DONOT_RET_ON_FAILURE,
               p_ssa_pdb->p_ecode,
               ret_val)

               /* Populating the called party address from
                * the To Header received in SIP message */
               if(ICF_NULL != p_to)
               {
                   icf_ssa_populate_address_from_sip_addr_spec(
                       p_ssa_pdb,p_to->pAddrSpec,
                       p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_called_party_address);
                   p_ssa_pdb->p_ssa_ctxt->p_criteria_data->bitmask |= ICF_TRACE_CALLED_PARTY_ADDR_PRESENT;
               }

               /* Extracting the transport mode from Via header and
                * based upon it populating the transport mode of
                * criteria data */
               if(SipFail == sip_getSentProtocolFromViaHdr(
                           &dTempHeader,&pSentProtocol,(SipError*)&(p_sdf_error->stkErrCode)))
                {
                    sip_freeSipHeader(&dTempHeader);
                    ret_val = ICF_FAILURE;
                }
               else
                {
                    if(ICF_NULL == icf_port_strcmp((icf_uint8_t*)pSentProtocol,(icf_uint8_t*)"SIP/2.0/UDP"))
                     {
                         p_ssa_pdb->p_ssa_ctxt->p_criteria_data->call_transport_mode =
                                                                   ICF_CALL_TRANSPORT_MODE_UDP;
                         p_ssa_pdb->p_ssa_ctxt->p_criteria_data->bitmask |= ICF_TRACE_TRANSPORT_MODE_PRESENT;
                     }
                    else if(ICF_NULL == icf_port_strcmp((icf_uint8_t*)pSentProtocol,(icf_uint8_t*)"SIP/2.0/TCP"))
                     {
                         p_ssa_pdb->p_ssa_ctxt->p_criteria_data->call_transport_mode =
                                                                   ICF_CALL_TRANSPORT_MODE_TCP;
                         p_ssa_pdb->p_ssa_ctxt->p_criteria_data->bitmask |= ICF_TRACE_TRANSPORT_MODE_PRESENT;
                     }
                    else if(ICF_NULL == icf_port_strcmp((icf_uint8_t*)pSentProtocol,(icf_uint8_t*)"SIP/2.0/TLS"))
                     {
                         p_ssa_pdb->p_ssa_ctxt->p_criteria_data->call_transport_mode =
                                                                   ICF_CALL_TRANSPORT_MODE_TLS;
                         p_ssa_pdb->p_ssa_ctxt->p_criteria_data->bitmask |= ICF_TRACE_TRANSPORT_MODE_PRESENT;
                     }

                    sip_freeSipHeader(&dTempHeader);
                }
           }
     }

     if(ICF_FAILURE == ret_val)
      {
          if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_criteria_data)
           {
               if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_calling_party_address)
                {
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_calling_party_address,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                }

               if(ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_called_party_address)
                {
                    ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        p_ssa_pdb->p_ssa_ctxt->p_criteria_data->p_called_party_address,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)
                }
               ICF_MEMFREE(
                   p_ssa_pdb->p_glb_pdb,
                   p_ssa_pdb->p_ssa_ctxt->p_criteria_data,
                   ICF_MEM_COMMON,
                   p_ssa_pdb->p_ecode,
                   ret_val)
           }
      }


     ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;

}
#endif

/*****************************************************************************
* Function    : icf_ssa_delete_auth_headers
*
* Description : This function is a utility function which deletes existing
*               Authorization and Proxy-Authorization from Call object 
*               and SipMessage
*
******************************************************************************/
icf_return_t   icf_ssa_delete_auth_headers(
       icf_ssa_pdb_st      *p_ssa_pdb,
       SipMessage          *p_sip_msg)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    Sdf_ty_slist        slAuthInfoHeaderList;
    Sdf_ty_u32bit       dIndex=0;
    Sdf_ty_u32bit       dAuthCount=0;
    Sdf_ty_u32bit       dAuthCountinMsg = 0;
    Sdf_ty_u32bit       dProxyauthCountinMsg = 0;
    Sdf_st_error        dLocalErr = {0,0,0,"\0"};

    /*Get count of Authorization headers present in SipMessage*/
    sip_getHeaderCount(p_sip_msg, SipHdrTypeAuthorization, 
                        &dAuthCountinMsg,
			(SipError *)&(dLocalErr.stkErrCode));

    /*Get count of Proxy-Authorization headers present in SipMessage*/
    sip_getHeaderCount(p_sip_msg, SipHdrTypeProxyauthorization, 
                        &dProxyauthCountinMsg,
			(SipError *)&(dLocalErr.stkErrCode));

    /* Get the Auth-Info Header List from the slPersistentHeaders header 
     * list of the call Object */
    if (sdf_ivk_uaGetHeaderListByCorrelation(&(p_ssa_pdb->p_ssa_ctxt->p_call_obj->slPersistentHeaders), \
        (Sdf_ty_s8bit *)"uat-authInfo", &slAuthInfoHeaderList,\
        &dLocalErr) == Sdf_co_fail)
    {
#ifdef SDF_ERROR			
        sdf_fn_setError(Sdf_en_minorErrors, dLocalErr.errCode,\
            (Sdf_ty_s8bit *)"sdf_fn_uaUpdateAuthorization(): "
            "Failed to get Auth-Info header list by correlation "
            " uat-authInfo",&dLocalErr);
#endif
        return ICF_FAILURE;
    }

    sdf_listSizeOf(&slAuthInfoHeaderList, &dAuthCount, &dLocalErr);

    /* If the Size is not Zero then delete the list */
    if(0 != dAuthCount)
    {
        sdf_listDeleteAll(&slAuthInfoHeaderList,&dLocalErr);
    }

    /* Remove the  Authorization header from the outgoing sipmsg */
    for(dIndex=0; dIndex < dAuthCountinMsg; dIndex++)
    {
        sip_deleteHeaderAtIndex(p_sip_msg, SipHdrTypeAuthorization, \
            dIndex,(SipError *)&(dLocalErr.stkErrCode));
    }
    /* Remove the  Proxy-Authorization header from the outgoing sipmsg */
    for(dIndex=0; dIndex < dProxyauthCountinMsg; dIndex++)
    {
        sip_deleteHeaderAtIndex(p_sip_msg, SipHdrTypeProxyauthorization, \
                dIndex,(SipError *)&(dLocalErr.stkErrCode));
    }
    return ret_val;
}

#ifdef ICF_SECURE_SUPPORT
/*****************************************************************************
 * FUNCTION:        icf_ssa_insert_alias_params_in_via
 *
 * DESCRIPTION:     This function inserts alias parameter in Via header
 *                  in case of persistent TLS
 *
 *****************************************************************************/
icf_return_t     icf_ssa_insert_alias_params_in_via(
         icf_ssa_pdb_st      *p_ssa_pdb,
         SipMessage          *p_sip_msg)
{
    icf_return_t            ret_val = ICF_SUCCESS;
    SipError                SipErr;
    en_SipMessageType       dReqRespType;
    SipParam                *p_param = ICF_NULL;
    SipParam                *p_param_1 = ICF_NULL;
    icf_int8_t             *p_temp_peer_ip = ICF_NULL;
    Sdf_st_error            sdf_error = {0,0,0,"\0"};

    /*Get message type from SIP message*/
    if(SipFail == sip_getMessageType(p_sip_msg,&dReqRespType,\
                                (SipError*)&(SipErr)))
    {
        ret_val = ICF_FAILURE;
    }
    else if (SipMessageRequest == dReqRespType)
    {
        /*If connection table entry is not NULL and connection type is TLS
         *and persistent connection is supported and message is request 
         *then send "alias" in Via header Also check bitmask should not be set
         *with ICF_ALIAS_HEADER_PRESENT bit, which indicates that alias is already
         *set*/
        if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_conn_table_req_entry) &&
            (0 != ICF_PURGE_TIMER_DURATION) &&
            (p_ssa_pdb->p_ssa_ctxt->p_conn_table_req_entry->prot_conn_bitmask &
             ICF_TRANSPORT_TLS) && 
             (ICF_ALIAS_HEADER_PRESENT != 
              (ICF_ALIAS_HEADER_PRESENT & p_ssa_pdb->p_ssa_ctxt->bitmask_1)))
        {
            if(SipFail == sip_initSipParam(&p_param,\
                        (SipError*)&(SipErr)))
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                Sdf_mc_strdup(p_param->pName,"alias");

                if (ICF_NULL == p_param->pName)
                {
                    ret_val = ICF_FAILURE;
                }
                else if(SipFail == icf_ssa_set_param_in_Via\
                            (p_sip_msg,p_ssa_pdb,p_param,\
                             SipErr))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    p_ssa_pdb->p_ssa_ctxt->bitmask_1 |=
                       ICF_ALIAS_HEADER_PRESENT;
                }
            }
            sip_freeSipParam(p_param);
        }
    }
    else if (SipMessageResponse == dReqRespType)
    {
        /*In case of response message in persitent TLS connection when alias
         *parameter is present in Via header, insert received parameter in Via
         *and remove alias header*/
        if ((ICF_NULL != p_ssa_pdb->p_ssa_ctxt->p_conn_table_resp_entry) &&
            (0 != ICF_PURGE_TIMER_DURATION) && 
            (p_ssa_pdb->p_ssa_ctxt->p_conn_table_resp_entry->prot_conn_bitmask &
                 ICF_TRANSPORT_TLS) &&
            (p_ssa_pdb->p_ssa_ctxt->bitmask_1 & ICF_ALIAS_HEADER_PRESENT))
        {
            if(ICF_FAILURE == icf_ssa_del_params_in_Via(\
                                    p_sip_msg,p_ssa_pdb,&SipErr))
            {
                ret_val = ICF_FAILURE;
            }
            else if(SipFail == sip_initSipParam(&p_param_1,\
                        (SipError*)&(SipErr)))
            {
                ret_val = ICF_FAILURE;
            }
            else if(SipFail == sip_initSipParam(&p_param,\
                        (SipError*)&(SipErr)))
            {
                sip_freeSipParam(p_param_1);
                ret_val = ICF_FAILURE;
            }
            else
            {
                Sdf_mc_strdup(p_param->pName,"alias");
                if (ICF_NULL == p_param->pName)
                {
                    ret_val = ICF_FAILURE;
                }
                else if(SipFail == icf_ssa_set_param_in_Via\
                            (p_sip_msg,p_ssa_pdb,p_param,\
                             SipErr))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    Sdf_mc_strdup(p_param_1->pName,"received");

                    if (ICF_NULL == p_param_1->pName)
                    {
                        ret_val = ICF_FAILURE;
                    }
                    else
                    {
                        sip_listInit(&(p_param_1->slValue),\
                                    __sip_freeString,\
                                    (SipError*)&(SipErr));

                       /* Take the peer_ip in pointer p_temp_peer_ip
                          which will be used in function 
                          sip_listInsertAt as a parameter*/ 
                        Sdf_mc_strdup(p_temp_peer_ip,
                                  (icf_int8_t *)(p_ssa_pdb->p_ssa_ctxt->p_conn_table_req_entry->peer_ip));
                    
                        if (ICF_NULL == p_temp_peer_ip)
                        {
                            ret_val = ICF_FAILURE;
                        }
                        else if(SipFail == sip_listInsertAt(\
                                   &(p_param_1->slValue),0,\
                                   (icf_void_t *)p_temp_peer_ip, \
                                   &SipErr))
                        {
                            sdf_memfree(Sdf_mc_callHandlerMemId,\
                                    (Sdf_ty_pvoid*)&p_temp_peer_ip,
                                    &sdf_error);
                            ret_val = ICF_FAILURE;
                        }
                        else if(SipFail == icf_ssa_set_param_in_Via\
                                (p_sip_msg,p_ssa_pdb,p_param_1,\
                                 SipErr))
                        {
                            ret_val = ICF_FAILURE;
                        }
                    }
                }
                sip_freeSipParam(p_param_1);
                sip_freeSipParam(p_param);
            }
        }
    }
    return ret_val;
}
#endif

#ifdef ICF_NAT_RPORT_SUPPORT
/*****************************************************************************
 * FUNCTION:        icf_ssa_insert_rport_params_in_via
 *
 * DESCRIPTION:     This function inserts rport parameter in Via header
 *                  in case of NAT Support
 *
 *****************************************************************************/
icf_return_t     icf_ssa_insert_rport_params_in_via(
         icf_ssa_pdb_st      *p_ssa_pdb,
         SipMessage          *p_sip_msg)
{
    icf_return_t                  ret_val = ICF_SUCCESS;
    SipError                      SipErr;
    en_SipMessageType             dReqRespType;
    icf_line_data_st              *p_line_data = ICF_NULL;
    icf_rport_config_data_st      *p_rport_config_data = ICF_NULL;
    SipParam                      *p_param = ICF_NULL;
    SipParam                      *p_param_1 = ICF_NULL;
    Sdf_st_error                  sdf_error = {0,0,0,"\0"};

    /*Fetch rport config data from line if configured per line
     *else fetch from config_data*/
    if (ICF_CFG_SELF_ADDR_PER_LINE ==
        p_ssa_pdb->p_glb_cfg_data->self_addr_per_line)
    {
        if(ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
             p_ssa_pdb->p_glb_pdb, p_ssa_pdb->p_ssa_ctxt->line_id,
             &p_line_data, p_ssa_pdb->p_ecode))
        {
              ret_val = ICF_FAILURE;
        }
        else
        {
             p_rport_config_data = p_line_data->p_rport_config_data;
        }
    }
    else
    {
        p_rport_config_data = &(p_ssa_pdb->p_glb_cfg_data->rport_config_data);
    }
    /* Null check added for SPR-19604 */ 
    if(ICF_NULL == p_rport_config_data)
    {
         return ICF_FAILURE;
    }
    /* Fix for SPR-19604 End */
    /*Get message type from SIP message*/
    if(SipFail == sip_getMessageType(p_sip_msg,&dReqRespType,\
                                (SipError*)&(SipErr)))
    {
        ret_val = ICF_FAILURE;
    }
    else
    {
        switch(dReqRespType)
        {
            case SipMessageRequest:
                /* send rport in the Via Header of request
                 * message */
                if((ICF_TRUE == p_rport_config_data->is_rport_reqd) &&
                   (ICF_TRANSPORT_TYPE_UDP == 
                    p_ssa_pdb->p_ssa_ctxt->transport))
                {
                   /*Initialize SipParam for rport parameter*/
                   if(SipFail == sip_initSipParam(&p_param,\
                              (SipError*)&(SipErr)))
                   {
                       ret_val = ICF_FAILURE;
                   }
                   else
                   {
                        /*Strdup is required as UATK internally
                         *frees it while deallocating SipMsg
                         *so local pointer reference will gice error*/
                        Sdf_mc_strdup(p_param->pName,"rport");
                    
                        if (ICF_NULL == p_param->pName)
                        {
                            ret_val = ICF_FAILURE;
                        }
                        /*Insert param in Via header*/
                        else if(SipFail == icf_ssa_set_param_in_Via\
                                (p_sip_msg,p_ssa_pdb,p_param,\
                                SipErr))
                        {
                            ret_val = ICF_FAILURE;
                        }
                        /*Free local reference of SipParam*/
                        sip_freeSipParam(p_param);
                    }
                 }
                 /* Persistent TLS connection */
                 else
                 {
                     p_rport_config_data->is_rport_reqd = ICF_FALSE;
                 }
                 break;
             case SipMessageResponse:
                    /* Check whether rport was received in the
                     * request, if yes then send the received
                     * and rport parameters in the Via Header of 
                     * the response.
                     */
                                     
                    if(ICF_RPORT_RECEIVED & p_ssa_pdb->p_ssa_ctxt->\
                        rport_bitmask)
                    {
                        icf_uint8_t   temp_rport[10];
                        icf_int8_t   *p_temp_rport = ICF_NULL;
                        icf_int8_t   *p_temp_dest_ip= ICF_NULL;

                        /* Delete the "rport" and "received" 
                         * parameters from the Via Header if 
                         * already present.  */
                        if(ICF_FAILURE == icf_ssa_del_params_in_Via(\
                                    p_sip_msg,p_ssa_pdb,&SipErr))
                        {
                            ICF_PRINT(((icf_uint8_t*)"\n Unable to delete Params"\
                                        " from Via Header.\n"));
                            ret_val = ICF_FAILURE;

                        }
                        /*Insert parameter for received=IP address*/
                        else if(SipFail != sip_initSipParam(&p_param,\
                                    (SipError*)&(SipErr)))

                        {
                            Sdf_mc_strdup(p_param->pName,"received");

                            /*Take destination_ip in pointer 
                              p_temp_dest_ip to pass in 
                              function sip_listInsertAt as 
                              parameter*/
                            Sdf_mc_strdup(p_temp_dest_ip,
                              (icf_int8_t*)(p_ssa_pdb->p_ssa_ctxt->destination_ip));

                            sip_listInit(&(p_param->slValue),\
                                    __sip_freeString, \
                                    (SipError*)&(SipErr));

                            if (ICF_NULL == p_param->pName)
                            {
                                sdf_memfree(Sdf_mc_callHandlerMemId,\
                                    (Sdf_ty_pvoid*)&p_temp_dest_ip,&sdf_error);
                                ret_val = ICF_FAILURE;
                            }
                            else if (ICF_NULL == p_temp_dest_ip)
                            {
                                sdf_memfree(Sdf_mc_callHandlerMemId,\
                                    (Sdf_ty_pvoid*)&p_param->pName,
                                    &sdf_error);
                                ret_val = ICF_FAILURE;
                            }
                            else if(SipFail == sip_listInsertAt(\
                                &(p_param->slValue),0,\
                                (icf_void_t *)p_temp_dest_ip, \
                                &SipErr))
                            {
                                ret_val = ICF_FAILURE;

                            }
                            else if(SipFail == icf_ssa_set_param_in_Via(\
                                        p_sip_msg,p_ssa_pdb,p_param,\
                                      SipErr))
                            {
                                ret_val = ICF_FAILURE;
                            }
                            /* Set the rport parameter in the Via Header as rport=PORT*/
                            else if(SipFail != sip_initSipParam(&p_param_1,(SipError*)&(SipErr)))
                            {
                                Sdf_mc_strdup(p_param_1->pName,"rport");

                                icf_port_sprintf((icf_int8_t *)temp_rport,"%d",\
                                        p_ssa_pdb->p_ssa_ctxt->destination_port);
                                /* Take temp_rport value in 
                                   pointer p_temp_rport to pass
                                   in function sip_listInsertAt
                                   as a parameter.*/
                                Sdf_mc_strdup(p_temp_rport, \
                                                   (icf_int8_t*)temp_rport);
                                sip_listInit(&(p_param_1->slValue),\
                                        __sip_freeString, \
                                        (SipError*)&(SipErr));

                                if (ICF_NULL == p_param_1->pName)
                                {
                                    sdf_memfree(Sdf_mc_callHandlerMemId,\
                                        (Sdf_ty_pvoid*)&p_temp_rport, &sdf_error);
                                    ret_val = ICF_FAILURE;
                                }
                                else if (ICF_NULL == p_temp_rport)
                                {
                                    sdf_memfree(Sdf_mc_callHandlerMemId,\
                                        (Sdf_ty_pvoid*)&p_param_1->pName, &sdf_error);
                                    ret_val = ICF_FAILURE;
                                }
                                else if(SipFail == sip_listInsertAt(\
                                  &(p_param_1->slValue),0,\
                                  (icf_void_t *)(p_temp_rport),\
                                   &SipErr))
                                {
                                    ret_val = ICF_FAILURE;
                                }
                                else if(SipFail == icf_ssa_set_param_in_Via(\
                                            p_sip_msg, p_ssa_pdb,p_param_1,\
                                            SipErr))
                                {
                                    ret_val = ICF_FAILURE;
                                }
                                sip_freeSipParam(p_param_1);
                            }
                            sip_freeSipParam(p_param);
                        }
                    }
                default:
                    ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Neither a Sip"\
                                "Request/Response Message"));
                    break;
            }
     }
     return ret_val;
}
#endif

/*****************************************************************************
 * FUNCTION:        icf_ssa_free_sip_txn_data_on_failure
 *
 * DESCRIPTION:     This function Iterate thru all TxnKeys in UATK 
 *                  pGlbToolkitData and compare if it is the given key 
 *                  to be freed then free both transaction key and buffer
 *
 *****************************************************************************/
icf_void_t     icf_ssa_free_sip_txn_data_on_failure(
        SipTxnKey *pSipTxnKey)
{
    SipTxnKey           *pTempSipTxnKey = Sdf_co_null;
    SipTxnBuffer        *pSipTxnBuffer = Sdf_co_null;
    Sdf_st_error        sdf_error = {0,0,0,"\0"};
    Sdf_st_hashIterator dIterator = {Sdf_co_null, 0};

    /*Iterate thru all TxnKeys in UATK pGlbToolkitData
     *and compare if it is the given key to be freed then
     *free both transaction key and buffer*/
    if (Sdf_co_null == pGlbToolkitData->pTxnFetchFunc)
    {
        sdf_ivk_uaHashInitIterator(&(pGlbToolkitData->dSipTxnHash), \
                &dIterator);

        while (Sdf_co_null != dIterator.pCurrentElement)
        {
            pTempSipTxnKey = 
                (SipTxnKey *)((dIterator.pCurrentElement)->pKey);
            pSipTxnBuffer = 
                (SipTxnBuffer *)((dIterator.pCurrentElement)->pElement);

            if(SipSuccess ==
                    sip_txn_compareTxnKeys(pTempSipTxnKey, 
                        pSipTxnKey,
                        (SipError *)&sdf_error.errCode))
            {
                (void)sdf_ivk_uaHashRemove(
                        &(pGlbToolkitData->dSipTxnHash), \
                        (Sdf_ty_pvoid) pSipTxnKey);

                sip_freeSipTxnKey(pSipTxnKey);
                sip_freeSipTxnBuffer(pSipTxnBuffer);
            }
            sdf_ivk_uaHashNext(&(pGlbToolkitData->dSipTxnHash), 
                    &dIterator);

        }
    }
}

/*****************************************************************************
 * FUNCTION:        icf_ssa_alloc_app_ctx_in_glb_pdb
 *
 * DESCRIPTION:     This function allocates module specfic context into p_glb_pdb
 *
 *****************************************************************************/
icf_void_t    icf_ssa_alloc_app_ctx_in_glb_pdb(
         icf_ssa_pdb_st       *p_ssa_pdb)
{
    icf_ssa_ctxt_st     *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;

    /*If SSA context is not NULL then allocate corresponding
     *APP context into p_glb_pdb*/
    if (ICF_NULL != p_ssa_ctxt)
    {
        if (ICF_NULL != p_ssa_ctxt->p_call_ctxt)
        {
            p_ssa_pdb->p_glb_pdb->line_id = p_ssa_ctxt->p_call_ctxt->line_id;
            p_ssa_pdb->p_glb_pdb->p_call_ctx = p_ssa_ctxt->p_call_ctxt;
        }
        else if (ICF_NULL != p_ssa_ctxt->p_sic_ctxt)
        {
            p_ssa_pdb->p_glb_pdb->line_id = p_ssa_ctxt->p_sic_ctxt->line_id;
            p_ssa_pdb->p_glb_pdb->p_sic_ctx = p_ssa_ctxt->p_sic_ctxt;
        }
        else if (ICF_NULL != p_ssa_ctxt->p_rgm_ctxt)
        {
            p_ssa_pdb->p_glb_pdb->line_id = 
                 p_ssa_ctxt->p_rgm_ctxt->rgm_list_of_lines[0];
            p_ssa_pdb->p_glb_pdb->p_rgm_ctx = p_ssa_ctxt->p_rgm_ctxt;
        }
    }
}

/*****************************************************************************
 * FUNCTION:        icf_ssa_populate_warning_text
 *
 * DESCRIPTION:     This function populates warning text against the warning code
 *                  populated in p_ssa_pdb
 *
 *****************************************************************************/
icf_void_t   icf_ssa_populate_warning_text(
          icf_ssa_pdb_st     *p_ssa_pdb)
{
    switch(p_ssa_pdb->warning_header_code)
    {
         case ICF_WARNING_CODE_INCOMPATIBLE_NW_PROTOCOL:
             icf_port_strcpy(p_ssa_pdb->warning_text.str,
                 (icf_uint8_t *)"\"Incompatible Network Protocol\"");
             break;

         case ICF_WARNING_CODE_INCOMPATIBLE_NW_ADDR_FMT:
             icf_port_strcpy(p_ssa_pdb->warning_text.str,
                 (icf_uint8_t *)"\"Incompatible Network Address Format\"");
             break;

         case ICF_WARNING_CODE_INCOMPATIBLE_TRANSPORT_PROTOCOL:
             icf_port_strcpy(p_ssa_pdb->warning_text.str,
                 (icf_uint8_t *)"\"Incompatible Transport Protocol\"");
             break;

         case ICF_WARNING_CODE_INCOMPATIBLE_BW_UNITS:
             icf_port_strcpy(p_ssa_pdb->warning_text.str,
                 (icf_uint8_t *)"\"Incompatible Bandwidth units\"");
             break;

         case ICF_WARNING_CODE_MEDIA_TYPE_NOT_AVAILABLE:
             icf_port_strcpy(p_ssa_pdb->warning_text.str,
                 (icf_uint8_t *)"\"Media type not available\"");
             break;

         case ICF_WARNING_CODE_INCOMPATIBLE_MEDIA_FMT:
             icf_port_strcpy(p_ssa_pdb->warning_text.str,
                 (icf_uint8_t *)"\"Incompatible media format\"");
             break;

         case ICF_WARNING_CODE_INCOMPATIBLE_ATTRIBUTE:
             icf_port_strcpy(p_ssa_pdb->warning_text.str,
                 (icf_uint8_t *)"\"Incompatible attribute line received\"");
             break;

         case ICF_WARNING_CODE_INCOMPATIBLE_SDP:
             icf_port_strcpy(p_ssa_pdb->warning_text.str,
                 (icf_uint8_t *)"\"Incompatible SDP received\"");
             break;

         case ICF_WARNING_CODE_MULTICAST_NOT_AVAILABLE:
             icf_port_strcpy(p_ssa_pdb->warning_text.str,
                 (icf_uint8_t *)"\"Multicast not available\"");
             break;

         case ICF_WARNING_CODE_UNICAST_NOT_AVAILABLE:
             icf_port_strcpy(p_ssa_pdb->warning_text.str,
                 (icf_uint8_t *)"\"Unicast not available\"");
             break;

         case ICF_WARNING_CODE_INSUFFICIENT_BANDWIDTH:
             icf_port_strcpy(p_ssa_pdb->warning_text.str,
                 (icf_uint8_t *)"\"Insufficient bandwidth received\"");
             break;
         default:
             icf_port_strcpy(p_ssa_pdb->warning_text.str, (icf_uint8_t*)"\0");
         break;
    }
    p_ssa_pdb->warning_text.str_len = 
        (icf_uint16_t)icf_port_strlen(p_ssa_pdb->warning_text.str);
}

/*******************************************************************************
 * FUNCTION          icf_ssa_change_request_uri 
 *
 *
 * Description:  This function changes the request URI for SIP message
 *
 * ****************************************************************************/

icf_return_t   icf_ssa_change_request_uri
                   (icf_ssa_pdb_st  *p_ssa_pdb,
                    icf_uint8_t     *p_change_address,
                    icf_address_type_t *p_addr_type) 
{
    icf_return_t       ret_val = ICF_SUCCESS;
    Sdf_st_callObject  *p_call_obj = Sdf_co_null;
    icf_uint8_t        *p_contact_addr = ICF_NULL;
    Sdf_st_error       sdf_error = {0,0,0,"\0"};
    SipAddrSpec        *pAddrSpec = Sdf_co_null;
    Sdf_ty_s8bit       req_uri_scheme[ICF_MAX_STR_LEN] = "\0";
 
    /* temporary tokens used for parsing */
    icf_int8_t   *p_temp_addr = ICF_NULL, *p_temp_addr1 = ICF_NULL;
    icf_uint32_t  port_num = ICF_NULL;
    icf_boolean_t sip_param_present = ICF_FALSE;

    p_call_obj = p_ssa_pdb->p_ssa_ctxt->p_call_obj;
    p_contact_addr = icf_port_strdup(p_change_address);

    /* check if the port number is present in the address string */
    icf_port_strtokr((icf_int8_t*)p_contact_addr,":",&p_temp_addr);

    if(ICF_NULL != p_temp_addr)
    {
         /* port is present , populate port number and then check for
          * other sip params 
          */
          icf_port_strtokr(p_temp_addr,";",&p_temp_addr1);
          port_num = icf_port_atoi(p_temp_addr);

          if(ICF_NULL != p_temp_addr1)
          {
              p_temp_addr =  p_temp_addr1;
              sip_param_present = ICF_TRUE;
          }
     }
     else
     {
          /* no port number, check for sip param */
          icf_port_strtokr((char*)p_contact_addr,";",&p_temp_addr);

         if(ICF_NULL != p_temp_addr)
         {
              sip_param_present = ICF_TRUE;
         }
     }
     /* Fix For SPR:20135*/
     /* Populate the req_uri_scheme depending upon *p_addr_type passed in
      * parameter to this function.*/
     if(ICF_ADDRESS_PLAN_SIP_URI == *p_addr_type)
     {
         icf_port_strcpy((icf_uint8_t *)req_uri_scheme, (icf_uint8_t *)"sip");
     }
     else if(ICF_ADDRESS_PLAN_SIPS_URI == *p_addr_type)
     {
         icf_port_strcpy((icf_uint8_t *)req_uri_scheme, (icf_uint8_t *)"sips");
     }
     else if(ICF_ADDRESS_PLAN_TEL_URI == *p_addr_type)
     {
         icf_port_strcpy((icf_uint8_t *)req_uri_scheme, (icf_uint8_t *)"tel");
     }
     else if(ICF_ADDRESS_PLAN_E164 == *p_addr_type)
     {
         icf_port_strcpy((icf_uint8_t *)req_uri_scheme, (icf_uint8_t *)"sip");
     }     

     if (Sdf_co_fail == sdf_ivk_uaMakeAddrSpecFromConstituents(
                  &pAddrSpec,
                  (Sdf_ty_s8bit*)p_contact_addr,
                  port_num,
                  (Sdf_ty_s8bit *)req_uri_scheme,
                  &sdf_error))
     {
          ret_val = ICF_FAILURE;
     }

     /* insert the sip params in address spec */
     while(ICF_TRUE == sip_param_present)
     {
           if (p_contact_addr) icf_port_strcpy(p_contact_addr,(icf_uint8_t*)p_temp_addr);

           icf_port_strtokr((char*)p_contact_addr,";",&p_temp_addr);

           icf_port_strtokr((char*)p_contact_addr,"=",&p_temp_addr1);

           if ( p_contact_addr && (ICF_FAILURE ==
                        icf_ssa_insert_param_in_addr_spec(
                        p_ssa_pdb,
                        pAddrSpec,
                        p_contact_addr,(icf_uint8_t*)p_temp_addr1,&sdf_error)))
           {
                ret_val = ICF_FAILURE;
                break;
           }

           if(ICF_NULL == p_temp_addr)
           {
                sip_param_present = ICF_FALSE;
           }
      }

      /* set the new Address Spec as Request URI */
      if ( pAddrSpec) { 
	  if (Sdf_co_fail == sdf_ivk_uaChangeRequestURI(
                     p_call_obj,
                     pAddrSpec, &sdf_error))
      {
           ret_val = ICF_FAILURE;
      }
      else
      {
            sip_freeSipAddrSpec(pAddrSpec);
      }
	  }

      icf_port_strfree(p_contact_addr);
      return ret_val;
} 
/*  CSR 1-6032268 Merge */
/*****************************************************************************
 * FUNCTION:        icf_ssa_check_if_join_configured
 *
 * DESCRIPTION:     This function is used to check whether join header has
 *                  been configured by application and join service has 
 *                  been enabled by application.
 *
 *****************************************************************************/
icf_return_t icf_ssa_check_if_join_configured(
        icf_ssa_pdb_st          *p_ssa_pdb,
        Sdf_ty_s8bit            *p_valid,
        SipMessage              *pSipMsg)
{
    icf_app_conf_st         *p_app_conf = ICF_NULL;
    icf_string_list_st      *p_supported_events = ICF_NULL;
    icf_string_list_node_st *p_cur_node = ICF_NULL;
    icf_return_t             ret_val = ICF_SUCCESS;

    /* Check for enabling through app add */
    if (ICF_NULL == p_ssa_pdb->p_app_conf)
    {
        ret_val = ICF_FAILURE;
    }
    else 
    { 
        p_app_conf = p_ssa_pdb->p_app_conf;
        p_supported_events = 
            &(p_app_conf->app_profile.supported_events);
        if((ICF_NULL != p_supported_events) &&
                (ICF_NULL != p_supported_events->p_list))  
        {
            icf_uint8_t count = 0;

            for(count = (icf_uint8_t) p_supported_events->count,
                    p_cur_node = p_supported_events->p_list;
                    count--; p_cur_node = p_cur_node->p_next)
            {
                if(0 == icf_port_strcasecmp((const icf_int8_t * )"join",(const icf_int8_t * ) p_cur_node->str.str))
                {
                    /*when join is present then only we will send
                      merge_media_req and hence further invoke the
                      service*/
                    *p_valid = ICF_TRUE;
                    break;
                }
                else
                {
                    /* In app_add join is absent in supported
                       event so we are not invoking service to
                       send the merge_media_req */
                    *p_valid = ICF_FALSE;
                }
            }
        }
        else
        {
            /* case when there is no supported events in
             * app_add*/
            *p_valid = ICF_FALSE;
        }    
    }


    if((ICF_SUCCESS == ret_val) && (ICF_TRUE == *p_valid))
    {
        icf_config_data_st   *p_cfg_data = ICF_NULL;

        SipReqLine               *p_req_line = SIP_NULL ; 
        SipAddrSpec              *p_req_uri = SIP_NULL;
        SipError                 err;
        icf_address_st           *p_user_address = ICF_NULL;
        icf_line_id_t		 line_id = (icf_line_id_t)ICF_INVALID_LINE_ID;

        p_cfg_data = p_ssa_pdb->p_glb_cfg_data;

        /*
         * Query DBM for the existence and availability 
         * of the user.Extract the user address from
         * the Req URI
         */
        if (SipFail == sip_getReqLineFromSipReqMsg(
                    pSipMsg, &p_req_line,&err))
        {
            ret_val = ICF_FAILURE;
        }
        else if (SipFail == sip_getAddrSpecFromReqLine(
                    p_req_line, &p_req_uri,&err))
        {
            ret_val = ICF_FAILURE;
        }
        else 
        {
            ICF_MEMGET(
                    p_ssa_pdb->p_glb_pdb,
                    sizeof(icf_address_st),
                    ICF_MEM_COMMON,
                    p_user_address,
                    ICF_RET_ON_FAILURE,
                    p_ssa_pdb->p_ecode,
                    ret_val)

                if (ICF_FAILURE == icf_ssa_populate_address_from_sip_addr_spec(
                            p_ssa_pdb,p_req_uri,
                            p_user_address))
                {
                    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                            p_user_address,
                            ICF_MEM_COMMON,
                            p_ssa_pdb->p_ecode,
                            ret_val)

                        ret_val = ICF_FAILURE;
                }
        }
        if (SIP_NULL != p_req_uri)
        {
            sip_freeSipAddrSpec(p_req_uri);
        } /* if (SIP_NULL != p_req_uri) */

        /* Free references of the Req line and addr spec */
        if (SIP_NULL != p_req_line)
        {
            sip_freeSipReqLine(p_req_line);
        } /* if (SIP_NULL != p_req_line) */

        if(ICF_FAILURE == ret_val)
        {
		/* Do not process further */
        }
        else if (ICF_FAILURE == icf_dbm_get_line_id_for_user(
                    p_ssa_pdb->p_glb_pdb,
                    p_user_address,
                    &line_id, p_ssa_pdb->p_ecode))
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_user_address,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
                ret_val = ICF_FAILURE;
        }
        else if(ICF_INVALID_LINE_ID == line_id)
        {
            p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= ICF_SSA_FAILURE_RESP_CODE_404;
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_user_address,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
                ret_val = ICF_FAILURE;

        }
        else if (ICF_NULL == p_ssa_pdb->p_line_data)
        { 
            if (ICF_FAILURE == icf_dbm_fetch_line_cntxt_blk(
                        p_ssa_pdb->p_glb_pdb, line_id,
                        &(p_ssa_pdb->p_line_data),
                        p_ssa_pdb->p_ecode))
            {
                ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                        p_user_address,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val) 
                    ret_val = ICF_FAILURE;                                             
            }
        }
        if ((ret_val == ICF_SUCCESS) && (SIP_NULL != p_user_address))
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_user_address,
                    ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode,
                    ret_val)
        } 

        /* Check for activation and subscription */

	if((ICF_FAILURE != ret_val) && (ICF_NULL != p_ssa_pdb->p_line_data))
	{
		/* Set is_valid = FALSE and set error code if 
		 * one of the flags is not set */
		if(ICF_NULL ==
				(ICF_SERVICE_SUBS_JOIN_HEADER & p_ssa_pdb->p_line_data->service_subscription_flag))
		{
			*p_valid = ICF_FALSE;
		} /* if(ICF_NULL ==(p_line_data-... */

		else if(ICF_NULL ==
				(ICF_SERVICE_ACT_JOIN_HEADER & p_ssa_pdb->p_line_data->service_activation_flag))
		{
			*p_valid = ICF_FALSE;
		} /* && (p_line_data->service_activ... */
	}
    }

    return ret_val;
}

/* SPR 18830: The transport scheme is set in the transaction so that within dialog
 * no need to do a NAPTR query. the transactions can be
 * reinvite transactions include call modify, call hold / resume, session timer, 
 * BYE, INFO, NOTIFY
 */
/*****************************************************************************
 * FUNCTION:        icf_ssa_set_transport_scheme_in_transaction 
 *
 * DESCRIPTION:     This function is used to set the transport scheme in the
 *                  transaction. 
 *
 *****************************************************************************/
icf_return_t icf_ssa_set_transport_scheme_in_transaction(
        icf_ssa_pdb_st          *p_ssa_pdb,
        Sdf_st_overlapTransInfo     **p_p_overlap_txn)
{
    icf_return_t    ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st *p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;
    Sdf_ty_s8bit    proto[ICF_MAX_SIZE_INT_USAGE_STR];
    Sdf_st_error            error;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (ICF_NULL == p_ssa_ctxt)
    {
	    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb) /* function exit trace */
        return ret_val;
    }
    else if(ICF_TRANSPORT_TYPE_INVALID ==  p_ssa_ctxt->transport)
    {
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb) /* function exit trace */
        return ret_val;
    }
    else if (ICF_TRANSPORT_TYPE_TCP == p_ssa_ctxt->transport)
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TCP"); 
    }
    else if (ICF_TRANSPORT_TYPE_TLS == p_ssa_ctxt->transport) 
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"TLS");
    }
    else if (ICF_TRANSPORT_TYPE_UDP == p_ssa_ctxt->transport)
    {
        icf_port_strcpy((icf_uint8_t *)proto, (icf_uint8_t *)"UDP");
    }
    else
    {
        icf_port_strcpy((icf_uint8_t *)proto,(icf_uint8_t *)"");
    }

    if (Sdf_co_fail == sdf_ivk_uaSetTransportSchemeInTransaction(
             p_ssa_ctxt->p_call_obj->pUacTransaction,
             *p_p_overlap_txn,
             proto,
             &error))
    {
            ret_val = ICF_FAILURE;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)    
    return ret_val;
}

/****************************************************************************
 * FUNCTION:            icf_ssa_is_valid_timer_blk
 * DESCRIPTION:         This function validates the timer expiry event received. 
 * RETURNS:             ICF_SUCCESS if timer expiry is valid, ICF_FAILURE otherwise.
 ***************************************************************************/
icf_return_t icf_ssa_is_valid_timer_blk(
        IN icf_ssa_pdb_st  *p_ssa_pdb,
        IN icf_void_t      *p_buff)
{
    icf_return_t ret_val = ICF_FAILURE;
    icf_return_t return_val = ICF_SUCCESS;
    icf_ssa_timer_list_st  *p_list = ICF_NULL;

    /* SPR 18880 : Added Null checks */
    if(ICF_NULL == p_ssa_pdb->p_glb_pdb)
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA] : p_glb_pdb is NULL.\n"))
        return ICF_FAILURE;
    }

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) /* function entry trace */
    
    ICF_CHECK_IF_ANY_OF_THREE_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                                          p_ssa_pdb->p_ssa_ctxt,
                                          p_ssa_pdb->p_ssa_ctxt->p_timer_list,
                                          p_buff,
                                          return_val)
    if(ICF_FAILURE == return_val)
    {
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb) /* function exit trace */
        return ICF_FAILURE;
    }

    /* Now iterate through the timer list in p_ssa_ctx. Check for the equality 
       of the two pointers. Break if matching pointers and matching Timer IDs 
       are found.
    */
    p_list = p_ssa_pdb->p_ssa_ctxt->p_timer_list;
    while(ICF_NULL != p_list)
    {
        if(((icf_ssa_timer_data_st *)p_buff)->p_timer_data == p_list->p_timer_data)
        {
            /* valid pointer found, check for the validity of the Timer ID */
            if(((icf_ssa_timer_data_st *)p_buff)->timer_id == p_list->timer_id)
            {
                /* valid Timer ID also found, break from loop */
                ret_val = ICF_SUCCESS;
                break;
            }
            else
            {
                /* Invalid Timer ID received */
                ICF_PRINT(((icf_uint8_t *)"[SSA] : Invalid timer ID received.\n"))
                ret_val = ICF_FAILURE;
                break;
            }
        }
        /* Continue to traverse the list */
        p_list = p_list->p_next;
    }
   
    /* if ret_val is failure, issue a trace as an invalid timer expiry 
       has been received. 
    */
    if(ICF_FAILURE == ret_val)
    {
        ICF_PRINT(((icf_uint8_t *)"[SSA] : Invalid timer block received.\n"))
    }
        
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb) /* function exit trace */
    return ret_val;
}
/*Fix for SPR : 19188 (Rel 7.1.2 SPR merging for SPR 18988)*/
/****************************************************************************
 * FUNCTION:            icf_ssa_set_reason_string_in_sip_message
 * DESCRIPTION:         This function  sets the reason string in the sip message 
 *                      if sip message is response message.
 * RETURNS:             ICF_SUCCESS if successfully set reason string, 
 *                      ICF_FAILURE otherwise.
 ***************************************************************************/
icf_return_t icf_ssa_set_reason_string_in_sip_message(icf_ssa_pdb_st *p_ssa_pdb,
                                             SipMessage *pMsg,
                                             SIP_S8bit  *p_reason)

{
    SipStatusLine     *pLine = Sdf_co_null;
    icf_return_t       ret_val = ICF_SUCCESS;
    icf_return_t       return_val = ICF_SUCCESS;
    en_SipMessageType  dType = SipMessageAny;
    Sdf_st_error       err = {0,0,0,"\0"};
    SIP_S8bit         *p_reason_string = ICF_NULL;

    if ((ICF_NULL == p_ssa_pdb) || (ICF_NULL == p_ssa_pdb->p_glb_pdb))
    {
       ICF_PRINT(((icf_uint8_t *)"[SSA] : Either p_ssa_pdb or p_ssa_pdb->p_glb_pdb is NULL.\n"))  
       return ICF_FAILURE; 
    }
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)    
    ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                             pMsg,
                             return_val)     
    if (ICF_FAILURE == return_val)
    {
       ret_val = ICF_FAILURE;
       ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
       return ret_val;
    }
    /*  Get the message type */ 
    if (sip_getMessageType(pMsg, &dType, (SipError*)&(err.stkErrCode)) \
            ==  SipFail)
    {        
        ret_val = ICF_FAILURE;
    }
    /*  if its a request then return failure because 
        reason string can not be set in message */
    else if (dType == SipMessageRequest)
    {
        ret_val = ICF_FAILURE;
    }

    /* GET the Status line form sip msg */
    else if ( SipFail == sip_getStatusLineFromSipRespMsg(pMsg,&pLine,(SipError*)\
                &(err.stkErrCode)))
    {
        ret_val = ICF_FAILURE;
    }
    if (ICF_SUCCESS == ret_val)
    {
        /*  THe memget and strcpy is being done because at the time
            of freeing the status line the function sip_freeSipStatusLine
            expects that the reason string is heap memory(memory that is 
            allocated through memget) */
        ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            icf_port_strlen((icf_uint8_t*)p_reason)+1,
            ICF_MEM_COMMON,
            p_reason_string,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val)
        /*  Copy the reason string in p_reason_string */
        icf_port_strcpy((icf_uint8_t*)p_reason_string,(icf_uint8_t*)p_reason);

        /*  SET new reason string in status line */
        if(SipFail == sip_setReasonInStatusLine(pLine, p_reason_string , \
                    (SipError *)&(err.stkErrCode)))
        {
            /*  If not able to set the string then free the memory */
            ICF_MEMFREE(
            p_ssa_pdb->p_glb_pdb,
            p_reason_string,
            ICF_MEM_COMMON,
            p_ssa_pdb->p_ecode,
            ret_val)
            ret_val = ICF_FAILURE;
        }
        /*  This free is done because when get_status_line is called
            it give a reference of statusline and increment the refcount of status line.
            and after going back from this function this reference would be lost so
            this free would decrement the refcount */  
        sip_freeSipStatusLine(pLine);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)    
    return ret_val;
}


/*Fix merged for CSR-1-6369301*/
/*****************************************************************************
 * FUNCTION:        icf_ssa_check_n_insert_route_header
 *
 * DESCRIPTION:		This function is invoked when Route header is to be added
 *					in INVITE as SipHdrTypeRoute instead of unknown header.
 *					This value comes from App in header_list of create_call.
 *					If Route hdr is set successfully, it sets the return 
 *					boolean p_route_hdr_added to TRUE.
 * 
 *****************************************************************************/
icf_return_t icf_ssa_check_n_insert_route_header(
		INOUT	icf_ssa_pdb_st			*p_ssa_pdb,
		INOUT	icf_boolean_t			*p_route_hdr_added)
{
    icf_return_t 				ret_val = ICF_SUCCESS;
	Sdf_st_error                sdf_error = {0,0,0,"\0"};

	icf_uint8_t					route_tpt_scheme[5] = "\0";
	icf_uint8_t					route_addr[ICF_MAX_STR_LEN] = "\0";
	icf_uint16_t				route_port = ICF_NULL;
	icf_int8_t					*p_temp = ICF_NULL, *p_temp2 = ICF_NULL;
	icf_uint8_t					temp_hdr_val[ICF_MAX_STR_LEN] = "\0";

	icf_uint16_t				list_count = ICF_NULL;
	icf_header_list_st			*p_hdr_list = ICF_NULL;
	icf_header_st				*p_hdr = ICF_NULL;
    icf_list_st                 *p_temp_list_node = ICF_NULL; 

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) 

    if ((ICF_NULL == p_ssa_pdb->p_ssa_ctxt) || 
		(ICF_NULL == p_ssa_pdb->p_ssa_ctxt->p_call_ctxt) ||
		(ICF_NULL == p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData))
    {
        return ICF_FAILURE;
    }

	/**** Iterate over the header list to check for Route header ****/
    /*SPR 19590 change start*/
    ret_val = icf_cmn_fetch_curr_hdr_list_node_from_call_ctx(
                   p_ssa_pdb->p_glb_pdb,
                   &p_temp_list_node);
    if((ICF_NULL != p_temp_list_node) && (p_temp_list_node->p_data))
    {    
          p_hdr_list = &(((icf_header_link_list_st*) \
                        (p_temp_list_node->p_data))->header_list);
	      list_count = p_hdr_list->count;
	      p_hdr = p_hdr_list->hdr;
    }     
    /*SPR 19590 change end*/

	while ((ICF_NULL < list_count) && (ICF_NULL != p_hdr))
	{
		if (ICF_NULL == icf_port_strcasecmp((const icf_int8_t * )p_hdr->hdr_name.str, "Route"))
		{

			/**** Extract the Route parameters from App header value ****/
			/* Following formats are supported for p_hdr->hdr_value.str
	 	 	 * <sip:addr>
	 	 	 * <sip:addr;lr>
	   	 	 * <sip:addr:port>
	 	 	 * <sip:addr:port;lr>
	 	 	 */
            /* Fix For SPR:19999 (Merged some changes from CSR-1-7471533)*/
            /* Following code changes is done such as application can send
             * Route header as 'Route: <sip:ip1>,<sip:ip2>,<sip:ip3> in
             * following scenario ie when application has added header list as
             * follows:
             * CASE 1:
             * header_list.count=1
             * header_list.hdr.hdr_name.str=Route
             * header_list.hdr.hdr_value.str=<sip:10.203.153.33:16715>,<sip:10.2.2.2>,<sip:10.2.2.1>
             * CASE 2:
             * header_list.count=2
             * header_list.hdr.hdr_name.str=Route
             * header_list.hdr.hdr_value.str=<sip:10.203.153.33:16715>
             * header_list.hdr.next.hdr_name.str=Route
             * header_list.hdr.next.hdr_value.str=<sip:10.2.2.2>
             * header_list.hdr.next.next.hdr_name.str=Route
             * header_list.hdr.next.next.hdr_value.str=<sip:10.2.2.1>
             */
			while ('\0' != (*p_hdr->hdr_value.str))
            {
				p_temp2 = ICF_NULL;
				route_port = ICF_NULL;

				/* Check for other sip-uris in Route header list 
				 * such as application may send Route header as 'Route: <sip:ip1>,<sip:ip2>,<sip:ip3>'
				 * So, to move to next IP, do the strtok */

				p_temp = icf_port_strtokr((icf_int8_t *)p_hdr->hdr_value.str,",", &p_temp2);
                icf_port_strcpy(temp_hdr_val, p_hdr->hdr_value.str);
                p_temp = (icf_int8_t*)&temp_hdr_val[1];
				/* If there is any next sip-uri, then copy in p_hdr
				 * else set p_hdr as null.*/
				if (ICF_NULL != p_temp2)
				{
					icf_port_strcpy (p_hdr->hdr_value.str, (icf_uint8_t*)p_temp2);
				}
				else
				{
					icf_port_strcpy (p_hdr->hdr_value.str, (icf_uint8_t *)"\0");	
				}
                /* Fetch the transport scheme */
                if (ICF_NULL != icf_port_strchr((icf_uint8_t*)p_temp, ':'))
                {
                    p_temp2 = icf_port_strtokr(p_temp, ":", &p_temp);
                    if (p_temp2) icf_port_strcpy(route_tpt_scheme, (icf_uint8_t *)p_temp2);
                }

                /* Fetch the address */
                if ( (p_temp) && (ICF_NULL != icf_port_strchr((icf_uint8_t*)p_temp, ':')))
                {
                    if (p_temp ) p_temp2 = icf_port_strtokr(p_temp, ":", &p_temp);
                    if (p_temp2) icf_port_strcpy(route_addr, (icf_uint8_t*)p_temp2);

                    /* Fetch the port */
                    if (p_temp  && (ICF_NULL != icf_port_strchr((icf_uint8_t*)p_temp, ';')))
                    {
                        if (p_temp) p_temp2 = icf_port_strtokr(p_temp, ";", &p_temp);
                        if (p_temp2) route_port = icf_port_atoi(p_temp2);
                    }
                    else if ( p_temp && (ICF_NULL != icf_port_strchr((icf_uint8_t*)p_temp, '>')))
                    {
                        if (p_temp) p_temp2 = icf_port_strtokr(p_temp, ">", &p_temp);
                        if (p_temp2) route_port = icf_port_atoi(p_temp2);
                    }
                }
                else if (p_temp && (ICF_NULL != icf_port_strchr((icf_uint8_t*)p_temp, ';')))
                {
                    if (p_temp) p_temp2 = icf_port_strtokr(p_temp, ";", &p_temp);
                    if (p_temp2) icf_port_strcpy(route_addr, (icf_uint8_t*)p_temp2);
                }
                else if (p_temp && (ICF_NULL != icf_port_strchr((icf_uint8_t*)p_temp, '>')))
                {
                    if (p_temp) p_temp2 = icf_port_strtokr(p_temp, ">", &p_temp);
                    if (p_temp2) icf_port_strcpy(route_addr, (icf_uint8_t*)p_temp2);
                }

                if (Sdf_co_fail == sdf_ivk_uaAddDefaultPreLoadedRoute(
                            p_ssa_pdb->p_ssa_ctxt->p_call_obj->pInitData,
                            Sdf_co_null,
                            (Sdf_ty_s8bit*)route_addr,
                            route_port,
                            "lr",
                            (Sdf_ty_s8bit*)route_tpt_scheme,
                            &sdf_error))
                {
                    ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Failed to set App Route as default route\n"));
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    ICF_PRINT(((icf_uint8_t*)"\n[SSA]: App Route set as default route\n"));
                    *p_route_hdr_added = ICF_TRUE;
                }
            }
		} /* Route hdr */
        list_count = list_count - 1;
        p_hdr = p_hdr->next;
	} /* while () */


    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
} /* End function icf_ssa_check_n_insert_route_header( ) */


#ifdef ICF_DNS_LOOKUP_ENABLED
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_send_dns_map_change_ind
 *
 * DESCRIPTION:     The function send DNS mapping change indication to App
 *                  whenever a DNS entry is created or deleted from buffer.
 *                  The argument p_ip will be set as NULL in calling function
 *                  when the entry is being deleted.
 *
 ******************************************************************************/
icf_return_t icf_ssa_send_dns_map_change_ind(
        INOUT	icf_glb_pdb_st              *p_glb_pdb,
        IN		icf_uint8_t                 *p_fqdn,
        IN		icf_uint8_t                 *p_ip,
		IN		icf_uint8_t					dns_map_change_cause)
{
    icf_return_t                    ret_val = ICF_SUCCESS;
    icf_return_t                    dummy_retval = ICF_SUCCESS;

    icf_msg_st                      *p_pa_msg = ICF_NULL;
    icf_dns_mapping_change_ind_st   *p_dns_map_ind = ICF_NULL;
    icf_internal_msg_st             internal_msg = {{0,0,0,0,0,0},0};
    icf_uint32_t                    msg_len = ICF_NULL;

    icf_line_data_st                *p_line_data = ICF_NULL;
    icf_config_data_st              *p_config_data = ICF_NULL;
    icf_line_id_t                   line_id = ICF_NULL;
    icf_error_t                     ecode = ICF_ERROR_NONE;
    icf_uint8_t						record_type = ICF_DNS_RECORD_TYPE_INVALID;
	icf_boolean_t					send_ind = ICF_FALSE;

    ICF_FUNCTION_ENTER(p_persistent_glb_pdb)

	/* Check if the input arguments are valid */
    if ((ICF_NULL == p_glb_pdb) || (ICF_NULL == p_fqdn))
    {
        ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Incorrect invocation of DNS mapping function\n"));
    	ICF_FUNCTION_EXIT(p_persistent_glb_pdb)
		ret_val = ICF_FAILURE;
        return ret_val;
    }
	/* Check if the DNS mapping change cause is valid */
    else if (ICF_DNS_MAP_CHANGE_INVALID == dns_map_change_cause)
    {
        ICF_PRINT(((icf_uint8_t*)"\n[SSA]: API invocation not supported for cause %d\n",
							dns_map_change_cause));
    	ICF_FUNCTION_EXIT(p_glb_pdb)
		ret_val = ICF_SUCCESS;
        return ret_val;
    }
	/* Get access to config data */
    else if (ICF_FAILURE == icf_dbm_get_module_glb_data(
                            p_glb_pdb,
                            (icf_int_module_id_t)ICF_INT_MODULE_CFG,
                            (icf_void_t *)&p_config_data,
                            &ecode))
    {
        ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Failed to fetch config data\n"));
    	ICF_FUNCTION_EXIT(p_glb_pdb)
		ret_val = ICF_FAILURE;
        return ret_val;
    }
	/* --------------------------------------------------------------------- */
    /* Iterate over the list of lines to check if p_fqdn is configured 
     * on any of the line.
     */
    else
    {
        for (line_id = ICF_NULL; line_id < p_config_data->max_lines; line_id++)
        {
            if (ICF_SUCCESS == icf_dbm_fetch_line_cntxt_blk(
                                    p_glb_pdb, line_id, &p_line_data, &ecode))
            {
				/* Check if p_fqdn is configured as proxy address */
                if ((ICF_CFG_LINE_DATA_PROXY_RECD &
                        	p_line_data->line_data_received) &&
                    (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                        	p_line_data->proxy_addr.addr.addr_type) &&
                    (ICF_NULL == icf_port_strcmp(
                            p_line_data->proxy_addr.addr.addr.domain.str,
                            p_fqdn)))
                {
                    record_type |= ICF_DNS_RECORD_TYPE_PROXY;
                }

				/* Check if p_fqdn is configured as registrar address */
                if ((ICF_CFG_LINE_DATA_REGISTRAR_RECD &
                        	p_line_data->line_data_received) &&
                    (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                        	p_line_data->registrar_addr.addr.addr_type) &&
                    (ICF_NULL == icf_port_strcmp(
                            p_line_data->registrar_addr.addr.addr.domain.str,
                            p_fqdn)))
                {
                    record_type |= ICF_DNS_RECORD_TYPE_REGISTRAR;
                }

                /* Check if p_fqdn is configured as reg_route address */
                if ((ICF_CFG_LINE_DATA_REG_ROUTE_ADDR_RECD &
                            p_line_data->line_data_received) &&
                    (ICF_TRANSPORT_ADDRESS_DOMAIN_NAME ==
                            p_line_data->reg_route_addr.addr.addr_type) &&
                    (ICF_NULL == icf_port_strcmp(
                            p_line_data->reg_route_addr.addr.addr.domain.str,
                            p_fqdn)))
                {
                    record_type |= ICF_DNS_RECORD_TYPE_REG_ROUTE;
                }

            } /* if (ICF_SUCCESS == icf_dbm_fetch_line_cntxt_blk) */
        } /* for (line_id) */
    } /* else if (ICF_FAILURE == icf_dbm_get_module_glb_data) */

	/* Check if the record type is valid */
    if (ICF_DNS_RECORD_TYPE_INVALID == record_type)
    {
        ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Address %s does not match any configuration\n",
							p_fqdn));
    	ICF_FUNCTION_EXIT(p_glb_pdb)
		ret_val = ICF_SUCCESS;
        return ret_val;
    }

	/* --------------------------------------------------------------------- */
    /* Initialize the internal msg */

    icf_port_memset(&internal_msg, 0, ICF_PORT_SIZEOF(icf_internal_msg_st));

    /* Calculate the message length */
    msg_len = sizeof(icf_api_header_st) + sizeof(icf_dns_mapping_change_ind_st);

    /* Allocate memory for msg */
    ICF_MEMGET(p_glb_pdb, msg_len, ICF_MEM_COMMON, p_pa_msg,
                ICF_RET_ON_FAILURE, &ecode, ret_val)

	/* --------------------------------------------------------------------- */
    /* Fill API header structure */

    p_pa_msg->hdr.api_id = ICF_DNS_MAPPING_CHANGE_IND;
    p_pa_msg->hdr.version = ICF_VERSION_1_0;
    p_pa_msg->hdr.source_id = ICF_MODULE_ICF;
    p_pa_msg->hdr.destination_id = ICF_MODULE_PA;
    p_pa_msg->hdr.call_id = ICF_INVALID_CALL_ID;
    p_pa_msg->hdr.app_id = ICF_GENERIC_APP_ID;
    p_pa_msg->hdr.api_length = msg_len;

	/* --------------------------------------------------------------------- */
    /* Fill API payload structure */

    p_dns_map_ind = (icf_dns_mapping_change_ind_st *)(p_pa_msg->payload);

    p_dns_map_ind->record_type = record_type;
    p_dns_map_ind->cause = dns_map_change_cause;

    icf_port_strcpy(p_dns_map_ind->fqdn.str, p_fqdn);
    p_dns_map_ind->fqdn.str_len = icf_port_strlen(p_dns_map_ind->fqdn.str);

    if (ICF_NULL != p_ip)
    {
        icf_port_strcpy(p_dns_map_ind->ip.str, p_ip);
    }
    else
    {
        icf_port_strcpy(p_dns_map_ind->ip.str, (icf_uint8_t *)"0.0.0.0");
    }
    p_dns_map_ind->ip.str_len = icf_port_strlen(p_dns_map_ind->ip.str);

	/* --------------------------------------------------------------------- */
    /* Fill the internal msg that should be sent to ADM */

    internal_msg.msg_hdr.msg_id = ICF_DNS_MAPPING_CHANGE_IND;
    internal_msg.msg_hdr.payload_length = msg_len;
    internal_msg.msg_hdr.p_glb_pdb = p_glb_pdb;
    internal_msg.p_msg_data = (icf_uint8_t *)p_pa_msg;

	/* --------------------------------------------------------------------- */
    /* Send the message to App via ADM */

	icf_port_check_dns_change_inform_to_app(
		p_dns_map_ind,
		p_config_data->app_port_config,
		&send_ind);
	if (ICF_TRUE == send_ind)
	{
    	ret_val = icf_adm_process_mesg(&internal_msg);
	}

	/* --------------------------------------------------------------------- */
	/* Clean up */
	
    ICF_MEMFREE(p_glb_pdb, p_pa_msg, ICF_MEM_COMMON, &ecode, dummy_retval)

    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
} /* End function icf_ssa_send_dns_map_change_ind( ) */
#endif /* ICF_DNS_LOOKUP_ENABLED */

/*******************************************************************************
 * FUNCTION:        icf_ssa_get_tunneled_sdp_from_sdpmessage
 *
 * DESCRIPTION:     This function is used for populating the
 *                  icf_tunnelled_sdp_info structure from
 *                  SdpMessage.Individual fields are extracted from the SDP
 *                  messages and place in the icf_tunnelled_sdp_info structure
 *                  at the respective placeholder.
 *
 * RETURN VALUES:   ICF_SUCCESS/ICF_FAILURE                  
 ******************************************************************************/
icf_return_t icf_ssa_get_tunneled_sdp_from_sdpmessage(
        IN      icf_ssa_pdb_st               *p_ssa_pdb,
        IN      SdpMessage                   *p_sdpMessage,
        INOUT   icf_tunnelled_sdp_info_st    *p_tunneled_sdp,
        OUT     Sdf_st_error                 *p_error)        
{
    icf_return_t         ret_val = ICF_SUCCESS;
    icf_uint8_t          enc_attr_count = 0;
    Sdf_ty_retVal        dRetval = Sdf_co_fail;
    icf_uint8_t          count = 0; 
    icf_uint32_t         m_line_count = 0; 
    icf_uint32_t         dConnectionCount = 0;
    icf_uint32_t         dBandwidthCount = 0;
    icf_uint32_t         dAttrCount = 0;
    icf_uint8_t          index = 0; 

    /*Initialized the memory for icf_tunnelled_sdp_info_st*/
    icf_port_memset(
        (icf_void_t *)p_tunneled_sdp,
        0,ICF_PORT_SIZEOF(
        icf_tunnelled_sdp_info_st));    
   
    /* Invoke the UATK API for populating the c line structure in
     * p_tunneled_sdp from SDP message*/
    dRetval = sdf_ivk_uaGetClineFromSdpMessage(\
            (SdpMessage *)p_sdpMessage,
            (Sdf_st_cLineInSdp *)&(p_tunneled_sdp->session_level_cline),
            p_error);
    
    /* If the return value of dRetval is success it means that session level c
     * line is present.Set the bitmask for the same*/
    if (Sdf_co_success == dRetval)
    {
        p_tunneled_sdp->bitmask |= ICF_TUNNELLED_SDP_SESSION_CLINE_PRESENT;
    }

    /* Start a loop less than equal to 5 .
     * In the for loop we are invoking the stack API
     * sdf_ivk_uaGetElementFromSessionAttr, which on the bases of count value
     * return a session level attribute if the same is present*/
    for (count = 0;count<=5 ; count++)
    {
        icf_uint8_t        *pAttr_str = ICF_NULL;
        Sdf_ty_retVal      dRetval = Sdf_co_fail;

        /*Allocate the memory equal to 128 bytes for extracting the session
         * level attibute from sdp message*/
        ICF_MEMGET(
                   p_ssa_pdb->p_glb_pdb,
                   SDF_MAXIMUM_STR_LEN,
                   ICF_MEM_COMMON,
                   pAttr_str,
                   ICF_DONOT_RET_ON_FAILURE,
                   p_ssa_pdb->p_ecode,
                   ret_val)

        if (ICF_FAILURE == ret_val) 
        {
            ICF_PRINT(((icf_uint8_t *)"\n[SSA]:MemgetFailure in function icf_ssa_get_tunneled_sdp_from_sdpmessage "));
            return ret_val;
        }
        else
        {
            /* If the memory allocation for pAttr_str is successfull invoke the
             * API sdf_ivk_uaGetElementFromSessionAttr for extracting session 
             * level attributes for SDP message.*/
            dRetval =
                sdf_ivk_uaGetElementFromSessionAttr((SdpMessage *)p_sdpMessage,
                        pAttr_str,count,p_error);
        }
       
        /* If success is returned by API sdf_ivk_uaGetElementFromSessionAttr 
         * populate the same in icf_tunnelled_sdp_info.*/
        if (Sdf_co_success == dRetval)
        {
            icf_uint8_t         *p_temp_string = ICF_NULL;
            icf_uint32_t        temp_size = 0;
            
            /*Starting location where Attribute string is to be saved*/
            p_temp_string = 
                p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.dStr;

            /* Fix for SPR 19935 : We will copy a maximum of SDF_MAXIMUM_STR_LEN
               bytes. If the size is greater or equal to SDF_MAXIMUM_STR_LEN,
               we will copy the first SDF_MAXIMUM_STR_LEN - 1 bytes only.
            */
            temp_size = icf_port_strlen(pAttr_str);
            if(SDF_MAXIMUM_STR_LEN <= temp_size)
            {
                temp_size = SDF_MAXIMUM_STR_LEN - 1;
            }
            
            switch(count)
            {
                /* If the value of count is 0, it means UATK API 
                 * sdf_ivk_uaGetElementFromSessionAttr has successfully returned
                 * the origin line from SDP as string."o=" is already appended in
                 * the string.*/
                case 0:
                {
                    /* Fix for SPR 19935 : Replacing icf_port_strcat by 
                       icf_port_strncat. 
                    */
                    icf_port_strncat((icf_int8_t *)p_temp_string,
                                     (const icf_int8_t *)pAttr_str,
                                     temp_size);
                    /* End of fix of SPR 19935 */
                    icf_port_strcat(p_temp_string,(icf_uint8_t*)"\0");
                   
                    p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.\
                        dStrLen = icf_port_strlen(p_temp_string);
                    
                    /*Set the value of level in encoded_string as 1 indicating
                     * that it is a session level attribute*/
                    p_tunneled_sdp->encoded_string[enc_attr_count].level = 1;
                    /*Set the value of pos_of_media in encoded_string as 0*/ 
                    p_tunneled_sdp->encoded_string[enc_attr_count].pos_of_media
                        = 0;
                    /*Increment the enc_attr_count*/
                    enc_attr_count++;
                    break;
                }
                /*If the value of count is 1, it means UATK API 
                  sdf_ivk_uaGetElementFromSessionAttr has successfully returned
                  the version from SDP as string */
                case 1:
                {
                    icf_port_strcpy(p_temp_string,(icf_uint8_t *)"v=");
                    /* Fix for SPR 19935 : Replacing icf_port_strcat by 
                       icf_port_strncat. 
                    */
                    icf_port_strncat((icf_int8_t *)p_temp_string,(const icf_int8_t *)pAttr_str,
                            temp_size);
                    /* End of fix of SPR 19935 */
                    icf_port_strcat(p_temp_string,(icf_uint8_t*)"\0");
                   
                    p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.\
                        dStrLen = icf_port_strlen(p_temp_string);
                    
                    /*Set the value of level in encoded_string as 1 indicating
                     * that it is a session level attribute*/
                    p_tunneled_sdp->encoded_string[enc_attr_count].level = 1;
                    /*Set the value of pos_of_media in encoded_string as 0*/ 
                    p_tunneled_sdp->encoded_string[enc_attr_count].pos_of_media
                        = 0;
                    /*Increment the enc_attr_count*/
                    enc_attr_count++; 
                    break;                    
                    
                }
                /*If the value of count is 2, it means UATK API 
                  sdf_ivk_uaGetElementFromSessionAttr has successfully returned
                  the session from SDP as string */
                case 2:
                {
                    icf_port_strcpy(p_temp_string,(icf_uint8_t *)"s=");
                    /* Fix for SPR 19935 : Replacing icf_port_strcat by 
                       icf_port_strncat. 
                    */
                    icf_port_strncat((icf_int8_t *)p_temp_string,(const icf_int8_t *)pAttr_str,
                            temp_size);
                    /* End of fix of SPR 19935 */
                    icf_port_strcat(p_temp_string,(icf_uint8_t*)"\0");
                   
                    p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.\
                        dStrLen = icf_port_strlen(p_temp_string);

                    /*Set the value of level in encoded_string as 1 indicating
                     * that it is a session level attribute*/
                    p_tunneled_sdp->encoded_string[enc_attr_count].level = 1;
                    /*Set the value of pos_of_media in encoded_string as 0*/ 
                    p_tunneled_sdp->encoded_string[enc_attr_count].pos_of_media
                        = 0;
                    /*Increment the enc_attr_count*/
                    enc_attr_count++;
                    break;                    
                }
                /*If the value of count is 3, it means UATK API 
                  sdf_ivk_uaGetElementFromSessionAttr has successfully returned
                  the information from SDP as string*/
                case 3:
                {
                    icf_port_strcpy(p_temp_string,(icf_uint8_t *)"i=");
                    /* Fix for SPR 19935 : Replacing icf_port_strcat by 
                       icf_port_strncat. 
                    */
                    icf_port_strncat((icf_int8_t *)p_temp_string,(const icf_int8_t *)pAttr_str,
                            temp_size);
                    /* End of fix of SPR 19935 */
                    icf_port_strcat(p_temp_string,(icf_uint8_t*)"\0");
                   
                    p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.\
                        dStrLen = icf_port_strlen(p_temp_string);
                    
                    /*Set the value of level in encoded_string as 1 indicating
                     * that it is a session level attribute*/
                    p_tunneled_sdp->encoded_string[enc_attr_count].level = 1;
                    /*Set the value of pos_of_media in encoded_string as 0*/ 
                    p_tunneled_sdp->encoded_string[enc_attr_count].pos_of_media
                        = 0;
                    /*Increment the enc_attr_count*/
                    enc_attr_count++;
                    break;                    
                    
                }
                /*If the value of count is 4, it means UATK API 
                  sdf_ivk_uaGetElementFromSessionAttr has successfully returned
                  the uri from SDP as string */
                case 4:
                {
                    icf_port_strcpy(p_temp_string,(icf_uint8_t *)"u=");
                    /* Fix for SPR 19935 : Replacing icf_port_strcat by 
                       icf_port_strncat. 
                    */
                    icf_port_strncat((icf_int8_t *)p_temp_string,(const icf_int8_t *)pAttr_str,
                            temp_size);
                    /* End of fix of SPR 19935 */
                    icf_port_strcat(p_temp_string,(icf_uint8_t*)"\0");
                   
                    p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.\
                        dStrLen = icf_port_strlen(p_temp_string);
                    
                    /*Set the value of level in encoded_string as 1 indicating
                     * that it is a session level attribute*/
                    p_tunneled_sdp->encoded_string[enc_attr_count].level = 1;
                    /*Set the value of pos_of_media in encoded_string as 0*/ 
                    p_tunneled_sdp->encoded_string[enc_attr_count].pos_of_media
                        = 0;
                    /*Increment the enc_attr_count*/
                    enc_attr_count++;
                    break;                    
                    
                }
                /*If the value of count is 5, it means UATK API 
                  sdf_ivk_uaGetElementFromSessionAttr has successfully returned
                  the key field from SDP as string */
                case 5:
                {
                    icf_port_strcpy(p_temp_string,(icf_uint8_t *)"k=");
                    /* Fix for SPR 19935 : Replacing icf_port_strcat by 
                       icf_port_strncat. 
                    */
                    icf_port_strncat((icf_int8_t *)p_temp_string,(const icf_int8_t *)pAttr_str,
                            temp_size);
                    /* End of fix of SPR 19935 */
                    icf_port_strcat(p_temp_string,(icf_uint8_t*)"\0");
                   
                    p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.\
                        dStrLen = icf_port_strlen(p_temp_string);
                    
                    /*Set the value of level in encoded_string as 1 indicating
                     * that it is a session level attribute*/
                    p_tunneled_sdp->encoded_string[enc_attr_count].level = 1;
                    /*Set the value of pos_of_media in encoded_string as 0*/ 
                    p_tunneled_sdp->encoded_string[enc_attr_count].pos_of_media
                        = 0;
                    /*Increment the enc_attr_count*/
                    enc_attr_count++;
                    break;                    
                }
            }
        }
        
        /*Free the memory allocated for pAttr_str*/
        ICF_MEMFREE(
                p_ssa_pdb->p_glb_pdb,
                pAttr_str,
                ICF_MEM_COMMON,
                p_ssa_pdb->p_ecode,
                ret_val)
    }
    /* Start a loop less than equal to 4 .
     * In the for loop we are invoking the stack API
     * sdf_ivk_uaGetElementFromSessionAttrList, which on the bases of count
     * value return a session level attributes which are maintain as a list by
     * UATK.First we will get the size of the list and then individual element
     * is extracted ,if the same is present*/
    for (count = 0;count<=4 ; count++)
    {
        Sdf_ty_retVal        dRetval = Sdf_co_fail;
        icf_uint32_t         size = 0; 
        
        /*Get the size of particular list as specified by the count*/
        /*Count               List
          0                   Email list
          1                   phone list
          2                   Time list
          3                   Bandwidth list
          4                   Attribute list*/
        dRetval = sdf_ivk_uaGetSizeOfSessionAttrList((SdpMessage *)p_sdpMessage,
                count,&size,p_error);

        if (Sdf_co_success == dRetval)
        {
            /*Extract each element from sdp message and populate in
             * encoded_atrr string*/
            for(index=0 ; index < size ; index++)
            {
                Sdf_ty_retVal    dRetval1 = Sdf_co_fail;

                icf_uint8_t      *pAttr_str = ICF_NULL;

                ICF_MEMGET(
                        p_ssa_pdb->p_glb_pdb,
                        SDF_MAXIMUM_STR_LEN,
                        ICF_MEM_COMMON,
                        pAttr_str,
                        ICF_DONOT_RET_ON_FAILURE,
                        p_ssa_pdb->p_ecode,
                        ret_val)

                if (ICF_FAILURE == ret_val) 
                {
                    ICF_PRINT(((icf_uint8_t *)"\n[SSA]:MemgetFailure in function icf_ssa_get_tunneled_sdp_from_sdpmessage "));
                    return ret_val;
                }
                else
                {
                    /*Extract individual element from the list*/
                    dRetval1 = sdf_ivk_uaGetElementFromSessionAttrList(
                                (SdpMessage *)p_sdpMessage,pAttr_str,
                                count,index,p_error);
                }

                if ((Sdf_co_success == dRetval) && (enc_attr_count < ICF_MAX_NO_OF_ENC_STRING))
                {
                    icf_uint8_t         *p_temp_string = ICF_NULL; 
                    p_temp_string = 
                        p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.dStr;

                    /* Fix for SPR 19935 : Replacing icf_port_strcpy by 
                       icf_port_strncpy. 
                    */

                    icf_port_strncpy((icf_int8_t *)p_temp_string,(const icf_int8_t *)pAttr_str,
                                     SDF_MAXIMUM_STR_LEN - 1);
                    /* Null terminating the string */
                    *(p_temp_string + SDF_MAXIMUM_STR_LEN - 1) = '\0';

                    p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.\
                        dStrLen = icf_port_strlen(p_temp_string);
                    
                    /*Set the value of level in encoded_string as 1 indicating
                     * that it is a session level attribute*/
                    p_tunneled_sdp->encoded_string[enc_attr_count].level = 1;
                    /*Set the value of pos_of_media in encoded_string as 0*/ 
                    p_tunneled_sdp->encoded_string[enc_attr_count].pos_of_media
                        = 0;
                    enc_attr_count++;
                }
                /*Free the memory allocated for pAttr_str*/
                ICF_MEMFREE(
                        p_ssa_pdb->p_glb_pdb,
                        pAttr_str,
                        ICF_MEM_COMMON,
                        p_ssa_pdb->p_ecode,
                        ret_val)                
            }
        }
    }    

    /*Get the number of m line count from SDP message*/
    (void)sdp_getMediaCount(p_sdpMessage,&m_line_count,
                            (SipError*)&(p_error->stkErrCode));
    
    /*Start a loop equal to number of mline*/
    for (index = 0;(index < m_line_count) && (index < ICF_MAX_NO_OF_M_LINES) ; index++)
    {
        SdpMedia           *pSdpMedia=Sdf_co_null;
        icf_m_line_st      *p_tmp_m_line = ICF_NULL;
		icf_uint8_t        *p_temp_string = ICF_NULL;
        
        /*Temporay variable indicating m line in med-level_desc for particular
         * index depending upon the value of index*/
        p_tmp_m_line = (icf_m_line_st *)&(p_tunneled_sdp->
                med_level_desc[index].m_line);

        /* Get Media Line from sdp message */
        sdp_getMediaAtIndex(p_sdpMessage,&pSdpMedia,index,
                (SipError*)&(p_error->stkErrCode));
        
        /* If media line at index cannot be extracted from SDP message set the
         * value of ret_val as ICF_FAILURE and break from for loop.*/ 
        if (Sdf_co_null == pSdpMedia)
        {
           ret_val = ICF_FAILURE;
           break;
        }
 
        if(Sdf_co_null != pSdpMedia->pMediaValue)
        {
			p_temp_string = p_tmp_m_line->dMediaType.dStr;
				
            /*Populate the various field of m line structure frpm PSdpMedia*/
            /* Fix for SPR 19935 : Issue found in CERT case 3776 ,
               replacing icf_port_strcpy by icf_port_strncpy. 
            */
            icf_port_strncpy((icf_int8_t *)p_temp_string,(const icf_int8_t*)pSdpMedia->pMediaValue,
                             SDF_MAXIMUM_STR_LEN - 1);
            /* Null terminating the string */
            *(p_temp_string + SDF_MAXIMUM_STR_LEN - 1) = '\0';
            /* The length of the destination should be taken from the final string 
               copied and not from the source string.
            */   
            p_tmp_m_line->dMediaType.dStrLen = icf_port_strlen(p_temp_string);
            /* End of fix of SPR 19935 */
            
        }
       
        p_tmp_m_line->dPort = pSdpMedia->dPort;
       
        if (Sdf_co_null != pSdpMedia->pPortNum)
        {
            p_tmp_m_line->dNumOfPorts = *(pSdpMedia->pPortNum);
        }
       
        if(Sdf_co_null != pSdpMedia->pProtocol)
        {
			p_temp_string = p_tmp_m_line->dProtocol.dStr;
            /* Fix for SPR 19935 : Issue found in CERT case 3776 ,
               replacing icf_port_strcpy by icf_port_strncpy. 
            */
            icf_port_strncpy((icf_int8_t *)p_temp_string,(const icf_int8_t*)pSdpMedia->pProtocol,
                             SDF_MAXIMUM_STR_LEN - 1);
            /* Null terminating the string */
            *(p_temp_string + SDF_MAXIMUM_STR_LEN - 1) = '\0';
            /* The length of the destination should be taken from the final string 
               copied and not from the source string.
            */   
            p_tmp_m_line->dProtocol.dStrLen = icf_port_strlen(p_temp_string);
            /* End of fix of SPR 19935 */
        }

        if(Sdf_co_null != pSdpMedia->pFormat)
        {
			p_temp_string = p_tmp_m_line->dFormat.dStr;
            /* Fix for SPR 19935 : Issue found in CERT case 3776 ,
               replacing icf_port_strcpy by icf_port_strncpy. 
            */
            icf_port_strncpy((icf_int8_t *)p_temp_string,
                    (const icf_int8_t*)pSdpMedia->pFormat,
                             SDF_MAXIMUM_STR_LEN - 1);
            /* Null terminating the string */
            *(p_temp_string + SDF_MAXIMUM_STR_LEN - 1) = '\0';
            /* The length of the destination should be taken from the final string 
               copied and not from the source string.
            */   
            p_tmp_m_line->dFormat.dStrLen = icf_port_strlen(p_temp_string);
            /* End of fix of SPR 19935 */
        }
        
        /*Get the media level connection line count*/  
        (void)sdp_getConnectionCountFromMedia (pSdpMedia,&dConnectionCount,
                                               (SipError*)&(p_error->stkErrCode));
        /*If the count is greater than on equal to one*/ 
        if (dConnectionCount >=1)	 
		{
			SdpConnection  *pConnection = Sdf_co_null;

			/*Here we are extracting the connection line at index 0 only*/
			sdp_getConnectionAtIndexFromMedia(pSdpMedia,&pConnection,0,
					(SipError*)&(p_error->stkErrCode));
			if (Sdf_co_null == pConnection)
			{
				ret_val=ICF_FAILURE;
				break;
			}
 
            /*Populate the various field of c line structure from pConnection*/ 

            if(Sdf_co_null != pConnection->pNetType)
            {
				p_temp_string = p_tunneled_sdp->med_level_desc[index].med_level_cline.dNetType.dStr;
                /* Fix for SPR 19935 : Issue found in CERT case 3776 ,
                   replacing icf_port_strcpy by icf_port_strncpy. 
                */
                icf_port_strncpy((icf_int8_t *)p_temp_string,
                        (const icf_int8_t*)pConnection->pNetType,
                    SDF_MAXIMUM_STR_LEN - 1);
                /* Null terminating the string */
                *(p_temp_string + SDF_MAXIMUM_STR_LEN - 1) = '\0';
                /* The length of the destination should be taken from the final string 
                   copied and not from the source string.
                */   
                p_tunneled_sdp->med_level_desc[index].med_level_cline.\
                    dNetType.dStrLen = icf_port_strlen(p_temp_string);
                /* End of fix of SPR 19935 */
            }

            if(Sdf_co_null != pConnection->pAddrType)
            {
                /*If the address type is set as IP4 in connection line set the value of
                 * address type in cline structure as SDF_CLINE_ADDRESS_IPV4_ADDR*/
                if (Sdf_mc_strncmp(pConnection->pAddrType,"IP4",3) == 0)
                {
                    p_tunneled_sdp->med_level_desc[index].med_level_cline.
                        dNetworkAddress.dAddrType = SDF_CLINE_ADDRESS_IPV4_ADDR;
                }
                /*If the address type is set as IP6 in connection line set the value of
                 * address type in cline structure as SDF_CLINE_ADDRESS_IPV6_ADDR*/
                else if(Sdf_mc_strncmp(pConnection->pAddrType,"IP6",3) == 0)
                {
                    p_tunneled_sdp->med_level_desc[index].med_level_cline.
                        dNetworkAddress.dAddrType = SDF_CLINE_ADDRESS_IPV6_ADDR;
                }
                /*As currently rfc:4566 states that the value of address type in
                 * connection line can be IP4 or IP6 so for other values also we are
                 * setting the value of dAddress type to SDF_CLINE_ADDRESS_IPV4_ADDR */
                else
                {
                    p_tunneled_sdp->med_level_desc[index].med_level_cline.
                        dNetworkAddress.dAddrType = SDF_CLINE_ADDRESS_IPV4_ADDR;
                }
            }

            if(Sdf_co_null != pConnection->pAddr)
            {
				p_temp_string = p_tunneled_sdp->med_level_desc[index].med_level_cline.dNetworkAddress.dAddrVal.dStr;
                /* Fix for SPR 19935 : Issue found in CERT case 3776 ,
                   replacing icf_port_strcpy by icf_port_strncpy. 
                */
                icf_port_strncpy((icf_int8_t *)p_temp_string,
                    (const icf_int8_t*)pConnection->pAddr,SDF_MAXIMUM_STR_LEN - 1);
                /* Null terminating the string */
                *(p_temp_string + SDF_MAXIMUM_STR_LEN - 1) = '\0';
                /* The length of the destination should be taken from the final string 
                   copied and not from the source string.
                */
                p_tunneled_sdp->med_level_desc[index].med_level_cline.
                    dNetworkAddress.dAddrVal.dStrLen = 
                    icf_port_strlen(p_temp_string);
                /* End of fix of SPR 19935 */

                /*Set the bitmask indicating that media level c line is present*/     
                p_tunneled_sdp->med_level_desc[index].bitmask |= 
                    ICF_TUNNELLED_SDP_MEDIA_CLINE_PRESENT;   
            }
            
            /* Free the local reference */
            sip_freeSdpConnection(pConnection);

        }
        /* If the media level Key value is present set the same in encoded
         * string*/
        if((pSdpMedia && (ICF_NULL != pSdpMedia->pKey)) && 
           (enc_attr_count < ICF_MAX_NO_OF_ENC_STRING))
        {
            icf_uint8_t         *p_temp_string = ICF_NULL; 
            p_temp_string = 
                p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.dStr;

            /* Fix for SPR 19935 : Replacing icf_port_strcpy by 
               icf_port_strncpy. 
            */
            icf_port_strncpy((icf_int8_t *)p_temp_string,
                    (const icf_int8_t*)pSdpMedia->pKey,
                             SDF_MAXIMUM_STR_LEN - 1);
            /* Null terminating the string */
            *(p_temp_string + SDF_MAXIMUM_STR_LEN - 1) = '\0';

            /* The length of the destination should be taken from the final string 
               copied and not from the source string.
            */
            p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.\
                dStrLen = icf_port_strlen(p_temp_string);
            /* End of fix of SPR 19935 */
            
            /* Set the value of level in encoded_string as 0 indicating
             * that it is a media level attribute*/
            p_tunneled_sdp->encoded_string[enc_attr_count].level = 0;
            /* Set the value of pos_of_media in encoded_string as specified by
             * index*/ 
            p_tunneled_sdp->encoded_string[enc_attr_count].pos_of_media
                = index;
            
            enc_attr_count++;
        }
        /* If the media level Information value is present set the same in 
           encoded string*/
        if (pSdpMedia &&  (ICF_NULL != pSdpMedia->pInformation) &&
           (enc_attr_count < ICF_MAX_NO_OF_ENC_STRING))
        {
            icf_uint8_t         *p_temp_string = ICF_NULL; 
            p_temp_string = 
                p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.dStr;

            /* Fix for SPR 19935 : Replacing icf_port_strcpy by 
               icf_port_strncpy. 
            */
            icf_port_strncpy((icf_int8_t *)p_temp_string,
                    (const icf_int8_t*)pSdpMedia->pInformation,
                             SDF_MAXIMUM_STR_LEN - 1);

            /* Null terminating the string */
            *(p_temp_string + SDF_MAXIMUM_STR_LEN - 1) = '\0';

            /* The length of the destination should be taken from the final string 
               copied and not from the source string.
            */
            p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.\
                dStrLen = icf_port_strlen(p_temp_string);

            /* Set the value of level in encoded_string as 0 indicating
             * that it is a media level attribute*/
            p_tunneled_sdp->encoded_string[enc_attr_count].level = 0;
            /* Set the value of pos_of_media in encoded_string as specified by
             * index*/ 
            p_tunneled_sdp->encoded_string[enc_attr_count].pos_of_media
                = index;

            enc_attr_count++;
        }
        /*Get the media level bandwidth count*/  
        (void)sdp_getBandwidthCountFromMedia(pSdpMedia,&dBandwidthCount,
                                           (SipError*)&(p_error->stkErrCode));
        
        /*Extract each bandwidth value and populate in encoded string*/
        for(count=0; (count<dBandwidthCount) && (enc_attr_count < ICF_MAX_NO_OF_ENC_STRING);count++)
        {
            icf_uint8_t	       *pBandwidth = ICF_NULL;
            icf_uint8_t        *p_temp_string = ICF_NULL;
            icf_uint32_t       temp_size = 0;
            p_temp_string = 
                p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.dStr;

            /*Extract individual element from the pSdpMedia*/
            (void)sdp_getBandwidthAtIndexFromMedia(pSdpMedia,&pBandwidth,
                                                   count,(SipError*)&(p_error->stkErrCode));

            if (ICF_NULL == pBandwidth )
			{
				ret_val = ICF_FAILURE; 
				break; 
			}

            /* Fix for SPR 19935 : We will copy a maximum of SDF_MAXIMUM_STR_LEN
               bytes. If the size is greater or equal to SDF_MAXIMUM_STR_LEN,
               we will copy the first SDF_MAXIMUM_STR_LEN - 1 bytes only.
            */
            temp_size = icf_port_strlen(pBandwidth);
            if(SDF_MAXIMUM_STR_LEN <= temp_size)
            {
                temp_size = SDF_MAXIMUM_STR_LEN - 1;
            }

			icf_port_strcpy(p_temp_string,(icf_uint8_t*)"b=");
            /* Fix for SPR 19935 : Replacing icf_port_strcat by 
               icf_port_strncat. 
            */
            icf_port_strncat((icf_int8_t *)p_temp_string,(const icf_int8_t *)pBandwidth,temp_size);
            /* End of fix of SPR 19935 */
            icf_port_strcat(p_temp_string,(icf_uint8_t*)"\0");
            p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.dStrLen =
                  icf_port_strlen(p_temp_string);

            /* Set the value of level in encoded_string as 0 indicating
             * that it is a media level attribute*/
            p_tunneled_sdp->encoded_string[enc_attr_count].level = 0;
            /* Set the value of pos_of_media in encoded_string as specified by
             * index*/ 
            p_tunneled_sdp->encoded_string[enc_attr_count].pos_of_media
                = index;

            enc_attr_count++;
        }
        /*Get the media level attribute count*/  
        (void)sdp_getAttrCountFromMedia(pSdpMedia,&dAttrCount,
                                      (SipError*)&(p_error->stkErrCode));

        /*Extract each attribute value and populate in encoded string*/
        for (count=0;(count < dAttrCount) && (enc_attr_count < ICF_MAX_NO_OF_ENC_STRING) ;count++)
        {
            icf_uint8_t        *p_temp_string = ICF_NULL; 
            SdpAttr            *pAttr     = Sdf_co_null;
            icf_uint32_t       temp_size = 0,temp_size2 = 0;
            icf_boolean_t      continue_copy = ICF_TRUE;
            
            p_temp_string = 
                p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.dStr; 
           
            /*Extract individual element from the pSdpMedia*/
            (void)sdp_getAttrAtIndexFromMedia(pSdpMedia,&pAttr,count,
                    (SipError*)&(p_error->stkErrCode));
            if ( Sdf_co_null == pAttr)
			{
				ret_val = ICF_FAILURE; 
				break ;
			}

            /* Fix for SPR 19935 : We will copy a maximum of SDF_MAXIMUM_STR_LEN
               bytes. If the remaining size is greater or equal to
               SDF_MAXIMUM_STR_LEN,
               we will copy the first SDF_MAXIMUM_STR_LEN - 1 bytes only.
            */
            icf_port_strcpy(p_temp_string,(icf_uint8_t*)"a=");
			if (ICF_NULL != pAttr->pName)
			{
                temp_size = icf_port_strlen((icf_uint8_t *)pAttr->pName);
			}

            if((SDF_MAXIMUM_STR_LEN - 3) <= temp_size)
            {
                continue_copy = ICF_FALSE;
                if(ICF_NULL != pAttr->pName) 
                {
                    /* Fix for SPR 19935 : Replacing icf_port_strcat by 
                       icf_port_strncat. 
                       Copy only SDF_MAXIMUM_STR_LEN - 3 bytes,remaining
                       2 are for string "a=" and 1 for the Null termination.
                    */
                    icf_port_strncat((icf_int8_t *)p_temp_string,(const icf_int8_t*)pAttr->pName,
                                     SDF_MAXIMUM_STR_LEN - 3);
                    /* Null terminate as the limit of SDF_MAXIMUM_STR_LEN 
                       has been reached.
                    */   
                    icf_port_strcat(p_temp_string,(icf_uint8_t*)"\0");
                }
            }
            else
            {
                if(ICF_NULL != pAttr->pName) 
                {
                    /* Fix for SPR 19935 : Replacing icf_port_strcat by 
                       icf_port_strncat. 
                       Copy temp_size bytes, remaining 2 are for string
                       "a=" and 1 for the Null termination.
                    */
                    icf_port_strncat((icf_int8_t *)p_temp_string,(const icf_int8_t*)pAttr->pName,
                                     temp_size);
                }
            }
            /* Proceed only if continue_copy is set to ICF_TRUE */ 
            if((ICF_TRUE == continue_copy) && (ICF_NULL != pAttr->pValue))
            {
                /* Copy the remaining values till we reach 
                   SDF_MAXIMUM_STR_LEN.
                */  
                icf_port_strcat(p_temp_string,(icf_uint8_t*)":");
                temp_size ++;

                if((SDF_MAXIMUM_STR_LEN - 3) >= temp_size)
                { 
                    /* Now append the string after taking care of
                       the already appended strings.
                    */   
                    temp_size2 = icf_port_strlen((icf_uint8_t *)pAttr->pValue);

                    icf_port_strncat((icf_int8_t *)p_temp_string,
                            (const icf_int8_t*)pAttr->pValue,
                                     (SDF_MAXIMUM_STR_LEN - 3 - temp_size));
                }
                /* If the above 'if' condition is FALSE, the last 
                   character to be appended wll be ':'.
                */   
                icf_port_strcat(p_temp_string,(icf_uint8_t*)"\0");
            }
            p_tunneled_sdp->encoded_string[enc_attr_count].attr_str.dStrLen =
                icf_port_strlen(p_temp_string);

            /* Set the value of level in encoded_string as 0 indicating
             * that it is a media level attribute*/
            p_tunneled_sdp->encoded_string[enc_attr_count].level = 0;
            /* Set the value of pos_of_media in encoded_string as specified by
             * index*/ 
            p_tunneled_sdp->encoded_string[enc_attr_count].pos_of_media
                = index;
            
            /*This is done to decrement the refcount which is increased by
             * function call sdp_getAttrAtIndexFromMedia */
            sip_freeSdpAttr(pAttr);
            enc_attr_count++;
        }

        /*Free Local Reference*/	
        sip_freeSdpMedia(pSdpMedia);
    }
    /*SPR19465 We should copy the m line count as ICF_MAX_NO_OF_M_LINES
     if the number of m lines are more than the maximum limit as defined
     by ICF_MAX_NO_OF_M_LINES (7).*/
    if(m_line_count < ICF_MAX_NO_OF_M_LINES)
    {   
        p_tunneled_sdp->num_of_m_line = m_line_count;
    }
    else
    {
        p_tunneled_sdp->num_of_m_line = ICF_MAX_NO_OF_M_LINES;
    }
    p_tunneled_sdp->num_of_encoded_string = enc_attr_count;

    return ret_val;
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_set_tunneled_sdp_in_sdpmessage
 *
 * DESCRIPTION:     This function is used for populating the
 *                  SdpMessage structure from icf_tunnelled_sdp_info structure.
 *                  Individual fields are extracted from the tunnelled
 *                  structure and using UATK API SdpMessage structure 
 *                  will be populated.
 *
 * RETURN VALUES:   ICF_SUCCESS/ICF_FAILURE                  
 ******************************************************************************/

icf_return_t icf_ssa_set_tunneled_sdp_in_sdpmessage(
        IN   icf_ssa_pdb_st             *p_ssa_pdb,
        INOUT   SdpMessage                 **p_p_sdpMessage,
        IN      icf_tunnelled_sdp_info_st  *p_tunneled_sdp,
        OUT     Sdf_st_error               *p_error)
{
    icf_return_t                ret_val = ICF_SUCCESS;
    Sdf_ty_retVal               dRetVal = Sdf_co_success;
    SdpMessage                  *p_sdpMessage = Sdf_co_null;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* To remove compile time warning when ICF_TRACE_ENABLE is 
       not defined.
    */
    p_ssa_pdb = p_ssa_pdb;
        
	/* This function will allocate memory for the SDP message and init
	 * the buffer */
	if (SipFail == sip_initSdpMessage(
		p_p_sdpMessage,(SipError *)&(p_error->stkErrCode)))
	{
		ICF_PRINT(((icf_uint8_t *)"\nFailure in sip_initSdpMessage"));
		ret_val = ICF_FAILURE;
	}
    else if(ICF_NULL  == *p_p_sdpMessage)
    {
		ret_val = ICF_FAILURE;
    }
    else
    {
       p_sdpMessage = *p_p_sdpMessage;
    }
    if (ICF_FAILURE != ret_val)
    {
        /*If the session level connection line is present*/
        if (p_tunneled_sdp && (ICF_TRUE == ICF_IS_BIT_SET(p_tunneled_sdp->bitmask,\
                    ICF_TUNNELLED_SDP_SESSION_CLINE_PRESENT)))
        {
            SdpConnection        *p_connection = Sdf_co_null;
            
            /* Form the session level c-line in SDP message*/
            if(Sdf_co_fail == Sdf_ivk_uaInitAndFormCline(\
                  (Sdf_st_cLineInSdp *)&(p_tunneled_sdp->session_level_cline),\
				    &p_connection,\
					p_error))
            {
                ret_val = ICF_FAILURE;
            }
            else if (SipFail == sdp_setConnection(p_sdpMessage,p_connection,\
                        (SipError *)&(p_error->stkErrCode)))
            {
                ret_val = ICF_FAILURE;
            }            
            
            sip_freeSdpConnection (p_connection);		
            
        }/*C Line handling Block End*/
    }
    
    if ( p_tunneled_sdp && (ICF_FAILURE != ret_val))
    {
        icf_uint8_t          count = 0;
        SdpMedia             *p_media = Sdf_co_null;
        SdpConnection        *p_connection = Sdf_co_null;
        
        for (count = 0;(count<p_tunneled_sdp->num_of_m_line) && (count < ICF_MAX_NO_OF_M_LINES) ;count++)
        {
            /* Form the session level m-line in SDP message*/
            if(Sdf_co_fail == Sdf_ivk_uaInitAndFormMline(\
                    (Sdf_st_mLineInSdp *)&(p_tunneled_sdp->\
                     med_level_desc[count].m_line),\
					 &p_media,\
					 p_error))
            {
                sip_freeSdpMedia(p_media);
                ret_val = ICF_FAILURE;
                break;
            }
            /*If the media level connection line is present*/
            if (ICF_TRUE ==
                    ICF_IS_BIT_SET(p_tunneled_sdp->med_level_desc[count].bitmask,\
                        ICF_TUNNELLED_SDP_MEDIA_CLINE_PRESENT))
            { 
                /* Form the media level c-line for SDP */
                if(Sdf_co_fail == Sdf_ivk_uaInitAndFormCline(\
                            (Sdf_st_cLineInSdp *)&(p_tunneled_sdp->\
                             med_level_desc[count].med_level_cline),\
                             &p_connection,\
                             p_error))
                {
                    sip_freeSdpMedia(p_media);
                    sip_freeSdpConnection(p_connection);                    
                    ret_val = ICF_FAILURE;
                    break;
                } 
                /*Append the connection line in connection list*/
                else if(Sdf_co_fail == sdf_listAppend((Sdf_ty_slist *)&(p_media->\
                                slConnection),p_connection,p_error))
                {
                    sip_freeSdpMedia(p_media);
                    sip_freeSdpConnection (p_connection);
                    ret_val = ICF_FAILURE;
                    break;
                }                   
			}/*Successfull insertion of c-line in m-line*/
			if(Sdf_co_null != p_media)
			{             
                if ((SipFail == sdp_insertMediaAtIndex(\
                                p_sdpMessage, p_media, count,\
                                (SipError *)&(p_error->stkErrCode))))
                {
                    sip_freeSdpMedia(p_media);
                    ret_val = ICF_FAILURE;
                    break;
                }
                else
                {
                    sip_freeSdpMedia(p_media);
                    p_media = Sdf_co_null;
                }            
            }
        }/*End of for loop for number of m-line to be insereted*/
    }

    if ( p_tunneled_sdp && (ICF_FAILURE != ret_val))
    {
        icf_uint8_t          count = 0;
        icf_uint8_t          level = 0;
        
        /*Insert each encoded attribute string in SDP message*/
        for (count = 0;(count<p_tunneled_sdp->num_of_encoded_string) && (count < ICF_MAX_NO_OF_ENC_STRING) ;count++)
        {
            icf_uint8_t          pos_of_mline = 0;
            
            level =  p_tunneled_sdp->encoded_string[count].level;
            /*If the level field in encoded attribute string is set to 0 it
             * indicates that it is a media level attribute so extract that
             * postion of m line. */
            if (0 == level)
            {
                pos_of_mline =
                    p_tunneled_sdp->encoded_string[count].pos_of_media;
            }
            /* If the value of level is set to 0 it indicate that it is a media
             * level attribute.Value of level set to 1 indicate that it is a
             * session level attribute.Invoke the appropriate UATK API.*/
            switch(level)
            {
                case 0:
                    dRetVal = Sdf_ivk_uaSetMediaLevelAttrInSdpMsg(p_sdpMessage,
                            p_tunneled_sdp->encoded_string[count].attr_str,
                            pos_of_mline,p_error);
                    break;
                case 1:
                    dRetVal = Sdf_ivk_uaSetSessionLevelAttrInSdpMsg(p_sdpMessage,
                            p_tunneled_sdp->encoded_string[count].attr_str,
                            p_error);
                    break;
                default : 
                    ICF_PRINT(((icf_uint8_t *)"\nInvalid m-line position"));
                    ret_val = ICF_FAILURE;
            }
            if ((Sdf_co_fail == dRetVal) || (ICF_FAILURE == ret_val))
            {
                break;
            }
        }
    }
    
    if (Sdf_co_fail == dRetVal)
    {
        ret_val = ICF_FAILURE;
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
	return ret_val;    
}

/*******************************************************************************
 * FUNCTION:        icf_ssa_find_matching_ssa_ctxt
 *
 * DESCRIPTION:     This function will traverse the list
 *                  of ssa ctxt and find the ssa_ctxt that
 *                  matches the to tag. If matching ssa ctxt is
 *                  found then it return SUCCESS else it returns 
 *                  FAILURE
 *
 * RETURN VALUES:   ICF_SUCCESS/ICF_FAILURE                  
 ******************************************************************************/
icf_return_t icf_ssa_find_matching_ssa_ctxt(
             icf_ssa_pdb_st  *p_ssa_pdb,
             icf_uint8_t     *p_call_id,
             icf_uint8_t     *p_to_tag_orig,
             icf_ssa_ctxt_st **p_ssa_ctxt)
{
    SipHeader            *p_to_header = Sdf_co_null;
    Sdf_ty_s8bit         *p_to_tag=Sdf_co_null;
    Sdf_st_callObjectKey *p_key = Sdf_co_null;
    Sdf_st_commonInfo    *p_common_info = ICF_NULL;
    icf_ssa_ctxt_list_st *p_ssa_list = ICF_NULL;
    icf_ssa_ctxt_list_st *p_ssa_temp = ICF_NULL;
    icf_error_t           ecode = 0;
    icf_return_t          ret_val = ICF_FAILURE;
    Sdf_st_error          sdf_error = {0,0,0,"\0"};

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* get the list of ssa ctxt that matches call id */
    ret_val = icf_dbm_fetch_ssa_ctxt_from_hash_table(
              p_ssa_pdb->p_glb_pdb,p_call_id,
              (icf_void_t **)&p_ssa_list,&ecode);
    if (ICF_SUCCESS == ret_val)
    {
        /*  It is done to retain the failure
         */
        ret_val = ICF_FAILURE;
        /*  traverse the list of ssa ctxt */
        for (p_ssa_temp = p_ssa_list;p_ssa_temp != ICF_NULL; p_ssa_temp =  
             p_ssa_temp->p_next)
        {
            /* Get the common info */
            if(Sdf_co_fail == sdf_ivk_uaGetCommonInfoFromCallObject(
                               p_ssa_temp->p_ssa_ctxt->p_call_obj, 
                               &p_common_info, &sdf_error))
            {  
                ret_val = ICF_FAILURE;
            }
            else
            {
                p_key = p_common_info->pKey;
                p_to_header = p_key->pRemoteAddr;
                /* Get the to tag */
                if (sip_getTagAtIndexFromFromHdr(p_to_header, &p_to_tag, 0, 
                   (SipError *)&(sdf_error.stkErrCode)) == SipFail)
                {
                    ret_val = ICF_FAILURE;
                }
                /*SPR 19574 Added null check to avoid crash if any of two
                  var is null during strcmp*/
                else if((ICF_NULL != p_to_tag) && (ICF_NULL != p_to_tag_orig))
                {
                    /* compare the to tags if match then copy the ssa_ctxt
                     * and break the loop.
                     */

                    if(ICF_NULL == 
                        icf_port_strcmp((icf_uint8_t *)p_to_tag, 
                       p_to_tag_orig))
                    {
                        *p_ssa_ctxt = p_ssa_temp->p_ssa_ctxt;                      
                        ret_val = ICF_SUCCESS;
                    }
                }
                sdf_ivk_uaFreeCommonInfo(p_common_info);
            }
        }/* loop*/
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}


#ifdef ICF_SESSION_TIMER
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_session_timer_toggle 
 *
 * DESCRIPTION:     This function processes the session timer functionality 
 *                  as per the information received in session timer toggle API. 
 *
 ******************************************************************************/
icf_return_t icf_ssa_session_timer_toggle(
        INOUT	icf_ssa_pdb_st		*p_ssa_pdb)
{
    icf_return_t          ret_val = ICF_SUCCESS;
    Sdf_st_error          sdf_error = {0,0,0,"\0"};
    Sdf_st_callObject      *pCallObj = Sdf_co_null;
    Sdf_st_eventContext *p_event_context = Sdf_co_null;
    icf_session_timer_from_toggle_req_st *p_session_timer_info = ICF_NULL;
    Sdf_ty_refresher       dRefresher = Sdf_en_refresherNone;
    Sdf_ty_refresher       session_refresher = Sdf_en_refresherNone;
    Sdf_ty_refresher       call_obj_session_refresh = Sdf_en_refresherNone;    
        

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    ICF_CHECK_IF_ANY_OF_THREE_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb, \
          p_ssa_pdb->p_glb_pdb->p_call_ctx, \
          p_ssa_pdb->p_ssa_ctxt, p_ssa_pdb->p_ssa_ctxt->p_call_obj, \
          ret_val) 

    if(ICF_FAILURE == ret_val)
    {
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ICF_FAILURE;
    }

    pCallObj = p_ssa_pdb->p_ssa_ctxt->p_call_obj; 

    ICF_CHECK_IF_ANY_OF_TWO_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb, \
          pCallObj->pSessionTimer, \
          pCallObj->pAppData, \
          ret_val)

    if(ICF_FAILURE == ret_val)
    {
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ICF_FAILURE;
    }        

    if(ICF_FALSE == p_ssa_pdb->p_glb_pdb->p_call_ctx->session_timer_enable)
    {
        /* SPR 20195: The refresher should be set as Sdf_en_refresherNone
         * as Sdf_en_refresherInvalid is not valid value and its value
         * matches to Sdf_en_refresherRemote
         */
        pCallObj->pSessionTimer->dRefresher = Sdf_en_refresherNone;

        if(ICF_NULL != (ICF_CALL_DIR &
               p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask))
        {
            /* do nothing */
            /* in case of incoming call, no session timer as been started
             * as yet therefore we should not stop the session timer.
             * Although it is of no impact but still result into error traces.
             */ 
        }
        /* stop the session timer */
        else if(sdf_fn_uaStopSessionTimer((Sdf_ty_pvoid *)\
                   &(pCallObj->pSessionTimer->pTimerId) ,&sdf_error)
                   ==Sdf_co_fail)
        {
              ICF_PRINT(((icf_uint8_t*)"\n[SSA] Failed to Stop the timer"));
              ret_val = ICF_FAILURE;
        }
        else
        {
             ICF_PRINT(((icf_uint8_t *)"\n [SSA] Session Timer stopped by SSA"));
        }
    }
    else
    {

        if(ICF_NULL == (ICF_CALL_DIR &
               p_ssa_pdb->p_glb_pdb->p_call_ctx->common_bitmask))
        {

            /* SPR 19768 : After the new enhancement where for incoming offer
             * if no information provided by application then the values in
             * offer deem to be valid, the following two lines of code are
             * only applicable for outgoing call where the values in the 
             * session timer toggle are mandatory
             */ 
           /* reset the session timer values in Call object so that the new
            * values can  be configured as per application requests.
            */ 
            pCallObj->pSessionTimer->dIsSupportedTimer = Sdf_co_false;
            pCallObj->pSessionTimer->dRefresher = Sdf_en_refresherNone;

            /* in case of outgoing call the handling should be to set all the
             * session timer details and then start the session timer.
             * This peice of code shall be invoked when the call is connected and
             * now application need to start the session timer
             */ 
            if (Sdf_co_fail ==
                    sdf_ivk_uaInitEventContext(&p_event_context, &sdf_error))
            {
                ICF_PRINT(((icf_uint8_t *)"\n[SSA]:FailureInInitEventCtxt in SSASendToPeer"));
                ret_val = ICF_FAILURE;
            }
            else
            {
                p_event_context->pData = pCallObj->pAppData->pData;
            }

            if(ICF_FAILURE == ret_val)
            {
                /* do nothing */
            }
            /* update information in the call object */
            else if(ICF_FAILURE == icf_ssa_set_session_timer_details(p_ssa_pdb,pCallObj))
            {
                ret_val = ICF_FAILURE;
            }

            if(ICF_SUCCESS == ret_val)
            {
                /* start the session timer */
#ifdef ICF_WITH_MUATK_2_2
                if ((sdf_ivk_uaStartRefresh(pCallObj,p_event_context, &sdf_error)) == Sdf_co_fail)
#else
                if ((sdf_ivk_uaStartRefresh(pCallObj,&sdf_error)) == Sdf_co_fail)
#endif
                {
                     ICF_PRINT(((icf_uint8_t *)"\n [SSA] Session Timer can not be started"));
                     ret_val = ICF_FAILURE;
                }
                else
                {
                     ICF_PRINT(((icf_uint8_t *)"\n [SSA] Session Timer started by SSA"));
                }
            }
            sdf_ivk_uaFreeEventContext(p_event_context);
        }
        else 
        {
            /* Extract the payload from the internal msg */
            p_session_timer_info = (icf_session_timer_from_toggle_req_st *)
                p_ssa_pdb->p_internal_msg->p_msg_data;

            ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                    p_session_timer_info,ret_val)
                
            if(ICF_FAILURE == ret_val)
            {
                ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
                return ICF_FAILURE;
            }
            
            /* In case value of Session Expires  present in toggle API is
             * more than the received offer,set the value of ecode in internal
             * message. This ecode is used to reject the toggle API.*/
            if((ICF_SESS_TIMER_PRESENT_IN_TOGG_REQ ==
                        (p_session_timer_info->bitmask &
                        ICF_SESS_TIMER_PRESENT_IN_TOGG_REQ))
                                     &&
                    (ICF_NULL !=(icf_uint32_t)pCallObj->pSessionTimer->dSessionInterval) 
                                     &&
                    (p_session_timer_info->session_timer > 
                    (icf_uint32_t)pCallObj->pSessionTimer->dSessionInterval))
            {
                p_ssa_pdb->p_internal_msg->msg_hdr.ecode =
                    ICF_ECODE_INVALID_SESSION_EXPIRE_VALUE;
                
                ICF_PRINT(((icf_uint8_t *)"\n [SSA] Session Timer Value in"
                            "Toggle API greater than the one in initial request"));
            }
            /* In case value of Session Expires present in toggle API 
             * is less than the Min-Se of received offer,set the value of ecode in internal
             * message. This ecode is used to reject the toggle API.*/
            else if((ICF_SESS_TIMER_PRESENT_IN_TOGG_REQ ==
                        (p_session_timer_info->bitmask &
                        ICF_SESS_TIMER_PRESENT_IN_TOGG_REQ)) &&
                    (p_session_timer_info->session_timer < 
                    (icf_uint32_t)pCallObj->pSessionTimer->dMinSe))
            {
                p_ssa_pdb->p_internal_msg->msg_hdr.ecode =
                    ICF_ECODE_INVALID_SESSION_EXPIRE_VALUE;
                
                ICF_PRINT(((icf_uint8_t *)"\n [SSA] Session Timer Value in"
                            "Toggle API is less than the one in Min-SE of initial request"));
            }
            /* In case value of Min-SE present in toggle API is
             * more than the received offer,set the value of ecode in internal
             * message. This ecode is used to reject the toggle API.*/
            else if((ICF_MINSE_PRESENT_IN_TOGG_REQ == 
                        (p_session_timer_info->bitmask &
                        ICF_MINSE_PRESENT_IN_TOGG_REQ)) 
                                    &&
                    (ICF_NULL != (icf_uint32_t)pCallObj->pSessionTimer->dMinSe)
                                    &&
                    (p_session_timer_info->min_se > 
                        (icf_uint32_t)pCallObj->pSessionTimer->dMinSe))
            {
                p_ssa_pdb->p_internal_msg->msg_hdr.ecode =
                    ICF_ECODE_INVALID_MINSE_VALUE;
                ICF_PRINT(((icf_uint8_t *)"\n [SSA] Min-SE Value in"
                            "Toggle API greater than the one in initial request"));                
            }
            else
            {
                /* If the value of Session-Timer is given by toggle API
                 * populate the same in session timer data of call context
                 * else populate the value as received in original request.*/
                if(ICF_SESS_TIMER_PRESENT_IN_TOGG_REQ ==
                        (p_session_timer_info->bitmask &
                         ICF_SESS_TIMER_PRESENT_IN_TOGG_REQ))
                {
                    p_ssa_pdb->p_glb_pdb->p_call_ctx->p_session_timer_data->\
                        session_timer = p_session_timer_info->session_timer;
                }
                else
                {
                    p_ssa_pdb->p_glb_pdb->p_call_ctx->p_session_timer_data->\
                        session_timer =
                        pCallObj->pSessionTimer->dSessionInterval;                    
                }
                /* If the value of Min-SE is given by toggle API
                 * populate the same in session timer data of call context
                 * else populate the value as received in original request.*/
                if(ICF_MINSE_PRESENT_IN_TOGG_REQ == 
                        (p_session_timer_info->bitmask &
                         ICF_MINSE_PRESENT_IN_TOGG_REQ))
                {
                    p_ssa_pdb->p_glb_pdb->p_call_ctx->p_session_timer_data->\
                        min_se = p_session_timer_info->min_se;                    
                }
                else
                {
                    p_ssa_pdb->p_glb_pdb->p_call_ctx->p_session_timer_data->\
                        min_se = pCallObj->pSessionTimer->dMinSe;                       
                }
                
                if(ICF_SESS_TOGG_REQ_REFRESHER_PRESENT ==
                        (p_session_timer_info->bitmask &
                         ICF_SESS_TOGG_REQ_REFRESHER_PRESENT))
                {

                    /* SPR 19768 : After the new enhancement where for incoming offer
                     * if no information provided by application then the values in
                     * offer deem to be valid, when refresher is specified by application
                     * then the call object refresher have to be reset before setting
                     * new value.  
                     */ 
                    /* reset the session timer values in Call object so that the new
                     * values can  be configured as per application requests.
                     */ 
                    pCallObj->pSessionTimer->dRefresher = Sdf_en_refresherNone;

                    p_ssa_pdb->p_glb_pdb->p_call_ctx->p_session_timer_data->\
                        session_timer_refresher = 
                        p_session_timer_info->session_timer_refresher;
                    
                    /* In case of incoming call, the session timer shoul dnot be started
                     * as after sending 200 OK, UATK shall start the session timer.
                     * Since this API is expected before call setup so only the application
                     * specified refresher shoul dbe updated, session timer value and min SE
                     * will be updated later */
                    session_refresher = p_ssa_pdb->p_glb_pdb->p_call_ctx->\
                                        p_session_timer_data->session_timer_refresher;

                    /* The refresher in Call Object is set as per the party who is
                     * expected to refresh. In this API , application specifies the refresher
                     * which is call direction specific ie if in incoming INVITE refresher
                     * is received as UAS and application provides the refresher to be UAC, so
                     * from call object perspective, the refresher should be set as 
                     * Sdf_en_refresherRemote so that the session timer is started as a gaurd
                     * timer to clear the session in case the remote does not refresh the
                     * session within the session expiry duration */
                    if(ICF_SESSION_REFRESHER_UAC == session_refresher)
                    {
                        call_obj_session_refresh = Sdf_en_refresherRemote;
                    }
                    else if(ICF_SESSION_REFRESHER_UAS == session_refresher)
                    {
                        call_obj_session_refresh = Sdf_en_refresherLocal;
                    }

                    if(Sdf_co_fail == sdf_ivk_uaSetRefresher(pCallObj,
                                call_obj_session_refresh, 
                                &sdf_error))
                    {
                        ret_val = ICF_FAILURE;
                    }                    
                }/*End of (session_timer_info->bit_mask &
                   ICF_SESS_TOGG_REQ_REFRESHER_PRESENT)*/
                else
                {
                    /* If the Refresher parameter is not provided in toggle
                     * API, fetch the same from initial request and populate
                     * the same in session timer data of call context.*/
                    if(Sdf_co_fail != sdf_ivk_uaGetRefresher(pCallObj,
                                &dRefresher,&sdf_error))
                    {
                        if(Sdf_en_refresherRemote == dRefresher)
                        {
                            p_ssa_pdb->p_glb_pdb->p_call_ctx->p_session_timer_data->\
                                session_timer_refresher = ICF_SESSION_REFRESHER_UAC;
                        }
                        else if(Sdf_en_refresherLocal == dRefresher)
                        {
                            p_ssa_pdb->p_glb_pdb->p_call_ctx->p_session_timer_data->\
                                session_timer_refresher = ICF_SESSION_REFRESHER_UAS;
                        }
                        else
                        {
                            p_ssa_pdb->p_glb_pdb->p_call_ctx->p_session_timer_data->\
                                session_timer_refresher = ICF_SESSION_REFRESHER_NONE;
                        }
                    }
                }/*End of !(session_timer_info->bit_mask &
                   ICF_SESS_TOGG_REQ_REFRESHER_PRESENT)*/
            }/*End of else block(Successfull validation handling)*/
        }/*Block For incoming call handling*/
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
#endif


/*******************************************************************************
 * FUNCTION:        icf_ssa_get_txn_from_call_obj
 *
 * DESCRIPTION:     This function takes temporary and permanent call objects as
 *					input and does the following:
 *					1. Get the SIP msg from temp_call_obj
 *					2. Get the method name from SIP msg in temp_call_obj
 *					3. Get the txn from perm_call_obj based on method name
 *
 ******************************************************************************/
icf_return_t icf_ssa_get_txn_from_call_obj(
        IN      Sdf_st_callObject       *p_temp_call_obj,
        INOUT   Sdf_st_callObject       *p_perm_call_obj,
        INOUT   icf_glb_pdb_st          *p_glb_pdb,
        INOUT   Sdf_st_error            *p_sdf_err,
        OUT     Sdf_st_transaction      **p_p_txn,
		OUT     Sdf_st_overlapTransInfo **p_p_overlap_txn)
{
	icf_return_t				ret_val = ICF_SUCCESS;
	SipMessage					*p_sip_msg = SIP_NULL;
	Sdf_ty_messageType			msg_type = Sdf_en_unknownRequest;
	Sdf_st_overlapTransInfo     *p_ovtxn = Sdf_co_null;
	Sdf_ty_s8bit        		*p_method = Sdf_co_null;
	icf_uint32_t              	list_size = 0, count = 0;

	/* Validate the input arguments */
	if ((ICF_NULL == p_temp_call_obj) || (ICF_NULL == p_perm_call_obj) ||
		(ICF_NULL == p_glb_pdb) || (ICF_NULL == p_sdf_err) ||
		(ICF_NULL == p_p_txn) || (ICF_NULL == p_p_overlap_txn))
	{
		ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Check arguments icf_ssa_get_txn_from_call_obj\n"));
		ret_val = ICF_FAILURE;
		ICF_FUNCTION_EXIT(p_glb_pdb)
		return ret_val;
	}

	ICF_FUNCTION_ENTER(p_glb_pdb)

	/* ---------------------------------------------------------------------- */
	/* 1. Get the SIP msg from temp_call_obj */
	/* ---------------------------------------------------------------------- */

	if (ICF_NULL != p_temp_call_obj->pUacTransaction->pSipMsg)
		p_sip_msg = p_temp_call_obj->pUacTransaction->pSipMsg;
	else
		p_sip_msg = p_temp_call_obj->pUasTransaction->pSipMsg;

	/* ---------------------------------------------------------------------- */
	/* 2. Get the method name from SIP msg in temp_call_obj */
	/* ---------------------------------------------------------------------- */

	if (Sdf_co_fail == sdf_ivk_uaGetMethodFromSipMessage(
							p_sip_msg, &p_method, p_sdf_err))
	{
		ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Failed to get method from SIP msg\n"));
		ret_val = ICF_FAILURE;
	}

	/* ---------------------------------------------------------------------- */
	/* 3. Get the txn from perm_call_obj based on method name */
	/* ---------------------------------------------------------------------- */

	else if (Sdf_co_fail == sdf_fn_uaGetMethodNameAsEnum(
							(const Sdf_ty_s8bit *)p_method, &msg_type, p_sdf_err))
	{
		ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Failed to get msg type from method name\n"));
		ret_val = ICF_FAILURE;
	}
	else if ((msg_type == Sdf_en_invite) || (msg_type == Sdf_en_ack) ||
			 (msg_type == Sdf_en_cancel) || (msg_type == Sdf_en_bye))
	{
		*p_p_txn = p_perm_call_obj->pUacTransaction;
	}
	else
	{
		/* We cannot invoke icf_ssa_fetch_matching_overlap_txn( ) here since 
         * p_ssa_pdb is not available at this point.
		 */
		
		if (Sdf_co_fail == sdf_listSizeOf(
								&(p_perm_call_obj->slOverlapTransInfo),
                				(Sdf_ty_u32bit *)(&list_size),
								p_sdf_err))
    	{
			ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Failed to get size of overlap txn list\n"));
        	ret_val = ICF_FAILURE;
    	}
	    else
    	{
        	for (count = 0; count < list_size; count++)
	        {
	            if (Sdf_co_fail == sdf_listGetAt(
	                        		&(p_perm_call_obj->slOverlapTransInfo),
	                        		count,
	                        		(Sdf_ty_pvoid)&p_ovtxn,
	                        		p_sdf_err))
	            {
					ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Failed to get overlap txn\n"));
	                ret_val = ICF_FAILURE;
                	break;
            	}
    	        /* Check for the message type and the transaction state */
                else if (msg_type == p_ovtxn->dMsgType)
    	        {
                    /* Found the matching transaction */
                   	*p_p_overlap_txn = p_ovtxn;
               	    break;
        	    }
    	    } /* End for(count) */
	        if (count == list_size || ICF_FAILURE == ret_val)
	        {
    	        ret_val = ICF_FAILURE ;
	        } /* if (count == list_size) */
    	} /* End else */
	} /* End else */
	
	ICF_FUNCTION_EXIT(p_glb_pdb)
	return ret_val;
} /* End function icf_ssa_get_txn_from_call_obj() */

/*******************************************************************************
 * FUNCTION:    icf_ssa_extract_contact_list_from_register_resp
 * 
 * DESCRIPTION: This function is used to populated the contact_list field in 
 *              regm_context with the contact header(s) other than local
 *              contact as obtained in the 200 OK response for REGISTER request.
 *
 *******************************************************************************/

icf_return_t icf_ssa_extract_contact_list_from_register_resp(
                IN       icf_ssa_pdb_st         *p_ssa_pdb,
                INOUT    icf_rgm_context_st     *p_regm_ctx,
                IN       SipMessage             *pSipMsg,       
                OUT      icf_error_t            *p_ecode)
{
      icf_return_t              ret_val = ICF_SUCCESS;
      icf_return_t              return_val = ICF_SUCCESS;
      icf_uint32_t              index=0;
      icf_header_st**           p_p_hdr = ICF_NULL;
      icf_uint8_t*              p_temp_buff = ICF_NULL;
      Sdf_ty_u32bit             dCount = 0;
      icf_uint8_t*              p_token = ICF_NULL;
      icf_int8_t*               p_remainingbuff = ICF_NULL;
      SipError                  sip_err = 0;
      icf_string_st             cfg_contact_ip = {0,{"\0"}};
      SipAddrSpec              *p_addr_spec = ICF_NULL;
      SipUrl                   *p_contact_sip_url = ICF_NULL;
      SipHeader                 contact_hdr = {SipHdrTypeAny,SIP_NULL};
      icf_address_st            rgm_user_addr;
      icf_uint8_t	           *p_rgm_user_info = ICF_NULL;
      icf_header_list_st*       p_contact_hdr_list = ICF_NULL;
        
      ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
      /*SPR 19953 - Free the contact list which is due to any previous
        SIP message before allocating new node to avoid memory leak. 
        In NAT case 200OK for first REGISTER request does populates the
        contact_list which is not freed as no API is given to application.
        Now when the REGISTER 200OK comes after the rport handling is
        complete the existing contact_list gets overwritten*/
      if(ICF_NULL != p_regm_ctx->contact_list.count)
      {
          ret_val = icf_cmn_free_header_list(
                          p_ssa_pdb->p_glb_pdb,
                          &(p_regm_ctx->contact_list),
                          p_ssa_pdb->p_ecode);
      }
      p_contact_hdr_list = &(p_regm_ctx->contact_list);
        
      /* 
       * IPTK sends the contact in REGISTER request as
       * <sip:rgm_user_info@self_IP:self_port>.
       * Example:   Contact:<sip:user@172.16.104.221:20103>
       * To filter the local contact from the contact headers as
       * obtained in the 200 OK response for REGISTER request,
       * three information are required to compare.
       * 1. rgm_user_info  i.e. user
       * 2. self_IP        i.e. 172.16.104.221
       * 3. self_port      i.e. 20103
       */      
   
     /* Extract the rgm user info for which the REGISTER is ongoing*/
  
#ifdef ICF_SECURE_SUPPORT
     if ((ICF_ADDRESS_PLAN_SIPS_URI ==
				 p_regm_ctx->rgm_user_address.addr_type) ||
             (ICF_ADDRESS_PLAN_SIP_URI ==
				 p_regm_ctx->rgm_user_address.addr_type))
#else      
     if (ICF_ADDRESS_PLAN_SIP_URI ==
				 p_regm_ctx->rgm_user_address.addr_type)
#endif
      {
	     icf_port_memcpy(
                &rgm_user_addr,
                &(p_regm_ctx->rgm_user_address),
                ICF_PORT_SIZEOF(icf_address_st));

         p_rgm_user_info = (icf_uint8_t *)icf_port_strtok(
                           (icf_int8_t *)rgm_user_addr.addr_val.str,
                           "@");
     }

    /* Extract the contact_ip_addr and save it into cfg_contact_ip.str.
     * In case of NAT, it will be the Public IP address and in case of 
     * non-NAT, it will be the self ip address.
     */
 
#ifdef ICF_NAT_RPORT_SUPPORT
     if (ICF_SUCCESS != icf_ssa_convert_to_IP_addr(
                         &p_ssa_pdb->p_glb_cfg_data->
                         rport_config_data.contact_ip_addr, 
                        (icf_uint8_t*)&(cfg_contact_ip.str)))
     {
         ret_val = Sdf_co_fail;
     }
#else
     if (ICF_SUCCESS != icf_ssa_convert_to_IP_addr(
                         &p_ssa_pdb->p_glb_cfg_data->
                         self_ip_address, 
                        (icf_uint8_t*)&(cfg_contact_ip.str)))
     {
         ret_val = Sdf_co_fail;
     }
#endif
    /* Get the count of contact headers received in 200 OK response
     * for REGISTER request.
     */

    /* There can be multiple hdrs for that type */
     if(SipFail == sip_getHeaderCount((SipMessage *)pSipMsg,
                       SipHdrTypeContactAny, &dCount,  &sip_err))
     {
        ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                                 pSipMsg,
                                 return_val)
        if (ICF_FAILURE == return_val)
        {
           ret_val = ICF_FAILURE;
           ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
           return ret_val;
        }
     }

    /* Process all the contacts one by one and populate the contact_list
     * in regm context pointed by p_contact_hdr_list. Ignore the
     * local contact.
     */ 

    /* Iterate through the list to get all headers of type SipHdrTypeContactAny*/
     for(p_p_hdr = &(p_contact_hdr_list->hdr),index = 0; index < dCount; index++)
     {
           icf_uint8_t  user_match = ICF_FALSE;
           icf_uint8_t  port_match = ICF_FALSE;

           /* Below the STACK APIs are used to get the contact at index and
            * extract the different parameters from a contact URI and save into
            * p_contact_sip_url.
            * For example: If the contact header value is
            * <sip:user@127.0.0.1:5061>, After extracting it into
            * p_contact_sip_url,the parameters are saved as below.
            *   p_contact_sip_url->pHost = "127.0.0.1"
            *   p_contact_sip_url->pUser = "user"
            *   p_contact_sip_url->dPort = 5061
            * Now these parameters are used to compare and find 
            * the local contact.If failure happens in any STACK API,
            * make continue the for loop to process other contact
            * headers.
            */     

           if (SipFail == sip_getHeaderAtIndex((SipMessage *)pSipMsg,
               SipHdrTypeContactAny,&contact_hdr,index, &sip_err))
           {
               continue;
           }
           else if (SipFail == sip_getAddrSpecFromContactHdr(
                       &contact_hdr,&p_addr_spec,&sip_err))
           {
               sip_freeSipHeader(&contact_hdr);
               continue;
           }
           else if
#ifdef ICF_SECURE_SUPPORT
           ((SipAddrSipSUri == p_addr_spec->dType) ||
#endif
           (SipAddrSipUri == p_addr_spec->dType)
#ifdef ICF_SECURE_SUPPORT
           )
#endif
           {
               if (SipFail == sip_getUrlFromAddrSpec(p_addr_spec,
                                    &p_contact_sip_url,&sip_err))
               {
                   sip_freeSipAddrSpec(p_addr_spec);
                   sip_freeSipHeader(&contact_hdr);
                   continue;
              } 
           }
                 
          /* Now compare the different parameters in contact URI with the
           * local contact value extracted before starting of for loop to
           * identify the local contact.
           */  
     
           /* p_contact_sip_url will be NULL for the URL type 
            * other than SIP in case of Non-TLS. In case of TLS,
            * p_contact_sip_url will be NULL when the URL type is other
            * than SIP or SIPS.  
            */

           /* Compare the IP part*/ 
           if ((ICF_NULL != p_contact_sip_url) &&
                (ICF_NULL != p_contact_sip_url->pHost) && 
                    (0 == icf_port_strcmp(cfg_contact_ip.str,
                     (icf_uint8_t*)p_contact_sip_url->pHost)))
           {
               /*Compare the user part*/ 
               if ((ICF_NULL != p_rgm_user_info) &&
                   (ICF_NULL != p_contact_sip_url->pUser) &&
                   (ICF_NULL == icf_port_strcmp(p_rgm_user_info,
                                    (icf_uint8_t*)p_contact_sip_url->pUser)))
               {
		           user_match = ICF_TRUE;
               }
               
              /* If user and IP have been matched then compare the port*/
              if(ICF_TRUE == user_match)
              {
#ifdef ICF_NAT_RPORT_SUPPORT
                  if ((Sdf_co_null != p_contact_sip_url->dPort) &&
                                   (p_ssa_pdb->p_glb_cfg_data->
                        rport_config_data.contact_ip_addr.port_num == 
                                     *p_contact_sip_url->dPort))                         
                  {
                      port_match = ICF_TRUE;
                  }
#else
                  if ((Sdf_co_null != p_contact_sip_url->dPort) &&
                                  (p_ssa_pdb->p_glb_cfg_data->
                                  self_ip_address.port_num == 
                                  *p_contact_sip_url->dPort))                         
                  {
                      port_match = ICF_TRUE; 
                  }
#endif
              }
               
            /* port_match will be true only when the user, IP and port all
             * are matched.It indicates that it is the local contact.
             * Ignore this contact header and process the next contact header.
             */
    
             if(ICF_TRUE == port_match )
             {
                 sip_freeSipUrl(p_contact_sip_url);
                 sip_freeSipHeader(&contact_hdr);
                 sip_freeSipAddrSpec(p_addr_spec);
                 continue;
             }
          }
          /* If the contact match is unsuccessfull i.e. the processed contact is
           * not the local contact, free these memories and after that process
           * the unmatched contact headers.
           */ 
          sip_freeSipUrl(p_contact_sip_url);
          sip_freeSipHeader(&contact_hdr);
          sip_freeSipAddrSpec(p_addr_spec);

          /* This contact header is not the local contact. Populate this
           * contact header value in contact_list.
           */ 

         if(SipFail == 
            sip_getHeaderAsStringAtIndex((SipMessage *)pSipMsg,
                                          SipHdrTypeContactAny,
                                          ((SIP_S8bit **)&p_temp_buff),
                                          index,&sip_err))
         {
              continue;
         }
   
         /* Tokenize the : separated string into hdr name/value.*/
         p_token = (icf_uint8_t *)icf_port_strtokr((icf_int8_t *)
                  p_temp_buff,(const icf_int8_t *)":",&p_remainingbuff);

         if (ICF_NULL == p_token)
         {                    
               ret_val = ICF_FAILURE;
         }
         else
         {
             /* allocate memory for header node and add to List*/
              ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
                        ICF_PORT_SIZEOF(icf_header_st),
                        ICF_MEM_COMMON, 
                        *p_p_hdr,
                        ICF_DONOT_RET_ON_FAILURE, p_ecode, ret_val)
         }
                    
         if (ICF_FAILURE == ret_val)
         {
              if (ICF_NULL != p_temp_buff)
              {
                /* free the memory allocated for p_temp_buff */
                   fast_memfree(0, p_temp_buff, &sip_err);
              }
              ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
              return ICF_FAILURE;
         }
                    
         /* Increment the header count by one */
         p_contact_hdr_list->count++;
         (*p_p_hdr)->next = ICF_NULL;
                
         /* Populate Name/Value for header in regm context */                
         icf_port_strncpy((icf_int8_t *)(*p_p_hdr)->hdr_name.str, \
                        (const icf_int8_t *)p_token,ICF_MAX_STR_LEN-1);

         (*p_p_hdr)->hdr_name.str[ICF_MAX_STR_LEN - 1]='\0';
         (*p_p_hdr)->hdr_name.str_len = 
              (icf_uint16_t )icf_port_strlen((*p_p_hdr)->hdr_name.str);
                
         if (ICF_NULL != p_remainingbuff)
         {
             icf_port_strncpy((icf_int8_t *)(*p_p_hdr)->hdr_value.str,
                             (const icf_int8_t *)p_remainingbuff, ICF_MAX_LARGE_STR_LEN - 1);
         }

         (*p_p_hdr)->hdr_value.str[ICF_MAX_LARGE_STR_LEN - 1] = '\0';
         (*p_p_hdr)->hdr_value.str_len = 
              (icf_uint16_t)icf_port_strlen((*p_p_hdr)->hdr_value.str);

         /* Move pointer to next node */
         p_p_hdr = &((*p_p_hdr)->next);
                 
         if (ICF_NULL != p_temp_buff)
         {
             /* free the memory allocated for p_temp_buff */
             fast_memfree(0, p_temp_buff, &sip_err);
         }
                                
     } /* for ends */
     ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
     return ret_val;
}/*End function icf_ssa_extract_contact_list_from_register_resp */

/*****************************************************************************
 * FUNCTION:     icf_ssa_extract_n_populate_security_server_hdr
 * DESCRIPTION:  This function extracts the security-server header from 
 *               received message and populate into 
 *               p_security_verify/p_security_server depending on security
 *               association status.
 *****************************************************************************/
icf_return_t   icf_ssa_extract_n_populate_security_server_hdr(
                   IN     SipMessage             *p_sip_msg,
                   INOUT  icf_ssa_ctxt_st        *p_ssa_ctxt,
                   INOUT  SipError               *p_error )
{
   Sdf_ty_u32bit        unknown_hdr_count = 0;
   Sdf_ty_u32bit        curr_count = 0;
   SIP_S8bit            *pUnkHdrName = SIP_NULL;
   SIP_S8bit            *pBuffer = SIP_NULL;
   Sdf_ty_u32bit        buf_count = 0;
   SipHeader            dHeader;
   icf_return_t         ret_val = ICF_SUCCESS;
   icf_rgm_context_st   *p_rgm_ctx = ICF_NULL; 
   icf_ssa_pdb_st       *p_ssa_pdb =
                        (icf_ssa_pdb_st *)(p_ssa_ctxt->p_ssa_pdb);

   ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

   p_rgm_ctx = p_ssa_ctxt->p_rgm_ctxt;

   if(ICF_NULL == p_rgm_ctx)
   {
       ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
       return ret_val;
   }

   /* Get unknown header counts*/
   if(sip_getHeaderCount((SipMessage *)p_sip_msg, SipHdrTypeUnknown,
                        &unknown_hdr_count, p_error)==SipFail)
   {
       ret_val = ICF_FAILURE;
   }

  /*Try to find the security-server header in received message.*/ 
   for(curr_count=0;curr_count<unknown_hdr_count;curr_count++)
   {
      if(SipFail == sip_getHeaderAtIndex((SipMessage *)p_sip_msg, 
                          SipHdrTypeUnknown, &dHeader, 
                          curr_count, p_error))
      {
          ret_val = ICF_FAILURE;
          break;
      }

      if(SipFail == sip_getNameFromUnknownHdr(&dHeader,
                           &pUnkHdrName,p_error))
      {
         sip_freeSipHeader(&dHeader);
         continue;
      }
      if(0 == sip_strcasecmp(pUnkHdrName,"Security-Server"))
      {
         buf_count=icf_port_strlen((icf_uint8_t*)(
                    (SipUnknownHeader *)(dHeader.pHeader))->pStr2);
         pBuffer = (((SipUnknownHeader *)(dHeader.pHeader))->pStr2);

        /* Terminate the value of security-Server header
         * with null char.
         */
         pBuffer[buf_count] = '\0';

        /* If Security association exists, store the Secuirty-Server
         * value in  p_rgm_ctx->p_security_server.
         */
		 if(ICF_NULL != (p_rgm_ctx->indicator_1 &
                          ICF_RGM_SECURITY_ASSOCIATION_DONE))
         {
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                       ICF_PORT_SIZEOF(icf_large_string_st),
                       ICF_MEM_COMMON,
                       p_rgm_ctx->p_security_server,
                       ICF_DONOT_RET_ON_FAILURE,
                       p_ssa_pdb->p_ecode,ret_val)
            
            if(ICF_SUCCESS == ret_val)
            {
               icf_port_strcpy(p_rgm_ctx->p_security_server->str,
							              (icf_uint8_t *)pBuffer);
               p_rgm_ctx->p_security_server->str_len =
                        (icf_uint16_t)icf_port_strlen(
                            p_rgm_ctx->p_security_server->str);
            }
         }
        /* If Security association does not exist, store the
         * Secuirty-Server value in  p_rgm_ctx->p_security_verify.
         */
         else
         {
            ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
                       ICF_PORT_SIZEOF(icf_large_string_st),
                       ICF_MEM_COMMON,
                       p_rgm_ctx->p_security_verify,
                       ICF_DONOT_RET_ON_FAILURE,
                       p_ssa_pdb->p_ecode,ret_val)
            if(ICF_SUCCESS == ret_val)
            {
               icf_port_strcpy(p_rgm_ctx->p_security_verify->str,
                                           (icf_uint8_t *)pBuffer);
               p_rgm_ctx->p_security_verify->str_len =
                   (icf_uint16_t)icf_port_strlen(
                            p_rgm_ctx->p_security_verify->str); 
            }
         }				
						
         sip_freeSipHeader(&dHeader);
         break;
						
      }/* Security-Server header found: processing ends */
      else
      {
         sip_freeSipHeader(&dHeader);
      }

   }/* For loop on unknown headers : ends here */
         
   ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
   return ret_val;
}


/*****************************************************************************
 * FUNCTION:     icf_ssa_form_and_insert_security_agreement_hdrs
 * DESCRIPTION:  This function forms and inserts the Security-Client,
 *               Security-Verify,Require and Proxy-Require header into the 
 *               SIP message.
 *****************************************************************************/
icf_return_t icf_ssa_form_and_insert_security_agreement_hdrs(
        INOUT      icf_ssa_pdb_st   *p_ssa_pdb,
        IN         icf_uint8_t      *method,
        INOUT      SipMessage       *p_otg_sip_msg)
{
    icf_return_t                ret_val = ICF_SUCCESS;
    icf_rgm_context_st          *p_rgm_ctx = ICF_NULL;
    icf_call_ctx_st             *p_call_ctx = ICF_NULL;
    icf_sic_ctx_st              *p_sic_ctx = ICF_NULL;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    
    p_rgm_ctx = p_ssa_pdb->p_ssa_ctxt->p_rgm_ctxt;
    p_call_ctx = p_ssa_pdb->p_ssa_ctxt->p_call_ctxt;
    p_sic_ctx = p_ssa_pdb->p_ssa_ctxt->p_sic_ctxt;

    if(ICF_NULL == p_rgm_ctx)
    {
      if(ICF_NULL != p_call_ctx)
      {
          /* This function returns ICF_FAILURE if no regm context
           * found.So in failure leg of this function return 
           * ICF_SUCCESS to handle the scenario in which regm context
           * is not avilable.
           */ 
          if(ICF_FAILURE == icf_rgm_fetch_ctxt_wrt_uri_wrt_line(
                                       p_ssa_pdb->p_glb_pdb,
                                       &(p_call_ctx->local_address),
                                       &p_rgm_ctx,
                                       p_call_ctx->line_id,
                                       p_ssa_pdb->p_ecode))
          {
               return ICF_SUCCESS; 
          }
      }
      else if(ICF_NULL != p_sic_ctx)
      {
          /* This function returns ICF_FAILURE if no regm context
           * found.So in failure leg of this function return 
           * ICF_SUCCESS to handle the scenario in which regm context
           * is not avilable.
           */ 
          if(ICF_FAILURE == icf_rgm_fetch_ctxt_wrt_uri_wrt_line(
                                     p_ssa_pdb->p_glb_pdb,
                                     p_sic_ctx->p_user_address,
                                     &p_rgm_ctx,
                                     p_sic_ctx->line_id,
                                     p_ssa_pdb->p_ecode))
          {
               return ICF_SUCCESS; 
          } 
      }
      
    }

    if(ICF_NULL != p_rgm_ctx)
    {
    /* If the security-association does not exist and method is REGISTER,
     * check for secuirty-client value present in regm context.
     * If the security-client value present in regm context and method
     * is RREGISTER,insert the security headers Secuirty-Client, Require
     * and Proxy-Require in sip message.
     */
    
        if(ICF_NULL == (p_rgm_ctx->indicator_1 &
                          ICF_RGM_SECURITY_ASSOCIATION_DONE) &&
           (ICF_NULL == icf_port_strcmp(method,(icf_uint8_t*)"REGISTER")) &&
           (ICF_NULL != p_rgm_ctx->p_security_client))
        {
           /*insert the Security-Client header in sip mesasge*/ 
           if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                                 p_ssa_pdb,
                                 (icf_uint8_t*)"Security-Client",
                                 p_rgm_ctx->p_security_client->str,
                                 p_otg_sip_msg))
           {
              ICF_PRINT(((icf_uint8_t*)"\nFailed to insert unknown SA header"
                                             " (Security-Client)"));
              ret_val = ICF_FAILURE;
           }
          /*insert the Require header in sip mesasge*/ 
           else if(ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                                     p_ssa_pdb,
                                     (icf_uint8_t*)"Require",
                                     (icf_uint8_t*)"Sec-Agree",
                                     p_otg_sip_msg))
           {
              ICF_PRINT(((icf_uint8_t*)"\nFailed to insert unknown SA header (Require)"));
              ret_val = ICF_FAILURE;
           }
          /*insert the proxy-Require header in sip mesasge*/ 
           else if(ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                                       p_ssa_pdb,
                                      (icf_uint8_t*)"Proxy-Require",
                                      (icf_uint8_t*)"Sec-Agree",
                                       p_otg_sip_msg))
           {
              ICF_PRINT(((icf_uint8_t*)"\nFailed to insert unknown SA header"
                                                 " (Proxy-Require)"));
              ret_val = ICF_FAILURE;
           }

        }/*End of if:(SA not exist)*/

       /* If the security-associtaion exists,form and insert the security
        * headers Security-Client, Secuirty-Verify, Require and Proxy-Require
        * in sip mesasge.
        */
        else if(ICF_NULL != (p_rgm_ctx->indicator_1 &
                            ICF_RGM_SECURITY_ASSOCIATION_DONE) &&
               (ICF_NULL != p_rgm_ctx->p_security_client) &&
               (ICF_NULL != p_rgm_ctx->p_security_verify))
        {
          /*insert the Security-Client header in sip mesasge*/ 
          if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                                 p_ssa_pdb,
                                (icf_uint8_t*)"Security-Client",
                                 p_rgm_ctx->p_security_client->str,
                                 p_otg_sip_msg))
          {
             ICF_PRINT(((icf_uint8_t*)"\nFailed to insert unknown SA header"
                                             " (Security-Client)"));
             ret_val = ICF_FAILURE;
          }
          /*insert the Security-Verify header in sip mesasge*/ 
          else if (ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                                    p_ssa_pdb,
                                   (icf_uint8_t*)"Security-Verify",
                                    p_rgm_ctx->p_security_verify->str,
                                    p_otg_sip_msg))
          {
              ICF_PRINT(((icf_uint8_t*)"\nFailed to insert unknown SA header"
                                              " (Security-Verify)"));
              ret_val = ICF_FAILURE;
          }
          /*insert the Require header in sip mesasge*/ 
          else if(ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                                     p_ssa_pdb,
                                     (icf_uint8_t*)"Require",
                                     (icf_uint8_t*)"Sec-Agree",
                                     p_otg_sip_msg))
          {
              ICF_PRINT(((icf_uint8_t*)"\nFailed to insert unknown SA header (Require)"));
              ret_val = ICF_FAILURE;
          }
          /*insert the proxy-Require header in sip mesasge*/ 
          else if(ICF_FAILURE == icf_ssa_insert_unknown_hdr_in_sip_msg(
                                     p_ssa_pdb,
                                     (icf_uint8_t*)"Proxy-Require",
                                     (icf_uint8_t*)"Sec-Agree",
                                     p_otg_sip_msg))
          {
             ICF_PRINT(((icf_uint8_t*)"\nFailed to insert unknown SA header"
                                              " (Proxy-Require)"));
             ret_val = ICF_FAILURE;
          }
        }/*End of else if:(SA exists)*/
    }/*End of if(ICF_NULL != p_rgm_ctx)*/

   ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
   return ret_val;
}

/*******************************************************************************
 * FUNCTION:    icf_ssa_remove_100rel_from_callobj_profile
 *
 * DESCRIPTION: This function is used to remove 100rel from supported header
 *              It will be called in two scenarion one for Outgoing INVITE
 *              and the second one for Provisionol responses
 *
 *******************************************************************************/
icf_return_t icf_ssa_remove_100rel_from_callobj_profile
(
 INOUT   icf_ssa_pdb_st       *p_ssa_pdb,
 INOUT   Sdf_st_initData      *pInitData,
 OUT     Sdf_st_error         *p_error)
{
    icf_return_t        ret_val = ICF_SUCCESS;
    Sdf_st_listIterator dListIterator;
    /* Rel 8.2 Klocworks fix */
    Sdf_st_error        Err = {0,0,0,"\0"};
    /* Rel 8.2 Klocworks fix end */
    /*To remove warning*/
    p_error = p_error;
    p_ssa_pdb = p_ssa_pdb;
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    
    /*set list iterator to first element */    
    sdf_listInitIterator(&(pInitData->slExtraHeadersList),
                         &dListIterator,
                         &Err);
    while (Sdf_co_null != dListIterator.pCurrentElement)
    {
        Sdf_st_configExtraHeaders *pTemp = Sdf_co_null;
        en_HeaderType pType = SipHdrTypeAny;
        Sdf_ty_s8bit dTempType[Sdf_co_characterBufferSize]="";
        
        pTemp = (Sdf_st_configExtraHeaders*)\
            (dListIterator.pCurrentElement->pData);
    
        Sdf_mc_strcpy(dTempType,pTemp->pParam->pName);
        if (icf_port_strlen((icf_uint8_t*)dTempType) < Sdf_co_characterBufferSize - 2)
        {
            /* Max length - 2 
             * (1 for NULL) +
             * (1 for ":" to be appended) */
            icf_port_strcat((icf_uint8_t*)dTempType,(icf_uint8_t*)":");
            dTempType[icf_port_strlen((icf_uint8_t*)dTempType)] = '\0';
        }
        /*
        * Invoke stack API to convert the Header name into the stacks
        * en_HeaderType enumeration
        */
        if(SipFail == sip_getTypeFromString(dTempType,
                                            &pType, 
                                            (SipError*)&(Err.stkErrCode)))
        {
            Err.errCode = Sdf_en_headerManipulationError;
            ret_val = ICF_FAILURE;
        }
        /*If header type is "supported" then check for
          presence of "100rel" in it. If present
          then delete the same from list */
        if(pType == SipHdrTypeSupported)
        {
            Sdf_ty_u32bit size,index;
            
            sip_listSizeOf(&(pTemp->pParam->slValue),
                           &size, 
                           (SipError*)&(Err.stkErrCode));
            
            for (index = 0; index < size; index++)
            {
                Sdf_ty_s8bit *pTempVal = Sdf_co_null;
                
                if (SipFail == sip_listGetAt(&(pTemp->pParam->slValue), 
                                  (Sdf_ty_u32bit) index,
                                  (Sdf_ty_pvoid *)&pTempVal,
                                  (SipError*)&(Err.stkErrCode)))
                {
                    Err.errCode=Sdf_en_extraHeaderAccessError;
                    ret_val = ICF_FAILURE;
                }
                
                if(Sdf_mc_strcmp(pTempVal,"100rel") == 0)
                {
                    /* Remove this parameter from the header list
                     */
                    sip_listDeleteAt (&(pTemp->pParam->slValue),
                                      index,
                                      (SipError*)&(Err.stkErrCode));
                    ret_val = ICF_SUCCESS;
                    break;
                }
            }/* End of for loop of supported/require header values.*/
        }

        sdf_listNext(&dListIterator, &Err);
    }/* End of while */
        
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;

}

/*******************************************************************************
 * FUNCTION   : icf_ssa_handle_generic_msg_ind
 * 
 * DESCRIPTION: This function handles an incoming generic message request from
 *              the peer.It copies the header and message body list in the call
 *              context and triggers CC.
 *******************************************************************************/
icf_return_t icf_ssa_handle_generic_msg_ind(
	icf_ssa_pdb_st          *p_ssa_pdb,
    Sdf_st_callObject       *pCallObj,
	Sdf_st_overlapTransInfo *pOverlapTransInfo,
    Sdf_ty_s8bit            *p_method)
{
    icf_return_t                   ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st                *p_ssa_ctxt = ICF_NULL;
	icf_nw_inc_generic_msg_ind_st  *p_internal_msg_param = ICF_NULL;

	ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) /* function entry trace */

    ICF_CHECK_IF_ANY_OF_THREE_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                                          p_ssa_pdb->p_internal_msg,
                                          p_ssa_pdb->p_internal_msg->p_msg_data,
										  p_ssa_pdb->p_ssa_ctxt,
					                      ret_val)

    if(ICF_FAILURE == ret_val)
    {
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }

	p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;

	ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
			                 p_ssa_ctxt->p_call_ctxt,
							 ret_val)
    if(ICF_FAILURE == ret_val)
    {
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }
	/* Form an internal message and trigger CC. */
    p_internal_msg_param = (icf_nw_inc_generic_msg_ind_st *)
                               (p_ssa_pdb->p_internal_msg->p_msg_data);

    /* This new request from network will be rejected with a 491 response in the
       following 3 conditions:
       1. If any generic message has already been received from the network and
          its processing is ongoing, 
       2. If call connect is not done or
       3. If signalling ongoing is not set to invalid.
    */

    if((ICF_GENERIC_MSG_IND_ONGOING & p_ssa_ctxt->p_call_ctxt->common_bitmask_2) ||
       !(ICF_CALL_CONNECT_DONE & p_ssa_ctxt->p_call_ctxt->common_bitmask) ||
       (ICF_INT_MODULE_INVALID != p_ssa_ctxt->p_call_ctxt->signalling_ongoing))
    {
		/* Reject with a 491 */
        if(ICF_FAILURE == icf_ssa_form_and_send_response(
                              p_ssa_pdb,491,
                              pCallObj,
                	          pOverlapTransInfo,
                              p_method, Sdf_co_false))
	 	{
            ret_val = ICF_FAILURE;
		}
    }
    else
    {
		/* None of the above 3 conditions are true. Process the request. */

		/* Copy the method name to the internal message */
		icf_port_strcpy(p_internal_msg_param->method_name.str,(icf_uint8_t*)p_method);
        p_internal_msg_param->method_name.str_len = icf_port_strlen((icf_uint8_t*)p_method);

		/* Populate header and message body list in the call context */
        ret_val = icf_ssa_populate_header_body_list_in_call_ctxt(p_ssa_pdb,
                      pOverlapTransInfo->pSipMsg,
			          SipMessageRequest);
       
		if(ICF_SUCCESS == ret_val)
        {
			/* Trigger CC */
            p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CM;
            p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = ICF_NW_INC_GENERIC_MSG_IND;
            p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 
				ICF_PORT_SIZEOF(icf_nw_inc_generic_msg_ind_st);
 	    }
		else
		{

            /* If the function icf_ssa_populate_header_body_list_in_call_ctxt has 
               set the failure bitmask to send 500, send the response.Since ret_val is
               already set to ICF_FAILURE, there is no need to capture it again.
            */
            
            if(p_ssa_pdb->p_ssa_ctxt->failure_bitmask & 
                   ICF_SSA_FAILURE_RESP_CODE_500)
            {
                icf_ssa_form_and_send_response(
                               p_ssa_pdb,500,
                               pCallObj,
                  	           pOverlapTransInfo,
                               p_method, Sdf_co_false);
            }
            /* Reset bitmask as it is no longer required, a 500 response
               has been sent.
            */
            p_ssa_pdb->p_ssa_ctxt->failure_bitmask &= ~ICF_SSA_FAILURE_RESP_CODE_500;

			ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Failed to insert header/body list in call context\n"))
		}
    }
	ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * FUNCTION   : icf_ssa_handle_generic_msg_resp
 * 
 * DESCRIPTION: This function handles an incoming response of the generic
 *              message request sent by the application.It copies the header
                and message body list in the call context and triggers CC.
 *******************************************************************************/
icf_return_t icf_ssa_handle_generic_msg_resp(
	icf_ssa_pdb_st          *p_ssa_pdb,
	Sdf_st_overlapTransInfo *pOverlapTransInfo,
    Sdf_ty_s8bit            *p_method,
	Sdf_ty_u16bit           resp_code)
{
    icf_return_t                   ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_st                *p_ssa_ctxt = ICF_NULL;
	icf_nw_inc_generic_msg_resp_st *p_internal_msg_param = ICF_NULL;

	ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) /* function entry trace */

    ICF_CHECK_IF_ANY_OF_THREE_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
                                          p_ssa_pdb->p_internal_msg,
                                          p_ssa_pdb->p_internal_msg->p_msg_data,
										  p_ssa_pdb->p_ssa_ctxt,
					                      ret_val)

    if(ICF_FAILURE == ret_val)
    {
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }

	p_ssa_ctxt = p_ssa_pdb->p_ssa_ctxt;

	ICF_CHECK_IF_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
			                 p_ssa_ctxt->p_call_ctxt,
							 ret_val)
    if(ICF_FAILURE == ret_val)
    {
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }
	/* Form an internal message and trigger CC. */
    p_internal_msg_param = (icf_nw_inc_generic_msg_resp_st *)
                               (p_ssa_pdb->p_internal_msg->p_msg_data);

    /* Copy method name and response code */
    icf_port_strcpy(p_internal_msg_param->method_name.str,(icf_uint8_t*)p_method);
    p_internal_msg_param->method_name.str_len = icf_port_strlen((icf_uint8_t*)p_method);
    p_internal_msg_param->response_code = resp_code;

    /* Copy Header and body list in call context */
    ret_val = icf_ssa_populate_header_body_list_in_call_ctxt(p_ssa_pdb,
                  pOverlapTransInfo->pSipMsg,
			      SipMessageResponse);
	
	if(ICF_SUCCESS == ret_val)
    {
		/* Trigger CC */
        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CM;
        p_ssa_pdb->p_internal_msg->msg_hdr.msg_id = ICF_NW_INC_GENERIC_MSG_RESP;
        p_ssa_pdb->p_internal_msg->msg_hdr.payload_length = 
			ICF_PORT_SIZEOF(icf_nw_inc_generic_msg_resp_st);
 	}
	else
	{
		ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Failed to insert header/body list in call context\n"))
	}
	ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*******************************************************************************
 * FUNCTION   : icf_ssa_populate_header_body_list_in_call_ctxt
 * 
 * DESCRIPTION: This function copies the headers and bodies received in a
 *              request/response from the network in the call context.
 *******************************************************************************/
icf_return_t icf_ssa_populate_header_body_list_in_call_ctxt(
	icf_ssa_pdb_st      *p_ssa_pdb,
	SipMessage          *pSipMsg,
    en_SipMessageType 	dReqRespType)
{
    icf_return_t    ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) /* function entry trace */

    /* Copy headers and message bodies in the call context */	
    if(ICF_FAILURE == icf_ssa_populate_app_specific_hdrs(
	     			      p_ssa_pdb, 
    				      ICF_INT_MODULE_CC,
        			      (icf_void_t*)p_ssa_pdb->p_ssa_ctxt->p_call_ctxt,
        				  pSipMsg,
				          p_ssa_pdb->p_ecode))
	{
		ICF_PRINT(((icf_uint8_t *)"\nUnable to get application specific headers"))
		/* Set failure bit only for requests */
        if(SipMessageRequest == dReqRespType)
		{
			p_ssa_pdb->p_ssa_ctxt->failure_bitmask |= 
				ICF_SSA_FAILURE_RESP_CODE_500;
		}	
		ret_val = ICF_FAILURE;
	}
        /* SPR 19590 : Start */
	else if(ICF_FAILURE == icf_ssa_get_msg_body_frm_sip_message_in_call_ctx(
				                                       p_ssa_pdb,
				                                         pSipMsg,
            				                           dReqRespType))
        /* SPR 19590 : End */
	{
		ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Failure In Msg Body retreival from SIP msg"))
		ret_val = ICF_FAILURE;
	}
	ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/* Fix for SPR 19481 */
/*******************************************************************************
 * FUNCTION   : icf_ssa_fetch_txn_and_send_response
 * 
 * DESCRIPTION: This function fetches an overlapped transaction from the call
 *              object list and sends a failure response for that transaction.
 *******************************************************************************/
icf_return_t icf_ssa_fetch_txn_and_send_response(
	icf_ssa_pdb_st      *p_ssa_pdb)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    icf_uint32_t           	 list_size = ICF_NULL,
                             count = ICF_NULL;
    Sdf_st_overlapTransInfo  *p_ovtxn = Sdf_co_null;
    Sdf_st_error             sdf_error = {0,0,0,"\0"};
    SipOptions               options = {0};

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) /* function entry trace */
    
    /* Get the size of the overlapped transaction list in the call object */
    if(Sdf_co_fail == sdf_listSizeOf(
	  				      &(p_ssa_pdb->p_ssa_ctxt->p_call_obj->slOverlapTransInfo),
                		  (Sdf_ty_u32bit *)(&list_size),
						  &sdf_error))
    {
	    ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Failed to get size of overlap txn list\n"));
        ret_val = ICF_FAILURE;
    }
	else
    {
        /* Iterate through the list, fetch the overlapping transaction */
        for(count = 0; count < list_size; count++)
	    {
	        if(Sdf_co_fail == sdf_listGetAt(
	                  	          &(p_ssa_pdb->p_ssa_ctxt->\
                                  p_call_obj->slOverlapTransInfo),
	                        	  count,
	                        	  (Sdf_ty_pvoid)&p_ovtxn,
	                        	  &sdf_error))
	        {
			    ICF_PRINT(((icf_uint8_t*)"\n[SSA]: Failed to get overlap txn\n"));
	            ret_val = ICF_FAILURE;
                break;
            }
    	    /* If the generic message is a REFER or a NOTIFY, then only free
               the transaction key.
            */
            else
            {
                if(Sdf_en_refer == p_ovtxn->dMsgType)
                {
                    p_ssa_pdb->p_method = (icf_uint8_t *)"REFER";
                }
                else if(Sdf_en_notify == p_ovtxn->dMsgType)
                {
                    p_ssa_pdb->p_method = (icf_uint8_t *)"NOTIFY";
                }
    	    
                /* Now form a failure response */
                
                if (Sdf_co_fail == sdf_ivk_uaFormResponse(500,(const Sdf_ty_s8bit*)p_ssa_pdb->p_method,
                                       p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                                       p_ovtxn,
                                       Sdf_co_false,
                                       &sdf_error))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    /* To add the P-Access-Network Info header to the response */
                    if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx)
                    {  
                        if(ICF_FAILURE == 
                               icf_ssa_form_and_insert_access_nw_info_hdr(
                                   p_ssa_pdb,p_ovtxn->pSipMsg))
                        {
                            ret_val = ICF_FAILURE;
                        }
                    }
                    if(ICF_SUCCESS == ret_val)
                    {
                        /* Specify the stack options */
                        options.dOption = SIP_OPT_CLEN|SIP_OPT_FULLFORM;
 
                        if(ICF_FAILURE == icf_ssa_send_to_peer(p_ssa_pdb,
                                             p_ssa_pdb->p_ssa_ctxt->p_call_obj,
                                             p_ovtxn->pSipMsg,
                                             &options,&sdf_error))
                        {
                            ret_val = ICF_FAILURE;
                        }
                    }
                }
            }
    	} /* End for(count) */
    } /* End else */
    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}
/* Fix For SPR: 19593*/
/*******************************************************************************
 * FUNCTION   : icf_ssa_validate_dnsEventContext
 * 
 * DESCRIPTION: This function is used to validate the dns event context
 *              returned from DNS CLIENT.Here we are iterarting all the valid
 *              ssa context and validate whether the pDnsEventContext poniter
 *              is present in it or not.
 *
 * RETURN VALUE: ICF_SUCCESS: If Dns Event Context is present in ssa context.
 *               ICF_FAILURE: If Dns Event Context is not present in ssa context.
 *
 *******************************************************************************/
icf_return_t icf_ssa_validate_dnsEventContext(
	icf_void_t   *pDnsEventContext)
{
    icf_glb_pdb_st             *p_glb_pdb = p_persistent_glb_pdb;
    icf_ssa_ctxt_st            *p_ssa_ctxt = ICF_NULL;
    icf_return_t               ret_val = ICF_FAILURE;
    icf_return_t               return_val = ICF_SUCCESS;
    icf_ssa_ctxt_list_st       *p_ssa_list = ICF_NULL;
    icf_list_st                *p_root = ICF_NULL;
    icf_list_st                *p_tmp_root = ICF_NULL;
    icf_list_st                *p_temp_ssa_list = ICF_NULL;    
    icf_boolean_t              loop_break = ICF_FALSE;
    icf_error_t                ecode = ICF_ERROR_NONE;
    
    /* Function entry trace */
    ICF_FUNCTION_ENTER(p_glb_pdb)     

    /* Get the starting pointer of SSA context list*/   
    p_root =  icf_dbm_fetch_all_ssa_ctxt_from_hash_table(p_glb_pdb);  
    
    for (p_temp_ssa_list = p_root; ICF_NULL != p_temp_ssa_list;
            p_temp_ssa_list = p_temp_ssa_list->p_next)
    {
        for (p_ssa_list = (icf_ssa_ctxt_list_st *)p_temp_ssa_list->p_data;
                ICF_NULL != p_ssa_list;p_ssa_list = p_ssa_list->p_next)
        {
            return_val = ICF_SUCCESS;
            
            p_ssa_ctxt = p_ssa_list->p_ssa_ctxt;

            ICF_CHECK_IF_ANY_OF_TWO_VAR_IS_NULL(p_glb_pdb, p_ssa_ctxt, 
                    p_ssa_ctxt->p_dns_event_context, return_val) 
                
            if(ICF_FAILURE == return_val)
            {
                continue;
            }    
            else
            {
                /* If the p_dns_event_context is present in ssa context then it
                 * is a valid Dns Event Context.Set the value of ret_val as
                 * success and break from the loop*/
                if (p_ssa_ctxt->p_dns_event_context == pDnsEventContext)
                {
                    ret_val = ICF_SUCCESS;
                    loop_break = ICF_TRUE;
                    break;
                }
            }
        }
        /* If the valid ssa context containing the pDnsEventContext is found,
         * break from the for loop*/
        if (ICF_TRUE == loop_break)
        {
            break;
        }
    }

    /* Free the memory allocated to "p_root" list structure in function 
     * icf_dbm_fetch_all_ssa_ctxt_from_hash_table*/ 
    for ( ;ICF_NULL != p_root; )
    {
        p_tmp_root = p_root;
        p_root = p_root->p_next;
        ICF_MEMFREE(
                p_glb_pdb,
                p_tmp_root,
                ICF_MEM_COMMON,
                &ecode,
                return_val);
    }
    
    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}


/*******************************************************************************
 * FUNCTION   : icf_ssa_get_msg_body_frm_sip_message_in_call_ctx
 * 
 * DESCRIPTION: This function is used for adding a node and then retriving 
 *              the body_list in this node. Also associated txn_id is stored
 *              in the added node. 
 *
 *******************************************************************************/
icf_return_t    icf_ssa_get_msg_body_frm_sip_message_in_call_ctx(
        INOUT  icf_ssa_pdb_st         *p_ssa_pdb,
        INOUT  SipMessage             *p_sip_msg,
        INOUT  en_SipMessageType      dReqRespType)
{
    icf_msg_body_link_list_st *p_temp_body_list = ICF_NULL;
    icf_return_t             ret_val = ICF_SUCCESS;

    /* Function entry trace */
   ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
   ICF_CHECK_IF_ANY_OF_TWO_VAR_IS_NULL(p_ssa_pdb->p_glb_pdb,
            p_ssa_pdb->p_ssa_ctxt,
            p_ssa_pdb->p_ssa_ctxt->p_call_ctxt,
            ret_val)
   if(ICF_FAILURE == ret_val)
   {
       ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
       return ret_val;
   }
   /*Allocate memory for the new node to be added
     in call ctx lists of body list */
    ICF_MEMGET(p_ssa_pdb->p_glb_pdb,
        ICF_PORT_SIZEOF(icf_msg_body_link_list_st),
        ICF_MEM_COMMON,\
        p_temp_body_list, ICF_RET_ON_FAILURE,\
        p_ssa_pdb->p_ecode, ret_val);
    
   /* Store the transaction id from the call context to newly added node */
   p_temp_body_list->txn_id =
            p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->txn_id;
   if(ICF_SUCCESS == icf_ssa_get_msg_body_frm_sip_message(
              p_ssa_pdb,
              p_sip_msg,
              dReqRespType,
              &(p_temp_body_list->body_list)))
   {
       /* Adding node in the list */
       ret_val = icf_cmn_add_node_to_list(p_ssa_pdb->p_glb_pdb,\
               &(p_ssa_pdb->p_ssa_ctxt->p_call_ctxt->p_list_of_body_list),\
                   p_temp_body_list);
   }
   else
   {
       /*SPR 19917: In case the function icf_ssa_get_msg_body_frm_sip_message
         returns failure the node is not created in call ctx list.
         Therefore the memory allocated for p_temp_body_list in start of
         function should be freed before returning.*/
       ICF_MEMFREE(p_ssa_pdb->p_glb_pdb, 
                   p_temp_body_list,
                   ICF_MEM_COMMON, 
                   p_ssa_pdb->p_ecode, 
                   ret_val)
       ret_val = ICF_FAILURE;
   }   
   ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
   return ret_val;
}

/*******************************************************************************
 * FUNCTION          icf_ssa_handle_parser_error 
 *
 *
 * Description:  This function handles the error Sdf_en_parserError as returned
 *               by UATK in case of message decode failure.
 *
 * ****************************************************************************/

icf_return_t   icf_ssa_handle_parser_error
                   (icf_ssa_pdb_st  *p_ssa_pdb,
                    Sdf_st_callObject *p_call_obj) 
{
    icf_return_t       ret_val = ICF_SUCCESS;
    icf_uint8_t        *p_call_id = ICF_NULL;
    SipMessage		   *p_sip_msg = Sdf_co_null;
    Sdf_ty_s8bit       *p_method = Sdf_co_null;
    Sdf_st_error       Sdf_error = {0,0,0,"\0"};
    icf_error_t        ecode = ICF_ERROR_NONE;
    icf_ssa_ctxt_st          *p_ssa_ctxt = ICF_NULL;
    Sdf_st_overlapTransInfo  *p_overlap_txn = Sdf_co_null;
    icf_boolean_t      is_method_present = ICF_TRUE;

   ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)
    if(Sdf_co_null == p_call_obj)
    {
        ICF_PRINT(((icf_uint8_t*)"Call Object not present\n"));
        return ICF_FAILURE;
    }
    else if(Sdf_co_null != p_call_obj->pUacTransaction->pSipMsg)
    {   
        p_sip_msg = p_call_obj->pUacTransaction->pSipMsg;
    }    
    else  if(Sdf_co_null != p_call_obj->pUasTransaction->pSipMsg)
    {    
        p_sip_msg = p_call_obj->pUasTransaction->pSipMsg;
    }
    else
    {
        ICF_PRINT(((icf_uint8_t*)"Sip Message not present\n"));
        return ICF_FAILURE;
    }
    sip_freeSipHeader(p_call_obj->pCommonInfo->pKey->pLocalAddr);	
    sip_freeSipHeader(p_call_obj->pCommonInfo->pKey->pRemoteAddr);	

    if (Sdf_co_fail == sdf_ivk_uaGetMethodFromSipMessage(\
                p_sip_msg,\
                &p_method, &Sdf_error))
    {
        is_method_present = ICF_FALSE;
    }

    if ((ICF_TRUE == is_method_present) && 
            (0 == icf_port_strcmp((icf_uint8_t *)p_method, (icf_uint8_t *)"ACK")))
    {
        if (SipFail == (sip_getHeader(p_sip_msg, SipHdrTypeTo, \
                        p_call_obj->pCommonInfo->pKey->pLocalAddr, 
                        (SipError *)&(Sdf_error.stkErrCode))))
        {
            ICF_PRINT(((icf_uint8_t*)"failed to fetch local address\n"));
            return ICF_FAILURE;
        }
        else if (SipFail == (sip_getHeader(p_sip_msg, SipHdrTypeFrom, \
                        p_call_obj->pCommonInfo->pKey->pRemoteAddr, 
                        (SipError *)&(Sdf_error.stkErrCode))))
        {
            ICF_PRINT(((icf_uint8_t*)"failed to fetch remote address\n"));
            return ICF_FAILURE;
        }


        if(Sdf_co_null != p_call_obj->pCommonInfo->pCallid)
        {
            p_call_id = (icf_uint8_t *)p_call_obj->pCommonInfo->pCallid;
        }
        else if(Sdf_co_null != p_sip_msg->pGeneralHdr->pCallidHdr)
        {
            p_call_id = (icf_uint8_t *)p_sip_msg->pGeneralHdr->pCallidHdr->pStr1;
        }
        else
        {
            /* call ID is not received, SSA context can not be fetched,
             * just free the transaction and return from the function
             */ 
            icf_ssa_free_sip_txn_data_on_failure(
                    p_call_obj->pUasTransaction->pTxnKey);
            ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
            return ICF_SUCCESS;
        }
        /*1.
          <----------------- INVITE (decode fails/successfully decoded)
          -----------------> 4xx/5xx
          <----------------- ACK (fails to decode)

          2.
          <----------------- INVITE (successfully decoded)
          -----------------> 2xx
          <----------------- ACK (fails to decode)

          In scenario 1), we would fetch the ssa context and simply
          call the function icf_ssa_process_forceful_call_clear to 
          clear the ongoing transaction and do call object related
          clean-up.

          In scenario 2), we would fetch the ssa context and would
          update the call state in the call object and also trigger
          generic call clear to CC.Call state is changed so that UATK
          allows sending of BYE.
         */                
        if( ICF_FAILURE != icf_ssa_map_nw_callid(
                    p_ssa_pdb, 
#ifdef ICF_LOOPBACK_SUPPORT
                    p_call_obj, 
#endif
                    p_call_id,
                    &p_ssa_ctxt, 
#ifdef ICF_LOOPBACK_SUPPORT
                    &Sdf_error, 
#endif
                    &ecode))
        {
            /* if the call context exist only then send
             * Generic Call Clear Indication and also change the call state
             * for attempting BYE.
             */ 
            /* Scenario 2 */
            if( p_ssa_ctxt && (ICF_NULL != p_ssa_ctxt->p_call_ctxt))
            {
                /* Trigger generic call clear towards CC */
                if(ICF_NULL != p_ssa_pdb->p_internal_msg)
                {                         
                    p_ssa_pdb->p_internal_msg->msg_hdr.msg_id =
                        ICF_GENERIC_CALL_CLEAR;
                    p_ssa_pdb->p_internal_msg->msg_hdr.p_glb_pdb = 
                        p_ssa_pdb->p_glb_pdb;
                    p_ssa_pdb->p_internal_msg->msg_hdr.p_glb_pdb->p_call_ctx = 
                        p_ssa_ctxt->p_call_ctxt;

                    p_ssa_pdb->p_internal_msg->p_msg_data = ICF_NULL;

                }
                p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CM;
                p_ssa_ctxt->p_call_ctxt->signalling_ongoing=
                    ICF_INT_MODULE_INVALID;

                /* change the call object state so that BYE can be sent
                 */ 
                sdf_ivk_uaChangeCallState(p_ssa_ctxt->p_call_obj,
                        p_overlap_txn,
                        p_sip_msg, 
                        Sdf_en_msgModeRecd, &Sdf_error);

                ret_val = icf_ssa_process_otg_intrnl_msg(
                        p_ssa_pdb);
            }
            else
            {
                /* Assigning the mapped ssa context to ssa pdb so
                   that the following function does cleanup of the
                   correct call object.
                 */
                p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;
                /* Call the following function to clean the INVITE
                   transaction and the related call object.
                 */
                icf_ssa_process_forceful_call_clear(p_ssa_pdb);

            }
        }
    }
    else
    {
        /* free the transaction 
         */ 
        icf_ssa_free_sip_txn_data_on_failure(
                p_call_obj->pUasTransaction->pTxnKey);
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/* Fix for SPR: 19886 (Merged CSR 1-7444867)*/
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_clear_div_info
 *
 * DESCRIPTION:     This function would clear the diversion information from 
 *                  call context
 *
 ******************************************************************************/
icf_return_t icf_ssa_clear_div_info(
        INOUT icf_ssa_pdb_st *p_ssa_pdb)
{
    icf_return_t                     ret_val = ICF_SUCCESS;
    icf_diversion_data_st            *p_div_data = ICF_NULL;
    icf_diversion_data_st            *p_div_data_temp = ICF_NULL;


    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb) /* function entry trace */
      

    /* Free the diversion header list - This is a list */
    if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list)
    {
                  
        /* Free the contact addr if present */
        if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx->
                p_diversion_header_list->p_contact_addr)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list->
                    p_contact_addr, ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode, ret_val)

            p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list->p_contact_addr
                    = ICF_NULL;
        }
        
        /* Free the contact name if present */
        if(ICF_NULL != p_ssa_pdb->p_glb_pdb->p_call_ctx->
                p_diversion_header_list->p_contact_name)
        {
            ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                    p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list->
                    p_contact_name, ICF_MEM_COMMON,
                    p_ssa_pdb->p_ecode, ret_val)

            p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list->p_contact_name
                    = ICF_NULL;
        }

        /*Read the next element in list */
        p_div_data = 
            p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list->p_diversion_data;
  
       if(ICF_NULL !=  p_div_data)
       {
           /* If next element is not null, copy it in list */ 
           while(ICF_NULL != p_div_data->p_next)
           {
               p_div_data_temp = p_div_data->p_next;

               ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                      p_div_data, ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)
               p_div_data = p_div_data_temp;
           } 
           ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                   p_div_data,
                   ICF_MEM_COMMON,p_ssa_pdb->p_ecode, ret_val)
           p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list->p_diversion_data =
               ICF_NULL;
       }
        
        ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
                p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list,
                ICF_MEM_COMMON, p_ssa_pdb->p_ecode, ret_val)

        p_ssa_pdb->p_glb_pdb->p_call_ctx->p_diversion_header_list = ICF_NULL;
    }

    
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb) /* function exit trace */
    return ret_val;
}/* end of icf_cc_clear_div_info */


/* CSR 1-7586154 : SPR-19920*/

/******************************************************************************
 * Function: icf_ssa_validate_string_against_word_in_rfc_grammar
 *
 * Description: This function validates the characters present in input_string
 *              against the possible characters present in word as defined in
 *              Grammer of RFC-3261.
 *
 *              word        =  1*(alphanum / "-" / "." / "!" / "%" / "*" /
 *                   "_" / "+" / "`" / "'" / "~" /
 *                   "(" / ")" / "<" / ">" /
 *                   ":" / "\" / DQUOTE /
 *                   "/" / "[" / "]" / "?" /
 *                   "{" / "}" )
 *
 *
 * ***************************************************************************/
icf_return_t icf_ssa_validate_string_against_word_in_rfc_grammar(
                   IN            icf_ssa_pdb_st *p_ssa_pdb,
                   IN            icf_uint8_t    *input_string)
{
    icf_return_t           ret_val = ICF_SUCCESS,dummy_ret_val = ICF_SUCCESS;
    icf_uint16_t           length = 0;
    icf_uint16_t           index  = 0;
    icf_uint8_t            *p_tmp_string = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    length = icf_port_strlen(input_string);

    /* Following code changes is done to remove the klocwork warning.This
     * function is a generic function which can be used in future to validate
     * any word of any length as per RFC. Now in the calling function of the
     * function if the input_string is an array of 256 character then even if
     * the calling function has taken care of population of only 256
     * characters, Klocwork doubt that we are reading the variable as per the
     * length of this variable ie input_string. Klockwork evaluate that the
     * length of this variable can be 0 to 65535 and in the following for loop
     * we will enconter ABR. To cater this problem a local pointer is taken,
     * for which memory is allocated of size length + 1 ; value is copied to 
     * this variable and in the traversing of this loop, local variable is used.*/

    ICF_MEMGET(p_ssa_pdb->p_glb_pdb, 
            length+1,
            ICF_MEM_COMMON,p_tmp_string,
            ICF_DONOT_RET_ON_FAILURE,p_ssa_pdb->p_ecode, ret_val)     

    if (ICF_FAILURE == ret_val) 
    {
        ICF_PRINT(((icf_uint8_t *)"\nMemory Allocation Failure while"\
                    "validating word against RFC grammer\n"));
        return ret_val;
    }
    else
    {
        icf_port_memcpy(p_tmp_string,(icf_uint8_t *)input_string,length+1);
    }

    /* Validate the string against the characters of "word" defined
     * in RFC 3261.
     */

    for(index=0;index < length ;index++)
    {
        if(0 != isalnum(*(p_tmp_string+index)))
        {
            /* do nothing; */
        }
        else
        {
            switch(*(p_tmp_string+index))
            {
                case '-':
                case '.':
                case '!':
                case '%':
                case '*':
                case '_':
                case '+':
                case '\'':
                case '`':
                case '~':
                case '(':
                case ')':
                case '<':
                case '>':
                case ':':
                case '\\':
                case '/':
                case '[':
                case ']':
                case '?':
                case '{':
                case '"':
                case '}':
                    break;
                default:
                    ret_val = ICF_FAILURE;
                    break;
            }
        }
        /* If ret val is FALSE, brake the loop and return from function.*/
        if (ICF_FAILURE == ret_val)
        { 
            break;
        }
     }

    ICF_MEMFREE(p_ssa_pdb->p_glb_pdb,
            p_tmp_string,
            ICF_MEM_COMMON,
            p_ssa_pdb->p_ecode,
            dummy_ret_val)
        
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/******************************************************************************
 * Function: icf_ssa_validate_incoming_request
 *
 * Description: This function validates the following headers in incoming 
 *              request as per Grammar defined in RFC-3261.
 *              1) Call-ID
 *
 * ***************************************************************************/
icf_return_t icf_ssa_validate_incoming_request(
                    IN           icf_ssa_pdb_st *p_ssa_pdb,
                    IN           SipMessage     *pMessage)
{
   icf_return_t           ret_val = ICF_SUCCESS;
   SipHeader              dHeader = {SipHdrTypeAny,SIP_NULL};
   SipError               error  = 0;
   icf_uint8_t            callid[ICF_MAX_NW_CALL_ID_DGTS]= "\0";
   icf_uint8_t            *p_temp   = ICF_NULL;
   icf_uint8_t            *p_token1 = ICF_NULL;
   icf_uint8_t            *p_token2 = ICF_NULL;

   ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

   /*Validation for ******** Call-ID ************ Start*/

   /*Get the Call-ID header*/ 
   if (sip_getHeader((SipMessage*)pMessage, SipHdrTypeCallId, \
                           &dHeader, &error) == SipFail)
   {
       ICF_PRINT(((icf_uint8_t *)"\nFailed to get Call-ID Header"));
       ret_val = ICF_FAILURE;
       ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
       return ret_val;
   }
   /*Copy the Call-Id value in local variable callid for further processing*/
   else
   {
       icf_port_strncpy((icf_int8_t *)callid,((SipCommonHeader*)dHeader.pHeader)->pStr1,
                                             ICF_MAX_NW_CALL_ID_DGTS - 1);
       callid[ICF_MAX_NW_CALL_ID_DGTS - 1] = '\0';
   }
   sip_freeSipHeader(&dHeader);

   /* If '@' is the first or last character in Call-ID string,
    * return failure since as per RFC-3261,'@' should neither
    * be first nor last character in call-ID string.
    */
   if(('@' == callid[0]) ||
      ('@' == callid[icf_port_strlen(callid)-1]))
   {
       ret_val = ICF_FAILURE; 
   }
   else
   {
      /* Find whether the character '@' is present in Call-ID string*/
      p_temp = icf_port_strchr(callid, '@');

      /* If '@' is not present in Call-ID string,valiadte the string with word*/
      if(ICF_NULL == p_temp)
      {
        ret_val = 
         icf_ssa_validate_string_against_word_in_rfc_grammar(p_ssa_pdb,callid);
      }
      /* If '@' is present in Call-ID string*/
      else
      {
        p_token2 = p_temp + 1;

        p_token1 = (icf_uint8_t *)icf_port_strtok((icf_int8_t *)callid, "@");

        /* Validate token1 and token2 against word(defined in RFC-3261).*/
        if((ICF_FAILURE != ret_val) &&
                (ICF_NULL != p_token2) &&
                (ICF_NULL != p_token1))
        {
           if(ICF_FAILURE ==
             icf_ssa_validate_string_against_word_in_rfc_grammar(p_ssa_pdb,p_token1))
           {
                ret_val = ICF_FAILURE;
           }
           else if(ICF_FAILURE ==
             icf_ssa_validate_string_against_word_in_rfc_grammar(p_ssa_pdb,p_token2))
           {
                ret_val = ICF_FAILURE;
           }
        }
      }
   }
   /*Validation for ******** Call-ID ************ End*/

   ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
   return ret_val;
}

/*Fix for SPR: 19999 (Merged CSR 1-7586127 : SPR-19988)*/
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_get_via_key
 *
 * DESCRIPTION:     This function is used by SSA for fetching the via
 *                  parameters.
 *
 ******************************************************************************/
icf_return_t icf_ssa_get_via_key (
        INOUT  icf_ssa_pdb_st     *p_ssa_pdb,
        INOUT  SipMessage         *p_sip_message,
        INOUT  icf_uint8_t        *p_key,
        OUT    Sdf_st_error       *p_sdf_error)
{
    icf_return_t             ret_val = ICF_SUCCESS;
    Sdf_ty_s8bit             *p_sentby = ICF_NULL;
    Sdf_ty_s8bit             *p_viabranch = ICF_NULL;
    SipHeader                dTempHeader;
     
    /* Find the sentby and branch parameters from
     * topmost Via header and concatenate them to form the string which will
     * be compared with p_nw_via. 
     */
    p_ssa_pdb = p_ssa_pdb;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (SipFail == sip_getHeaderAtIndex(
                    p_sip_message, SipHdrTypeVia,&dTempHeader,
                     0, (SipError*)&(p_sdf_error->stkErrCode)))
    {
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val;
    }
    else if (SipFail == sdf_fn_GetBranchFromViaHdr(
             &dTempHeader, &p_viabranch, p_sdf_error))
    {
            p_viabranch = ICF_NULL;
            ret_val = ICF_FAILURE;
    }
    else if (SipFail == sip_getSentByFromViaHdr(
              &dTempHeader, &p_sentby,(SipError*)&(p_sdf_error->stkErrCode)))
    {        
        sip_freeSipHeader(&dTempHeader);
        ret_val = ICF_FAILURE;
        ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
        return ret_val; 
    }

    /* If Branch parameter is not present in Via header or the magic cookie is
     * not present in Branch parameter, return failure.
     */
    if((ICF_NULL != p_viabranch) && 
       (0 != icf_port_strncmp((icf_uint8_t *)p_viabranch,
                              (icf_uint8_t *)"z9hG4bK",7)))
    {
        ret_val = ICF_FAILURE;
    }
    /* Generate the via hash key by concatenating the sent-by parameter value
     * and brnach parameter value received in Via header.
     */
    else if(ICF_NULL != p_viabranch)
    {
        icf_port_strcpy((icf_uint8_t *)p_key,(icf_uint8_t *)p_sentby);
        icf_port_strcat((icf_uint8_t *)p_key,(icf_uint8_t *)p_viabranch);
        p_key[icf_port_strlen(p_key)] = '\0';
    }
    sip_freeSipHeader(&dTempHeader);
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*Fix for SPR: 19999 (Merged CSR 1-7586127 : SPR-19988)*/
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_map_nw_via
 *
 * DESCRIPTION:     This function is used by SSA for fetching the mapped
 *                  ssa context with via branch parameter.
 *
 ******************************************************************************/
icf_return_t icf_ssa_map_nw_via(
        INOUT  icf_ssa_pdb_st     *p_ssa_pdb,
        INOUT  Sdf_st_callObject  *p_temp_call_obj,
        INOUT  icf_uint8_t        *p_nw_via,
        OUT    icf_ssa_ctxt_st    **p_p_mapped_ssa_ctxt,
        OUT    Sdf_st_error       *p_sdf_error)
{
    icf_return_t          ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_list_st  *p_ssa_list = ICF_NULL;
    icf_ssa_ctxt_list_st  *p_ssa_temp = ICF_NULL;
    
    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    (void)p_temp_call_obj;
    (void)p_sdf_error;

    ret_val = icf_dbm_fetch_ssa_ctxt_from_via_mapped_hash_table(
                     p_ssa_pdb->p_glb_pdb, p_nw_via,
                     (icf_void_t **)&p_ssa_list,p_ssa_pdb->p_ecode);

    if ((ret_val == ICF_SUCCESS) &&
            (ICF_NULL != p_ssa_list))
    {
        *p_p_mapped_ssa_ctxt = p_ssa_list->p_ssa_ctxt ;

        /*  Each ssa context will fetched from list and compared the 
         *  via branch parameter value in call object with received via branch
         *  parameter value. If the match match is found, loop is break.
         */

        for (p_ssa_temp = p_ssa_list;p_ssa_temp != ICF_NULL;
                                p_ssa_temp = p_ssa_temp->p_next)
        {
            if(0 == icf_port_strcmp(p_nw_via, 
                        p_ssa_temp->p_ssa_ctxt->p_via_hash_key))
            {
              *p_p_mapped_ssa_ctxt = p_ssa_temp->p_ssa_ctxt;
               ret_val =  ICF_SUCCESS;
               break;
            }
        }

        if(ICF_NULL == p_ssa_temp)
        {
            *p_p_mapped_ssa_ctxt = ICF_NULL;
            ret_val = ICF_FAILURE;
        }
    }
    else
        *p_p_mapped_ssa_ctxt = ICF_NULL;

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*Fix for SPR: 19999 (Merged CSR 1-7586127 : SPR-19988)*/
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_add_via_callobj_map
 *
 * DESCRIPTION:     This function is used by SSA for adding SSA ctxt
 *                  nw via mapping to the SSA db.
 *
 ******************************************************************************/
icf_return_t icf_ssa_add_via_callobj_map(
        INOUT  icf_ssa_pdb_st   *p_ssa_pdb,
        OUT    icf_ssa_ctxt_st  *p_ssa_ctxt,
        IN     icf_uint8_t      *p_nw_via)
{
    icf_return_t                   ret_val = ICF_SUCCESS;
    icf_ssa_ctxt_list_st          *p_map_ssa_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st          *p_map_temp_ssa_ctxt = ICF_NULL;
    icf_uint32_t                   key_length = 0;

    if((ICF_NULL == p_nw_via) || 
            (ICF_NULL == p_ssa_pdb) || 
                (ICF_NULL == p_ssa_ctxt))
    {
        return  ICF_FAILURE;
    }

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

#ifdef ICF_LOAD_DEBUG
    printf("\nSSA CTXT Allocated: %x %s\n", p_ssa_ctxt,p_nw_via); 
#endif
    /* Get the length of via header which will be used for hash key. */
    key_length = icf_port_strlen((icf_uint8_t *)p_nw_via); 

    /* Allocate the memory for via_hash_key. */
    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            key_length+ 1,
            ICF_MEM_COMMON,
            p_ssa_ctxt->p_via_hash_key,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val);

    /* Copy the Via header to identify the p_via_hash_key. 
     * p_via_hash_key only contains the branch parameter value
     * received in Via header. */
    icf_port_strcpy(p_ssa_ctxt->p_via_hash_key,(icf_uint8_t *)p_nw_via);

    ICF_MEMGET(
            p_ssa_pdb->p_glb_pdb,
            sizeof(icf_ssa_ctxt_list_st),
            ICF_MEM_COMMON,
            p_map_ssa_ctxt,
            ICF_RET_ON_FAILURE,
            p_ssa_pdb->p_ecode,
            ret_val);
    p_map_ssa_ctxt->p_ssa_ctxt = p_ssa_ctxt;
    p_map_ssa_ctxt->p_next = ICF_NULL;

    /* Fetch the existing ssa context list from hash table based on Via
     * header received*/  
    ret_val = icf_dbm_fetch_ssa_ctxt_from_via_mapped_hash_table(p_ssa_pdb->p_glb_pdb,
                             p_ssa_ctxt->p_via_hash_key,
                             (icf_void_t **)&p_map_temp_ssa_ctxt,
                             p_ssa_pdb->p_ecode);

    if ( ICF_SUCCESS == ret_val)
    {
        /*  append it to link list */
        icf_ssa_append_to_ssa_ctxt_list(p_map_temp_ssa_ctxt, p_map_ssa_ctxt);
    }
    else
    {
        ret_val = icf_dbm_hash_add_ssa_ctxt_mapped_with_via(
                            p_ssa_pdb->p_glb_pdb,
                            p_ssa_ctxt->p_via_hash_key,
                            p_map_ssa_ctxt,p_ssa_pdb->p_ecode);
    }

    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*Fix for SPR: 19999 (Merged CSR 1-7586127 : SPR-19988)*/
/******************************************************************************
 * Function:    icf_ssa_match_via_and_clear
 *
 * Description: This function checks the Cancel's Via if it contains
 *              magic cookie then compare the Via else 
 *              1) Call-ID
 *
 * ***************************************************************************/
icf_return_t icf_ssa_match_via_and_clear(
                    INOUT  icf_ssa_pdb_st       *p_ssa_pdb,
                    INOUT  Sdf_st_callObject    *p_call_obj)
{
    Sdf_st_error        sdf_error = {0,0,0,"\0"};
    SipMessage          *p_sip_msg = Sdf_co_null;
    Sdf_ty_s8bit        *p_method = Sdf_co_null;
    icf_return_t        ret_val = ICF_FAILURE;
    en_SipMessageType   dMsgType = SipMessageAny;
    Sdf_ty_s8bit        key[ICF_MAX_LARGE_STR_LEN] = "\0";
    icf_ssa_ctxt_st     *p_ssa_ctxt = ICF_NULL;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    /* Get the sip message from Call object*/
    if ((Sdf_co_null != p_call_obj->pUacTransaction) &&
            (Sdf_co_null != p_call_obj->pUacTransaction->pSipMsg))
    {
        p_sip_msg = p_call_obj->pUacTransaction->pSipMsg;
    }
    else if(Sdf_co_null != p_call_obj->pUasTransaction) 
    {
        p_sip_msg = p_call_obj->pUasTransaction->pSipMsg;
    }

    /* Get the message type and method name*/
    if (Sdf_co_null != p_sip_msg)
    {
        sip_getMessageType(p_sip_msg, &dMsgType, \
                (SipError*)	&(sdf_error.stkErrCode)) ;
        if (SipMessageRequest != dMsgType)
        {
            ret_val = ICF_FAILURE;
        }

        else if(Sdf_co_fail ==
                sdf_ivk_uaGetMethodFromSipMessage(
                    p_sip_msg, &p_method, &sdf_error))
        {
            ret_val = ICF_FAILURE;
        }
        /* If the method is CANCEL, match the transaction based on via key*/ 
        else if (ICF_NULL == 
                icf_port_strcmp((icf_uint8_t *)p_method,(icf_uint8_t*)"CANCEL"))
        {
            if (ICF_FAILURE == icf_ssa_get_via_key (
                        p_ssa_pdb, p_sip_msg, (icf_uint8_t *)(&key), &sdf_error))
            {
                ret_val = ICF_FAILURE;
            }
            /* then call icf_ssa_map_via_hdr()*/
            else if(ICF_SUCCESS == icf_ssa_map_nw_via(
                        p_ssa_pdb, p_call_obj,(icf_uint8_t *)key,
                        &p_ssa_ctxt, &sdf_error ))
            {
                if (ICF_NULL != p_ssa_ctxt)
                {
                    /* Call the force ful call clear */
                    /* Assigning the mapped ssa context to ssa pdb so
                       that the following function does cleanup of the
                       correct call object.
                     */
                    p_ssa_pdb->p_ssa_ctxt = p_ssa_ctxt;
                    /* Call the following function to clean the INVITE
                       transaction and the related call object.
                     */
                    if(ICF_NULL != p_ssa_ctxt->p_call_ctxt)
                    {
                        /* Trigger generic call clear towards CC */
                        if(ICF_NULL != p_ssa_pdb->p_internal_msg)
                        {
                            p_ssa_pdb->p_internal_msg->p_msg_data = ICF_NULL;
                            p_ssa_pdb->p_internal_msg->msg_hdr.msg_id =
                                ICF_FORCEFUL_CALL_CLEAR_IND;
                            p_ssa_pdb->p_internal_msg->msg_hdr.p_glb_pdb = 
                                p_ssa_pdb->p_glb_pdb;
                            p_ssa_pdb->p_internal_msg->msg_hdr.p_glb_pdb->p_call_ctx = 
                                p_ssa_ctxt->p_call_ctxt;
                        }
                        p_ssa_pdb->dest_module_id = ICF_INT_MODULE_CM;
                        p_ssa_ctxt->p_call_ctxt->signalling_ongoing =
                            ICF_INT_MODULE_INVALID;
                        ICF_SSA_SET_COMMON_BITMASK((p_ssa_pdb->common_bitmask),\
                                ICF_SSA_INTER_MODULAR_MSG)
                            icf_ssa_process_otg_intrnl_msg(p_ssa_pdb);
                    }
                    ret_val = ICF_SUCCESS;
                }
                else 
                {
                    ret_val = ICF_FAILURE;
                }
            }
            else
            {
                ret_val = ICF_FAILURE;
            }
        }
        else
        {
            ret_val = ICF_FAILURE;
        }
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/*Fix for SPR: 19999 (Merged CSR 1-7586127 : SPR-19988)*/
/*******************************************************************************
 *
 * FUNCTION:        icf_ssa_remove_via_mapped_ctxt_list_entry
 *
 * DESCRIPTION:     This function is used by SSA for removing SSA ctxt
 *                  entry from hash table maintained based on via.
 *
 ******************************************************************************/

icf_return_t icf_ssa_remove_via_mapped_ctxt_list_entry(
                   INOUT  icf_glb_pdb_st   *p_glb_pdb,
                   INOUT  icf_ssa_ctxt_st  *p_ssa_ctxt)
{
    icf_ssa_ctxt_list_st *p_temp_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st *p_ret_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st *p_hold_ctxt = ICF_NULL;
    icf_ssa_ctxt_list_st *p_prev_ctxt = ICF_NULL;
    icf_uint8_t          flag = ICF_FALSE;
    icf_ssa_ctxt_st      *p_tmp_ssa_ctxt = ICF_NULL;
    icf_error_t          ecode = ICF_NULL;
    icf_return_t         ret_val = ICF_FAILURE;

    /*Find the first node in ssa_context_list from the hash table*/
    ret_val = icf_dbm_fetch_ssa_ctxt_from_via_mapped_hash_table(p_glb_pdb,
                             p_ssa_ctxt->p_via_hash_key,
                             (icf_void_t **)&p_ret_ctxt,
                             &ecode);

    if (ICF_FAILURE == ret_val)
    {
        return ICF_FAILURE;
    }
    /* Find the matching ssa context from the list
     * if matching context is found, set the flag as TRUE.
     */
    for (p_temp_ctxt = p_ret_ctxt; p_temp_ctxt != ICF_NULL; p_temp_ctxt = p_temp_ctxt->p_next)
    {
        if (p_temp_ctxt->p_ssa_ctxt == p_ssa_ctxt)
        {
            flag = ICF_TRUE;
            break;
        }
        p_prev_ctxt = p_temp_ctxt;
    }
    /* If the flag is TRUE and p_temp_ctxt is not NULL, it indicates that the
     * matching ssa context node is found.Delete that node from the list.
     */
    if ((ICF_TRUE == flag) && (ICF_NULL != p_temp_ctxt))
    {
        ICF_PRINT(((icf_uint8_t *)"\nGot the list context to be deleted." 
                    "Searching whether any linked node is present"));
        p_hold_ctxt = p_temp_ctxt->p_next;

        /* If matched ssa context node in the first node in SSA context
         * list
         */
        if (p_temp_ctxt == p_ret_ctxt)
        {
#ifdef ICF_LOAD_DEBUG
    printf("\nSSA CTXT DE-Allocated: %x %s\n", p_ssa_ctxt,p_ssa_ctxt->p_via_hash_key);
#endif
            /* Remove ssa contetxt from hash table*/
            icf_dbm_remove_via_mapped_ssa_ctxt(p_glb_pdb,
                    p_ssa_ctxt->p_via_hash_key,
                    p_tmp_ssa_ctxt,&ecode);

            if (ICF_NULL != p_hold_ctxt)
            {
                ICF_PRINT(((icf_uint8_t *)"\nThere is another entry present so adding this entry"));
                icf_dbm_hash_add_ssa_ctxt_mapped_with_via(
                        p_glb_pdb,
                        p_ssa_ctxt->p_via_hash_key,
                        (icf_void_t *)p_hold_ctxt,&ecode);
            }
            else
            {
                ICF_PRINT(((icf_uint8_t *)"\nOnly one context is there so removing it"));
            }
        }
        else
        {
            ICF_PRINT(((icf_uint8_t *)"\nRemoving only link as it is not the first entry"));
            if (ICF_NULL != p_prev_ctxt)
                p_prev_ctxt->p_next = p_hold_ctxt;
        }
        /* Delete the matched node*/
        ICF_MEMFREE(
                p_glb_pdb,
                p_temp_ctxt,
                ICF_MEM_COMMON,
                &ecode,
                ret_val);
    }
   /* Delete the p_via_hash_key from ssa context as this entry is deleted from
    * hash table.
    */ 
    ICF_MEMFREE(
           p_glb_pdb,
           p_ssa_ctxt->p_via_hash_key,
           ICF_MEM_COMMON,
           &ecode,
           ret_val)

	p_ssa_ctxt->p_via_hash_key = ICF_NULL; 

    return ret_val;
}

/* Fix for SPR: 19999(Merged CSR 1-7605218: SPR-19997 fixed)*/
/*****************************************************************************
 * FUNCTION:        icf_ssa_compare_request_uri
 *
 * DESCRIPTION:		This function is used to compare the request URI of 
 *					received SIP request and Request URI of existing SSA 
 *					CONTEXT passed into this function
 * RETURN:          It returns SUCCESS if Request URI matches else return
 *                  FAILURE
 *****************************************************************************/
icf_return_t icf_ssa_compare_request_uri(icf_ssa_pdb_st  *p_ssa_pdb, 
                                         SipMessage      *p_temp_msg,
                                         icf_ssa_ctxt_st *p_ssa_ctxt)
{
    SipReqLine      *p_req_line = SIP_NULL;
    SipAddrSpec     *p_req_addr_spec = SIP_NULL;
    icf_address_st  req_uri = {{0,"\0"},0};
    Sdf_st_error    sdf_error = {0,0,0,"\0"};
    icf_return_t    ret_val = ICF_SUCCESS;

    ICF_FUNCTION_ENTER(p_ssa_pdb->p_glb_pdb)

    if (SipFail == sip_getReqLineFromSipReqMsg(
                p_temp_msg,
                &p_req_line,(SipError*)&(sdf_error.stkErrCode)))
    {
        ret_val = ICF_FAILURE;
    }
    else if (SipFail == sip_getAddrSpecFromReqLine(
                p_req_line, &p_req_addr_spec,
                (SipError*)&(sdf_error.stkErrCode)))
    {
        sip_freeSipReqLine(p_req_line);
        ret_val = ICF_FAILURE;
    }
    else
    {
        ret_val = icf_ssa_populate_address_from_sip_addr_spec(p_ssa_pdb,
                p_req_addr_spec,
                &req_uri);
        if ((ICF_SUCCESS == ret_val) && (ICF_NULL != p_ssa_ctxt))
        {
            if (p_ssa_ctxt->req_uri.addr_type != req_uri.addr_type)
            {
                ret_val = ICF_FAILURE;
            }
            else
            {
                if (ICF_NULL !=
                        icf_port_strcmp(p_ssa_ctxt->req_uri.addr_val.str,
                            req_uri.addr_val.str))
                {
                    ret_val = ICF_FAILURE;
                }
                else
                {
                    ret_val = ICF_SUCCESS;
                }
            }
        }
        sip_freeSipAddrSpec(p_req_addr_spec);
        sip_freeSipReqLine(p_req_line);
    }
    ICF_FUNCTION_EXIT(p_ssa_pdb->p_glb_pdb)
    return ret_val;
}

/* Fix for SPR: 19999(Changes done while merging CSR 1-7605218*/
/***************************************************************************
 *
 * FUNCTION:     icf_ssa_init_pdb_for_tcp_extra_msg_hdlg
 * DESCRIPTION:  This functions initialise the selective SSA pdb variable 
 *               except p_conn_table_entry and the one which are initialised
 *               at the begining of function icf_ssa_process_nw_msg.
 *
 ***************************************************************************/
icf_return_t  icf_ssa_init_pdb_for_tcp_extra_msg_hdlg(icf_ssa_pdb_st *p_ssa_pdb,
        icf_glb_pdb_st  *p_glb_pdb)
{
    icf_return_t   ret_val = ICF_SUCCESS;
    
    if(ICF_NULL == p_glb_pdb)
    {
        ICF_PRINT(((icf_uint8_t *)"\n[SSA]:Glb PDB is NULL"))
        return ICF_FAILURE;
    }

    ICF_FUNCTION_ENTER(p_glb_pdb)

    p_ssa_pdb->p_line_data = ICF_NULL;
    p_ssa_pdb->p_rgm_context = ICF_NULL;
    p_ssa_pdb->p_call_ctxt = ICF_NULL;
    p_ssa_pdb->p_sic_ctxt = ICF_NULL;
#ifdef ICF_IPSEC_ENABLED
    p_ssa_pdb->p_sa_context = ICF_NULL;
#endif
    p_ssa_pdb->p_app_conf = ICF_NULL;
#ifdef ICF_DNS_LOOKUP_ENABLED
    p_ssa_pdb->p_event_ctxt = Sdf_co_null;
#endif
    p_ssa_pdb->common_bitmask = ICF_NULL;
    p_ssa_pdb->line_recvd = ICF_NULL;    
    p_ssa_pdb->p_ssa_ctxt = Sdf_co_null;
    p_ssa_pdb->hash_index = 0;
#ifdef ICF_TRACE_ENABLE
    p_ssa_pdb->dialog_status = 0;
    p_ssa_pdb->sdp_present = ICF_FALSE;
    p_ssa_pdb->replace_header_present = ICF_FALSE;
    p_ssa_pdb->p_buf = ICF_NULL;
    p_ssa_pdb->len = 0;
    p_ssa_pdb->result = ICF_FALSE;
    ICF_CMN_INIT_ADDRESS(p_ssa_pdb->local_addr)
    ICF_CMN_INIT_ADDRESS(p_ssa_pdb->remote_addr)
    p_ssa_pdb->p_subs_state = Sdf_co_null;
    p_ssa_pdb->dns_query_type = ICF_NULL;
    p_ssa_pdb->notify_duration = ICF_NULL;
    p_ssa_pdb->reason_code[0] = '\0'; 
#endif
    p_ssa_pdb->send_trans_param = ICF_FALSE;
    p_ssa_pdb->bye_rejected = ICF_FALSE;
    p_ssa_pdb->is_otg_msg = ICF_FALSE;
    p_ssa_pdb->p_method = ICF_NULL;
    p_ssa_pdb->dest_module_id = ICF_INT_MODULE_INVALID;
    p_ssa_pdb->conn_type = ICF_NULL;
    p_ssa_pdb->warning_header_code = ICF_NULL;
    p_ssa_pdb->retrans_count = ICF_NULL;
    p_ssa_pdb->resp_code = ICF_NULL;
    p_ssa_pdb->dRespCode = ICF_NULL;
    p_ssa_pdb->call_direction = ICF_NULL;
    p_ssa_pdb->trans_param[0] = '\0';
    p_ssa_pdb->dMsgType = SipMessageAny;
    p_ssa_pdb->dest_port = ICF_NULL;
    p_ssa_pdb->dest_ip[0] = '\0';
    p_ssa_pdb->protocol = ICF_NULL;
    ICF_CMN_INIT_ADDRESS(p_ssa_pdb->conference_uri)
    ICF_CMN_INIT_STRING(p_ssa_pdb->warning_text)
    p_ssa_pdb->authorised_req = ICF_FALSE;
    p_ssa_pdb->notify_tag_mismatch = ICF_FALSE;
    p_ssa_pdb->addr_param_not_reqd = ICF_FALSE;
    p_ssa_pdb->precondition_in_require_hdr = ICF_FALSE;
    p_ssa_pdb->precondition_in_supp_hdr = ICF_FALSE;
    p_ssa_pdb->rem_srv_cnt = ICF_NULL;
    p_ssa_pdb->p_app_ctxt = ICF_NULL;
    p_ssa_pdb->p_invalid_assoc_uri = ICF_NULL;
    p_ssa_pdb->p_call_obj_to_dealloc = ICF_NULL;
    p_ssa_pdb->mline_rcvd_w_app_profile = ICF_NULL;
    p_ssa_pdb->p_line_data= ICF_NULL;
    p_ssa_pdb->dest_module_id = ICF_INT_MODULE_INVALID;
    p_ssa_pdb->copy_msg_body_from_persitent_data = ICF_TRUE;
    p_ssa_pdb->reason_code_1 = ICF_NULL;
    p_ssa_pdb->auth_params_pres_in_chal = ICF_TRUE;
    p_ssa_pdb->common_bitmask = ICF_NULL;
    p_ssa_pdb->qos_call_check = ICF_FALSE;
    p_ssa_pdb->prack_reqd_for_qos = ICF_FALSE;
    p_ssa_pdb->qos_update_succ_resp_recv = ICF_FALSE;
    p_ssa_pdb->p_stream_pdu = ICF_NULL;
    p_ssa_pdb->pdu_len = ICF_NULL; 
#ifdef ICF_ERROR_ENABLE
    p_ssa_pdb->err_str[0] = '\0';
#endif
    ICF_FUNCTION_EXIT(p_glb_pdb)
    return ret_val;
}

